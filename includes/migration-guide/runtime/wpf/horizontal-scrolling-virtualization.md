### <a name="horizontal-scrolling-and-virtualization"></a>Défilement horizontal et virtualisation

|   |   |
|---|---|
|Détails|Cette modification s’applique à un <xref:System.Windows.Controls.ItemsControl?displayProperty=name> qui fait sa propre virtualisation dans le sens orthogonal vers la direction de défilement principale (l’exemple classique est <xref:System.Windows.Controls.DataGrid?displayProperty=name> avec EnableColumnVirtualization=&quot;True&quot;).  Le résultat de certaines opérations de défilement horizontal a été changé pour produire des résultats qui sont plus intuitifs et plus proches des résultats des opérations verticales comparables. Les opérations sont &quot;Défilement ici&quot; et &quot;Bord droit&quot;, pour utiliser les noms du menu obtenu en cliquant avec le bouton droit sur une barre de défilement horizontale.  Les deux calculent un décalage candidat et appellent <xref:System.Windows.Controls.Primitives.IScrollInfo.SetHorizontalOffset(System.Double)>. Après le défilement jusqu’au nouveau décalage, la notion représentée par &quot;ici&quot; ou &quot;bord droit&quot; peut avoir changé, car le contenu nouvellement dévirtualisé a changé la valeur de <xref:System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth?displayProperty=name>. Avant .NET 4.6.2, l’opération de défilement utilise simplement le décalage candidat, même s’il peut ne plus être &quot;ici&quot; ou au &quot;bord droit&quot;.  Ceci entraîne des effets comme un « rebondissement » du curseur de défilement, comme illustré dans l’exemple. Supposons qu’un <xref:System.Windows.Controls.DataGrid?displayProperty=name> a ExtentWidth=1000 et Width=200.  Un défilement vers « Bord droit » utilise un décalage candidat de 1000-200 = 800.  Lors du défilement jusqu’à ce décalage, les nouvelles colonnes sont dévirtualisées. Supposons qu’elles sont très larges, de sorte que <xref:System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth?displayProperty=name> passe à 2000.  Le défilement se termine avec HorizontalOffset=800, et le curseur &quot;rebondit&quot; et revient à proximité du milieu de la barre de défilement - précisément à 800/2000 = 40 %. La modification consiste à recalculer un nouveau décalage candidat quand cette situation se produit et à réessayer. (Ceci est la façon dont le défilement vertical fonctionne déjà.) Le changement produit une expérience plus prévisible et intuitive pour l’utilisateur final, mais il peut aussi affecter les applications qui dépendent de la valeur exacte de <xref:System.Windows.Controls.Primitives.IScrollInfo.HorizontalOffset?displayProperty=name> après un défilement horizontal, qu’il s’agisse d’un appel explicite à <xref:System.Windows.Controls.Primitives.IScrollInfo.SetHorizontalOffset(System.Double)> ou d’un appel effectué par l’utilisateur final.|
|Suggestion|Une application qui utilise une valeur prédite pour <xref:System.Windows.Controls.Primitives.IScrollInfo.HorizontalOffset?displayProperty=name> doit être changée afin de récupérer la valeur réelle (et la valeur de <xref:System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth?displayProperty=name>) après un défilement horizontal susceptible de modifier <xref:System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth?displayProperty=name> en raison de la dévirtualisation.|
|Portée|Mineur|
|Version|4.6.2|
|Type|Runtime|
|API affectées|<ul><li><xref:System.Windows.Controls.Primitives.IScrollInfo?displayProperty=nameWithType></li></ul>|

