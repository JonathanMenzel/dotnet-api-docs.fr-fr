### <a name="horizontal-scrolling-and-virtualization"></a>Défilement horizontal et la virtualisation

|   |   |
|---|---|
|Détails|Cette modification s’applique à un <xref:System.Windows.Controls.ItemsControl?displayProperty=name> qui effectue son propre virtualisation dans le sens orthogonale à la direction de défilement principale (l’exemple principal est <xref:System.Windows.Controls.DataGrid?displayProperty=name> avec EnableColumnVirtualization =&quot;True&quot;).  Le résultat de certaines opérations de défilement horizontales a été modifié pour produire des résultats qui sont plus intuitive et plus similaire pour les résultats des opérations verticales comparables. Les opérations suivantes sont &quot;défilement ici&quot; et &quot;bord droit&quot;, pour utiliser les noms à partir du menu obtenu en double-cliquant sur une barre de défilement horizontale.  Ces deux éléments de calcul un décalage de candidat et un appel <xref:System.Windows.Controls.Primitives.IScrollInfo.SetHorizontalOffset(System.Double)>. Après le défilement à l’offset de nouveau, la notion de &quot;ici&quot; ou &quot;droit&quot; ont peut-être été modifiées qui vient d’être virtualisé Annuler contenu a été modifié la valeur de <xref:System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth?displayProperty=name>. Avant .net 4.6.2, l’opération de défilement utilise simplement le décalage candidate, bien qu’il ne peut pas être &quot;ici&quot; ou à la &quot;droit&quot; plus.  Cela entraîne des effets tels que &quot;rebondissent&quot; le curseur de défilement, meilleures illustré par l’exemple. Supposons qu’un <xref:System.Windows.Controls.DataGrid?displayProperty=name> a ExtentWidth = 1000 et la largeur = 200.  Faites défiler un &quot;bord droit&quot; candidat utilise décalage 200-1000 = 800.  Pendant le défilement à la fonction, les nouvelles colonnes sont de-virtualisé ; Supposons qu’ils sont très larges, afin que le <xref:System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth?displayProperty=name> change à 2000.  Le défilement se termine par HorizontalOffset = 800 et curseur &quot;rebondit&quot; à proximité du centre de la barre de défilement - précisément à 800/2000 = 40 %. La modification consiste à recalculer un nouveau décalage de candidat Lorsque cette situation se produit, puis réessayez. (Il s’agit d’un défilement vertical comment fonctionne déjà.) La modification génère une expérience plus prévisible et plus intuitive pour l’utilisateur final, mais il peut également affecter n’importe quelle application qui dépend de la valeur exacte du <xref:System.Windows.Controls.Primitives.IScrollInfo.HorizontalOffset?displayProperty=name> après une barre de défilement horizontale, si l’appelé par l’utilisateur final ou par un appel explicite à <xref:System.Windows.Controls.Primitives.IScrollInfo.SetHorizontalOffset(System.Double)>.|
|Suggestion|Une application qui utilise une valeur prédite pour <xref:System.Windows.Controls.Primitives.IScrollInfo.HorizontalOffset?displayProperty=name> doit être modifié pour extraire la valeur réelle (et la valeur de <xref:System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth?displayProperty=name>) après un défilement horizontal susceptibles de changer <xref:System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth?displayProperty=name> en raison de la virtualisation de déduplication.|
|Portée|Mineur|
|Version|4.6.2|
|Type|Runtime|
|API affectées|<ul><li><xref:System.Windows.Controls.Primitives.IScrollInfo?displayProperty=nameWithType></li></ul>|

