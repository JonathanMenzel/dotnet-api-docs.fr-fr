<Type Name="SqlFileStream" FullName="System.Data.SqlTypes.SqlFileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="403a0ae49fdd5ffa469053b5179e2508361e3888" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36746095" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SqlFileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SqlFileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.Data.SqlTypes.SqlFileStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SqlFileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class SqlFileStream sealed : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type SqlFileStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Expose des données SQL Server qui sont stockées avec l’attribut de colonne FILESTREAM en tant que séquence d’octets.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.SqlTypes.SqlFileStream> classe est utilisée pour travailler avec `varbinary(max)` données stockées avec l’attribut FILESTREAM dans une base de données SQL Server 2008. Vous devez installer le .NET Framework 3.5 SP1 (ou version ultérieure) à utiliser <xref:System.Data.SqlTypes.SqlFileStream> pour travailler avec les données FILESTREAM.  
  
 Spécification du flux de fichier de l’attribut un `varbinary(max)` colonne entraîne par SQL Server stocker les données dans le système de fichiers local NTFS et non dans le fichier de base de données. Instructions Transact-SQL fournissent des fonctionnalités de manipulation de données au sein du serveur et les interfaces de système de fichiers Win32 fournissent l’accès en continu aux données.  
  
> [!NOTE]
>  Fichiers individuels stockés dans une colonne FILESTREAM ne peut pas être ouvert directement à partir de système de fichiers NTFS. Diffusion en continu de données FILESTREAM fonctionne uniquement dans le contexte d’une transaction SQL Server.  
  
 Le <xref:System.Data.SqlTypes.SqlFileStream> classe est dérivée de la <xref:System.IO.Stream> (classe), qui représente une abstraction d’une séquence d’octets à partir d’une source de données arbitraire telle qu’un fichier ou un bloc de mémoire. Vous pouvez lire à partir d’un FILESTREAM en transférant les données à partir d’un flux de données dans une structure de données tel qu’un tableau d’octets. Vous pouvez écrire dans un fichier FILESTREAM en transférant les données à partir d’une structure de données dans un flux de données. Vous pouvez également effectuer une recherche dans le flux, qui vous permet d’interroger et modifier des données à la position actuelle dans le flux.  
  
 Pour la documentation conceptuelle et des exemples de code, consultez [les données FILESTREAM](~/docs/framework/data/adonet/sql/filestream-data.md).  
  
 Pour plus d’informations sur la configuration et la configuration des données FILESTREAM sur SQL Server, consultez [conception et implémentation du stockage FILESTREAM](http://go.microsoft.com/fwlink/?LinkId=121499) dans la documentation en ligne de SQL Server 2008.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les autorisations de sécurité (CA) d’accès du code tous les appelants de la pile doivent avoir à utiliser le `SqlFileStream` constructeurs.  
  
|Accès aux fichiers|Autorisation|  
|-----------------|----------------|  
|Lecture|<xref:System.Security.Permissions.FileIOPermissionAccess.Read>|  
|Write|<xref:System.Security.Permissions.FileIOPermissionAccess.Write>|  
|Lecture/écriture|<xref:System.Security.Permissions.FileIOPermissionAccess.Read> et <xref:System.Security.Permissions.FileIOPermissionAccess.Write>|  
  
 Pour plus d’informations sur les autorités de certification, consultez [sécurité d’accès du Code et ADO.NET](~/docs/framework/data/adonet/code-access-security.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlFileStream (string path, byte[] transactionContext, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, unsigned int8[] transactionContext, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.#ctor(System.String,System.Byte[],System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, transactionContext As Byte(), access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlFileStream(System::String ^ path, cli::array &lt;System::Byte&gt; ^ transactionContext, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.Data.SqlTypes.SqlFileStream : string * byte[] * System.IO.FileAccess -&gt; System.Data.SqlTypes.SqlFileStream" Usage="new System.Data.SqlTypes.SqlFileStream (path, transactionContext, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactionContext" Type="System.Byte[]" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Chemin logique du fichier. Le chemin peut être récupéré à l’aide de la fonction Transact-SQL Pathname sur la colonne FILESTREAM sous-jacente dans la table.</param>
        <param name="transactionContext">Contexte de transaction de l’objet <see langword="SqlFileStream" />. Les applications doivent renvoyer le tableau d’octets retourné en appelant la méthode GET_FILESTREAM_TRANSACTION_CONTEXT.</param>
        <param name="access">Mode d’accès à utiliser à l’ouverture du fichier. Les valeurs d’énumération <see cref="T:System.IO.FileAccess" /> prises en charge sont <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" /> et <see cref="F:System.IO.FileAccess.ReadWrite" />.  Quand vous utilisez <see langword="FileAccess.Read" />, l’objet <see langword="SqlFileStream" /> peut servir à lire toutes les données existantes.  Quand vous utilisez <see langword="FileAccess.Write" />, <see langword="SqlFileStream" /> pointe vers un fichier de zéro octet. Les données existantes sont écrasées quand l’objet est fermé et la transaction validée.  Quand vous utilisez <see langword="FileAccess.ReadWrite" />, <see langword="SqlFileStream" /> pointe vers un fichier qui contient toutes les données existantes. Le handle est positionné au début du fichier. Vous pouvez utiliser l’une des méthodes <see langword="System.IO" /><see langword="Seek" /> pour déplacer la position du handle au sein du fichier afin d’écrire ou d’ajouter de nouvelles données.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une exception est levée, toutes les transactions ouvertes doivent être annulées. Sinon, une perte de données peut se produire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est une référence Null, ou <paramref name="transactionContext" /> est Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="path" /> est une chaîne vide (""), contient seulement un espace blanc ou contient un ou plusieurs caractères non valides.  
  
 <paramref name="path" /> commence par « \\\\.\\ », par exemple « \\\\.\PHYSICALDRIVE0 ».  Le handle retourné par l’appel à NTCreateFile n’est pas du type FILE_TYPE_DISK.  
  
 <paramref name="options" /> contient une valeur non prise en charge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de trouver le fichier.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le <paramref name="path" /> spécifié n’est pas valide ; il est, par exemple, sur un lecteur non mappé.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’accès demandé n’est pas autorisé par le système d’exploitation pour le chemin spécifié. Cela se produit quand l’accès Write ou ReadWrite est spécifié et que le fichier ou répertoire est défini pour un accès en lecture seule.</exception>
        <exception cref="T:System.InvalidOperationException">NtCreateFile échoue avec le code d’erreur défini sur ERROR_SHARING_VIOLATION.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlFileStream (string path, byte[] transactionContext, System.IO.FileAccess access, System.IO.FileOptions options, long allocationSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, unsigned int8[] transactionContext, valuetype System.IO.FileAccess access, valuetype System.IO.FileOptions options, int64 allocationSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.#ctor(System.String,System.Byte[],System.IO.FileAccess,System.IO.FileOptions,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, transactionContext As Byte(), access As FileAccess, options As FileOptions, allocationSize As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlFileStream(System::String ^ path, cli::array &lt;System::Byte&gt; ^ transactionContext, System::IO::FileAccess access, System::IO::FileOptions options, long allocationSize);" />
      <MemberSignature Language="F#" Value="new System.Data.SqlTypes.SqlFileStream : string * byte[] * System.IO.FileAccess * System.IO.FileOptions * int64 -&gt; System.Data.SqlTypes.SqlFileStream" Usage="new System.Data.SqlTypes.SqlFileStream (path, transactionContext, access, options, allocationSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactionContext" Type="System.Byte[]" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="allocationSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="path">Chemin logique du fichier. Le chemin peut être récupéré à l’aide de la fonction Transact-SQL Pathname sur la colonne FILESTREAM sous-jacente dans la table.</param>
        <param name="transactionContext">Contexte de transaction de l’objet <see langword="SqlFileStream" />. Quand la valeur est Null, une transaction implicite est utilisée pour l’objet <see langword="SqlFileStream" />. Les applications doivent renvoyer le tableau d’octets retourné en appelant la méthode GET_FILESTREAM_TRANSACTION_CONTEXT.</param>
        <param name="access">Mode d’accès à utiliser à l’ouverture du fichier. Les valeurs d’énumération <see cref="T:System.IO.FileAccess" /> prises en charge sont <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" /> et <see cref="F:System.IO.FileAccess.ReadWrite" />.  Quand vous utilisez <see langword="FileAccess.Read" />, l’objet <see langword="SqlFileStream" /> peut servir à lire toutes les données existantes.  Quand vous utilisez <see langword="FileAccess.Write" />, <see langword="SqlFileStream" /> pointe vers un fichier de zéro octet. Les données existantes sont écrasées quand l’objet est fermé et la transaction validée.  Quand vous utilisez <see langword="FileAccess.ReadWrite" />, <see langword="SqlFileStream" /> pointe vers un fichier qui contient toutes les données existantes. Le handle est positionné au début du fichier. Vous pouvez utiliser l’une des méthodes <see langword="System.IO" /><see langword="Seek" /> pour déplacer la position du handle au sein du fichier afin d’écrire ou d’ajouter de nouvelles données.</param>
        <param name="options">Spécifie l’option à utiliser pendant l’ouverture du fichier. Les valeurs de <see cref="T:System.IO.FileOptions" /> prises en charge sont <see cref="F:System.IO.FileOptions.Asynchronous" />, <see cref="F:System.IO.FileOptions.WriteThrough" />, <see cref="F:System.IO.FileOptions.SequentialScan" /> et <see cref="F:System.IO.FileOptions.RandomAccess" />.</param>
        <param name="allocationSize">Taille d’allocation à utiliser pendant la création d’un fichier. Si la valeur est 0, la valeur par défaut est utilisée.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une exception est levée, toutes les transactions ouvertes doivent être annulées. Sinon, une perte de données peut se produire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est une référence Null, ou <paramref name="transactionContext" /> est Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="path" /> est une chaîne vide (""), contient seulement un espace blanc ou contient un ou plusieurs caractères non valides.  
  
 <paramref name="path" /> commence par « \\\\.\\ », par exemple « \\\\.\PHYSICALDRIVE0 ».  Le handle retourné par l’appel à NTCreateFile n’est pas du type FILE_TYPE_DISK.  
  
 <paramref name="options" /> contient une valeur non prise en charge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de trouver le fichier.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le <paramref name="path" /> spécifié n’est pas valide ; il est, par exemple, sur un lecteur non mappé.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’accès demandé n’est pas autorisé par le système d’exploitation pour le chemin spécifié. Cela se produit quand l’accès Write ou ReadWrite est spécifié et que le fichier ou répertoire est défini pour un accès en lecture seule.</exception>
        <exception cref="T:System.InvalidOperationException">NtCreateFile échoue avec le code d’erreur défini sur ERROR_SHARING_VIOLATION.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="sqlFileStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dans laquelle lire les données.buffer</param>
        <param name="offset">Dans <c>buffer</c>, décalage d’octet auquel commencer l’écriture des données lues à partir du flux.</param>
        <param name="count">Nombre maximal d'octets à lire.</param>
        <param name="callback">Rappel asynchrone facultatif, à appeler quand la lecture est terminée.</param>
        <param name="state">Objet fourni par l’utilisateur qui distingue cette requête de lecture asynchrone des autres requêtes</param>
        <summary>Débute une opération de lecture asynchrone.</summary>
        <returns>Élément <see cref="T:System.IAsyncResult" /> représentant la lecture asynchrone, qui peut être encore en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> propriété pour déterminer si l’instance actuelle prend en charge la lecture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La lecture de données n’est pas prise en charge dans le flux.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="sqlFileStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dont sont issues les données à écrire.</param>
        <param name="offset">Dans <c>buffer</c>, décalage d’octet à partir duquel l’écriture doit commencer.</param>
        <param name="count">Nombre maximal d'octets à écrire.</param>
        <param name="callback">Rappel asynchrone facultatif, à appeler quand l'écriture est terminée.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'écriture asynchrone des autres requêtes.</param>
        <summary>Débute une opération d'écriture asynchrone.</summary>
        <returns>Élément <see cref="T:System.IAsyncResult" /> représentant l'écriture asynchrone, qui peut être encore en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.SqlTypes.SqlFileStream.CanWrite%2A> propriété pour déterminer si l’instance actuelle prend en charge l’écriture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L’écriture de données n’est pas prise en charge dans le flux.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Data.SqlTypes.SqlFileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le flux actuel prend en charge la lecture.</summary>
        <value>
          <see langword="true" /> si le flux actuel prend en charge la lecture ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Data.SqlTypes.SqlFileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le flux actuel prend en charge la recherche.</summary>
        <value>
          <see langword="true" /> si le flux actuel prend en charge la recherche ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.Data.SqlTypes.SqlFileStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le flux actuel peut expirer.</summary>
        <value>
          <see langword="true" /> si le flux actuel peut expirer ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Data.SqlTypes.SqlFileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le flux actuel prend en charge l'écriture.</summary>
        <value>
          <see langword="true" /> si le flux actuel prend en charge l’écriture ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="sqlFileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="sqlFileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Référence à la requête asynchrone en attente à terminer.</param>
        <summary>Attend que la requête asynchrone en attente se termine.</summary>
        <returns>Nombre d'octets lus dans le flux, entre zéro (0) et le nombre demandé. Les flux retournent uniquement zéro (0) à la fin du flux ; sinon, ils devraient se bloquer jusqu'à ce qu'au moins un octet soit disponible.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">L’objet <see cref="T:System.IAsyncResult" /> ne provient pas de la méthode <see langword="BeginRead" /> correspondante.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="sqlFileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Référence à la requête d'E/S asynchrone en attente.</param>
        <summary>Termine une opération d'écriture asynchrone.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">L’objet <see cref="T:System.IAsyncResult" /> ne provient pas de la méthode <see langword="BeginWrite" /> correspondante.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SqlFileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SqlFileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="sqlFileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie que les ressources sont libérées et que toute autre opération de nettoyage est effectuée quand le garbage collector récupère l'élément <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="sqlFileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface toutes les mémoires tampons pour ce flux et provoque l’écriture des données mises en mémoire tampon sur l’appareil sous-jacent.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Data.SqlTypes.SqlFileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique la longueur du flux actuel en octets.</summary>
        <value>
          <see cref="T:System.Int64" /> indiquant en octets la longueur du flux de données actuel.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Data.SqlTypes.SqlFileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le chemin logique du <see cref="T:System.Data.SqlTypes.SqlFileStream" /> passé au constructeur.</summary>
        <value>Valeur de chaîne indiquant le nom du <see cref="T:System.Data.SqlTypes.SqlFileStream" /> .</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Data.SqlTypes.SqlFileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position dans le flux actuel.</summary>
        <value>Position actuelle dans le <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="sqlFileStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau d'octets. Quand cette méthode retourne un résultat, la mémoire tampon contient le tableau d’octets spécifié dont les valeurs comprises entre offset et (offset + nombre - 1) sont remplacées par les octets lus dans la source actuelle.</param>
        <param name="offset">Offset d’octet de base zéro dans la mémoire tampon auquel commencer le stockage des données lues dans le flux actuel.</param>
        <param name="count">Nombre maximal d'octets à lire dans le flux actuel.</param>
        <summary>Lit une séquence d'octets dans le flux actuel et avance la position dans le flux du nombre d'octets lus.</summary>
        <returns>Nombre total d'octets lus dans la mémoire tampon. Le nombre d'octets peut être inférieur au nombre d'octets demandés si ce nombre n'est pas actuellement disponible ou égal à zéro (0) si la fin du flux a été atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> propriété pour déterminer si l’instance actuelle prend en charge l’écriture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L’objet ne prend pas en charge la lecture des données.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="sqlFileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit un octet du flux et avance d'un octet la position au sein du flux, ou retourne -1 si la fin du flux a été atteinte.</summary>
        <returns>Conversion de type (transtypage) de l'octet non signé en <see cref="T:System.Int32" />, ou -1 si la fin du flux a été atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> propriété pour déterminer si l’instance actuelle prend en charge la lecture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L’objet ne prend pas en charge la lecture des données.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.Data.SqlTypes.SqlFileStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur, exprimée en millisecondes, qui définit la durée pendant laquelle le flux tentera d’effectuer la lecture avant dépassement du délai d’attente.</summary>
        <value>Valeur, exprimée en millisecondes, qui définit la durée pendant laquelle le flux tentera d’effectuer la lecture avant dépassement du délai d’attente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="sqlFileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Décalage d’octet par rapport au paramètre <c>origin</c>.</param>
        <param name="origin">Valeur de type <see cref="T:System.IO.SeekOrigin" /> indiquant le point de référence utilisé pour obtenir la nouvelle position</param>
        <summary>Définit la position dans le flux actuel.</summary>
        <returns>Nouvelle position dans le flux actuel.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="sqlFileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Longueur souhaitée du flux actuel en octets.</param>
        <summary>Définit la longueur du flux actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> propriété pour déterminer si l’instance actuelle prend en charge la lecture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L’objet ne prend pas en charge la lecture des données.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionContext">
      <MemberSignature Language="C#" Value="public byte[] TransactionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] TransactionContext" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.TransactionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionContext As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ TransactionContext { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionContext : byte[]" Usage="System.Data.SqlTypes.SqlFileStream.TransactionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le contexte de transaction pour cet objet <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <value>Tableau <paramref name="transactionContext" /> qui a été passé au constructeur pour cet objet <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="sqlFileStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau d'octets. Cette méthode copie <c>count</c> octets à partir de <c>buffer</c> dans le flux actuel.</param>
        <param name="offset">Dans <c>buffer</c>, décalage d’octet de base zéro auquel commencer la copie des octets dans le flux actuel.</param>
        <param name="count">Nombre d'octets à écrire dans le flux actuel.</param>
        <summary>Écrit une séquence d’octets dans le flux actuel et avance la position actuelle dans ce flux du nombre d’octets écrits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.SqlTypes.SqlFileStream.CanWrite%2A> propriété pour déterminer si l’instance actuelle prend en charge l’écriture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L’objet ne prend pas en charge l’écriture de données.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="sqlFileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Octet à écrire dans le flux.</param>
        <summary>Écrit un octet à la position actuelle dans le flux et avance d'un octet la position dans le flux.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.SqlTypes.SqlFileStream.CanWrite%2A> propriété pour déterminer si l’instance actuelle prend en charge l’écriture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L’objet ne prend pas en charge l’écriture de données.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.Data.SqlTypes.SqlFileStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur, exprimée en millisecondes, qui définit la durée pendant laquelle le flux tentera d’écrire des données avant l’expiration du délai d’attente.</summary>
        <value>Valeur, exprimée en millisecondes, qui définit la durée pendant laquelle le flux tentera d’écrire des données avant l’expiration du délai d’attente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>