<Type Name="Matrix" FullName="System.Windows.Media.Matrix">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e94d4f8f681fbdb4a65983e657c03fb75efbf212" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39985299" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Matrix : IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Matrix extends System.ValueType implements class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Matrix" />
  <TypeSignature Language="VB.NET" Value="Public Structure Matrix&#xA;Implements IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Matrix : IFormattable" />
  <TypeSignature Language="F#" Value="type Matrix = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Media.MatrixConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.Media.Converters.MatrixValueSerializer))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une matrice de transformation affine 3x3 utilisée pour les transformations dans un espace 2D.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une matrice 3 x 3 est utilisée pour les transformations dans un [!INCLUDE[TLA2#tla_2d](~/includes/tla2sharptla-2d-md.md)] plan x-y. Les matrices de transformation affine peuvent être multipliés pour former de n’importe quel nombre de transformations linéaires, telles que la rotation et l’inclinaison (inclinaison), suivi par la conversion. Une matrice de transformation affine la dernière colonne est égal à (0, 0, 1), afin que seuls les membres dans le deux premières colonnes doivent être spécifiés.  Notez que les vecteurs sont exprimés en lignes de vecteurs, pas des vecteurs de colonne.  
  
 Un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Media.Matrix> est stocké dans l’ordre ligne-champ et a la structure suivante :  
  
||||  
|-|-|-|  
|<xref:System.Windows.Media.Matrix.M11%2A>|<xref:System.Windows.Media.Matrix.M12%2A>|0|  
|<xref:System.Windows.Media.Matrix.M21%2A>|<xref:System.Windows.Media.Matrix.M22%2A>|0|  
|<xref:System.Windows.Media.Matrix.OffsetX%2A>|<xref:System.Windows.Media.Matrix.OffsetY%2A>|1|  
  
 Les membres dans la dernière ligne, <xref:System.Windows.Media.Matrix.OffsetX%2A> et <xref:System.Windows.Media.Matrix.OffsetY%2A>, représentent les valeurs de translation.  
  
 Dans les méthodes et propriétés, la matrice de transformation est généralement spécifiée comme un vecteur à six membres seulement, comme suit :  
  
 (<xref:System.Windows.Media.Matrix.M11%2A>, <xref:System.Windows.Media.Matrix.M12%2A>, <xref:System.Windows.Media.Matrix.M21%2A>, <xref:System.Windows.Media.Matrix.M22%2A>, <xref:System.Windows.Media.Matrix.OffsetX%2A>, <xref:System.Windows.Media.Matrix.OffsetY%2A>)  
  
 Bien que vous pouvez utiliser un <xref:System.Windows.Media.Matrix> structure directement pour convertir des points individuels, ou avec un <xref:System.Windows.Media.MatrixTransform> pour transformer des objets, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] fournit également un ensemble de classes qui vous permettent de transformer des objets travailler directement avec des matrices : <xref:System.Windows.Media.RotateTransform>, <xref:System.Windows.Media.ScaleTransform>, <xref:System.Windows.Media.SkewTransform>, et <xref:System.Windows.Media.TranslateTransform>.  
  
<a name="xamlAttributeUsage_Matrix"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="m11, m12, m21, m22, offsetX, offsetY"/>  
- or -  
<object property="Identity"/>  
```  
  
<a name="xamlValues_Matrix"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *m11*  
 <xref:System.Double?displayProperty=nameWithType>  
  
 La valeur dans la première ligne et la première colonne de ce <xref:System.Windows.Media.Matrix>. Pour plus d'informations, consultez la propriété <xref:System.Windows.Media.Matrix.M11%2A>.  
  
 *m12*  
 <xref:System.Double?displayProperty=nameWithType>  
  
 La valeur dans la première ligne et la deuxième colonne. Pour plus d'informations, consultez la propriété <xref:System.Windows.Media.Matrix.M12%2A>.  
  
 *m21*  
 <xref:System.Double?displayProperty=nameWithType>  
  
 La valeur dans la deuxième ligne et de la première colonne. Pour plus d'informations, consultez la propriété <xref:System.Windows.Media.Matrix.M21%2A>.  
  
 *m22*  
 <xref:System.Double?displayProperty=nameWithType>  
  
 La valeur dans la deuxième ligne et la deuxième colonne. Pour plus d'informations, consultez la propriété <xref:System.Windows.Media.Matrix.M22%2A>.  
  
 *offsetX*  
 <xref:System.Double?displayProperty=nameWithType>  
  
 La valeur dans la troisième ligne et la première colonne. Pour plus d'informations, consultez la propriété <xref:System.Windows.Media.Matrix.OffsetX%2A>.  
  
 *offsetY*  
 <xref:System.Double?displayProperty=nameWithType>  
  
 La valeur dans la troisième ligne et la deuxième colonne. Pour plus d'informations, consultez la propriété <xref:System.Windows.Media.Matrix.OffsetY%2A>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Matrix (double m11, double m12, double m21, double m22, double offsetX, double offsetY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 m11, float64 m12, float64 m21, float64 m22, float64 offsetX, float64 offsetY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (m11 As Double, m12 As Double, m21 As Double, m22 As Double, offsetX As Double, offsetY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Matrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY);" />
      <MemberSignature Language="F#" Value="new System.Windows.Media.Matrix : double * double * double * double * double * double -&gt; System.Windows.Media.Matrix" Usage="new System.Windows.Media.Matrix (m11, m12, m21, m22, offsetX, offsetY)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="m11" Type="System.Double" />
        <Parameter Name="m12" Type="System.Double" />
        <Parameter Name="m21" Type="System.Double" />
        <Parameter Name="m22" Type="System.Double" />
        <Parameter Name="offsetX" Type="System.Double" />
        <Parameter Name="offsetY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="m11">Le nouveau coefficient <see cref="T:System.Windows.Media.Matrix" /> de la structure <see cref="P:System.Windows.Media.Matrix.M11" />.</param>
        <param name="m12">Le nouveau coefficient <see cref="T:System.Windows.Media.Matrix" /> de la structure <see cref="P:System.Windows.Media.Matrix.M12" />.</param>
        <param name="m21">Le nouveau coefficient <see cref="T:System.Windows.Media.Matrix" /> de la structure <see cref="P:System.Windows.Media.Matrix.M21" />.</param>
        <param name="m22">Le nouveau coefficient <see cref="T:System.Windows.Media.Matrix" /> de la structure <see cref="P:System.Windows.Media.Matrix.M22" />.</param>
        <param name="offsetX">Le nouveau coefficient <see cref="T:System.Windows.Media.Matrix" /> de la structure <see cref="P:System.Windows.Media.Matrix.OffsetX" />.</param>
        <param name="offsetY">Le nouveau coefficient <see cref="T:System.Windows.Media.Matrix" /> de la structure <see cref="P:System.Windows.Media.Matrix.OffsetY" />.</param>
        <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Windows.Media.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(valuetype System.Windows.Media.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Append(System.Windows.Media.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Windows::Media::Matrix matrix);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Windows.Media.Matrix -&gt; unit" Usage="matrix.Append matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">La structure <see cref="T:System.Windows.Media.Matrix" /> à ajouter à cette structure <see cref="T:System.Windows.Media.Matrix" />.</param>
        <summary>Ajoute la structure <see cref="T:System.Windows.Media.Matrix" /> spécifiée à cette <see cref="T:System.Windows.Media.Matrix" /> structure.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération revient à multiplier cette <xref:System.Windows.Media.Matrix> structure par le paramètre `matrix`.  Multiplication de matrice n’est pas commutative, cependant, et cette opération n’est pas identique à la multiplication du paramètre `matrix` par ce <xref:System.Windows.Media.Matrix> structure ; autrement dit, (ce * `matrix`) n’est pas identique (`matrix` * cela).  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter un <xref:System.Windows.Media.Matrix> structure à un autre <xref:System.Windows.Media.Matrix> structure.  
  
 [!code-csharp[MatrixExamples_snip#MatrixRotateAboutPointExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixrotateaboutpointexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.Multiply(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
        <altmember cref="M:System.Windows.Media.Matrix.op_Multiply(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
        <altmember cref="M:System.Windows.Media.Matrix.Prepend(System.Windows.Media.Matrix)" />
      </Docs>
    </Member>
    <Member MemberName="Determinant">
      <MemberSignature Language="C#" Value="public double Determinant { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Determinant" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.Determinant" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Determinant As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Determinant { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Determinant : double" Usage="System.Windows.Media.Matrix.Determinant" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le déterminant de cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <value>Le déterminant de cette <see cref="T:System.Windows.Media.Matrix" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple montre comment obtenir le déterminant d’un <xref:System.Windows.Media.Matrix>.  
  
 [!code-csharp[MatrixExamples_snip#MatrixDeterminantExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixdeterminantexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si les deux structures <see cref="T:System.Windows.Media.Matrix" /> spécifiées ont les mêmes valeurs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Un <xref:System.Windows.Media.Matrix> stocke ses valeurs en tant que valeurs de type double. Étant donné que la valeur d’un <xref:System.Double> peuvent perdre en précision lorsque les opérations arithmétiques sont exécutées dessus, une comparaison entre deux <xref:System.Double> des structures qui sont logiquement égales peuvent échouer.  
  
   
  
## Examples  
 L’exemple suivant montre comment vérifier deux <xref:System.Windows.Media.Matrix> structures sont égales.  
  
 [!code-csharp[MatrixExamples_snip#MatrixEqualityExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixequalityexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="matrix.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <see cref="T:System.Object" /> à comparer.</param>
        <summary>Détermine si le <see cref="T:System.Object" /> spécifié est une structure <see cref="T:System.Windows.Media.Matrix" /> identique à cette <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="o" /> est une structure <see cref="T:System.Windows.Media.Matrix" /> identique à cette structure <see cref="T:System.Windows.Media.Matrix" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Un <xref:System.Windows.Media.Matrix> stocke ses valeurs en tant que valeurs de type double. Étant donné que la valeur d’un <xref:System.Double> peuvent perdre en précision lorsque les opérations arithmétiques sont exécutées dessus, une comparaison entre deux <xref:System.Double> des structures qui sont logiquement égales peuvent échouer.  
  
   
  
## Examples  
 L’exemple suivant montre comment vérifier deux <xref:System.Windows.Media.Matrix> structures sont égales.  
  
 [!code-csharp[MatrixExamples_snip#MatrixEqualityExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixequalityexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.op_Equality(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Windows.Media.Matrix value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.Windows.Media.Matrix value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Equals(System.Windows.Media.Matrix)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Matrix) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Windows::Media::Matrix value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Windows.Media.Matrix -&gt; bool" Usage="matrix.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="value">Instance de <see cref="T:System.Windows.Media.Matrix" /> à comparer à cette instance.</param>
        <summary>Détermine si la structure <see cref="T:System.Windows.Media.Matrix" /> spécifiée est identique à cette instance.</summary>
        <returns>
          <see langword="true" /> si les instances sont égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Un <xref:System.Windows.Media.Matrix> stocke ses valeurs en tant que valeurs de type double. Étant donné que la valeur d’un <xref:System.Double> peuvent perdre en précision lorsque les opérations arithmétiques sont exécutées dessus, une comparaison entre deux <xref:System.Double> des structures qui sont logiquement égales peuvent échouer.  
  
   
  
## Examples  
 L’exemple suivant montre comment vérifier deux <xref:System.Windows.Media.Matrix> structures sont égales.  
  
 [!code-csharp[MatrixExamples_snip#MatrixEqualityExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixequalityexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.op_Equality(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (System.Windows.Media.Matrix matrix1, System.Windows.Media.Matrix matrix2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(valuetype System.Windows.Media.Matrix matrix1, valuetype System.Windows.Media.Matrix matrix2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Equals(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (matrix1 As Matrix, matrix2 As Matrix) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Windows::Media::Matrix matrix1, System::Windows::Media::Matrix matrix2);" />
      <MemberSignature Language="F#" Value="static member Equals : System.Windows.Media.Matrix * System.Windows.Media.Matrix -&gt; bool" Usage="System.Windows.Media.Matrix.Equals (matrix1, matrix2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix1" Type="System.Windows.Media.Matrix" />
        <Parameter Name="matrix2" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix1">Première structure <see cref="T:System.Windows.Media.Matrix" /> à comparer.</param>
        <param name="matrix2">Deuxième structure <see cref="T:System.Windows.Media.Matrix" /> à comparer.</param>
        <summary>Détermine si les deux structures <see cref="T:System.Windows.Media.Matrix" /> spécifiées sont identiques.</summary>
        <returns>
          <see langword="true" /> si <paramref name="matrix1" /> et <paramref name="matrix2" /> sont identiques ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Un <xref:System.Windows.Media.Matrix> stocke ses valeurs en tant que valeurs de type double. Étant donné que la valeur d’un <xref:System.Double> peuvent perdre en précision lorsque les opérations arithmétiques sont exécutées dessus, une comparaison entre deux <xref:System.Double> des structures qui sont logiquement égales peuvent échouer.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.op_Equality(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="matrix.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage pour cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <returns>Code de hachage de cette instance.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasInverse">
      <MemberSignature Language="C#" Value="public bool HasInverse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasInverse" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.HasInverse" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasInverse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasInverse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasInverse : bool" Usage="System.Windows.Media.Matrix.HasInverse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si cette structure <see cref="T:System.Windows.Media.Matrix" /> est réversible.</summary>
        <value>
          <see langword="true" /> si la <see cref="T:System.Windows.Media.Matrix" /> a un inverse ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie si un <xref:System.Windows.Media.Matrix> est réversible. S’il est réversible, le <xref:System.Windows.Media.Matrix> est inversée.  
  
 [!code-csharp[MatrixExamples_snip#MatrixInverseExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixinverseexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Identity">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.Matrix Identity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Media.Matrix Identity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.Identity" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Identity As Matrix" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Media::Matrix Identity { System::Windows::Media::Matrix get(); };" />
      <MemberSignature Language="F#" Value="member this.Identity : System.Windows.Media.Matrix" Usage="System.Windows.Media.Matrix.Identity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Matrix</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une identité <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <value>Matrice d'identité.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une matrice d’identité a la valeur 1 dans les coefficients [1,1], [2,2], [3,3] et la valeur 0 dans le reste des coefficients. Cela correspond au paramètre <xref:System.Windows.Media.Matrix.M11%2A> et <xref:System.Windows.Media.Matrix.M22%2A> 1 et <xref:System.Windows.Media.Matrix.M12%2A>, <xref:System.Windows.Media.Matrix.M21%2A>, <xref:System.Windows.Media.Matrix.OffsetX%2A>, et <xref:System.Windows.Media.Matrix.OffsetY%2A> à 0. Dans une matrice affine, qui est l’implémentation qui [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] utilise pour le <xref:System.Windows.Media.Matrix>, structure, les coefficients [3,1], [3,2], [3,3] toujours ont respectivement les valeurs 0,0,1.  
  
||||  
|-|-|-|  
|1|0|0|  
|0|1|0|  
|0|0|1|  
  
 Pour une matrice d’identité, le <xref:System.Windows.Media.Matrix.ToString%2A> méthode retourne la chaîne « Identité » au lieu des coefficients de la <xref:System.Windows.Media.Matrix>.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer le <xref:System.Windows.Media.Matrix.Identity%2A> matrice.  
  
 [!code-csharp[MatrixExamples_snip#MatrixIdentityExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixidentityexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.SetIdentity" />
        <altmember cref="P:System.Windows.Media.Matrix.IsIdentity" />
      </Docs>
    </Member>
    <Member MemberName="Invert">
      <MemberSignature Language="C#" Value="public void Invert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Invert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invert();" />
      <MemberSignature Language="F#" Value="member this.Invert : unit -&gt; unit" Usage="matrix.Invert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inverse cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie si un <xref:System.Windows.Media.Matrix> structure est réversible. S’il est réversible, le <xref:System.Windows.Media.Matrix> structure est inversée.  
  
 [!code-csharp[MatrixExamples_snip#MatrixInverseExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixinverseexample_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La structure <see cref="T:System.Windows.Media.Matrix" /> n'est pas réversible.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsIdentity">
      <MemberSignature Language="C#" Value="public bool IsIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.IsIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIdentity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIdentity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIdentity : bool" Usage="System.Windows.Media.Matrix.IsIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si cette structure <see cref="T:System.Windows.Media.Matrix" /> est une matrice d'identité.</summary>
        <value>
          <see langword="true" /> si la structure <see cref="T:System.Windows.Media.Matrix" /> est une matrice d'identité ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une matrice d’identité a la valeur 1 dans les coefficients [1,1], [2,2], [3,3] et la valeur 0 dans le reste des coefficients. Cela correspond au paramètre <xref:System.Windows.Media.Matrix.M11%2A> et <xref:System.Windows.Media.Matrix.M22%2A> 1 et <xref:System.Windows.Media.Matrix.M12%2A>, <xref:System.Windows.Media.Matrix.M21%2A>, <xref:System.Windows.Media.Matrix.OffsetX%2A>, et <xref:System.Windows.Media.Matrix.OffsetY%2A> à 0. Dans une matrice affine, qui est l’implémentation qui [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] utilise pour le <xref:System.Windows.Media.Matrix> structure, les coefficients [3,1], [3,2], [3,3] toujours ont respectivement les valeurs 0,0,1.  
  
||||  
|-|-|-|  
|1|0|0|  
|0|1|0|  
|0|0|1|  
  
 Pour une matrice d’identité, le <xref:System.Windows.Media.Matrix.ToString%2A> méthode retourne la chaîne « Identité », au lieu des coefficients de la <xref:System.Windows.Media.Matrix>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Matrix.Identity" />
        <altmember cref="M:System.Windows.Media.Matrix.SetIdentity" />
      </Docs>
    </Member>
    <Member MemberName="M11">
      <MemberSignature Language="C#" Value="public double M11 { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 M11" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.M11" />
      <MemberSignature Language="VB.NET" Value="Public Property M11 As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double M11 { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.M11 : double with get, set" Usage="System.Windows.Media.Matrix.M11" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de la première ligne et de la première colonne de cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <value>Valeur de la première ligne et de la première colonne de cette <see cref="T:System.Windows.Media.Matrix" />. La valeur par défaut est 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment multiplier deux <xref:System.Windows.Media.Matrix> structures et comment affecter des valeurs à un <xref:System.Windows.Media.Matrix> lorsqu’il est déclaré, et une fois que la structure est déclarée.  
  
 [!code-csharp[MatrixExamples_snip#MatrixMultiplicationExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixmultiplicationexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="M12">
      <MemberSignature Language="C#" Value="public double M12 { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 M12" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.M12" />
      <MemberSignature Language="VB.NET" Value="Public Property M12 As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double M12 { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.M12 : double with get, set" Usage="System.Windows.Media.Matrix.M12" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de la première ligne et de la deuxième colonne de cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <value>Valeur de la première ligne et de la deuxième colonne de cette <see cref="T:System.Windows.Media.Matrix" />. La valeur par défaut est 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant montre la disposition d’un <xref:System.Windows.Media.Matrix>.  
  
||||  
|-|-|-|  
|<xref:System.Windows.Media.Matrix.M11%2A>|<xref:System.Windows.Media.Matrix.M12%2A>|0|  
|<xref:System.Windows.Media.Matrix.M21%2A>|<xref:System.Windows.Media.Matrix.M22%2A>|0|  
|<xref:System.Windows.Media.Matrix.OffsetX%2A>|<xref:System.Windows.Media.Matrix.OffsetY%2A>|1|  
  
   
  
## Examples  
 L’exemple suivant montre comment multiplier deux <xref:System.Windows.Media.Matrix> structures et comment affecter des valeurs à un <xref:System.Windows.Media.Matrix> lorsqu’il est déclaré, et une fois que la structure est déclarée.  
  
 [!code-csharp[MatrixExamples_snip#MatrixMultiplicationExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixmultiplicationexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="M21">
      <MemberSignature Language="C#" Value="public double M21 { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 M21" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.M21" />
      <MemberSignature Language="VB.NET" Value="Public Property M21 As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double M21 { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.M21 : double with get, set" Usage="System.Windows.Media.Matrix.M21" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de la deuxième ligne et de la première colonne pour cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <value>Valeur de la deuxième ligne et de la première colonne de cette <see cref="T:System.Windows.Media.Matrix" />. La valeur par défaut est 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant montre la disposition d’un <xref:System.Windows.Media.Matrix>.  
  
||||  
|-|-|-|  
|<xref:System.Windows.Media.Matrix.M11%2A>|<xref:System.Windows.Media.Matrix.M12%2A>|0|  
|<xref:System.Windows.Media.Matrix.M21%2A>|<xref:System.Windows.Media.Matrix.M22%2A>|0|  
|<xref:System.Windows.Media.Matrix.OffsetX%2A>|<xref:System.Windows.Media.Matrix.OffsetY%2A>|1|  
  
   
  
## Examples  
 L’exemple suivant montre comment multiplier deux <xref:System.Windows.Media.Matrix> structures et comment affecter des valeurs à un <xref:System.Windows.Media.Matrix> lorsqu’il est déclaré, et une fois que la structure est déclarée.  
  
 [!code-csharp[MatrixExamples_snip#MatrixMultiplicationExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixmultiplicationexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="M22">
      <MemberSignature Language="C#" Value="public double M22 { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 M22" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.M22" />
      <MemberSignature Language="VB.NET" Value="Public Property M22 As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double M22 { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.M22 : double with get, set" Usage="System.Windows.Media.Matrix.M22" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de la deuxième ligne et de la deuxième colonne de cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <value>Valeur de la deuxième ligne et de la deuxième colonne de cette structure <see cref="T:System.Windows.Media.Matrix" />. La valeur par défaut est 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant montre la disposition d’un <xref:System.Windows.Media.Matrix> structure.  
  
||||  
|-|-|-|  
|<xref:System.Windows.Media.Matrix.M11%2A>|<xref:System.Windows.Media.Matrix.M12%2A>|0|  
|<xref:System.Windows.Media.Matrix.M21%2A>|<xref:System.Windows.Media.Matrix.M22%2A>|0|  
|<xref:System.Windows.Media.Matrix.OffsetX%2A>|<xref:System.Windows.Media.Matrix.OffsetY%2A>|1|  
  
   
  
## Examples  
 L’exemple suivant montre comment multiplier deux <xref:System.Windows.Media.Matrix> structures et comment affecter des valeurs à un <xref:System.Windows.Media.Matrix> lorsqu’il est déclaré, et une fois que la structure est déclarée.  
  
 [!code-csharp[MatrixExamples_snip#MatrixMultiplicationExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixmultiplicationexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.Matrix Multiply (System.Windows.Media.Matrix trans1, System.Windows.Media.Matrix trans2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.Matrix Multiply(valuetype System.Windows.Media.Matrix trans1, valuetype System.Windows.Media.Matrix trans2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Multiply(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (trans1 As Matrix, trans2 As Matrix) As Matrix" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::Matrix Multiply(System::Windows::Media::Matrix trans1, System::Windows::Media::Matrix trans2);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Windows.Media.Matrix * System.Windows.Media.Matrix -&gt; System.Windows.Media.Matrix" Usage="System.Windows.Media.Matrix.Multiply (trans1, trans2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Matrix</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trans1" Type="System.Windows.Media.Matrix" />
        <Parameter Name="trans2" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="trans1">La première structure <see cref="T:System.Windows.Media.Matrix" /> à multiplier.</param>
        <param name="trans2">La deuxième structure <see cref="T:System.Windows.Media.Matrix" /> à multiplier.</param>
        <summary>Multiplie une structure <see cref="T:System.Windows.Media.Matrix" /> par une autre structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <returns>Résultat de la multiplication de <paramref name="trans1" /> par <paramref name="trans2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiplication de matrice n’est pas commutative. Multiplication `trans1` par `trans2` n’est pas identique à la multiplication `trans2` par `trans1`.  
  
   
  
## Examples  
 L’exemple suivant montre comment multiplier deux <xref:System.Windows.Media.Matrix> structures.  
  
 [!code-csharp[MatrixExamples_snip#MatrixMultiplicationExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixmultiplicationexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.op_Multiply(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
        <altmember cref="M:System.Windows.Media.Matrix.Prepend(System.Windows.Media.Matrix)" />
        <altmember cref="M:System.Windows.Media.Matrix.Append(System.Windows.Media.Matrix)" />
      </Docs>
    </Member>
    <Member MemberName="OffsetX">
      <MemberSignature Language="C#" Value="public double OffsetX { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 OffsetX" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.OffsetX" />
      <MemberSignature Language="VB.NET" Value="Public Property OffsetX As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double OffsetX { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.OffsetX : double with get, set" Usage="System.Windows.Media.Matrix.OffsetX" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de la troisième ligne et de la première colonne de cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <value>Valeur de la troisième ligne et de la première colonne de cette structure <see cref="T:System.Windows.Media.Matrix" />. La valeur par défaut est 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Media.Matrix.OffsetX%2A> propriété est nommée ainsi car elle spécifie la valeur de conversion de l’espace de coordonnées sur l’axe x.  
  
 Le tableau suivant montre la disposition d’un <xref:System.Windows.Media.Matrix>.  
  
||||  
|-|-|-|  
|<xref:System.Windows.Media.Matrix.M11%2A>|<xref:System.Windows.Media.Matrix.M12%2A>|0|  
|<xref:System.Windows.Media.Matrix.M21%2A>|<xref:System.Windows.Media.Matrix.M22%2A>|0|  
|<xref:System.Windows.Media.Matrix.OffsetX%2A>|<xref:System.Windows.Media.Matrix.OffsetY%2A>|1|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetY">
      <MemberSignature Language="C#" Value="public double OffsetY { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 OffsetY" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.OffsetY" />
      <MemberSignature Language="VB.NET" Value="Public Property OffsetY As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double OffsetY { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.OffsetY : double with get, set" Usage="System.Windows.Media.Matrix.OffsetY" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de la troisième ligne et de la deuxième colonne de cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <value>Valeur de la troisième ligne et de la deuxième colonne de cette structure <see cref="T:System.Windows.Media.Matrix" />. La valeur par défaut est 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Media.Matrix.OffsetY%2A> propriété est nommée ainsi car elle spécifie le taux de conversion de l’espace de coordonnées sur l’axe y.  
  
 Le tableau suivant montre la disposition d’un <xref:System.Windows.Media.Matrix>.  
  
||||  
|-|-|-|  
|<xref:System.Windows.Media.Matrix.M11%2A>|<xref:System.Windows.Media.Matrix.M12%2A>|0|  
|<xref:System.Windows.Media.Matrix.M21%2A>|<xref:System.Windows.Media.Matrix.M22%2A>|0|  
|<xref:System.Windows.Media.Matrix.OffsetX%2A>|<xref:System.Windows.Media.Matrix.OffsetY%2A>|1|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Media.Matrix matrix1, System.Windows.Media.Matrix matrix2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Windows.Media.Matrix matrix1, valuetype System.Windows.Media.Matrix matrix2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.op_Equality(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (matrix1 As Matrix, matrix2 As Matrix) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Media::Matrix matrix1, System::Windows::Media::Matrix matrix2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Media.Matrix * System.Windows.Media.Matrix -&gt; bool" Usage="matrix1 = matrix2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix1" Type="System.Windows.Media.Matrix" />
        <Parameter Name="matrix2" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix1">Première structure <see cref="T:System.Windows.Media.Matrix" /> à comparer.</param>
        <param name="matrix2">Deuxième structure <see cref="T:System.Windows.Media.Matrix" /> à comparer.</param>
        <summary>Détermine si les deux structures <see cref="T:System.Windows.Media.Matrix" /> spécifiées sont identiques.</summary>
        <returns>
          <see langword="true" /> si <paramref name="matrix1" /> et <paramref name="matrix2" /> sont identiques ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Un <xref:System.Windows.Media.Matrix> stocke ses valeurs en tant que valeurs de type double. Étant donné que la valeur d’un <xref:System.Double> peuvent perdre en précision lorsque les opérations arithmétiques sont exécutées dessus, une comparaison entre deux <xref:System.Double> des structures qui sont logiquement égales peuvent échouer.  
  
   
  
## Examples  
 L’exemple suivant montre comment vérifier deux <xref:System.Windows.Media.Matrix> structures sont égales.  
  
 [!code-csharp[MatrixExamples_snip#MatrixEqualityExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixequalityexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Media.Matrix.Equals" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Media.Matrix matrix1, System.Windows.Media.Matrix matrix2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Windows.Media.Matrix matrix1, valuetype System.Windows.Media.Matrix matrix2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.op_Inequality(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (matrix1 As Matrix, matrix2 As Matrix) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Media::Matrix matrix1, System::Windows::Media::Matrix matrix2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Media.Matrix * System.Windows.Media.Matrix -&gt; bool" Usage="System.Windows.Media.Matrix.op_Inequality (matrix1, matrix2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix1" Type="System.Windows.Media.Matrix" />
        <Parameter Name="matrix2" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix1">Première structure <see cref="T:System.Windows.Media.Matrix" /> à comparer.</param>
        <param name="matrix2">Deuxième structure <see cref="T:System.Windows.Media.Matrix" /> à comparer.</param>
        <summary>Détermine si les deux structures <see cref="T:System.Windows.Media.Matrix" /> spécifiées ne sont pas identiques.</summary>
        <returns>
          <see langword="true" /> si <paramref name="matrix1" /> et <paramref name="matrix2" /> ne sont pas identiques ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Un <xref:System.Windows.Media.Matrix> stocke ses valeurs en tant que valeurs de type double. Étant donné que la valeur d’un <xref:System.Double> peuvent perdre en précision lorsque les opérations arithmétiques sont exécutées dessus, une comparaison entre deux <xref:System.Double> des structures qui sont logiquement égales peuvent échouer.  
  
   
  
## Examples  
 L’exemple suivant montre comment vérifier deux <xref:System.Windows.Media.Matrix> structures sont égales.  
  
 [!code-csharp[MatrixExamples_snip#MatrixEqualityExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixequalityexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.Matrix operator * (System.Windows.Media.Matrix trans1, System.Windows.Media.Matrix trans2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Windows.Media.Matrix op_Multiply(valuetype System.Windows.Media.Matrix trans1, valuetype System.Windows.Media.Matrix trans2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.op_Multiply(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (trans1 As Matrix, trans2 As Matrix) As Matrix" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::Matrix operator *(System::Windows::Media::Matrix trans1, System::Windows::Media::Matrix trans2);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Windows.Media.Matrix * System.Windows.Media.Matrix -&gt; System.Windows.Media.Matrix" Usage="trans1 * trans2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Matrix</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trans1" Type="System.Windows.Media.Matrix" />
        <Parameter Name="trans2" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="trans1">La première structure <see cref="T:System.Windows.Media.Matrix" /> à multiplier.</param>
        <param name="trans2">La deuxième structure <see cref="T:System.Windows.Media.Matrix" /> à multiplier.</param>
        <summary>Multiplie une structure <see cref="T:System.Windows.Media.Matrix" /> par une autre structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <returns>Résultat de la multiplication de <paramref name="trans1" /> par <paramref name="trans2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiplication de matrice n’est pas commutative. Multiplication `trans1` par `trans2` n’est pas identique à la multiplication `trans2` par `trans1`.  
  
   
  
## Examples  
 L’exemple suivant montre comment multiplier deux <xref:System.Windows.Media.Matrix> structures.  
  
 [!code-csharp[MatrixExamples_snip#MatrixMultiplicationExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixmultiplicationexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.Multiply(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
        <altmember cref="M:System.Windows.Media.Matrix.Prepend(System.Windows.Media.Matrix)" />
        <altmember cref="M:System.Windows.Media.Matrix.Append(System.Windows.Media.Matrix)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.Matrix Parse (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.Matrix Parse(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (source As String) As Matrix" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::Matrix Parse(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Windows.Media.Matrix" Usage="System.Windows.Media.Matrix.Parse source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Matrix</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">La représentation <see cref="T:System.String" /> de la matrice.</param>
        <summary>Convertit une représentation de matrice <see cref="T:System.String" /> en la structure <see cref="T:System.Windows.Media.Matrix" /> équivalente.</summary>
        <returns>Structure <see cref="T:System.Windows.Media.Matrix" /> équivalente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment convertir une représentation sous forme de chaîne d’une matrice en un <xref:System.Windows.Media.Matrix> structure.  
  
 [!code-csharp[MatrixExamples_snip#MatrixParseExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixparseexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prepend">
      <MemberSignature Language="C#" Value="public void Prepend (System.Windows.Media.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Prepend(valuetype System.Windows.Media.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Prepend(System.Windows.Media.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Prepend(System::Windows::Media::Matrix matrix);" />
      <MemberSignature Language="F#" Value="member this.Prepend : System.Windows.Media.Matrix -&gt; unit" Usage="matrix.Prepend matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">La structure <see cref="T:System.Windows.Media.Matrix" /> à ajouter au début de cette structure <see cref="T:System.Windows.Media.Matrix" />.</param>
        <summary>Ajoute la structure <see cref="T:System.Windows.Media.Matrix" /> spécifiée au début de cette structure<see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération revient à multiplier le paramètre `matrix` par ce <xref:System.Windows.Media.Matrix> structure. Multiplication de matrice n’est pas commutative, toutefois, cette opération n’est pas identique à multiplier cette <xref:System.Windows.Media.Matrix> structure par le paramètre `matrix`; autrement dit, `matrix` * Ceci n’est pas le même que cela * `matrix`.  
  
 Dans une transformation composite, l’ordre des diverses transformations est important. Par exemple, si vous tout d’abord faire pivoter, mettre à l’échelle, puis traduisez, vous obtenez un résultat différent que si vous convertissez tout d’abord, faire pivoter, puis mettre à l’échelle. Un ordre est important parce que les transformations telles que rotation et mise à l’échelle sont effectuées par rapport à l’origine du système de coordonnées. Mise à l’échelle un objet qui est centré à l’origine de produit le même résultat que la mise à l’échelle un objet qui a été déplacé en dehors de l’origine. De même, la rotation d’un objet qui est centré à l’origine produit le même résultat que la rotation d’un objet qui a été déplacé en dehors de l’origine.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter un <xref:System.Windows.Media.Matrix> sur un autre <xref:System.Windows.Media.Matrix>.  
  
 [!code-csharp[MatrixExamples_snip#MatrixPrependExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixprependexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.Multiply(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
        <altmember cref="M:System.Windows.Media.Matrix.op_Multiply(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
        <altmember cref="M:System.Windows.Media.Matrix.Append(System.Windows.Media.Matrix)" />
      </Docs>
    </Member>
    <Member MemberName="Rotate">
      <MemberSignature Language="C#" Value="public void Rotate (double angle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Rotate(float64 angle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Rotate(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rotate (angle As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Rotate(double angle);" />
      <MemberSignature Language="F#" Value="member this.Rotate : double -&gt; unit" Usage="matrix.Rotate angle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="angle">Angle de rotation.</param>
        <summary>Applique une rotation d'un angle spécifié par rapport à l'origine de cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment faire pivoter un <xref:System.Windows.Media.Matrix>.  
  
 [!code-csharp[MatrixExamples_snip#MatrixRotateExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixrotateexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.RotatePrepend(System.Double)" />
        <altmember cref="M:System.Windows.Media.Matrix.RotateAt(System.Double,System.Double,System.Double)" />
        <altmember cref="M:System.Windows.Media.Matrix.RotateAtPrepend(System.Double,System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="RotateAt">
      <MemberSignature Language="C#" Value="public void RotateAt (double angle, double centerX, double centerY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotateAt(float64 angle, float64 centerX, float64 centerY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.RotateAt(System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RotateAt (angle As Double, centerX As Double, centerY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotateAt(double angle, double centerX, double centerY);" />
      <MemberSignature Language="F#" Value="member this.RotateAt : double * double * double -&gt; unit" Usage="matrix.RotateAt (angle, centerX, centerY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Double" />
        <Parameter Name="centerX" Type="System.Double" />
        <Parameter Name="centerY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="angle">L'angle, en degrés, selon lequel faire pivoter cette matrice.</param>
        <param name="centerX">La coordonnée x du point par rapport auquel faire pivoter cette matrice.</param>
        <param name="centerY">La coordonnée y du point par rapport auquel faire pivoter cette matrice.</param>
        <summary>Fait pivoter cette matrice par rapport au point spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment faire pivoter un <xref:System.Windows.Media.Matrix> sur un point spécifié.  
  
 [!code-csharp[MatrixExamples_snip#MatrixRotateAboutPointExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixrotateaboutpointexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RotateAtPrepend">
      <MemberSignature Language="C#" Value="public void RotateAtPrepend (double angle, double centerX, double centerY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotateAtPrepend(float64 angle, float64 centerX, float64 centerY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.RotateAtPrepend(System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RotateAtPrepend (angle As Double, centerX As Double, centerY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotateAtPrepend(double angle, double centerX, double centerY);" />
      <MemberSignature Language="F#" Value="member this.RotateAtPrepend : double * double * double -&gt; unit" Usage="matrix.RotateAtPrepend (angle, centerX, centerY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Double" />
        <Parameter Name="centerX" Type="System.Double" />
        <Parameter Name="centerY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="angle">L'angle de rotation, en degrés.</param>
        <param name="centerX">La coordonnée x du centre de rotation.</param>
        <param name="centerY">La coordonnée y du centre de rotation.</param>
        <summary>Ajoute une rotation d'angle spécifié à un point spécifié au début de cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans une transformation composite, l’ordre des diverses transformations est important. Par exemple, si vous tout d’abord faire pivoter, mettre à l’échelle, puis traduisez, vous obtenez un résultat différent que si vous convertissez tout d’abord, faire pivoter, puis mettre à l’échelle. Un ordre est important parce que les transformations telles que rotation et mise à l’échelle sont effectuées par rapport à l’origine du système de coordonnées. Mise à l’échelle un objet qui est centré à l’origine de produit le même résultat que la mise à l’échelle un objet qui a été déplacé en dehors de l’origine. De même, la rotation d’un objet qui est centré à l’origine produit le même résultat que la rotation d’un objet qui a été déplacé en dehors de l’origine.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter une rotation au début une <xref:System.Windows.Media.Matrix>.  
  
 [!code-csharp[MatrixExamples_snip#MatrixPrependRotateExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixprependrotateexamples_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RotatePrepend">
      <MemberSignature Language="C#" Value="public void RotatePrepend (double angle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotatePrepend(float64 angle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.RotatePrepend(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RotatePrepend (angle As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotatePrepend(double angle);" />
      <MemberSignature Language="F#" Value="member this.RotatePrepend : double -&gt; unit" Usage="matrix.RotatePrepend angle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="angle">L'angle de rotation à ajouter au début.</param>
        <summary>Ajoute une rotation d'un angle spécifié au début de cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans une transformation composite, l’ordre des diverses transformations est important. Par exemple, si vous tout d’abord faire pivoter, mettre à l’échelle, puis traduisez, vous obtenez un résultat différent que si vous convertissez tout d’abord, faire pivoter, puis mettre à l’échelle. Un ordre est important parce que les transformations telles que rotation et mise à l’échelle sont effectuées par rapport à l’origine du système de coordonnées. Mise à l’échelle un objet qui est centré à l’origine de produit le même résultat que la mise à l’échelle un objet qui a été déplacé en dehors de l’origine. De même, la rotation d’un objet qui est centré à l’origine produit le même résultat que la rotation d’un objet qui a été déplacé en dehors de l’origine.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter une rotation au début une <xref:System.Windows.Media.Matrix>.  
  
 [!code-csharp[MatrixExamples_snip#MatrixPrependRotateExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixprependrotateexamples_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.Rotate(System.Double)" />
        <altmember cref="M:System.Windows.Media.Matrix.RotateAt(System.Double,System.Double,System.Double)" />
        <altmember cref="M:System.Windows.Media.Matrix.RotateAtPrepend(System.Double,System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (double scaleX, double scaleY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float64 scaleX, float64 scaleY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Scale(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (scaleX As Double, scaleY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(double scaleX, double scaleY);" />
      <MemberSignature Language="F#" Value="member this.Scale : double * double -&gt; unit" Usage="matrix.Scale (scaleX, scaleY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scaleX" Type="System.Double" />
        <Parameter Name="scaleY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="scaleX">La valeur à laquelle mettre à l'échelle cette <see cref="T:System.Windows.Media.Matrix" /> le long de l'axe x.</param>
        <param name="scaleY">La valeur à laquelle mettre à l'échelle cette <see cref="T:System.Windows.Media.Matrix" /> le long de l'axe y.</param>
        <summary>Ajoute le vecteur d'échelle spécifié à cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment mettre à l’échelle un <xref:System.Windows.Media.Matrix> structure.  
  
 [!code-csharp[MatrixExamples_snip#MatrixScaleExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixscaleexamples_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.ScaleAt(System.Double,System.Double,System.Double,System.Double)" />
        <altmember cref="M:System.Windows.Media.Matrix.ScaleAtPrepend(System.Double,System.Double,System.Double,System.Double)" />
        <altmember cref="M:System.Windows.Media.Matrix.ScalePrepend(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleAt">
      <MemberSignature Language="C#" Value="public void ScaleAt (double scaleX, double scaleY, double centerX, double centerY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleAt(float64 scaleX, float64 scaleY, float64 centerX, float64 centerY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.ScaleAt(System.Double,System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleAt (scaleX As Double, scaleY As Double, centerX As Double, centerY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleAt(double scaleX, double scaleY, double centerX, double centerY);" />
      <MemberSignature Language="F#" Value="member this.ScaleAt : double * double * double * double -&gt; unit" Usage="matrix.ScaleAt (scaleX, scaleY, centerX, centerY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scaleX" Type="System.Double" />
        <Parameter Name="scaleY" Type="System.Double" />
        <Parameter Name="centerX" Type="System.Double" />
        <Parameter Name="centerY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="scaleX">L'échelle à appliquer à cette <see cref="T:System.Windows.Media.Matrix" /> le long de l'axe x.</param>
        <param name="scaleY">L'échelle à appliquer à cette <see cref="T:System.Windows.Media.Matrix" /> le long de l'axe y.</param>
        <param name="centerX">La coordonnée x du point central de la mise à l'échelle.</param>
        <param name="centerY">La coordonnée y du point central de la mise à l'échelle.</param>
        <summary>Met à l'échelle cette <see cref="T:System.Windows.Media.Matrix" /> au taux spécifié par rapport du point spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment mettre à l’échelle un <xref:System.Windows.Media.Matrix> structure.  
  
 [!code-csharp[MatrixExamples_snip#MatrixScaleExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixscaleexamples_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleAtPrepend">
      <MemberSignature Language="C#" Value="public void ScaleAtPrepend (double scaleX, double scaleY, double centerX, double centerY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleAtPrepend(float64 scaleX, float64 scaleY, float64 centerX, float64 centerY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.ScaleAtPrepend(System.Double,System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleAtPrepend (scaleX As Double, scaleY As Double, centerX As Double, centerY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleAtPrepend(double scaleX, double scaleY, double centerX, double centerY);" />
      <MemberSignature Language="F#" Value="member this.ScaleAtPrepend : double * double * double * double -&gt; unit" Usage="matrix.ScaleAtPrepend (scaleX, scaleY, centerX, centerY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scaleX" Type="System.Double" />
        <Parameter Name="scaleY" Type="System.Double" />
        <Parameter Name="centerX" Type="System.Double" />
        <Parameter Name="centerY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="scaleX">Facteur d'échelle de l'axe-x.</param>
        <param name="scaleY">Facteur d'échelle de l'axe-y</param>
        <param name="centerX">La coordonnée x du point par rapport auquel la mise à l'échelle est exécutée.</param>
        <param name="centerY">La coordonnée y du point par rapport auquel la mise à l'échelle est exécutée.</param>
        <summary>Ajoute l'échelle spécifiée par rapport au point spécifié au début de cette <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans une transformation composite, l’ordre des diverses transformations est important. Par exemple, si vous tout d’abord faire pivoter, mettre à l’échelle, puis traduisez, vous obtenez un résultat différent que si vous convertissez tout d’abord, faire pivoter, puis mettre à l’échelle. Un ordre est important parce que les transformations telles que rotation et mise à l’échelle sont effectuées par rapport à l’origine du système de coordonnées. Mise à l’échelle un objet qui est centré à l’origine de produit le même résultat que la mise à l’échelle un objet qui a été déplacé en dehors de l’origine. De même, la rotation d’un objet qui est centré à l’origine produit le même résultat que la rotation d’un objet qui a été déplacé en dehors de l’origine.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter une échelle à un <xref:System.Windows.Media.Matrix>.  
  
 [!code-csharp[MatrixExamples_snip#MatrixPrependScaleExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixprependscaleexamples_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScalePrepend">
      <MemberSignature Language="C#" Value="public void ScalePrepend (double scaleX, double scaleY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScalePrepend(float64 scaleX, float64 scaleY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.ScalePrepend(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScalePrepend (scaleX As Double, scaleY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScalePrepend(double scaleX, double scaleY);" />
      <MemberSignature Language="F#" Value="member this.ScalePrepend : double * double -&gt; unit" Usage="matrix.ScalePrepend (scaleX, scaleY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scaleX" Type="System.Double" />
        <Parameter Name="scaleY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="scaleX">La valeur à laquelle mettre à l'échelle cette structure <see cref="T:System.Windows.Media.Matrix" /> le long de l'axe x.</param>
        <param name="scaleY">La valeur à laquelle mettre à l'échelle cette structure <see cref="T:System.Windows.Media.Matrix" /> le long de l'axe y.</param>
        <summary>Ajoute le vecteur d'échelle spécifié au début de cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans une transformation composite, l’ordre des diverses transformations est important. Par exemple, si vous tout d’abord faire pivoter, mettre à l’échelle, puis traduisez, vous obtenez un résultat différent que si vous convertissez tout d’abord, faire pivoter, puis mettre à l’échelle. Un ordre est important parce que les transformations telles que rotation et mise à l’échelle sont effectuées par rapport à l’origine du système de coordonnées. Mise à l’échelle un objet qui est centré à l’origine de produit le même résultat que la mise à l’échelle un objet qui a été déplacé en dehors de l’origine. De même, la rotation d’un objet qui est centré à l’origine produit le même résultat que la rotation d’un objet qui a été déplacé en dehors de l’origine.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter une échelle à un <xref:System.Windows.Media.Matrix> structure.  
  
 [!code-csharp[MatrixExamples_snip#MatrixPrependScaleExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixprependscaleexamples_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.ScaleAtPrepend(System.Double,System.Double,System.Double,System.Double)" />
        <altmember cref="M:System.Windows.Media.Matrix.Scale(System.Double,System.Double)" />
        <altmember cref="M:System.Windows.Media.Matrix.ScaleAt(System.Double,System.Double,System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetIdentity">
      <MemberSignature Language="C#" Value="public void SetIdentity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIdentity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.SetIdentity" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIdentity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIdentity();" />
      <MemberSignature Language="F#" Value="member this.SetIdentity : unit -&gt; unit" Usage="matrix.SetIdentity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Change cette structure <see cref="T:System.Windows.Media.Matrix" /> en une matrice d'identité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une matrice d’identité a la valeur 1 dans les coefficients [1,1], [2,2], [3,3] et la valeur 0 dans le reste des coefficients. Cela correspond au paramètre <xref:System.Windows.Media.Matrix.M11%2A> et <xref:System.Windows.Media.Matrix.M22%2A> 1 et <xref:System.Windows.Media.Matrix.M12%2A>, <xref:System.Windows.Media.Matrix.M21%2A>, <xref:System.Windows.Media.Matrix.OffsetX%2A>, et <xref:System.Windows.Media.Matrix.OffsetY%2A> à 0. Dans une matrice affine, qui est l’implémentation qui [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] utilise pour le <xref:System.Windows.Media.Matrix> structure, les coefficients [3,1], [3,2], [3,3] toujours ont respectivement les valeurs 0,0,1.  
  
||||  
|-|-|-|  
|1|0|0|  
|0|1|0|  
|0|0|1|  
  
 Pour une matrice d’identité, le <xref:System.Windows.Media.Matrix.ToString%2A> méthode retourne la chaîne « Identité », au lieu des coefficients de la <xref:System.Windows.Media.Matrix>.  
  
   
  
## Examples  
 L’exemple suivant montre comment activer un <xref:System.Windows.Media.Matrix> structure dans une matrice d’identité.  
  
 [!code-csharp[MatrixExamples_snip#MatrixIdentityExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixidentityexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Matrix.Identity" />
        <altmember cref="P:System.Windows.Media.Matrix.IsIdentity" />
      </Docs>
    </Member>
    <Member MemberName="Skew">
      <MemberSignature Language="C#" Value="public void Skew (double skewX, double skewY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Skew(float64 skewX, float64 skewY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Skew(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Skew (skewX As Double, skewY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Skew(double skewX, double skewY);" />
      <MemberSignature Language="F#" Value="member this.Skew : double * double -&gt; unit" Usage="matrix.Skew (skewX, skewY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="skewX" Type="System.Double" />
        <Parameter Name="skewY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="skewX">L'angle dans la dimension x selon lequel incliner cette <see cref="T:System.Windows.Media.Matrix" />.</param>
        <param name="skewY">L'angle dans la dimension y selon lequel incliner cette <see cref="T:System.Windows.Media.Matrix" />.</param>
        <summary>Ajoute une inclinaison des degrés spécifiés dans les dimensions x et y à cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple montre comment incliner un <xref:System.Windows.Media.Matrix> structure.  
  
 [!code-csharp[MatrixExamples_snip#MatrixSkewExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixskewexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.SkewPrepend(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SkewPrepend">
      <MemberSignature Language="C#" Value="public void SkewPrepend (double skewX, double skewY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkewPrepend(float64 skewX, float64 skewY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.SkewPrepend(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkewPrepend (skewX As Double, skewY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkewPrepend(double skewX, double skewY);" />
      <MemberSignature Language="F#" Value="member this.SkewPrepend : double * double -&gt; unit" Usage="matrix.SkewPrepend (skewX, skewY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="skewX" Type="System.Double" />
        <Parameter Name="skewY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="skewX">L'angle dans la dimension x selon lequel incliner cette <see cref="T:System.Windows.Media.Matrix" />.</param>
        <param name="skewY">L'angle dans la dimension y selon lequel incliner cette <see cref="T:System.Windows.Media.Matrix" />.</param>
        <summary>Ajoute une inclinaison des degrés spécifiés dans les dimensions x et y au début de cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans une transformation composite, l’ordre des diverses transformations est important. Par exemple, si vous tout d’abord faire pivoter, mettre à l’échelle, puis traduisez, vous obtenez un résultat différent que si vous convertissez tout d’abord, faire pivoter, puis mettre à l’échelle. Un ordre est important parce que les transformations telles que rotation et mise à l’échelle sont effectuées par rapport à l’origine du système de coordonnées. Mise à l’échelle un objet qui est centré à l’origine de produit le même résultat que la mise à l’échelle un objet qui a été déplacé en dehors de l’origine. De même, la rotation d’un objet qui est centré à l’origine produit le même résultat que la rotation d’un objet qui a été déplacé en dehors de l’origine.  
  
   
  
## Examples  
 Cet exemple montre comment ajouter une inclinaison au début une <xref:System.Windows.Media.Matrix> structure.  
  
 [!code-csharp[MatrixExamples_snip#MatrixSkewPrependExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixskewprependexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.Skew(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="System.IFormattable.ToString">
      <MemberSignature Language="C#" Value="string IFormattable.ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IFormattable.ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.System#IFormattable#ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (format As String, provider As IFormatProvider) As String Implements IFormattable.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IFormattable.ToString(System::String ^ format, IFormatProvider ^ provider) = IFormattable::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Format à utiliser.  
  
- ou - 
Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser le format par défaut défini pour le type de l'implémentation <see cref="T:System.IFormattable" />.</param>
        <param name="provider">Fournisseur à utiliser pour mettre en forme la valeur.  
  
- ou - 
Référence null (<see langword="Nothing" /> en Visual Basic) pour obtenir les informations de mise en forme des nombres à partir des paramètres régionaux définis dans le système d'exploitation.</param>
        <summary>Met en forme la valeur de l’instance actuelle en utilisant le format spécifié.</summary>
        <returns>Valeur de l’instance actuelle dans le format spécifié.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.IFormatProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une représentation <see cref="T:System.String" /> de cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette <xref:System.Windows.Media.Matrix> structure est une matrice d’identité, la chaîne « Identité » est retournée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="matrix.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une représentation <see cref="T:System.String" /> de cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <returns>
          <see cref="T:System.String" /> contenant les valeurs <see cref="P:System.Windows.Media.Matrix.M11" />, <see cref="P:System.Windows.Media.Matrix.M12" />, <see cref="P:System.Windows.Media.Matrix.M21" />, <see cref="P:System.Windows.Media.Matrix.M22" />, <see cref="P:System.Windows.Media.Matrix.OffsetX" />, et <see cref="P:System.Windows.Media.Matrix.OffsetY" /> de cette <see cref="T:System.Windows.Media.Matrix" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette <xref:System.Windows.Media.Matrix> est un <xref:System.Windows.Media.Matrix.Identity%2A> matrice, la chaîne « Identité » est retournée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="matrix.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Informations de mise en forme propres à la culture.</param>
        <summary>Crée une représentation <see cref="T:System.String" /> de cette structure <see cref="T:System.Windows.Media.Matrix" /> avec des informations de mise en forme propres à la culture.</summary>
        <returns>
          <see cref="T:System.String" /> contenant les valeurs <see cref="P:System.Windows.Media.Matrix.M11" />, <see cref="P:System.Windows.Media.Matrix.M12" />, <see cref="P:System.Windows.Media.Matrix.M21" />, <see cref="P:System.Windows.Media.Matrix.M22" />, <see cref="P:System.Windows.Media.Matrix.OffsetX" />, et <see cref="P:System.Windows.Media.Matrix.OffsetY" /> de cette <see cref="T:System.Windows.Media.Matrix" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette <xref:System.Windows.Media.Matrix> structure est une matrice d’identité, la chaîne « Identité » est retournée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Transform">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Transforme le point, le tableau de points, le vecteur ou le tableau de vecteurs spécifiés par cette <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Windows.Media.Matrix> pour transformer des points et des vecteurs.  
  
 [!code-csharp[MatrixExamples_snip#MatrixTransformExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixtransformexamples_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public System.Windows.Point Transform (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point Transform(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Transform(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point Transform(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Windows.Point -&gt; System.Windows.Point" Usage="matrix.Transform point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Point à transformer.</param>
        <summary>Transforme le point spécifié par la <see cref="T:System.Windows.Media.Matrix" /> et renvoie le résultat.</summary>
        <returns>Résultat de la transformation de <paramref name="point" /> par cette structure <see cref="T:System.Windows.Media.Matrix" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Windows.Media.Matrix> pour transformer des points et des vecteurs.  
  
 [!code-csharp[MatrixExamples_snip#MatrixTransformExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixtransformexamples_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public void Transform (System.Windows.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transform(valuetype System.Windows.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Transform(System.Windows.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transform (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transform(cli::array &lt;System::Windows::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Windows.Point[] -&gt; unit" Usage="matrix.Transform points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Windows.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Points à transformer. Les points d'origine du tableau sont remplacés par leurs valeurs transformées.</param>
        <summary>Transforme les points spécifiés par cette <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Windows.Media.Matrix> pour transformer des points et des vecteurs.  
  
 [!code-csharp[MatrixExamples_snip#MatrixTransformExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixtransformexamples_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public System.Windows.Vector Transform (System.Windows.Vector vector);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Vector Transform(valuetype System.Windows.Vector vector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Transform(System.Windows.Vector)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Vector Transform(System::Windows::Vector vector);" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Windows.Vector -&gt; System.Windows.Vector" Usage="matrix.Transform vector" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vector" Type="System.Windows.Vector" />
      </Parameters>
      <Docs>
        <param name="vector">Vecteur à transformer.</param>
        <summary>Transforme le vecteur spécifié par cette <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <returns>Résultat de la transformation de <paramref name="vector" /> par cette structure <see cref="T:System.Windows.Media.Matrix" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Windows.Media.Matrix> pour transformer des points et des vecteurs.  
  
 [!code-csharp[MatrixExamples_snip#MatrixTransformExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixtransformexamples_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public void Transform (System.Windows.Vector[] vectors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transform(valuetype System.Windows.Vector[] vectors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Transform(System.Windows.Vector[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transform (vectors As Vector())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transform(cli::array &lt;System::Windows::Vector&gt; ^ vectors);" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Windows.Vector[] -&gt; unit" Usage="matrix.Transform vectors" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vectors" Type="System.Windows.Vector[]" />
      </Parameters>
      <Docs>
        <param name="vectors">Vecteurs à transformer. Les vecteurs d'origine du tableau sont remplacés par leurs valeurs transformées.</param>
        <summary>Transforme les vecteurs spécifiés par cette <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Windows.Media.Matrix> pour transformer des points et des vecteurs.  
  
 [!code-csharp[MatrixExamples_snip#MatrixTransformExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixtransformexamples_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public void Translate (double offsetX, double offsetY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Translate(float64 offsetX, float64 offsetY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Translate(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Translate (offsetX As Double, offsetY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Translate(double offsetX, double offsetY);" />
      <MemberSignature Language="F#" Value="member this.Translate : double * double -&gt; unit" Usage="matrix.Translate (offsetX, offsetY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offsetX" Type="System.Double" />
        <Parameter Name="offsetY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="offsetX">La valeur de l'offset de cette <see cref="T:System.Windows.Media.Matrix" /> le long de l'axe x.</param>
        <param name="offsetY">La valeur de l'offset de cette <see cref="T:System.Windows.Media.Matrix" /> le long de l'axe y.</param>
        <summary>Ajoute une traduction des offsets spécifiés à cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment ajouter une traduction sur une <xref:System.Windows.Media.Matrix> structure.  
  
 [!code-csharp[MatrixExamples_snip#MatrixTranslateExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixtranslateexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.TranslatePrepend(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="TranslatePrepend">
      <MemberSignature Language="C#" Value="public void TranslatePrepend (double offsetX, double offsetY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslatePrepend(float64 offsetX, float64 offsetY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.TranslatePrepend(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslatePrepend (offsetX As Double, offsetY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslatePrepend(double offsetX, double offsetY);" />
      <MemberSignature Language="F#" Value="member this.TranslatePrepend : double * double -&gt; unit" Usage="matrix.TranslatePrepend (offsetX, offsetY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offsetX" Type="System.Double" />
        <Parameter Name="offsetY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="offsetX">La valeur de l'offset de cette <see cref="T:System.Windows.Media.Matrix" /> le long de l'axe x.</param>
        <param name="offsetY">La valeur de l'offset de cette <see cref="T:System.Windows.Media.Matrix" /> le long de l'axe y.</param>
        <summary>Ajoute une traduction des offsets spécifiés au début de cette structure <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans une transformation composite, l’ordre des diverses transformations est important. Par exemple, si vous tout d’abord faire pivoter, mettre à l’échelle, puis traduisez, vous obtenez un résultat différent que si vous convertissez tout d’abord, faire pivoter, puis mettre à l’échelle. Un ordre est important parce que les transformations telles que rotation et mise à l’échelle sont effectuées par rapport à l’origine du système de coordonnées. Mise à l’échelle un objet qui est centré à l’origine de produit le même résultat que la mise à l’échelle un objet qui a été déplacé en dehors de l’origine. De même, la rotation d’un objet qui est centré à l’origine produit le même résultat que la rotation d’un objet qui a été déplacé en dehors de l’origine.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter qu’une traduction sur une <xref:System.Windows.Media.Matrix> structure.  
  
 [!code-csharp[MatrixExamples_snip#MatrixTranslatePrependExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixtranslateprependexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.Translate(System.Double,System.Double)" />
      </Docs>
    </Member>
  </Members>
</Type>