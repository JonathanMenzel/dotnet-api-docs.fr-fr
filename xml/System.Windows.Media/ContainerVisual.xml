<Type Name="ContainerVisual" FullName="System.Windows.Media.ContainerVisual">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7d6c2b9abc476a467fcf97c44a15588852de8ed1" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36469521" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ContainerVisual : System.Windows.Media.Visual" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ContainerVisual extends System.Windows.Media.Visual" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.ContainerVisual" />
  <TypeSignature Language="VB.NET" Value="Public Class ContainerVisual&#xA;Inherits Visual" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContainerVisual : System::Windows::Media::Visual" />
  <TypeSignature Language="F#" Value="type ContainerVisual = class&#xA;    inherit Visual" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Visual</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Gère une collection d’objets <see cref="T:System.Windows.Media.Visual" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Media.ContainerVisual> classe est utilisée comme un conteneur pour une collection de <xref:System.Windows.Media.Visual> objets. Le <xref:System.Windows.Media.DrawingVisual> classe dérive de la <xref:System.Windows.Media.ContainerVisual> (classe), telles que la <xref:System.Windows.Media.DrawingVisual> classe peut également contenir une collection d’objets visuels.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un <xref:System.Windows.Media.ContainerVisual> objet qui est utilisé en tant que parent pour deux <xref:System.Windows.Media.DrawingVisual> objets. Les objets qui sont ajoutés à la <xref:System.Windows.Media.ContainerVisual> objet doit être ajouté dans l’ordre z inverse (de bas en haut) pour vous assurer qu’ils sont restitués dans le bon ordre de dessin. Dans l’ordre de l’arborescence d’éléments visuels soit correctement énumérée, l’exemple fournit des implémentations substituées de la <xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A> méthode et <xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A> propriété.  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContainerVisual ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContainerVisual();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Crée une instance de la classe <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment créer une nouvelle instance d’un <xref:System.Windows.Media.ContainerVisual> de l’objet, puis lui ajouter des objets visuels enfants.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet1](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet1)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect BitmapEffect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect BitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.BitmapEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property BitmapEffect As BitmapEffect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::BitmapEffect ^ BitmapEffect { System::Windows::Media::Effects::BitmapEffect ^ get(); void set(System::Windows::Media::Effects::BitmapEffect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BitmapEffect : System.Windows.Media.Effects.BitmapEffect with get, set" Usage="System.Windows.Media.ContainerVisual.BitmapEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> pour le <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Effet bitmap pour cet objet visuel.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.BitmapEffectInput" />
      <MemberSignature Language="VB.NET" Value="Public Property BitmapEffectInput As BitmapEffectInput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::BitmapEffectInput ^ BitmapEffectInput { System::Windows::Media::Effects::BitmapEffectInput ^ get(); void set(System::Windows::Media::Effects::BitmapEffectInput ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BitmapEffectInput : System.Windows.Media.Effects.BitmapEffectInput with get, set" Usage="System.Windows.Media.ContainerVisual.BitmapEffectInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Windows.Media.Effects.BitmapEffectInput" /> pour le <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Valeur d'entrée de l'effet bitmap pour cet objet visuel.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode CacheMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode CacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.CacheMode" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheMode As CacheMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::CacheMode ^ CacheMode { System::Windows::Media::CacheMode ^ get(); void set(System::Windows::Media::CacheMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheMode : System.Windows.Media.CacheMode with get, set" Usage="System.Windows.Media.ContainerVisual.CacheMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la représentation mise en cache de <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.CacheMode" /> qui contient une représentation mise en cache de <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définir le <xref:System.Windows.Media.ContainerVisual.CacheMode%2A> propriété lorsque vous avez besoin augmenter les performances pour le contenu qui nécessite du temps effectuer le rendu. Pour plus d'informations, consultez <xref:System.Windows.Media.BitmapCache>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.CacheMode" />
        <altmember cref="P:System.Windows.Media.Visual.VisualCacheMode" />
        <altmember cref="T:System.Windows.Media.BitmapCache" />
        <altmember cref="T:System.Windows.Media.BitmapCacheBrush" />
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Media.VisualCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.VisualCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As VisualCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::VisualCollection ^ Children { System::Windows::Media::VisualCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Children : System.Windows.Media.VisualCollection" Usage="System.Windows.Media.ContainerVisual.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.VisualCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection enfant du <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.VisualCollection" /> qui contient les enfants du <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment récupérer le <xref:System.Windows.Media.VisualCollection> d’un <xref:System.Windows.Media.ContainerVisual> objet.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet3)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Property Clip As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Geometry ^ Clip { System::Windows::Media::Geometry ^ get(); void set(System::Windows::Media::Geometry ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Windows.Media.Geometry with get, set" Usage="System.Windows.Media.ContainerVisual.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la zone de découpage du <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.Geometry" /> qui définit la zone de découpage.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.Clip" />
      </Docs>
    </Member>
    <Member MemberName="ContentBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect ContentBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect ContentBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.ContentBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect ContentBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentBounds : System.Windows.Rect" Usage="System.Windows.Media.ContainerVisual.ContentBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le cadre englobant pour le contenu du <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>
          <see cref="T:System.Windows.Rect" /> qui spécifie le cadre englobant.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Windows.Media.ContainerVisual.DescendantBounds%2A> propriété pour retourner l’union de tous les rectangles englobants pour tous les descendants d’un <xref:System.Windows.Media.ContainerVisual> objet, mais pas l’objet lui-même.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer le rectangle englobant d’un <xref:System.Windows.Media.ContainerVisual> objet.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet4)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect DescendantBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect DescendantBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.DescendantBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DescendantBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect DescendantBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.DescendantBounds : System.Windows.Rect" Usage="System.Windows.Media.ContainerVisual.DescendantBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'union de tous les cadres englobants de contenu de tous les descendant du <see cref="T:System.Windows.Media.ContainerVisual" />, mais pas le contenu du <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>
          <see cref="T:System.Windows.Rect" /> qui spécifie le cadre englobant de combinaison.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obtenir le <xref:System.Windows.Media.ContainerVisual.ContentBounds%2A> propriété pour retourner le rectangle de cadre englobant mis en cache pour le <xref:System.Windows.Media.ContainerVisual> lui-même.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer le rectangle englobant d’un <xref:System.Windows.Media.ContainerVisual> descendants de l’objet.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet4)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Effect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect Effect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect Effect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Effect" />
      <MemberSignature Language="VB.NET" Value="Public Property Effect As Effect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::Effect ^ Effect { System::Windows::Media::Effects::Effect ^ get(); void set(System::Windows::Media::Effects::Effect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Effect : System.Windows.Media.Effects.Effect with get, set" Usage="System.Windows.Media.ContainerVisual.Effect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'effet bitmap à appliquer à <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.Effects.Effect" /> qui représente l'effet bitmap.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.ShaderEffect" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="containerVisual.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Un entier signé 32 bits qui représente la valeur d'index du <see cref="T:System.Windows.Media.Visual" /> enfant. La valeur de <c>index</c> doit être comprise entre 0 et <see cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" />- 1.</param>
        <summary>Retourne un enfant <see cref="T:System.Windows.Media.Visual" /> spécifié pour le parent <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <returns>Le <see cref="T:System.Windows.Media.Visual" /> enfant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, un <xref:System.Windows.Media.ContainerVisual> n’a pas d’enfants.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un <xref:System.Windows.Media.ContainerVisual> objet qui est utilisé en tant que parent pour deux <xref:System.Windows.Media.DrawingVisual> objets. Les objets qui sont ajoutés à la <xref:System.Windows.Media.ContainerVisual> objet doit être ajouté dans l’ordre z inverse (de bas en haut) pour vous assurer qu’ils sont restitués dans le bon ordre de dessin. Dans l’ordre de l’arborescence d’éléments visuels soit correctement énumérée, l’exemple fournit des implémentations substituées de la <xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A> méthode et <xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A> propriété.  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>L’arborescence d’éléments visuels ne peut pas être modifiée au cours de cet appel.</para>
        </block>
        <altmember cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HitTest">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne l’objet visuel le plus haut d’un test de positionnement.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public System.Windows.Media.HitTestResult HitTest (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.HitTestResult HitTest(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.HitTest(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::HitTestResult ^ HitTest(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="override this.HitTest : System.Windows.Point -&gt; System.Windows.Media.HitTestResult" Usage="containerVisual.HitTest point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Valeur de point pour laquelle effectuer le test de positionnement.</param>
        <summary>Retourne l’objet visuel supérieur d’un test de positionnement en spécifiant un <see cref="T:System.Windows.Point" />.</summary>
        <returns>Résultat du test de positionnement de l’élément visuel retourné en tant que type <see cref="T:System.Windows.Media.HitTestResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Media.HitTestResult.VisualHit%2A> propriété la valeur de retour représente le <xref:System.Windows.Media.Visual> objet qui a été atteint.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer le <xref:System.Windows.Media.HitTestResult> retourner la valeur à partir de la <xref:System.Windows.Media.ContainerVisual.HitTest%2A> (méthode).  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet2)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public void HitTest (System.Windows.Media.HitTestFilterCallback filterCallback, System.Windows.Media.HitTestResultCallback resultCallback, System.Windows.Media.HitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HitTest(class System.Windows.Media.HitTestFilterCallback filterCallback, class System.Windows.Media.HitTestResultCallback resultCallback, class System.Windows.Media.HitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.HitTest(System.Windows.Media.HitTestFilterCallback,System.Windows.Media.HitTestResultCallback,System.Windows.Media.HitTestParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HitTest(System::Windows::Media::HitTestFilterCallback ^ filterCallback, System::Windows::Media::HitTestResultCallback ^ resultCallback, System::Windows::Media::HitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="override this.HitTest : System.Windows.Media.HitTestFilterCallback * System.Windows.Media.HitTestResultCallback * System.Windows.Media.HitTestParameters -&gt; unit" Usage="containerVisual.HitTest (filterCallback, resultCallback, hitTestParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterCallback" Type="System.Windows.Media.HitTestFilterCallback" />
        <Parameter Name="resultCallback" Type="System.Windows.Media.HitTestResultCallback" />
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.HitTestParameters" />
      </Parameters>
      <Docs>
        <param name="filterCallback">Délégué qui vous permet d’ignorer les parties de l’arborescence d’éléments visuels que vous ne souhaitez pas traiter dans vos résultats de test de positionnement.</param>
        <param name="resultCallback">Délégué qui sert à contrôler le retour d’informations sur les tests de positionnement.</param>
        <param name="hitTestParameters">Définit le jeu de paramètres pour un test de positionnement.</param>
        <summary>Exécute un test de positionnement sur <see cref="T:System.Windows.Media.ContainerVisual" /> à l’aide des objets <see cref="T:System.Windows.Media.HitTestFilterCallback" /> et <see cref="T:System.Windows.Media.HitTestResultCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `filterCallback` paramètre peut être null, auquel cas, il est ignoré. Si `filterCallback` n’est pas `null`, il est appelé avant `resultCallback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public System.Windows.Vector Offset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Vector Offset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Offset" />
      <MemberSignature Language="VB.NET" Value="Public Property Offset As Vector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Vector Offset { System::Windows::Vector get(); void set(System::Windows::Vector value); };" />
      <MemberSignature Language="F#" Value="member this.Offset : System.Windows.Vector with get, set" Usage="System.Windows.Media.ContainerVisual.Offset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur offset du <see cref="T:System.Windows.Media.ContainerVisual" /> à partir de son point de référence.</summary>
        <value>
          <see cref="T:System.Windows.Vector" /> qui représente la valeur de l'offset de <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Opacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Opacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Opacity { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Opacity : double with get, set" Usage="System.Windows.Media.ContainerVisual.Opacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'opacité du <see cref="T:System.Windows.Media.ContainerVisual" />, selon 0=transparent, 1=opaque.</summary>
        <value>Une valeur de 0 à 1 qui spécifie une plage allant de totalement transparent à totalement opaque. Une valeur de 0 indique que le <see cref="T:System.Windows.Media.ContainerVisual" /> est complètement transparent, tandis qu'une valeur de 1 indique que le <see cref="T:System.Windows.Media.ContainerVisual" /> est complètement opaque. Une valeur de 0.5 indique un opaque de 50 pourcent, une valeur de 0,725 indique un opaque de 72,5 pourcent, etc. Les valeurs inférieures à 0 sont traitées comme 0, alors que les valeurs supérieures à 1 sont traitées comme 1.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.Opacity" />
      </Docs>
    </Member>
    <Member MemberName="OpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush OpacityMask { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush OpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.OpacityMask" />
      <MemberSignature Language="VB.NET" Value="Public Property OpacityMask As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ OpacityMask { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OpacityMask : System.Windows.Media.Brush with get, set" Usage="System.Windows.Media.ContainerVisual.OpacityMask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un pinceau qui spécifie un masque d'opacité possible pour le <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Une valeur de type <see cref="T:System.Windows.Media.Brush" /> qui représente la valeur du masque d'opacité du <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un masque d’opacité peut être utilisé pour créer des effets tels que des vignettes, selon les valeurs de canal alpha du pinceau.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.Media.ContainerVisual.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Windows.Media.Visual" /> parent pour le <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Parent de l’objet visuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que cette valeur est retournée en tant que <xref:System.Windows.DependencyObject>, au lieu d’un objet brut.  
  
 Cette propriété peut retourner `null` dans une arborescence déconnectée, ou si vous avez parcouru la racine de l’arborescence au niveau de la fenêtre.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform Transform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform Transform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Transform" />
      <MemberSignature Language="VB.NET" Value="Public Property Transform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ Transform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Windows.Media.Transform with get, set" Usage="System.Windows.Media.ContainerVisual.Transform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la transformation qui est appliquée au <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Valeur transform.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Transform> est une classe de base qui unifie de nombreux formulaires de transformations différents. Pour plus d'informations, consultez <xref:System.Windows.Media.Transform>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override sealed int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.Media.ContainerVisual.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d'enfants pour le <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Nombre d'enfants dans le <see cref="T:System.Windows.Media.VisualCollection" /> du <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, un <xref:System.Windows.Media.ContainerVisual> n’a pas d’enfants.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un <xref:System.Windows.Media.ContainerVisual> objet qui est utilisé en tant que parent pour deux <xref:System.Windows.Media.DrawingVisual> objets. Les objets qui sont ajoutés à la <xref:System.Windows.Media.ContainerVisual> objet doit être ajouté dans l’ordre z inverse (de bas en haut) pour vous assurer qu’ils sont restitués dans le bon ordre de dessin. Dans l’ordre de l’arborescence d’éléments visuels soit correctement énumérée, l’exemple fournit des implémentations substituées de la <xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A> méthode et <xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A> propriété.  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Les classes qui dérivent de <see cref="T:System.Windows.Media.ContainerVisual" /> doit implémenter le <see cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" /> propriété à énumérer les enfants visuels. La propriété dérivée doit retourner le nombre d’enfants pour le <see cref="T:System.Windows.Media.ContainerVisual" />.  L’arborescence d’éléments visuels ne peut pas être modifiée au cours de cet appel.</para>
        </block>
        <altmember cref="M:System.Windows.Media.ContainerVisual.GetVisualChild(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="XSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection XSnappingGuidelines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection XSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.XSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property XSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::DoubleCollection ^ XSnappingGuidelines { System::Windows::Media::DoubleCollection ^ get(); void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XSnappingGuidelines : System.Windows.Media.DoubleCollection with get, set" Usage="System.Windows.Media.ContainerVisual.XSnappingGuidelines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'indication X (horizontale) pour le <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Indication horizontale.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alignement de pixels est le processus dans lequel la disposition de contenu est fixe afin que les bords de l’objet sont rendus sur les pixels spécifiques au périphérique. Le système graphique [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] utilise des unités indépendantes de l’appareil pour assurer une indépendance de la résolution et de l’appareil. Chaque pixel indépendant de l’appareil s’ajuste automatiquement au paramètre [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] du système. Cela permet aux applications [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] de s’ajuster correctement aux différents paramètres [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] et de prendre automatiquement en charge [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)].  
  
 Toutefois, cela [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] indépendance peut générer un rendu irrégulier des bords en raison de l’anticrénelage. Ces artefacts, qui apparaît en général comme bords flous ou « soft », peuvent se produire lorsque l’emplacement d’un bord se situe au milieu d’un pixel de périphérique, plutôt qu’entre les pixels de périphérique. Pour résoudre ce problème, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] offre un moyen aux bords des objets dans une arborescence d’éléments visuels à « snap » aux pixels de périphérique via l’alignement des pixels, en éliminant les bords arrondis produits par l’anticrénelage.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.ContainerVisual.YSnappingGuidelines" />
      </Docs>
    </Member>
    <Member MemberName="YSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection YSnappingGuidelines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection YSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.YSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property YSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::DoubleCollection ^ YSnappingGuidelines { System::Windows::Media::DoubleCollection ^ get(); void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.YSnappingGuidelines : System.Windows.Media.DoubleCollection with get, set" Usage="System.Windows.Media.ContainerVisual.YSnappingGuidelines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'indication Y (verticale) pour le <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Indication verticale.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alignement de pixels est le processus dans lequel la disposition de contenu est fixe afin que les bords de l’objet sont rendus sur les pixels spécifiques au périphérique. Le système graphique [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] utilise des unités indépendantes de l’appareil pour assurer une indépendance de la résolution et de l’appareil. Chaque pixel indépendant de l’appareil s’ajuste automatiquement au paramètre [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] du système. Cela permet aux applications [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] de s’ajuster correctement aux différents paramètres [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] et de prendre automatiquement en charge [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)].  
  
 Toutefois, cela [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] indépendance peut générer un rendu irrégulier des bords en raison de l’anticrénelage. Ces artefacts, qui apparaît en général comme bords flous ou « soft », peuvent se produire lorsque l’emplacement d’un bord se situe au milieu d’un pixel de périphérique, plutôt qu’entre les pixels de périphérique. Pour résoudre ce problème, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] offre un moyen aux bords des objets dans une arborescence d’éléments visuels à « snap » aux pixels de périphérique via l’alignement des pixels, en éliminant les bords arrondis produits par l’anticrénelage.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.ContainerVisual.XSnappingGuidelines" />
      </Docs>
    </Member>
  </Members>
</Type>