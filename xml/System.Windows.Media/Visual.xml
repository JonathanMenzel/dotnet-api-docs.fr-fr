<Type Name="Visual" FullName="System.Windows.Media.Visual">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3e9ff5e020c2a0b40cc9f1a9cf79c83b9cddf495" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30670113" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Visual : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Visual extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Visual" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Visual&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Visual abstract : System::Windows::DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit la prise en charge du rendu dans WPF, qui inclut les tests de positionnement, les transformations de coordonnées et les calculs de zones englobantes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Media.Visual> classe est l’abstraction de base à partir de laquelle chaque <xref:System.Windows.FrameworkElement> dérive de l’objet. Il sert également de point d’entrée pour l’écriture de nouveaux contrôles dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]et de nombreuses manières peut être considéré comme un équivalent d’un handle de fenêtre (HWND) dans le [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] modèle d’application.  
  
 Le <xref:System.Windows.Media.Visual> est un objet [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] objet, dont le rôle principal consiste à fournir la prise en charge du rendu. Contrôles d’interface utilisateur, tel que <xref:System.Windows.Controls.Button> et <xref:System.Windows.Controls.TextBox>, dérivent de la <xref:System.Windows.Media.Visual> de classe et utiliser le <xref:System.Windows.Media.Visual> défini les propriétés de la persistance de leurs données de rendu. Le <xref:System.Windows.Media.Visual> objet prend en charge pour les éléments suivants :  
  
-   Affichage de sortie : rendu du contenu de dessin sérialisé persistant d’un objet visuel.  
  
-   Transformations : exécution de transformations sur un objet visuel.  
  
-   Détourage : prise en charge de la zone de détourage d’un objet visuel.  
  
-   Le test d’atteinte : déterminer si une géométrie ou une coordonnée spécifiée (point) est contenue dans les limites d’un élément visuel.  
  
-   Calculs de rectangle englobant : détermination du rectangle englobant d’un objet visuel.  
  
 Point de vue architectural, le <xref:System.Windows.Media.Visual> objet n’inclut pas de prise en charge pour les autres exigences de développement d’applications / [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] les fonctionnalités qui ne sont pas immédiatement liées à son rendu, tels que les éléments suivants :  
  
-   Gestion des événements  
  
-   Mise en page  
  
-   Styles  
  
-   Liaison de données  
  
-   Globalisation  
  
 <xref:System.Windows.Media.Visual> est fourni en tant que classe publique abstraite à partir de laquelle obtenir les classes peuvent être dérivées. L’illustration suivante montre la hiérarchie des objets visuels existants qui sont définies dans le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] architecture.  
  
 ![Diagramme des classes dérivées de l’objet visuel](~/add/media/visualclass01.png "diagramme des classes dérivées de l’objet visuel")  
Hiérarchie de classe d’objet visuel  
  
 Dans certains cas, les membres qui sont définies comme protégé dans <xref:System.Windows.Media.Visual> sont exposées en tant que membres plus facilement accessibles avec des noms similaires dans dérivé <xref:System.Windows.UIElement> classe.  
  
 Pour plus d’informations, consultez [Vue d’ensemble du rendu graphique WPF](~/docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
 A <xref:System.Windows.Media.Visual> a un nombre limité de niveaux. Dans les versions précédentes du .NET Framework, cette profondeur maximale était de 255. Cette limite est insuffisant pour certaines dispositions qui ont de nombreux niveaux dans l’arborescence d’éléments visuels.  
  
 Dans [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], la profondeur maximale d’un <xref:System.Windows.Media.Visual> est 2047, ce qui permet des arborescences d’éléments visuels beaucoup plus profondes. Dans la plupart des applications, il n’est pas suffisamment d’espace pile pour parcourir de nombreux niveaux, et le résultat est un <xref:System.StackOverflowException> lors de la disposition. Pour la taille de pile par défaut, cette exception est généralement levée lorsque la profondeur d’arborescence est d’environ 800, ce qui correspond à approximativement 190 imbriqués <xref:System.Windows.Controls.TreeViewItem> objets.  
  
 Si cette exception est levée par votre application et vous devez disposer d’une arborescence d’éléments visuels plus approfondie, vous pouvez augmenter la taille de la pile de l’application. Vous pouvez augmenter la taille de la pile à l’aide de l’option /STACK au moment de la compilation ou à l’aide de l’utilitaire EDITBIN. Augmentation de la taille de pile peut affecter les performances de votre application. Pour plus d’informations, consultez [Allocations de la pile](http://go.microsoft.com/fwlink/?LinkId=165510) et [Options EDITBIN](http://go.microsoft.com/fwlink/?LinkId=165511).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.VisualCollection" />
    <altmember cref="T:System.Windows.Media.VisualTreeHelper" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Visual ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Visual();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Assure l'initialisation de base des objets dérivés de la classe <see cref="T:System.Windows.Media.Visual" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddVisualChild">
      <MemberSignature Language="C#" Value="protected void AddVisualChild (System.Windows.Media.Visual child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AddVisualChild(class System.Windows.Media.Visual child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.AddVisualChild(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AddVisualChild (child As Visual)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AddVisualChild(System::Windows::Media::Visual ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="child">Objet visuel enfant à ajouter à l'objet visuel parent.</param>
        <summary>Définit la relation parent-enfant entre deux objets visuels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Media.Visual.AddVisualChild%2A> méthode définit la relation parent-enfant entre deux objets visuels. Cette méthode doit être utilisée lorsque vous avez besoin d’un contrôle de bas niveau supérieur sur l’implémentation de stockage sous-jacente des objets enfants visuels. <xref:System.Windows.Media.VisualCollection> peut être utilisé comme une implémentation par défaut pour le stockage d’objets enfants.  
  
   
  
## Examples  
 L’exemple suivant montre comment définir des exigences de stockage personnalisés pour un enfant de visual. L’exemple utilise le <xref:System.Windows.Media.Visual.AddVisualChild%2A> et <xref:System.Windows.Media.Visual.RemoveVisualChild%2A> méthodes pour configurer la relation parent-enfant entre le parent visuel et `child`. Dans l’ordre de l’arborescence d’éléments visuels soit correctement énumérée, l’exemple fournit des implémentations substituées de la <xref:System.Windows.Media.Visual.GetVisualChild%2A> méthode et <xref:System.Windows.Media.Visual.VisualChildrenCount%2A> propriété.  
  
> [!NOTE]
>  Bien qu’il soit possible d’utiliser <xref:System.Windows.Media.VisualCollection> pour créer des relations entre les objets visual parent-enfant, il est plus efficace de fournir votre propre implémentation de stockage personnalisée lorsque qu’un seul enfant est lié à un parent.  
  
 [!code-csharp[AddVisualChild#AddVisualChild01](~/samples/snippets/csharp/VS_Snippets_Wpf/AddVisualChild/CSharp/Window1.xaml.cs#addvisualchild01)]
 [!code-vb[AddVisualChild#AddVisualChild01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AddVisualChild/visualbasic/window1.xaml.vb#addvisualchild01)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.VisualCollection" />
      </Docs>
    </Member>
    <Member MemberName="FindCommonVisualAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject FindCommonVisualAncestor (System.Windows.DependencyObject otherVisual);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject FindCommonVisualAncestor(class System.Windows.DependencyObject otherVisual) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.FindCommonVisualAncestor(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindCommonVisualAncestor (otherVisual As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ FindCommonVisualAncestor(System::Windows::DependencyObject ^ otherVisual);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherVisual" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="otherVisual">Objet visuel de type <see cref="T:System.Windows.DependencyObject" />.</param>
        <summary>Retourne l'ancêtre commun de deux objets visuels.</summary>
        <returns>Ancêtre commun de l'objet visuel et <paramref name="otherVisual" /> le cas échéant ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Objets 2D et 3D peuvent avoir des ancêtres de visual courantes, par conséquent, il est possible de passer un <xref:System.Windows.Media.Media3D.Visual3D> pour `otherVisual`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de l'objet visuel dans le <see cref="T:System.Windows.Media.VisualCollection" />.</param>
        <summary>Retourne le <see cref="T:System.Windows.Media.Visual" /> spécifié dans le <see cref="T:System.Windows.Media.VisualCollection" /> parent.</summary>
        <returns>Enfant dans le <see cref="T:System.Windows.Media.VisualCollection" /> à la valeur <paramref name="index" /> spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, un <xref:System.Windows.Media.Visual> n’a pas d’enfants. Par conséquent, la valeur par défaut implémentation lève toujours une <xref:System.ArgumentOutOfRangeException>.  
  
   
  
## Examples  
 L’exemple suivant définit une implémentation substituée de <xref:System.Windows.Media.Visual.GetVisualChild%2A>.  
  
 [!code-csharp[DrawingVisualSample#102b](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#102b)]
 [!code-vb[DrawingVisualSample#102b](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#102b)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Une classe qui dérive de <see cref="T:System.Windows.Media.Visual" /> doit remplacer cette méthode et également le <see cref="P:System.Windows.Media.Visual.VisualChildrenCount" /> propriété, l’arborescence d’éléments visuels soit correctement énumérée.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="HitTestCore">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si la valeur d'un point ou d'une géométrie s'inscrit dans les limites de l'objet visuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.GeometryHitTestResult HitTestCore (System.Windows.Media.GeometryHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.GeometryHitTestResult HitTestCore(class System.Windows.Media.GeometryHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HitTestCore (hitTestParameters As GeometryHitTestParameters) As GeometryHitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::GeometryHitTestResult ^ HitTestCore(System::Windows::Media::GeometryHitTestParameters ^ hitTestParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeometryHitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.GeometryHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">Objet <see cref="T:System.Windows.Media.GeometryHitTestParameters" /> qui spécifie le <see cref="T:System.Windows.Media.Geometry" /> par rapport auquel effectuer le test de positionnement.</param>
        <summary>Détermine si la valeur d'une géométrie s'inscrit dans les limites de l'objet visuel.</summary>
        <returns>
          <see cref="T:System.Windows.Media.GeometryHitTestResult" /> qui représente le résultat du test de positionnement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez remplacer la valeur par défaut de test de positionnement prise en charge pour un objet visuel en substituant la <xref:System.Windows.Media.Visual.HitTestCore%2A> (méthode). Cela signifie que lorsque vous appelez le <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> (méthode), votre implémentation substituée de <xref:System.Windows.Media.Visual.HitTestCore%2A> est appelée. Votre méthode substituée est appelée lorsqu’un test de positionnement se trouve dans le rectangle englobant de l’objet visuel, même si la coordonnée se situe en dehors de la géométrie de l’objet visuel.  
  
   
  
## Examples  
 L'exemple suivant montre comment substituer la méthode <xref:System.Windows.Media.Visual.HitTestCore%28System.Windows.Media.GeometryHitTestParameters%29>. Une raison, que vous souhaiterez peut-être substituer cette méthode est de fournir des fonctionnalités supplémentaires pendant le processus de test d’atteinte.  
  
 [!code-csharp[HitTestingOverview#HitTestingOverviewSnippet13](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/GeometryHitTest.cs#hittestingoverviewsnippet13)]
 [!code-vb[HitTestingOverview#HitTestingOverviewSnippet13](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/geometryhittest.vb#hittestingoverviewsnippet13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HitTestCore (hitTestParameters As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">Objet <see cref="T:System.Windows.Media.PointHitTestParameters" /> qui spécifie le <see cref="T:System.Windows.Point" /> par rapport auquel effectuer le test de positionnement.</param>
        <summary>Détermine si la valeur de coordonnée d'un point s'inscrit dans les limites de l'objet visuel.</summary>
        <returns>
          <see cref="T:System.Windows.Media.HitTestResult" /> qui représente le <see cref="T:System.Windows.Media.Visual" /> retourné à partir d'un test de positionnement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez substituer la prise en charge sur des objets visuels test par défaut en remplaçant le <xref:System.Windows.Media.Visual.HitTestCore%2A> (méthode). Cela signifie que lorsque vous appelez le <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> (méthode), votre implémentation substituée de <xref:System.Windows.Media.Visual.HitTestCore%2A> est appelée. Votre méthode substituée est appelée lorsqu’un test de positionnement se trouve dans le rectangle englobant de l’objet visuel, même si la coordonnée se situe en dehors de la géométrie de l’objet visuel.  
  
   
  
## Examples  
 L'exemple suivant montre comment substituer la méthode <xref:System.Windows.Media.Visual.HitTestCore%28System.Windows.Media.PointHitTestParameters%29>. Une raison, que vous souhaiterez peut-être substituer cette méthode est de fournir des fonctionnalités supplémentaires pendant le processus de test d’atteinte.  
  
 [!code-csharp[HitTestingOverview#107](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/Window1.xaml.cs#107)]
 [!code-vb[HitTestingOverview#107](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/window1.xaml.vb#107)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAncestorOf">
      <MemberSignature Language="C#" Value="public bool IsAncestorOf (System.Windows.DependencyObject descendant);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAncestorOf(class System.Windows.DependencyObject descendant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.IsAncestorOf(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAncestorOf (descendant As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAncestorOf(System::Windows::DependencyObject ^ descendant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendant" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="descendant">Valeur de type <see cref="T:System.Windows.DependencyObject" />.</param>
        <summary>Détermine si l'objet visuel est un ancêtre de l'objet visuel descendant.</summary>
        <returns>
          <see langword="true" /> si l'objet visuel est un ancêtre de <paramref name="descendant" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDescendantOf">
      <MemberSignature Language="C#" Value="public bool IsDescendantOf (System.Windows.DependencyObject ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDescendantOf(class System.Windows.DependencyObject ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.IsDescendantOf(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDescendantOf (ancestor As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDescendantOf(System::Windows::DependencyObject ^ ancestor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="ancestor">Valeur de type <see cref="T:System.Windows.DependencyObject" />.</param>
        <summary>Détermine si l'objet visuel est un descendant de l'objet visuel ancêtre.</summary>
        <returns>
          <see langword="true" /> si l'objet visuel est un descendant d'<paramref name="ancestor" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">Le paramètre d’échelle ppp précédent.</param>
        <param name="newDpi">Le nouveau paramètre d’échelle ppp.</param>
        <summary>Appelé en cas de modification des ppp d’affichage de cette Vue.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualChildrenChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnVisualChildrenChanged (System.Windows.DependencyObject visualAdded, System.Windows.DependencyObject visualRemoved);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnVisualChildrenChanged(class System.Windows.DependencyObject visualAdded, class System.Windows.DependencyObject visualRemoved) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnVisualChildrenChanged (visualAdded As DependencyObject, visualRemoved As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnVisualChildrenChanged(System::Windows::DependencyObject ^ visualAdded, System::Windows::DependencyObject ^ visualRemoved);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visualAdded" Type="System.Windows.DependencyObject" />
        <Parameter Name="visualRemoved" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="visualAdded">
          <see cref="T:System.Windows.Media.Visual" /> ajouté à la collection.</param>
        <param name="visualRemoved">
          <see cref="T:System.Windows.Media.Visual" /> supprimé de la collection.</param>
        <summary>Appelé lorsque le <see cref="T:System.Windows.Media.VisualCollection" /> de l'objet visuel est modifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Valeur de type <see cref="T:System.Windows.DependencyObject" /> qui représente le parent précédent de l'objet <see cref="T:System.Windows.Media.Visual" />. Si l'objet <see cref="T:System.Windows.Media.Visual" /> n'avait pas de parent précédent, la valeur du paramètre est <see langword="null" />.</param>
        <summary>Appelé lorsque le parent de l'objet visuel est modifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une classe qui dérive de <xref:System.Windows.Media.Visual> pouvez choisir de remplacer cette méthode.  
  
 Il n’existe aucun événement de « VisualParentChanged » fourni pour signaler cette modification aux instances. Par conséquent, vous devez substituer cette méthode pour gérer des scénarios de notification et fournir une version de l’instance de la notification si qui fait partie de votre scénario.  
  
   
  
## Examples  
 L’exemple suivant définit une implémentation substituée de <xref:System.Windows.Media.Visual.OnVisualParentChanged%2A>.  
  
 [!code-csharp[VisualSnippets#VisualSnippet10](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet10)]
 [!code-vb[VisualSnippets#VisualSnippet10](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Visual.VisualParent" />
      </Docs>
    </Member>
    <Member MemberName="PointFromScreen">
      <MemberSignature Language="C#" Value="public System.Windows.Point PointFromScreen (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point PointFromScreen(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.PointFromScreen(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point PointFromScreen(System::Windows::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Valeur <see cref="T:System.Windows.Point" /> en coordonnées d'écran.</param>
        <summary>Convertit un <see cref="T:System.Windows.Point" /> en coordonnées d'écran en <see cref="T:System.Windows.Point" /> qui représente le système de coordonnées actuel du <see cref="T:System.Windows.Media.Visual" />.</summary>
        <returns>Valeur <see cref="T:System.Windows.Point" /> convertie qui représente le système de coordonnées actuel du <see cref="T:System.Windows.Media.Visual" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Windows.Media.Visual.PointToScreen%2A> méthode pour convertir un <xref:System.Windows.Point> qui représente le système de coordonnées en cours de la <xref:System.Windows.Media.Visual> dans un <xref:System.Windows.Point> en coordonnées d’écran.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointToScreen">
      <MemberSignature Language="C#" Value="public System.Windows.Point PointToScreen (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point PointToScreen(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.PointToScreen(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point PointToScreen(System::Windows::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Valeur <see cref="T:System.Windows.Point" /> qui représente le système de coordonnées actuel du <see cref="T:System.Windows.Media.Visual" />.</param>
        <summary>Convertit un <see cref="T:System.Windows.Point" /> qui représente le système de coordonnées actuel du <see cref="T:System.Windows.Media.Visual" /> en <see cref="T:System.Windows.Point" /> en coordonnées d'écran.</summary>
        <returns>Valeur <see cref="T:System.Windows.Point" /> convertie en coordonnées d'écran.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Windows.Media.Visual.PointFromScreen%2A> méthode pour convertir un <xref:System.Windows.Point> en coordonnées d’écran dans un <xref:System.Windows.Point> qui représente le système de coordonnées en cours de la <xref:System.Windows.Media.Visual>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveVisualChild">
      <MemberSignature Language="C#" Value="protected void RemoveVisualChild (System.Windows.Media.Visual child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RemoveVisualChild(class System.Windows.Media.Visual child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.RemoveVisualChild(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RemoveVisualChild (child As Visual)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RemoveVisualChild(System::Windows::Media::Visual ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="child">Objet visuel enfant à supprimer de l'objet visuel parent.</param>
        <summary>Supprime la relation parent-enfant entre deux objets visuels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Media.Visual.RemoveVisualChild%2A> méthode supprime la relation parent-enfant entre deux objets visuels. Cette méthode, avec la <xref:System.Windows.Media.Visual.AddVisualChild%2A> méthode, doit être utilisée lorsque vous avez besoin d’un contrôle de bas niveau supérieur sur l’implémentation de stockage sous-jacente des objets enfants visuels. <xref:System.Windows.Media.VisualCollection> peut être utilisé comme une implémentation par défaut pour le stockage d’objets enfants.  
  
   
  
## Examples  
 L’exemple suivant montre comment définir des exigences de stockage personnalisés pour un enfant de visual. L’exemple utilise le <xref:System.Windows.Media.Visual.AddVisualChild%2A> et <xref:System.Windows.Media.Visual.RemoveVisualChild%2A> méthodes pour configurer la relation parent-enfant entre le parent visuel et `child`. Dans l’ordre de l’arborescence d’éléments visuels soit correctement énumérée, l’exemple fournit des implémentations substituées de la <xref:System.Windows.Media.Visual.GetVisualChild%2A> méthode et <xref:System.Windows.Media.Visual.VisualChildrenCount%2A> propriété.  
  
> [!NOTE]
>  Bien qu’il soit possible d’utiliser <xref:System.Windows.Media.VisualCollection> pour créer des relations entre les objets visual parent-enfant, il est plus efficace de fournir votre propre implémentation de stockage personnalisée lorsque qu’un seul enfant est lié à un parent.  
  
 [!code-csharp[AddVisualChild#AddVisualChild01](~/samples/snippets/csharp/VS_Snippets_Wpf/AddVisualChild/CSharp/Window1.xaml.cs#addvisualchild01)]
 [!code-vb[AddVisualChild#AddVisualChild01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AddVisualChild/visualbasic/window1.xaml.vb#addvisualchild01)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.VisualCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TransformToAncestor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une transformation qui peut être utilisée pour transformer les coordonnées du <see cref="T:System.Windows.Media.Visual" /> dans l'ancêtre spécifié de l'objet visuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransformToAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Media3D.GeneralTransform2DTo3D TransformToAncestor (System.Windows.Media.Media3D.Visual3D ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Media3D.GeneralTransform2DTo3D TransformToAncestor(class System.Windows.Media.Media3D.Visual3D ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Media3D.Visual3D)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToAncestor (ancestor As Visual3D) As GeneralTransform2DTo3D" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Media3D::GeneralTransform2DTo3D ^ TransformToAncestor(System::Windows::Media::Media3D::Visual3D ^ ancestor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Media3D.GeneralTransform2DTo3D</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.Media.Media3D.Visual3D" />
      </Parameters>
      <Docs>
        <param name="ancestor">Le <see cref="T:System.Windows.Media.Media3D.Visual3D" /> auquel les coordonnées sont transformées.</param>
        <summary>Retourne une transformation qui peut être utilisée pour transformer les coordonnées du <see cref="T:System.Windows.Media.Visual" /> dans l'ancêtre <see cref="T:System.Windows.Media.Media3D.Visual3D" /> spécifié de l'objet visuel.</summary>
        <returns>Une transformation qui peut être utilisée pour transformer les coordonnées du <see cref="T:System.Windows.Media.Visual" /> dans l'ancêtre <see cref="T:System.Windows.Media.Media3D.Visual3D" /> spécifié de l'objet visuel.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransformToAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToAncestor (System.Windows.Media.Visual ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToAncestor(class System.Windows.Media.Visual ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToAncestor (ancestor As Visual) As GeneralTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToAncestor(System::Windows::Media::Visual ^ ancestor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="ancestor">Le <see cref="T:System.Windows.Media.Visual" /> auquel les coordonnées sont transformées.</param>
        <summary>Retourne une transformation qui peut être utilisée pour transformer les coordonnées du <see cref="T:System.Windows.Media.Visual" /> dans l'ancêtre <see cref="T:System.Windows.Media.Visual" /> spécifié de l'objet visuel.</summary>
        <returns>Valeur de type <see cref="T:System.Windows.Media.GeneralTransform" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez également utiliser le <xref:System.Windows.Media.VisualTreeHelper.GetOffset%2A?displayProperty=nameWithType> méthode pour récupérer le décalage d’un objet visuel par rapport à son parent. Les valeurs de décalage sont contenues dans la liste retournée <xref:System.Windows.Vector> valeur.  
  
 [!code-csharp[VisualSnippets#VisualSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet2)]
 [!code-vb[VisualSnippets#VisualSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet2)]  
  
   
  
## Examples  
 L’exemple de balise suivant montre un <xref:System.Windows.Controls.TextBlock> qui est imbriqué dans deux <xref:System.Windows.Controls.StackPanel> objets.  
  
 [!code-xaml[VisualSnippets#VisualSnippet7](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window2.xaml#visualsnippet7)]  
  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Media.Visual.TransformToAncestor%2A> méthode pour récupérer le décalage de la <xref:System.Windows.Controls.TextBlock> relatif au conteneur <xref:System.Windows.Window>. Les valeurs de décalage sont contenues dans la liste retournée <xref:System.Windows.Media.GeneralTransform>.  
  
 [!code-csharp[VisualSnippets#VisualSnippet5](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet5)]
 [!code-vb[VisualSnippets#VisualSnippet5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet5)]  
  
 L’offset prend en compte la <xref:System.Windows.FrameworkElement.Margin%2A> valeurs pour tous les objets dans le conteneur <xref:System.Windows.Window>. Dans ce cas, <xref:System.Windows.Vector.X%2A> est égal à 28 et <xref:System.Windows.Vector.Y%2A> est 28.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ancestor" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ancestor" /> n'est pas un ancêtre de l'objet visuel.</exception>
        <exception cref="T:System.InvalidOperationException">Les objets visuels ne sont pas liés.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransformToDescendant">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToDescendant (System.Windows.Media.Visual descendant);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToDescendant(class System.Windows.Media.Visual descendant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToDescendant(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToDescendant (descendant As Visual) As GeneralTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToDescendant(System::Windows::Media::Visual ^ descendant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendant" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="descendant">Le <see cref="T:System.Windows.Media.Visual" /> auquel les coordonnées sont transformées.</param>
        <summary>Retourne une transformation qui peut être utilisée pour transformer les coordonnées du <see cref="T:System.Windows.Media.Visual" /> dans le descendant spécifié de l'objet visuel.</summary>
        <returns>Valeur de type <see cref="T:System.Windows.Media.GeneralTransform" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de balise suivant montre un <xref:System.Windows.Controls.TextBlock> qui est contenue dans un <xref:System.Windows.Controls.StackPanel> objet.  
  
 [!code-xaml[VisualSnippets#VisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml#visualsnippet4)]  
  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Media.Visual.TransformToDescendant%2A> méthode pour récupérer le décalage de la <xref:System.Windows.Controls.StackPanel> par rapport à son enfant <xref:System.Windows.Controls.TextBlock>. Les valeurs de décalage sont contenues dans la liste retournée <xref:System.Windows.Media.GeneralTransform> valeur.  
  
 [!code-csharp[VisualSnippets#VisualSnippet9](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet9)]
 [!code-vb[VisualSnippets#VisualSnippet9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet9)]  
  
 L’offset prend en compte la <xref:System.Windows.FrameworkElement.Margin%2A> valeurs pour tous les objets. Dans ce cas, <xref:System.Windows.Vector.X%2A> -4, et <xref:System.Windows.Vector.Y%2A> est -4. Les valeurs de décalage sont des valeurs négatives, car l’objet parent est décalé vers par rapport à son objet enfant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="descendant" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'objet visuel n'est pas un ancêtre de l'objet visuel <paramref name="descendant" />.</exception>
        <exception cref="T:System.InvalidOperationException">Les objets visuels ne sont pas liés.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransformToVisual">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToVisual (System.Windows.Media.Visual visual);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToVisual(class System.Windows.Media.Visual visual) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToVisual(System.Windows.Media.Visual)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToVisual(System::Windows::Media::Visual ^ visual);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visual" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="visual">Le <see cref="T:System.Windows.Media.Visual" /> auquel les coordonnées sont transformées.</param>
        <summary>Retourne une transformation qui peut être utilisée pour transformer les coordonnées du <see cref="T:System.Windows.Media.Visual" /> dans l'objet visuel spécifié.</summary>
        <returns>Valeur de type <see cref="T:System.Windows.Media.GeneralTransform" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Media.Visual.TransformToAncestor%2A> et <xref:System.Windows.Media.Visual.TransformToDescendant%2A> méthodes peuvent également être utilisées pour retourner une transformation pour un objet visuel.  
  
   
  
## Examples  
 L’exemple de balise suivant montre un <xref:System.Windows.Controls.TextBlock> qui est contenue dans un <xref:System.Windows.Controls.StackPanel> objet.  
  
 [!code-xaml[VisualSnippets#VisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml#visualsnippet4)]  
  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Media.Visual.TransformToVisual%2A> méthode pour récupérer le décalage de la <xref:System.Windows.Controls.StackPanel> par rapport à son enfant <xref:System.Windows.Controls.TextBlock>. Les valeurs de décalage sont contenues dans la liste retournée <xref:System.Windows.Media.GeneralTransform> valeur.  
  
 [!code-csharp[VisualSnippets#VisualSnippet8](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet8)]
 [!code-vb[VisualSnippets#VisualSnippet8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet8)]  
  
 L’offset prend en compte la <xref:System.Windows.FrameworkElement.Margin%2A> valeurs pour tous les objets. Dans ce cas, <xref:System.Windows.Vector.X%2A> -4, et <xref:System.Windows.Vector.Y%2A> est -4. Les valeurs de décalage sont des valeurs négatives, car l’objet parent est décalé vers par rapport à son objet enfant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="visual" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Les objets visuels ne sont pas liés.</exception>
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect VisualBitmapEffect { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect VisualBitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapEffect As BitmapEffect" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::BitmapEffect ^ VisualBitmapEffect {  protected public:&#xA;System::Windows::Media::Effects::BitmapEffect ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::BitmapEffect ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> du <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Effet bitmap pour cet objet visuel.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.BitmapEffect" />
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput VisualBitmapEffectInput { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput VisualBitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapEffectInput" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapEffectInput As BitmapEffectInput" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::BitmapEffectInput ^ VisualBitmapEffectInput {  protected public:&#xA;System::Windows::Media::Effects::BitmapEffectInput ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::BitmapEffectInput ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur <see cref="T:System.Windows.Media.Effects.BitmapEffectInput" /> du <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Valeur d'entrée de l'effet bitmap pour cet objet visuel.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.BitmapEffectInput" />
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapScalingMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.BitmapScalingMode VisualBitmapScalingMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.BitmapScalingMode VisualBitmapScalingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapScalingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapScalingMode As BitmapScalingMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::BitmapScalingMode VisualBitmapScalingMode {  protected public:&#xA;System::Windows::Media::BitmapScalingMode get(); protected:&#xA; void set(System::Windows::Media::BitmapScalingMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.BitmapScalingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit <see cref="T:System.Windows.Media.BitmapScalingMode" /> pour <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Valeur <see cref="T:System.Windows.Media.BitmapScalingMode" /> pour <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualCacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode VisualCacheMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode VisualCacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualCacheMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualCacheMode As CacheMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::CacheMode ^ VisualCacheMode {  protected public:&#xA;System::Windows::Media::CacheMode ^ get(); protected:&#xA; void set(System::Windows::Media::CacheMode ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la représentation mise en cache de <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.CacheMode" /> qui contient une représentation mise en cache de <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définir le <xref:System.Windows.Media.Visual.VisualCacheMode%2A> propriété lorsque vous avez besoin augmenter les performances pour le contenu qui nécessite du temps effectuer le rendu. Pour plus d'informations, consultez <xref:System.Windows.Media.BitmapCache>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.CacheMode" />
        <altmember cref="P:System.Windows.Media.ContainerVisual.CacheMode" />
        <altmember cref="T:System.Windows.Media.BitmapCache" />
        <altmember cref="T:System.Windows.Media.BitmapCacheBrush" />
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected virtual int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d'éléments enfants du <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Nombre d'éléments enfants.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, un <xref:System.Windows.Media.Visual> n’a pas d’enfants. Par conséquent, l’implémentation par défaut toujours retourne 0.  
  
   
  
## Examples  
 L’exemple suivant définit une implémentation substituée de <xref:System.Windows.Media.Visual.VisualChildrenCount%2A>.  
  
 [!code-csharp[DrawingVisualSample#102a](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#102a)]
 [!code-vb[DrawingVisualSample#102a](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#102a)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Une classe qui dérive de <see cref="T:System.Windows.Media.Visual" /> doivent substituer cette propriété et également le <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" /> (méthode), pour l’arborescence d’éléments visuels soit correctement énumérée.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="VisualClearTypeHint">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.ClearTypeHint VisualClearTypeHint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.ClearTypeHint VisualClearTypeHint" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualClearTypeHint" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualClearTypeHint As ClearTypeHint" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::ClearTypeHint VisualClearTypeHint { System::Windows::Media::ClearTypeHint get(); void set(System::Windows::Media::ClearTypeHint value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ClearTypeHint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Windows.Media.ClearTypeHint" /> qui détermine la façon dont ClearType est rendu dans <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.ClearTypeHint" /> de <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualClip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry VisualClip { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry VisualClip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualClip" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualClip As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Geometry ^ VisualClip {  protected public:&#xA;System::Windows::Media::Geometry ^ get(); protected:&#xA; void set(System::Windows::Media::Geometry ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la zone de découpage du <see cref="T:System.Windows.Media.Visual" /> en tant que valeur <see cref="T:System.Windows.Media.Geometry" />.</summary>
        <value>Valeur de la zone de découpage de l'objet visuel en tant que type <see cref="T:System.Windows.Media.Geometry" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualEdgeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.EdgeMode VisualEdgeMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.EdgeMode VisualEdgeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualEdgeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualEdgeMode As EdgeMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::EdgeMode VisualEdgeMode {  protected public:&#xA;System::Windows::Media::EdgeMode get(); protected:&#xA; void set(System::Windows::Media::EdgeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.EdgeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le mode de bord du <see cref="T:System.Windows.Media.Visual" /> en tant que valeur <see cref="T:System.Windows.Media.EdgeMode" />.</summary>
        <value>Valeur <see cref="T:System.Windows.Media.EdgeMode" /> de l'objet visuel.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect VisualEffect { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect VisualEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualEffect As Effect" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::Effect ^ VisualEffect {  protected public:&#xA;System::Windows::Media::Effects::Effect ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::Effect ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'effet bitmap à appliquer à <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.Effects.Effect" /> qui représente l'effet bitmap.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.ShaderEffect" />
      </Docs>
    </Member>
    <Member MemberName="VisualOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Vector VisualOffset { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Vector VisualOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOffset As Vector" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Vector VisualOffset {  protected public:&#xA;System::Windows::Vector get(); protected:&#xA; void set(System::Windows::Vector value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de décalage de l'objet visuel.</summary>
        <value>
          <see cref="T:System.Windows.Vector" /> qui spécifie la valeur de décalage.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualOpacity">
      <MemberSignature Language="C#" Value="public double VisualOpacity { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 VisualOpacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOpacity" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOpacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:  property double VisualOpacity {  protected public:&#xA;double get(); protected:&#xA; void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'opacité du <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Valeur d'opacité de l'objet visuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de l’opacité de la <xref:System.Windows.Media.Visual> est exprimée sous la forme d’une valeur comprise entre 0 et 1. La valeur 0 indique que l’élément est complètement transparent, alors que la valeur 1 indique que l’élément est complètement opaque. Une valeur de 0,5 indique que l’élément est opaque à 50 %. Les valeurs inférieures à 0 sont traitées comme 0 ; les valeurs qui sont supérieures à 1 sont traitées comme 1.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualOpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush VisualOpacityMask { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush VisualOpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOpacityMask" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOpacityMask As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Brush ^ VisualOpacityMask {  protected public:&#xA;System::Windows::Media::Brush ^ get(); protected:&#xA; void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur <see cref="T:System.Windows.Media.Brush" /> qui représente le masque d'opacité du <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.Brush" /> qui représente la valeur du masque d'opacité de l'objet visuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le masque d’opacité est un <xref:System.Windows.Media.Brush> qui est appliquée aux masquages de canal alpha pour rendre le contenu de cet élément visuel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualParent">
      <MemberSignature Language="C#" Value="protected System.Windows.DependencyObject VisualParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject VisualParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualParent" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property VisualParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::DependencyObject ^ VisualParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le parent d'arborescence d'éléments visuels de l'objet visuel.</summary>
        <value>
          <see cref="T:System.Windows.Media.Visual" /> parent.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Parent" />
        <altmember cref="T:System.Windows.Media.VisualTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="VisualScrollableAreaClip">
      <MemberSignature Language="C#" Value="public Nullable&lt;System.Windows.Rect&gt; VisualScrollableAreaClip { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;valuetype System.Windows.Rect&gt; VisualScrollableAreaClip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualScrollableAreaClip" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualScrollableAreaClip As Nullable(Of Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:  property Nullable&lt;System::Windows::Rect&gt; VisualScrollableAreaClip {  protected public:&#xA;Nullable&lt;System::Windows::Rect&gt; get(); protected:&#xA; void set(Nullable&lt;System::Windows::Rect&gt; value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Windows.Rect&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une zone à défilement découpée pour <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>
          <see cref="T:System.Windows.Rect" /> qui représente la zone de découpage à défilement, ou <see langword="null" /> si aucune zone de découpage n'est assignée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définir le <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> propriété pour activer le défilement accéléré lors du rendu dans le logiciel. Cela est utile dans les scénarios de rendu à distance, par exemple en cours d’exécution sur le Bureau à distance ou en cours d’exécution sur un ordinateur virtuel. Définissez cette propriété sur l’élément parent dont les enfants seront défiler. Définition de la <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> propriété n’a aucun effet lorsque le rendu est accéléré par le matériel.  
  
 Le <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> propriété permet des scénarios avancés spécifiques. La liste suivante affiche les restrictions qui s’appliquent lorsque vous utilisez le <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> propriété.  
  
-   L’arrière-plan de la zone de défilement doit être opaque, ou les artefacts de défilement se produira.  
  
-   Le <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> propriété accélère le défilement uniquement lorsque WPF est rendu dans le logiciel. Par exemple, cette situation se produit lorsque l’application s’exécute sur le Bureau à distance ou localement sur un ordinateur virtuel.  
  
-   Le comportement de défilement est inchangé lors du rendu dans le matériel. Pour empêcher les différences de comportement de défilement, vous devez conserver le <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> propriété activée pour le matériel et logiciel.  
  
-   Les transformations de Rotate et l’inclinaison désactivent le défilement accéléré. Transformations d’échelle et des traductions au-dessus de la zone de défilement horizontales ou verticales fonctionnent correctement et ne désactivez pas l’accélération de défilement.  
  
-   Modification de la sous-arborescence ou le déclenchement des éléments de la zone de défilement à redessiner via l’animation se comportent comme prévu, mais perdre l’avantage du défilement accéléré pour la zone redessinée. Toute animation qui invalide la zone de défilement au cours de la même image dans lequel le défilement se produit élimine l’avantage de cette optimisation.  
  
-   Le <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> rectangle s’aligne vers l’intérieur, en pixels. Par conséquent, la taille alignée du rectangle de défilement est toujours inférieure ou égale à celle que vous avez défini.  
  
-   Les offsets s’alignent vers le bas. Cela signifie que la différence de la précédente aligné offset et en cours est toujours un nombre entier de pixels.  
  
-   Tests de positionnement peuvent être décalés jusqu'à un pixel.  
  
-   Arrondi de disposition doit être activé, car il garantit que les bords des zones de défilement et de la zone cliente de fenêtre limite sont alignées sur les limites en pixels, ce qui entraîne un alignement correct.  
  
-   L’accélération du défilement ne fonctionne pas sur les fenêtres superposées. Cela signifie que windows lesquelles AllowTransparency == true, window.windowstyle == none et ainsi de suite.  
  
-   L’accélération du défilement ne se produit pas pendant le rendu de fenêtre complète.  
  
-   L’accélération du défilement ne fonctionne pas lorsque la fenêtre chevauche deux moniteurs.  
  
-   L’accélération du défilement ne fonctionne pas en présence de cibles de rendu intermédiaires dans la chaîne parent de l’élément défilé. La liste suivante présente que certaines de ces cibles de rendu intermédiaires.  
  
    -   Éléments  
  
    -   Effects (Effets)  
  
    -   DrawingBrushes  
  
    -   VisualBrushes  
  
    -   OpacityMasks  
  
    -   Opacité  
  
-   Seul défilement accéléré peut se produire par frame. Il peut y avoir plusieurs zones de défilement d’accélérée, mais un seul d'entre eux peut effectuer un défilement accéléré pendant un laps de. Quelle zone de défilement est indéterminé.  
  
-   L’accélération du défilement prend en charge le contenu au-dessus de la zone de défilement ne défile pas avec le reste du contenu (dans l’ordre de plan). Le système calcule toutes les zones incorrectes et termine le défilement accéléré, mais envoie plusieurs bitmaps supplémentaires sur le réseau pour déplacer la partie involontairement parcourue sauvegarder à sa position correcte sur l’écran.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTextHintingMode">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.TextHintingMode VisualTextHintingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.TextHintingMode VisualTextHintingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTextHintingMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualTextHintingMode As TextHintingMode" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::TextHintingMode VisualTextHintingMode { System::Windows::Media::TextHintingMode get(); void set(System::Windows::Media::TextHintingMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextHintingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Windows.Media.TextHintingMode" /> de <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.TextHintingMode" /> appliqué à <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTextRenderingMode">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.TextRenderingMode VisualTextRenderingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.TextRenderingMode VisualTextRenderingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTextRenderingMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualTextRenderingMode As TextRenderingMode" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::TextRenderingMode VisualTextRenderingMode { System::Windows::Media::TextRenderingMode get(); void set(System::Windows::Media::TextRenderingMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextRenderingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Windows.Media.TextRenderingMode" /> de <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.TextRenderingMode" /> appliqué à <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform VisualTransform { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform VisualTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Transform ^ VisualTransform {  protected public:&#xA;System::Windows::Media::Transform ^ get(); protected:&#xA; void set(System::Windows::Media::Transform ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur <see cref="T:System.Windows.Media.Transform" /> du <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Valeur de transformation de l'objet visuel.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualXSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection VisualXSnappingGuidelines { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection VisualXSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualXSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualXSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::DoubleCollection ^ VisualXSnappingGuidelines {  protected public:&#xA;System::Windows::Media::DoubleCollection ^ get(); protected:&#xA; void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la collection d’indications de coordonnée X (verticale).</summary>
        <value>Collection d’indications de coordonnée X de l’élément visuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alignement de pixels est le processus dans lequel la disposition de contenu est fixe afin que les bords de l’objet sont rendus sur les pixels spécifiques au périphérique. Le système graphique [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] utilise des unités indépendantes de l’appareil pour assurer une indépendance de la résolution et de l’appareil. Chaque pixel indépendant de l’appareil s’ajuste automatiquement au paramètre [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] du système. Cela permet aux applications [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] de s’ajuster correctement aux différents paramètres [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] et de prendre automatiquement en charge [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)].  
  
 Toutefois, cela [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] indépendance peut générer un rendu irrégulier des bords en raison de l’anticrénelage. Ces artefacts, qui apparaît en général comme bords flous ou « soft », peuvent se produire lorsque l’emplacement d’un bord se situe au milieu d’un pixel de périphérique, plutôt qu’entre les pixels de périphérique. Pour résoudre ce problème, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] offre un moyen pour les bords de l’objet dans une arborescence d’éléments visuels à « snap » aux pixels de périphérique, en éliminant les bords arrondis produits par l’anticrénelage.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.VisualTreeHelper.GetXSnappingGuidelines(System.Windows.Media.Visual)" />
      </Docs>
    </Member>
    <Member MemberName="VisualYSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection VisualYSnappingGuidelines { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection VisualYSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualYSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualYSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::DoubleCollection ^ VisualYSnappingGuidelines {  protected public:&#xA;System::Windows::Media::DoubleCollection ^ get(); protected:&#xA; void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la collection d’indications de coordonnée y (horizontale).</summary>
        <value>Collection d’indications de coordonnée y de l’élément visuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alignement de pixels est le processus dans lequel la disposition de contenu est fixe afin que les bords de l’objet sont rendus sur les pixels spécifiques au périphérique. Le système graphique [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] utilise des unités indépendantes de l’appareil pour assurer une indépendance de la résolution et de l’appareil. Chaque pixel indépendant de l’appareil s’ajuste automatiquement au paramètre [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] du système. Cela permet aux applications [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] de s’ajuster correctement aux différents paramètres [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] et de prendre automatiquement en charge [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)].  
  
 Toutefois, cela [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] indépendance peut générer un rendu irrégulier des bords en raison de l’anticrénelage. Ces artefacts, qui apparaît en général comme bords flous ou « soft », peuvent se produire lorsque l’emplacement d’un bord se situe au milieu d’un pixel de périphérique, plutôt qu’entre les pixels de périphérique. Pour résoudre ce problème, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] offre un moyen pour les bords de l’objet dans une arborescence d’éléments visuels à « snap » aux pixels de périphérique, en éliminant les bords arrondis produits par l’anticrénelage.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.VisualTreeHelper.GetYSnappingGuidelines(System.Windows.Media.Visual)" />
      </Docs>
    </Member>
  </Members>
</Type>