<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="XamlReader.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cb6251512dd75740e1b01a33ceb7e3470f3a68d1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cb6251512dd75740e1b01a33ceb7e3470f3a68d1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads XAML input and creates an object graph, using the WPF default XAML reader and an associated XAML object writer.</source>
          <target state="translated">Lit l'entrée XAML et crée un graphique d'objet en utilisant le lecteur XAML par défaut de WPF et un writer d'objet XAML associé.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The synchronous <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> methods are static, but the asynchronous <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> methods are not static and require an instance of the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class to use.</source>
          <target state="translated">Synchrones <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> méthodes sont statiques, mais asynchrone <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> méthodes ne sont pas statiques et requièrent une instance de la <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe à utiliser.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The output of the <ph id="ph1">`Load`</ph> methods is a single object, which represents the root object of a created object tree or object graph.</source>
          <target state="translated">La sortie de la <ph id="ph1">`Load`</ph> méthodes est un objet unique, qui représente l’objet racine d’une arborescence d’objets créée ou un graphique d’objet.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Object graphs that are created by <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> are typically added to the existing object tree of a WPF application at run time.</source>
          <target state="translated">Les graphiques qui sont créés par l’objet <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> sont généralement ajoutés à l’arborescence d’objets existants d’une application WPF au moment de l’exécution.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Otherwise the new object graph is considered disconnected for purposes of the WPF application model.</source>
          <target state="translated">Sinon, le graphique d’objet est considéré comme déconnecté pour servir de modèle d’application WPF.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>This means that it does not render, and cannot be accessed using any of the object tree techniques as applied to the WPF application's main object tree (for example, the APIs <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>).</source>
          <target state="translated">Cela signifie qu’il n’est pas rendu et ne peut pas être accessible à l’aide des techniques objet arborescence en tant qu’appliqué à l’arborescence d’objets principale de l’application WPF (par exemple, les API <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For more information on object tree concepts, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les concepts d’arborescence d’objets, consultez <bpt id="p1">[</bpt>arborescences dans WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> supports the following primary scenarios:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> prend en charge les scénarios principaux suivants :</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Cloning/object factory<ept id="p1">**</ept>: Without additional mechanisms, a reference type generally cannot be included in more than one position in a WPF object tree.</source>
          <target state="translated"><bpt id="p1">**</bpt>Le clonage/fabrique d’objet<ept id="p1">**</ept>: sans des mécanismes supplémentaires, un type référence en règle générale ne peut pas être inclus dans plus d’une position dans une arborescence d’objets WPF.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>(Examples of additional mechanisms that offer support for sharing or re-use in WPF include objects that are based on <ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph>, or support for commonly shareable objects such as <ph id="ph2">&lt;xref:System.Windows.Media.Brush&gt;</ph> that are referenced as an item from a <ph id="ph3">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.) One way to clone an object that is already in the object tree is to serialize the object using <ph id="ph4">&lt;xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">(Les objets qui sont basés sur des exemples de mécanismes supplémentaires qui offrent une prise en charge pour le partage ou réutiliser dans WPF <ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph>, ou prend en charge pour les objets communément partageables tels que <ph id="ph2">&lt;xref:System.Windows.Media.Brush&gt;</ph> qui sont référencées comme un élément d’un <ph id="ph3">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.) Pour cloner un objet qui est déjà dans l’arborescence d’objets consiste à sérialiser l’objet à l’aide de <ph id="ph4">&lt;xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>You then use the serialized string as input for a call to <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>, with a stream or <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> as an intermediary.</source>
          <target state="translated">Vous utilisez ensuite la chaîne sérialisée comme entrée pour un appel à <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>, avec un flux de données ou <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> comme intermédiaire.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Constructing objects based on just-in-time information<ept id="p1">**</ept>: There are often other ways to have late-binding or user-supplied input change the state of existing objects.</source>
          <target state="translated"><bpt id="p1">**</bpt>Construction d’objets selon des informations juste-à-temps<ept id="p1">**</ept>: il existe souvent des autres façons de faire saisie à liaison tardive ou fourni par l’utilisateur de modifier l’état des objets existants.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For example you could use the same value to set more than one property, or use data binding.</source>
          <target state="translated">Par exemple, vous pourriez utiliser la même valeur pour définir plusieurs propriétés ou utiliser la liaison de données.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>But if you have a scenario where even the type of object to create is only determinable at run time or with user interaction, then creating such an object by building up a string for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> input is often a useful technique.</source>
          <target state="translated">Mais si vous avez un scénario où même le type d’objet à créer est uniquement déterminé au moment de l’exécution ou interaction avec l’utilisateur, puis en créant un tel objet en construisant une chaîne pour <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> entrée est souvent une technique utile.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Using existing resource techniques<ept id="p1">**</ept>: The <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> type is used frequently in other frameworks or technologies for transferring data or objects across application boundaries or for similar situations.</source>
          <target state="translated"><bpt id="p1">**</bpt>À l’aide des techniques de ressource existantes<ept id="p1">**</ept>: le <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> type est souvent utilisé dans d’autres infrastructures ou les technologies pour le transfert des données ou des objets au-delà des limites d’application ou pour des situations similaires.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>You can then use the <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> techniques to store or obtain XAML-formatted data that you eventually use to create an object as part of your application.</source>
          <target state="translated">Vous pouvez ensuite utiliser le <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> techniques pour stocker ou obtenir des données au format XAML que vous utilisez finalement pour créer un objet dans le cadre de votre application.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Fixed documents:<ept id="p1">**</ept> Your application might load local or downloaded XPS documents for inclusion in a WPF application object tree and UI.</source>
          <target state="translated"><bpt id="p1">**</bpt>Documents fixes :<ept id="p1">**</ept> votre application peut charger des documents XPS locaux ou téléchargés pour l’inclure dans une arborescence d’objets application WPF et l’interface utilisateur.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>This documentation sometimes describes an object graph, as opposed to an object tree.</source>
          <target state="translated">Parfois, cette documentation décrit un graphique d’objet, par opposition à une arborescence d’objets.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>A strict parent-child relationship does not always exist in the run time object relationships of a run time WPF application, so an object graph is a more widely applicable terminology.</source>
          <target state="translated">Une relation parent-enfant stricte n’existe pas toujours dans les relations d’objet moment de l’exécution d’une application WPF du moment de l’exécution, par conséquent, un graphique d’objet est une terminologie plus largement applicable.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, because WPF also includes two different tree conceptualization APIs (<ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>) the tree metaphor still applies adequately to most real-world cases in WPF.</source>
          <target state="translated">Toutefois, étant donné que WPF inclut également deux API de conceptualisation arborescence différente (<ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>) métaphore de l’arborescence s’applique encore correctement à la plupart des cas réels dans WPF.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>From the XAML language perspective however, the object graph is often the best way to think about how objects are created out of XAML, because the XAML language itself does not necessarily specify helper class methodologies that bring the relationships more into a tree structure again.</source>
          <target state="translated">Du point de vue du langage XAML, toutefois, le graphique d’objets est souvent la meilleure façon de réfléchir à la création des objets hors XAML, car le langage XAML lui-même ne spécifie pas nécessairement les méthodologies de classe d’assistance qui représentent les relations plusieurs à un structure arborescente à nouveau.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Code Access Security, Loose XAML, and XamlReader</source>
          <target state="translated">Sécurité d’accès du code XAML libre et XamlReader</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>XAML is a markup language that directly represents object instantiation and execution.</source>
          <target state="translated">Le XAML est un langage de balisage qui représente directement l’instanciation d’objets et leur exécution.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Therefore, elements created in XAML have the same ability to interact with system resources (network access, file system IO, for example) as the equivalent generated code does.</source>
          <target state="translated">Ainsi, les éléments créés en XAML ont la même capacité d’interagir avec les ressources système (accès réseau, e/s de système de fichiers, par exemple) que le code généré équivalent.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> supports the <ph id="ph2">[!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)]</ph> security framework <ph id="ph3">[!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> prend en charge la <ph id="ph2">[!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)]</ph> infrastructure de sécurité <ph id="ph3">[!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>This means that <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> content running in the internet zone has reduced execution permissions.</source>
          <target state="translated">Cela signifie que le contenu <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> en cours d’exécution dans la zone Internet dispose d’autorisations d’exécution réduites.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>"Loose XAML" (pages of noncompiled XAML interpreted at load time by a XAML viewer) and <ph id="ph1">[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]</ph> are usually run in this internet zone and use the same permission set.</source>
          <target state="translated">Le « XAML libre » (pages de code XAML non compilé, interprétées au moment du chargement par une visionneuse XAML) et <ph id="ph1">[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]</ph> sont généralement exécutés dans cette zone internet et utilisent le même jeu d’autorisations.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, XAML loaded in to a fully trusted application has the same access to the system resources as the hosting application does.</source>
          <target state="translated">Toutefois, le XAML chargé dans une application d’un niveau de confiance totale dispose du même accès aux ressources système que l’application d’hébergement.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For more information, see <bpt id="p1">[</bpt>WPF Partial Trust Security<ept id="p1">](~/docs/framework/wpf/wpf-partial-trust-security.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Sécurité de confiance partielle de WPF<ept id="p1">](~/docs/framework/wpf/wpf-partial-trust-security.md)</ept>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The implications of these statements for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> is that your application design must make trust decisions about the XAML you decide to load.</source>
          <target state="translated">Les conséquences de ces instructions pour <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> est que la conception de votre application doit prendre des décisions sur le code XAML vous décidez de charger.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are loading XAML that is not trusted, consider implementing your own sandboxing technique for how you load the resulting object graph.</source>
          <target state="translated">Si vous chargez le code XAML qui n’est pas approuvé, envisagez d’implémenter votre propre technique de sandboxing pour comment charger le graphique d’objet obtenu.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> can also be called by partial trust code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> peut également être appelée par le code de confiance partielle.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>In this case, Internet security zone is applied for code access security.</source>
          <target state="translated">Dans ce cas, la zone de sécurité Internet est appliquée pour la sécurité d’accès du code.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If anything in the loaded XAML is invalid under Internet security zone, a XAML parse exception is thrown.</source>
          <target state="translated">Si n’importe où dans le XAML chargé n’est pas valide dans la zone de sécurité Internet, une exception d’analyse XAML est levée.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Under XBAP and other cases that are partial trust at the platform level, where <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> is part of the execution, you get the same exception behavior as with explicit partial trust calls.</source>
          <target state="translated">Sous XBAP et autres qui sont de confiance partielle au niveau de la plateforme, où <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> fait partie de l’exécution, vous obtenez le même comportement d’exception, comme avec les appels de confiance partielle explicites.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>WPF XAML, XAML Readers/Writers, and XAML Language Versioning</source>
          <target state="translated">XAML WPF, lecteurs/Writers XAML et contrôle de version de langage XAML</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">[!INCLUDE[xaml2009](~/includes/xaml2009-md.md)]</ph> includes language features such as  and .</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[xaml2009](~/includes/xaml2009-md.md)]</ph> inclut des fonctionnalités de langage tels qu’et.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>You can use signatures of <ph id="ph1">`Load`</ph> or <ph id="ph2">`Parse`</ph> to load XAML that uses these features.</source>
          <target state="translated">Vous pouvez utiliser des signatures de <ph id="ph1">`Load`</ph> ou <ph id="ph2">`Parse`</ph> pour charger le code XAML qui utilise ces fonctionnalités.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, those language features are not supported for XAML that needs to be markup compiled (such as XAML for the <bpt id="p1">**</bpt>Page<ept id="p1">**</ept> build action in a WPF application, or any XAML that involves the markup compile task in the build actions).</source>
          <target state="translated">Toutefois, ces fonctionnalités de langage ne sont pas pris en charge pour le code XAML qui doit être compilé par balisage (tel que le code XAML pour la <bpt id="p1">**</bpt>Page<ept id="p1">**</ept> action dans une application WPF ou tout XAML qui implique la tâche de compilation de balisage dans les actions de génération de build).</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>WPF types and the WPF technology in general support concepts that rely on access to WPF internals.</source>
          <target state="translated">Les types et la technologie WPF prend en charge en général les concepts qui s’appuient sur l’accès aux éléments internes WPF.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For instance, how WPF implements dependency properties relies on internal techniques for efficient type-member lookup.</source>
          <target state="translated">Par exemple, comment WPF implémente des propriétés de dépendance s’appuie sur les techniques internes pour la recherche de membre de type efficace.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Access to these internals is enabled by the XAML reading and writing APIs provided in <ph id="ph1">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> from the <ph id="ph3">&lt;xref:System.Windows.Markup&gt;</ph> namespace and PresentationFramework assembly.</source>
          <target state="translated">Accès à ces éléments internes est activé par la lecture et l’écriture des API fournies dans XAML <ph id="ph1">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> et <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> à partir de la <ph id="ph3">&lt;xref:System.Windows.Markup&gt;</ph> espace de noms et l’assembly PresentationFramework.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, the lower-level XAML readers and XAML writers from the System.Xaml assembly (classes based on <ph id="ph1">&lt;xref:System.Xaml.XamlReader?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Xaml.XamlWriter?displayProperty=nameWithType&gt;</ph>) do not have access to the WPF internals.</source>
          <target state="translated">Toutefois, les lecteurs XAML de niveau inférieur et les writers XAML à partir de l’assembly System.Xaml (classes basées sur <ph id="ph1">&lt;xref:System.Xaml.XamlReader?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Xaml.XamlWriter?displayProperty=nameWithType&gt;</ph>) n’ont pas accès aux éléments internes WPF.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>There is no dependency from System.Xaml to any WPF-specific assembly.</source>
          <target state="translated">Il n’existe aucune dépendance de System.Xaml à n’importe quel assembly WPF spécifiques.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Without access to the WPF internals, System.Xaml readers and writers cannot correctly load or save all WPF types, or types based on WPF types.</source>
          <target state="translated">Sans accès aux éléments internes WPF, les enregistreurs et lecteurs de System.Xaml ne peut pas se charger correctement ou enregistrer WPF tous les types, ou selon les types WPF.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>In particular, the System.Xaml readers and writers do not understand concepts such as the WPF dependency property backing property store, or all the specifics of how WPF uses styles, resource dictionaries and templates.</source>
          <target state="translated">En particulier, les lecteurs et writers System.Xaml ne comprennent pas les concepts tels que la propriété de dépendance WPF banque de propriétés ou toutes les spécificités de la façon dont WPF utilise les styles, les dictionnaires de ressources et les modèles de stockage.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Therefore you have a choice to make:</source>
          <target state="translated">Par conséquent, vous devez faire un choix :</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are loading WPF types, and/or you are using XAML in BAML form in any way, use the PresentationFramework XAML readers and XAML writers.</source>
          <target state="translated">Si vous chargez des types WPF, et/ou vous utilisez XAML sous forme BAML en aucune façon, utilisez les lecteurs XAML PresentationFramework et writers XAML.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are not relying on any WPF types or the BAML form of XAML, and are not using another specific technology's XAML reader or XAML writer implementation for reasons that are specific to that framework, use the System.Xaml XAML readers and XAML writers.</source>
          <target state="translated">Si vous ne comptez pas sur les types WPF ou la forme BAML du XAML et que vous n’utilisez pas de lecteur XAML ou l’implémentation du writer XAML d’une autre technologie spécifique pour des raisons spécifiques à cette infrastructure, utilisez les lecteurs XAML System.Xaml et les writers XAML.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>System.Xaml Backing Implementation in .NET 4</source>
          <target state="translated">System.Xaml sauvegarde mise en œuvre dans .NET 4</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> is the callable API surface for the WPF framework-level XAML parser.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> est la surface API peut être appelée pour l’analyseur XAML de niveau infrastructure WPF.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The same underlying XAML parser also performs the run-time XAML loading and parsing for WPF applications that target <ph id="ph1">[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]</ph> and <ph id="ph2">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>.</source>
          <target state="translated">Le même analyseur XAML sous-jacent exécute également le code d’exécution XAML le chargement et l’analyse pour les applications WPF qui ciblent <ph id="ph1">[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]</ph> et <ph id="ph2">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are targeting <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, the external API is the same, but parts of the implementation are built on the <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> general XAML implementation in the System.Xaml assembly, which improves many of the technical and reporting aspects of parsing XAML.</source>
          <target state="translated">Si vous ciblez <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, l’API externe est la même, mais les parties de l’implémentation sont construites sur le <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> implémentation XAML générale dans l’assembly System.Xaml, ce qui améliore les plusieurs aspects techniques et création de rapports de l’analyse XAML.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Targeting <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> necessarily entails including System.Xaml as a reference, and details of implementation such as the exceptions reported may come from System.Xaml defined types.</source>
          <target state="translated">Ciblage <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> implique notamment System.Xaml comme une référence et les détails de l’implémentation, telles que les exceptions signalées peuvent provenir de System.Xaml nécessairement les types définis.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The following example converts a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> into a string using the <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> class.</source>
          <target state="translated">L’exemple suivant convertit un <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> dans une chaîne à l’aide de la <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The string is then loaded back into a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> using the static <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class.</source>
          <target state="translated">La chaîne est ensuite chargée dans un <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> à l’aide de la méthode statique <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> méthode sur la <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.CancelAsync">
          <source>Aborts the current asynchronous load operation, if there is an asynchronous load operation pending.</source>
          <target state="translated">Abandonne l'opération de chargement asynchrone actuelle, si une opération de ce type est en attente.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.CancelAsync">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.CancelAsync%2A&gt;</ph> is an asynchronous operation; therefore, some loading may occur before the operation is aborted.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.CancelAsync%2A&gt;</ph> est une opération asynchrone ; Par conséquent, certains chargement peut se produire avant l’abandon de l’opération.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph> object that represents the WPF schema context settings for a <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">Retourne un objet <ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph> qui représente les paramètres de contexte de schéma WPF pour un <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph> object that represents the WPF schema context settings for a <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph> représentant les paramètres de contexte de schéma WPF d'un <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads XAML input and returns the root of the corresponding object tree.</source>
          <target state="translated">Lit l'entrée XAML et retourne la racine de l'arborescence de l'objet correspondant.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The XAML to load, in stream form.</source>
          <target state="translated">XAML à charger, dans le formulaire de flux.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns an <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> that is the root of the corresponding object tree.</source>
          <target state="translated">Lit l'entrée XAML dans le <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> spécifié et retourne un <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> qui est la racine de l'arborescence de l'objet correspondant.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The object at the root of the created object tree.</source>
          <target state="translated">Objet à la racine de l'arborescence d'objets créée.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The following example saves a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> into a <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph> using the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> class.</source>
          <target state="translated">L’exemple suivant enregistre un <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> dans un <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph> à l’aide de la <ph id="ph3">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The stream is then loaded back into a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> using the static <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class.</source>
          <target state="translated">Le flux est ensuite chargé dans un <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> à l’aide de la méthode statique <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> méthode sur la <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph> object.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>This is expected to be initialized with input XAML.</source>
          <target state="translated">Attendu pour être initialisé avec l'entrée XAML.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>Reads the XAML input through a provided <ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph> and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">Lit l'entrée XAML via le <ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph> fourni et retourne un objet qui est la racine de l'arborescence de l'objet correspondant.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">Objet qui est la racine de l'arborescence d'objets créée.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>The input <ph id="ph1">&lt;xref:System.Xaml.XamlReader&gt;</ph> can be <ph id="ph2">&lt;xref:System.Windows.Baml2006.Baml2006Reader&gt;</ph>.</source>
          <target state="translated">L’entrée <ph id="ph1">&lt;xref:System.Xaml.XamlReader&gt;</ph> peut être <ph id="ph2">&lt;xref:System.Windows.Baml2006.Baml2006Reader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>This is how you can load BAML at run time, or for localization tool purposes.</source>
          <target state="translated">Voici comment vous pouvez charger BAML au moment de l’exécution, soit pour des raisons d’outil de localisation.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> that has already loaded the XAML input to load in XML form.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> qui a déjà chargé l'entrée XAML à charger dans le formulaire XML.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">Lit l'entrée XAML dans le <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> spécifié et retourne un objet qui est la racine de l'arborescence de l'objet correspondant.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">Objet qui est la racine de l'arborescence d'objets créée.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The following example converts a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> into a string using the <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> class.</source>
          <target state="translated">L’exemple suivant convertit un <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> dans une chaîne à l’aide de la <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The string is then loaded back into a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> using the static <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class.</source>
          <target state="translated">La chaîne est ensuite chargée dans un <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> à l’aide de la méthode statique <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> méthode sur la <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The stream that contains the XAML input to load.</source>
          <target state="translated">Flux qui contient l'entrée XAML à charger.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Context information used by the parser.</source>
          <target state="translated">Informations de contexte utilisées par l'analyseur.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">Lit l'entrée XAML dans le <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> spécifié et retourne un objet qui est la racine de l'arborescence de l'objet correspondant.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">Objet qui est la racine de l'arborescence d'objets créée.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source><ph id="ph1">&lt;paramref name="parserContext" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parserContext" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads XAML markup and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">Lit le balisage XAML et retourne un objet qui correspond à la racine du balisage spécifié.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>The stream containing the XAML input to load.</source>
          <target state="translated">Flux contenant l'entrée XAML à charger.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns the root of the corresponding object tree.</source>
          <target state="translated">Lit l'entrée XAML dans le <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> spécifié et retourne la racine de l'arborescence de l'objet correspondant.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">Objet qui est la racine de l'arborescence d'objets créée.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">Une opération de chargement XAML asynchrone retournera initialement un objet qui est purement l’objet racine.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">En mode asynchrone, l’analyse XAML sont ensuite continue, et tous les objets enfants sont remplis sous la racine.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">Ce comportement diffère le traitement XAML WPF typique comportement et son interaction avec les concepts WPF de durée de vie.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">Dans l’interaction classique (non-async), toutes les propriétés d’un objet, y compris toutes les collections enfants sont remplies avant de retourner un élément et de signaler comme chargé.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">Ce comportement équivaut à une méthodologie de bas en haut pour la création de l’arborescence où l’objet racine est le dernier objet devienne disponible.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>You typically would assign the returned object to some location in your WPF application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">Vous en général l’objet retourné à un emplacement dans l’arborescence d’objets de votre application WPF, sachant que le contenu pouvez être complété et pouvez provoquer des mises à jour de disposition incrémentielles si le contenu entier est exposé en tant que partie de l’interface utilisateur.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is handled.</source>
          <target state="translated">Pour cette raison, il est classique d’isoler ou de virtualiser les objets chargés de façon asynchrone à partir de XAML et d’utiliser une logique spécifique à l’application ou l’état de l’application pour notifier lorsque <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> est gérée.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>In order for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to load XAML input asynchronously, the root element in the XAML input must contain the attribute and value <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">Dans l’ordre pour <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> pour charger le XAML d’entrée de façon asynchrone, l’élément racine dans l’entrée XAML doit contenir l’attribut et la valeur <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">La valeur est traitée comme respectant la casse.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>If the XAML input root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is processed as a synchronous load (see <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;</ph>).</source>
          <target state="translated">Si la racine d’entrée XAML ne contient pas <ph id="ph1">`x:SynchronousMode="Async"`</ph>, aucune exception n’est levée et l’appel est traité comme une charge synchrone (voir <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Only one asynchronous load operation per instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class can be performed at a time.</source>
          <target state="translated">Une seule opération de chargement asynchrone par instance de la <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe peut être effectuée à la fois.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>If more than one asynchronous operation is attempted on the same instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">Si plus d’une opération asynchrone est tentée sur la même instance de la <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe une <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Multiple load operations are pending concurrently with the same <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">Plusieurs opérations de chargement sont en attente simultanément avec le même <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>An existing  <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> that has already loaded/read the XAML input.</source>
          <target state="translated">Classe <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> existante qui a déjà chargé/lu l'entrée XAML.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> and returns the root of the corresponding object tree.</source>
          <target state="translated">Lit l'entrée XAML dans le <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> spécifié et retourne la racine de l'arborescence de l'objet correspondant.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>The root of the created object tree.</source>
          <target state="translated">Racine de l'arborescence d'objets créée.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">Une opération de chargement XAML asynchrone retournera initialement un objet qui est purement l’objet racine.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">En mode asynchrone, l’analyse XAML sont ensuite continue, et tous les objets enfants sont remplis sous la racine.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">Ce comportement diffère le traitement XAML WPF typique comportement et son interaction avec les concepts WPF de durée de vie.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">Dans l’interaction classique (non-async), toutes les propriétés d’un objet, y compris toutes les collections enfants sont remplies avant de retourner un élément et de signaler comme chargé.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">Ce comportement équivaut à une méthodologie de bas en haut pour la création de l’arborescence où l’objet racine est le dernier objet devienne disponible.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>You typically would assign the returned object from <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">Vous devez en général attribuer l’objet retourné à partir de <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> vers un emplacement dans l’arborescence d’objets de votre application, sachant que le contenu peut toujours être complété et peut provoquer des mises à jour de disposition incrémentielles si le contenu entier est exposé dans le cadre de la INTERFACE UTILISATEUR.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is handled.</source>
          <target state="translated">Pour cette raison, il est classique d’isoler ou de virtualiser les objets chargés de façon asynchrone à partir de XAML et d’utiliser une logique spécifique à l’application ou l’état de l’application pour notifier lorsque <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> est gérée.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>In order for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to load XAML input asynchronously, the root element in the XAML markup must contain the attribute and value <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">Dans l’ordre pour <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> pour charger le XAML d’entrée de façon asynchrone, l’élément racine dans le balisage XAML doit contenir l’attribut et la valeur <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">La valeur est traitée comme respectant la casse.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>If the XAML markup root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is instead processed as a synchronous load (see <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;</ph>).</source>
          <target state="translated">Si la racine du balisage XAML ne contient pas <ph id="ph1">`x:SynchronousMode="Async"`</ph>, aucune exception n’est levée et l’appel est traité à la place comme une charge synchrone (voir <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Only one asynchronous load operation per instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class can be performed at a time.</source>
          <target state="translated">Une seule opération de chargement asynchrone par instance de la <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe peut être effectuée à la fois.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>If more than one asynchronous operation is attempted on the same instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">Si plus d’une opération asynchrone est tentée sur la même instance de la <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe une <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Multiple load operations are performed concurrently with the same <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">Plusieurs opérations de chargement sont réalisées simultanément avec le même <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>A stream containing the XAML input to load.</source>
          <target state="translated">Flux contenant l'entrée XAML à charger.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Context information used by the parser.</source>
          <target state="translated">Informations de contexte utilisées par l'analyseur.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns the root of the corresponding object tree.</source>
          <target state="translated">Lit l'entrée XAML dans le <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> spécifié et retourne la racine de l'arborescence de l'objet correspondant.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The root of the created object tree.</source>
          <target state="translated">Racine de l'arborescence d'objets créée.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">Une opération de chargement XAML asynchrone retournera initialement un objet qui est purement l’objet racine.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">En mode asynchrone, l’analyse XAML sont ensuite continue, et tous les objets enfants sont remplis sous la racine.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">Ce comportement diffère le traitement XAML WPF typique comportement et son interaction avec les concepts WPF de durée de vie.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">Dans l’interaction classique (non-async), toutes les propriétés d’un objet, y compris toutes les collections enfants sont remplies avant de retourner un élément et de signaler comme chargé.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">Ce comportement équivaut à une méthodologie de bas en haut pour la création de l’arborescence où l’objet racine est le dernier objet devienne disponible.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>You typically would assign the returned object to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">Vous en général l’objet retourné à un emplacement dans l’arborescence d’objets de votre application, sachant que le contenu pouvez être complété et pouvez provoquer des mises à jour de disposition incrémentielles si le contenu entier est exposé en tant que partie de l’interface utilisateur.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is handled.</source>
          <target state="translated">Pour cette raison, il est classique d’isoler ou de virtualiser les objets chargés de façon asynchrone à partir de XAML et d’utiliser une logique spécifique à l’application ou l’état de l’application pour notifier lorsque <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> est gérée.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>In order for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to load markup asynchronously, the root element in the XAML markup must contain the attribute and value <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">Dans l’ordre pour <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> pour charger le balisage en mode asynchrone, l’élément racine dans le balisage XAML doit contenir l’attribut et la valeur <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">La valeur est traitée comme respectant la casse.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>If the XAML markup root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is processed as a synchronous load (see <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;</ph>).</source>
          <target state="translated">Si la racine du balisage XAML ne contient pas <ph id="ph1">`x:SynchronousMode="Async"`</ph>, aucune exception n’est levée et l’appel est traité comme une charge synchrone (voir <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Only one asynchronous load operation per instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class can be performed at a time.</source>
          <target state="translated">Une seule opération de chargement asynchrone par instance de la <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe peut être effectuée à la fois.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>If more than one asynchronous operation is attempted on the same instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">Si plus d’une opération asynchrone est tentée sur la même instance de la <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe une <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Multiple load operations are performed concurrently with the same <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">Plusieurs opérations de chargement sont réalisées simultanément avec le même <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="E:System.Windows.Markup.XamlReader.LoadCompleted">
          <source>Occurs when an asynchronous load operation completes.</source>
          <target state="translated">Se produit lorsqu'une opération de chargement asynchrone se termine.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.Markup.XamlReader.LoadCompleted">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is also raised when an asynchronous load operation aborts.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> est également déclenché lorsqu’une opération de chargement asynchrone est abandonnée.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads the markup in the specified text string and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">Lit le balisage dans la chaîne de texte spécifiée et retourne un objet qui correspond à la racine du balisage indiqué.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>The input XAML, as a single text string.</source>
          <target state="translated">XAML d'entrée, en tant que chaîne de texte unique.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>Reads the XAML input in the specified text string and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">Lit l'entrée XAML dans la chaîne de texte spécifiée et retourne un objet qui correspond à la racine du balisage indiqué.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>The root of the created object tree.</source>
          <target state="translated">Racine de l'arborescence d'objets créée.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>The implementation calls <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> internally after creating a stream from the string.</source>
          <target state="translated">L’implémentation appelle <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> en interne après la création d’un flux de données à partir de la chaîne.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> for additional information such as possible exceptions.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> pour plus d’informations telles que les exceptions possibles.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>The input XAML, as a single text string.</source>
          <target state="translated">XAML d'entrée, en tant que chaîne de texte unique.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>Context information used by the parser.</source>
          <target state="translated">Informations de contexte utilisées par l'analyseur.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>Reads the XAML markup in the specified text string (using a specified <ph id="ph1">&lt;see cref="T:System.Windows.Markup.ParserContext" /&gt;</ph>) and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">Lit le balisage XAML dans la chaîne de texte spécifiée (à l'aide d'un <ph id="ph1">&lt;see cref="T:System.Windows.Markup.ParserContext" /&gt;</ph> spécifié) et retourne un objet qui correspond à la racine du balisage indiqué.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>The root of the created object tree.</source>
          <target state="translated">Racine de l'arborescence d'objets créée.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>The implementation calls <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> internally after creating a stream from the string.</source>
          <target state="translated">L’implémentation appelle <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> en interne après la création d’un flux de données à partir de la chaîne.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> for additional information such as possible exceptions.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> pour plus d’informations telles que les exceptions possibles.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>