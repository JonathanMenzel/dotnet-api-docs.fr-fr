<Type Name="XamlReader" FullName="System.Windows.Markup.XamlReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="eb09b92c85f6899f8f0386e85d5fda59b541d871" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39361139" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlReader extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.XamlReader" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlReader" />
  <TypeSignature Language="F#" Value="type XamlReader = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Lit l'entrée XAML et crée un graphique d'objet en utilisant le lecteur XAML par défaut de WPF et un writer d'objet XAML associé.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Synchrones <xref:System.Windows.Markup.XamlReader.Load%2A> méthodes sont statiques, mais asynchrone <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> méthodes ne sont pas statiques et requièrent une instance de la <xref:System.Windows.Markup.XamlReader> classe à utiliser.  
  
 La sortie de la `Load` méthodes est un objet unique, ce qui représente l’objet racine d’une arborescence d’objets créée ou un graphique d’objet. Les graphiques qui sont créés par l’objet <xref:System.Windows.Markup.XamlReader> sont généralement ajoutés à l’arborescence d’objets existants d’une application WPF en cours d’exécution. Sinon, le graphique d’objet est considéré comme déconnecté pour servir de modèle d’application WPF. Cela signifie qu’il n’affiche pas et ne peut pas être accessible à l’aide de techniques d’arborescence objet en tant qu’appliqué à l’arborescence d’objets principal de l’application WPF (par exemple, les API <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>). Pour plus d’informations sur les concepts d’arborescence d’objets, consultez [arborescences dans WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 <xref:System.Windows.Markup.XamlReader> prend en charge les scénarios principaux suivants :  
  
-   **Fabrique d’objet/clonage**: sans des mécanismes supplémentaires, un type référence en règle générale ne peut pas être inclus dans plus d’une position dans une arborescence d’objets WPF. (Objets qui sont basés sur des exemples de mécanismes supplémentaires qui offrent une prise en charge pour le partage ou réutiliser dans WPF <xref:System.Windows.Freezable>, ou prennent en charge pour les objets communément partageables comme <xref:System.Windows.Media.Brush> qui sont référencés sous la forme d’un élément à partir d’un <xref:System.Windows.ResourceDictionary>.) Pour cloner un objet qui se trouve déjà dans l’arborescence d’objets, vous pouvez sérialiser l’objet en utilisant <xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType>. Vous utilisez ensuite la chaîne sérialisée en tant qu’entrée pour un appel à <xref:System.Windows.Markup.XamlReader.Load%2A>, avec un flux de données ou <xref:System.Xml.XmlReader> comme intermédiaire.  
  
-   **Construction d’objets selon les informations de juste-à-temps**: il existe souvent des autres façons de faire d’entrée de liaison tardive ou fournie par l’utilisateur à modifier l’état des objets existants. Par exemple, vous pourrez utiliser la même valeur pour définir plusieurs propriétés, ou utiliser la liaison de données. Mais si vous avez un scénario où même le type d’objet à créer est déterminable uniquement au moment de l’exécution ou sans interaction utilisateur, puis en créant un tel objet en créant une chaîne pour <xref:System.Windows.Markup.XamlReader.Load%2A> entrée est souvent une technique utile.  
  
-   **À l’aide de techniques de ressource existantes**: le <xref:System.IO.Stream> type est fréquemment utilisé dans d’autres infrastructures ou les technologies pour le transfert de données ou des objets au-delà des limites d’application ou pour des situations similaires. Vous pouvez ensuite utiliser le <xref:System.IO.Stream> techniques pour stocker ou obtenir des données au format XAML, que vous utilisez pour créer un objet dans le cadre de votre application.  
  
-   **Documents fixes :** votre application peut charger des documents XPS locaux ou téléchargés pour l’inclusion dans une arborescence d’objets WPF application et l’interface utilisateur.  
  
> [!NOTE]
>  Parfois, cette documentation décrit un graphique d’objet, par opposition à une arborescence d’objets. Une relation parent-enfant stricte n’existe pas toujours dans les relations d’objet moment de l’exécution d’une application WPF du moment de l’exécution, par conséquent, un graphique d’objet est une terminologie plus largement applicable. Toutefois, étant donné que WPF inclut également deux API de conceptualisation arborescence différente (<xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>) la métaphore de l’arborescence s’applique encore correctement à la plupart des cas réels dans WPF. Du point de vue du langage XAML, toutefois, le graphique d’objets est souvent la meilleure façon de réfléchir à la création des objets hors XAML, comme le langage XAML lui-même ne spécifie pas nécessairement les méthodologies de classe d’assistance qui représentent les relations plus dans un structure arborescente à nouveau.  
  
## <a name="code-access-security-loose-xaml-and-xamlreader"></a>Sécurité d’accès du code XAML libre et XamlReader  
 Le XAML est un langage de balisage qui représente directement l’instanciation d’objets et leur exécution. Ainsi, les éléments créés en XAML ont la même capacité d’interagir avec les ressources système (accès réseau, e/s de système de fichiers, par exemple) que le code généré équivalent.  
  
 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] prend en charge la [!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)] infrastructure de sécurité [!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]. Cela signifie que le contenu [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] en cours d’exécution dans la zone Internet dispose d’autorisations d’exécution réduites. Le « XAML libre » (pages de code XAML non compilé, interprétées au moment du chargement par une visionneuse XAML) et [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] sont généralement exécutés dans cette zone internet et utilisent le même jeu d’autorisations.  Toutefois, le XAML chargé dans une application d’un niveau de confiance totale dispose du même accès aux ressources système que l’application d’hébergement. Pour plus d’informations, consultez [Sécurité de confiance partielle de WPF](~/docs/framework/wpf/wpf-partial-trust-security.md).  
  
 Les conséquences de ces instructions pour <xref:System.Windows.Markup.XamlReader> est que la conception de votre application doit prendre des décisions sur le XAML vous décidez de charger. Si vous chargez le XAML qui n’est pas fiable, envisagez d’implémenter votre propre technique de sandboxing pour comment charger le graphique d’objet qui en résulte.  
  
 <xref:System.Windows.Markup.XamlReader> peut également être appelée par le code de confiance partielle. Dans ce cas, la zone de sécurité Internet est appliquée pour la sécurité d’accès du code. Si rien dans le XAML chargé n’est pas valide sous la zone de sécurité Internet, une exception d’analyse XAML est levée. Sous XBAP et autres qui sont de confiance partielle au niveau de la plateforme, où <xref:System.Windows.Markup.XamlReader> fait partie de l’exécution, vous obtenez le même comportement d’exception, comme avec les appels explicites de confiance partielle.  
  
## <a name="wpf-xaml-xaml-readerswriters-and-xaml-language-versioning"></a>XAML de WPF, XAML lecteurs/rédacteurs et contrôle de version de langage XAML  
 XAML2009 inclut des fonctionnalités de langage tels que [x : Reference](~/docs/framework/xaml-services/x-reference-markup-extension.md) et [x : FactoryMethod](~/docs/framework/xaml-services/x-factorymethod-directive.md). Vous pouvez utiliser des signatures de `Load` ou `Parse` pour charger le XAML qui utilise ces fonctionnalités. Toutefois, ces fonctionnalités de langage ne sont pas pris en charge pour le XAML qui doit être compilé par balisage (tel que XAML pour le **Page** action dans une application WPF ou tout XAML qui implique la tâche de compilation de balisage dans les actions de génération de génération).  
  
 Les types et la technologie WPF prennent en charge en général les concepts qui s’appuient sur l’accès aux éléments internes WPF. Par exemple, comment WPF implémente des propriétés de dépendance s’appuie sur des techniques internes pour la recherche de membre de type efficace. Accès à ces éléments internes est activé par le XAML de lire et écrire des API fournies dans <xref:System.Windows.Markup.XamlWriter> et <xref:System.Windows.Markup.XamlReader> à partir de la <xref:System.Windows.Markup> espace de noms et l’assembly PresentationFramework. Toutefois, les lecteurs XAML de niveau inférieur et les writers XAML à partir de l’assembly System.Xaml (classes basées sur <xref:System.Xaml.XamlReader?displayProperty=nameWithType>, <xref:System.Xaml.XamlWriter?displayProperty=nameWithType>) n’ont pas accès aux éléments internes WPF. Il n’existe aucune dépendance de System.Xaml à n’importe quel assembly spécifique. Sans accès aux éléments internes WPF, enregistreurs et lecteurs de System.Xaml ne peut pas charger correctement ou enregistrer WPF tous les types, ou selon les types WPF. En particulier, les lecteurs et writers System.Xaml ne comprennent pas les concepts tels que la propriété de dépendance WPF banque de propriétés ou toutes les spécificités de la façon dont WPF utilise les styles, les dictionnaires de ressources et les modèles de stockage. Par conséquent, vous devez faire un choix :  
  
-   Si vous chargez des types WPF, et/ou vous utilisez XAML dans le formulaire BAML de toute façon, utilisez les lecteurs de PresentationFramework XAML et les writers XAML.  
  
-   Si vous ne comptez pas sur les types WPF ou le formulaire BAML de XAML et que vous n’utilisez pas de lecteur XAML ou l’implémentation du writer XAML une autre technologie spécifique pour des raisons qui sont spécifiques à cette infrastructure, utilisez les lecteurs de System.Xaml XAML et les writers XAML.  
  
## <a name="systemxaml-backing-implementation-in-net-4"></a>System.Xaml sauvegarde mise en œuvre dans .NET 4  
 <xref:System.Windows.Markup.XamlReader> est la surface d’API pouvant être appelée pour l’analyseur XAML de niveau infrastructure WPF. Le même analyseur XAML sous-jacent effectue également le XAML de l’exécution le chargement et l’analyse pour les applications WPF qui ciblent [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] et [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)].  
  
 Si vous ciblez [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], l’API externe est identique, mais les parties de l’implémentation sont appuient sur le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] implémentation générale de XAML dans l’assembly System.Xaml, ce qui améliore la plupart des aspects techniques et création de rapports de l’analyse XAML. Ciblage [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] nécessairement implique notamment System.Xaml comme référence et les détails d’implémentation telles que les exceptions signalées peuvent provenir de System.Xaml types définis par le.  
  
## Examples  
 L’exemple suivant convertit un <xref:System.Windows.Controls.Button> dans une chaîne en utilisant la <xref:System.Windows.Markup.XamlWriter> classe.  La chaîne est ensuite chargée dans un <xref:System.Windows.Controls.Button> à l’aide de la méthode statique <xref:System.Windows.Markup.XamlReader.Load%2A> méthode sur le <xref:System.Windows.Markup.XamlReader> classe.  
  
 [!code-csharp[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Markup.XamlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Markup.XamlReader" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="xamlReader.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Abandonne l'opération de chargement asynchrone actuelle, si une opération de ce type est en attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Markup.XamlReader.CancelAsync%2A> est une opération asynchrone ; Par conséquent, certains chargement peut se produire avant que l’opération est abandonnée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWpfSchemaContext">
      <MemberSignature Language="C#" Value="public static System.Xaml.XamlSchemaContext GetWpfSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xaml.XamlSchemaContext GetWpfSchemaContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetWpfSchemaContext () As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xaml::XamlSchemaContext ^ GetWpfSchemaContext();" />
      <MemberSignature Language="F#" Value="static member GetWpfSchemaContext : unit -&gt; System.Xaml.XamlSchemaContext" Usage="System.Windows.Markup.XamlReader.GetWpfSchemaContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Xaml.XamlSchemaContext" /> qui représente les paramètres de contexte de schéma WPF pour un <see cref="T:System.Windows.Markup.XamlReader" />.</summary>
        <returns>Objet <see cref="T:System.Xaml.XamlSchemaContext" /> représentant les paramètres de contexte de schéma WPF d'un <see cref="T:System.Windows.Markup.XamlReader" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit l'entrée XAML et retourne la racine de l'arborescence de l'objet correspondant.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">XAML à charger, dans le formulaire de flux.</param>
        <summary>Lit l'entrée XAML dans le <see cref="T:System.IO.Stream" /> spécifié et retourne un <see cref="T:System.Object" /> qui est la racine de l'arborescence de l'objet correspondant.</summary>
        <returns>Objet à la racine de l'arborescence d'objets créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant enregistre un <xref:System.Windows.Controls.Button> dans un <xref:System.IO.MemoryStream> à l’aide de la <xref:System.Windows.Markup.XamlWriter> classe. Le flux est ensuite chargé dans un <xref:System.Windows.Controls.Button> à l’aide de la méthode statique <xref:System.Windows.Markup.XamlReader.Load%2A> méthode sur le <xref:System.Windows.Markup.XamlReader> classe.  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xaml.XamlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xaml.XamlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XamlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xaml::XamlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xaml.XamlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xaml.XamlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Objet <see cref="T:System.Xaml.XamlReader" />. Attendu pour être initialisé avec l'entrée XAML.</param>
        <summary>Lit l'entrée XAML via le <see cref="T:System.Xaml.XamlReader" /> fourni et retourne un objet qui est la racine de l'arborescence de l'objet correspondant.</summary>
        <returns>Objet qui est la racine de l'arborescence d'objets créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’entrée <xref:System.Xaml.XamlReader> peut être <xref:System.Windows.Baml2006.Baml2006Reader>. Voici comment vous pouvez charger BAML au moment de l’exécution, soit pour des raisons d’outil de localisation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> qui a déjà chargé l'entrée XAML à charger dans le formulaire XML.</param>
        <summary>Lit l'entrée XAML dans le <see cref="T:System.Xml.XmlReader" /> spécifié et retourne un objet qui est la racine de l'arborescence de l'objet correspondant.</summary>
        <returns>Objet qui est la racine de l'arborescence d'objets créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant convertit un <xref:System.Windows.Controls.Button> dans une chaîne en utilisant la <xref:System.Windows.Markup.XamlWriter> classe.  La chaîne est ensuite chargée dans un <xref:System.Windows.Controls.Button> à l’aide de la méthode statique <xref:System.Windows.Markup.XamlReader.Load%2A> méthode sur le <xref:System.Windows.Markup.XamlReader> classe.  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream">Flux qui contient l'entrée XAML à charger.</param>
        <param name="parserContext">Informations de contexte utilisées par l'analyseur.</param>
        <summary>Lit l'entrée XAML dans le <see cref="T:System.IO.Stream" /> spécifié et retourne un objet qui est la racine de l'arborescence de l'objet correspondant.</summary>
        <returns>Objet qui est la racine de l'arborescence d'objets créée.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="parserContext" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadAsync">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit le balisage XAML et retourne un objet qui correspond à la racine du balisage spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream -&gt; obj" Usage="xamlReader.LoadAsync stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Flux contenant l'entrée XAML à charger.</param>
        <summary>Lit l'entrée XAML dans le <see cref="T:System.IO.Stream" /> spécifié et retourne la racine de l'arborescence de l'objet correspondant.</summary>
        <returns>Objet qui est la racine de l'arborescence d'objets créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une opération de chargement XAML asynchrone initialement retournera un objet qui est purement l’objet racine. De façon asynchrone, XAML analyse puis se poursuit, et tous les objets enfants sont remplis sous la racine. Ce comportement diffère du XAML WPF typique comportement et son interaction avec les concepts WPF de durée de vie de traitement. Dans l’interaction classique (non asynchrone), toutes les propriétés d’un objet, y compris toutes les collections enfants sont remplies avant de retourner un élément et de signaler comme chargé. Ce comportement équivaut à une méthodologie de bas en haut pour la création de l’arborescence où l’objet racine est le dernier objet devienne disponible.  
  
 Vous en général, l’objet retourné à un emplacement dans l’arborescence d’objets de votre application WPF, sachant que le contenu pouvez être complété et pouvez entraîner des mises à jour de disposition incrémentielle si le contenu entier est exposé en tant que partie de l’interface utilisateur. Pour cette raison, il est classique d’isoler ou de virtualiser les objets chargés de façon asynchrone à partir de XAML et d’utiliser une logique spécifique à l’application ou l’état de l’application pour notifier lorsque <xref:System.Windows.Markup.XamlReader.LoadCompleted> est gérée.  
  
 Dans l’ordre pour <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> pour charger le XAML d’entrée de façon asynchrone, l’élément racine dans le XAML d’entrée doit contenir l’attribut et la valeur `x:SynchronousMode="Async"`. La valeur est considérée comme respectant la casse. Si la racine d’entrée XAML ne contient-elle pas `x:SynchronousMode="Async"`, aucune exception n’est levée et l’appel est traité comme une charge synchrone (voir <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>).  
  
 Qu’une seule opération de chargement asynchrone par instance de la <xref:System.Windows.Markup.XamlReader> classe peut être effectuée à la fois.  Si plus d’une opération asynchrone est tentée sur la même instance de la <xref:System.Windows.Markup.XamlReader> classe un <xref:System.InvalidOperationException> est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Plusieurs opérations de chargement sont en attente simultanément avec le même <see cref="T:System.Windows.Markup.XamlReader" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadAsync (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.Xml.XmlReader -&gt; obj" Usage="xamlReader.LoadAsync reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Classe <see cref="T:System.Xml.XmlReader" /> existante qui a déjà chargé/lu l'entrée XAML.</param>
        <summary>Lit l'entrée XAML dans le <see cref="T:System.Xml.XmlReader" /> spécifié et retourne la racine de l'arborescence de l'objet correspondant.</summary>
        <returns>Racine de l'arborescence d'objets créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une opération de chargement XAML asynchrone initialement retournera un objet qui est purement l’objet racine. De façon asynchrone, XAML analyse puis se poursuit, et tous les objets enfants sont remplis sous la racine. Ce comportement diffère du XAML WPF typique comportement et son interaction avec les concepts WPF de durée de vie de traitement. Dans l’interaction classique (non asynchrone), toutes les propriétés d’un objet, y compris toutes les collections enfants sont remplies avant de retourner un élément et de signaler comme chargé. Ce comportement équivaut à une méthodologie de bas en haut pour la création de l’arborescence où l’objet racine est le dernier objet devienne disponible.  
  
 Vous assignerez l’objet retourné à partir de <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> vers un emplacement dans l’arborescence d’objets de votre application, avec le contenu de la base de connaissances peut être complété et peut entraîner des mises à jour de disposition incrémentielle si le contenu entier est exposé dans le cadre de la INTERFACE UTILISATEUR. Pour cette raison, il est classique d’isoler ou de virtualiser les objets chargés de façon asynchrone à partir de XAML et d’utiliser une logique spécifique à l’application ou l’état de l’application pour notifier lorsque <xref:System.Windows.Markup.XamlReader.LoadCompleted> est gérée.  
  
 Dans l’ordre pour <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> pour charger le XAML d’entrée de façon asynchrone, l’élément racine dans le balisage XAML doit contenir l’attribut et la valeur `x:SynchronousMode="Async"`. La valeur est considérée comme respectant la casse. Si la racine du balisage XAML ne contient-elle pas `x:SynchronousMode="Async"`, aucune exception n’est levée et l’appel est traité à la place comme une charge synchrone (voir <xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>).  
  
 Qu’une seule opération de chargement asynchrone par instance de la <xref:System.Windows.Markup.XamlReader> classe peut être effectuée à la fois.  Si plus d’une opération asynchrone est tentée sur la même instance de la <xref:System.Windows.Markup.XamlReader> classe un <xref:System.InvalidOperationException> est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Plusieurs opérations de chargement sont réalisées simultanément avec le même <see cref="T:System.Windows.Markup.XamlReader" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="xamlReader.LoadAsync (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream">Flux contenant l'entrée XAML à charger.</param>
        <param name="parserContext">Informations de contexte utilisées par l'analyseur.</param>
        <summary>Lit l'entrée XAML dans le <see cref="T:System.IO.Stream" /> spécifié et retourne la racine de l'arborescence de l'objet correspondant.</summary>
        <returns>Racine de l'arborescence d'objets créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une opération de chargement XAML asynchrone initialement retournera un objet qui est purement l’objet racine. De façon asynchrone, XAML analyse puis se poursuit, et tous les objets enfants sont remplis sous la racine. Ce comportement diffère du XAML WPF typique comportement et son interaction avec les concepts WPF de durée de vie de traitement. Dans l’interaction classique (non asynchrone), toutes les propriétés d’un objet, y compris toutes les collections enfants sont remplies avant de retourner un élément et de signaler comme chargé. Ce comportement équivaut à une méthodologie de bas en haut pour la création de l’arborescence où l’objet racine est le dernier objet devienne disponible.  
  
 Vous en général, l’objet retourné à un emplacement dans l’arborescence d’objets de votre application, sachant que le contenu pouvez être complété et pouvez entraîner des mises à jour de disposition incrémentielle si le contenu entier est exposé en tant que partie de l’interface utilisateur. Pour cette raison, il est classique d’isoler ou de virtualiser les objets chargés de façon asynchrone à partir de XAML et d’utiliser une logique spécifique à l’application ou l’état de l’application pour notifier lorsque <xref:System.Windows.Markup.XamlReader.LoadCompleted> est gérée.  
  
 Dans l’ordre pour <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> pour charger le balisage en mode asynchrone, l’élément racine dans le balisage XAML doit contenir l’attribut et la valeur `x:SynchronousMode="Async"`. La valeur est considérée comme respectant la casse. Si la racine du balisage XAML ne contient-elle pas `x:SynchronousMode="Async"`, aucune exception n’est levée et l’appel est traité comme une charge synchrone (voir <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>).  
  
 Qu’une seule opération de chargement asynchrone par instance de la <xref:System.Windows.Markup.XamlReader> classe peut être effectuée à la fois.  Si plus d’une opération asynchrone est tentée sur la même instance de la <xref:System.Windows.Markup.XamlReader> classe un <xref:System.InvalidOperationException> est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Plusieurs opérations de chargement sont réalisées simultanément avec le même <see cref="T:System.Windows.Markup.XamlReader" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AsyncCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AsyncCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Markup.XamlReader.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As AsyncCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AsyncCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " Usage="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AsyncCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'une opération de chargement asynchrone se termine.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Markup.XamlReader.LoadCompleted> est également déclenché lorsqu’une opération de chargement asynchrone est abandonnée.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.AsyncCompletedEventHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit le balisage dans la chaîne de texte spécifiée et retourne un objet qui correspond à la racine du balisage indiqué.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (xamlText As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse xamlText" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlText">XAML d'entrée, en tant que chaîne de texte unique.</param>
        <summary>Lit l'entrée XAML dans la chaîne de texte spécifiée et retourne un objet qui correspond à la racine du balisage indiqué.</summary>
        <returns>Racine de l'arborescence d'objets créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation appelle <xref:System.Windows.Markup.XamlReader.Load%2A> en interne après la création d’un flux de données à partir de la chaîne. Consultez <xref:System.Windows.Markup.XamlReader.Load%2A> pour plus d’informations telles que les exceptions possibles.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse (xamlText, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="xamlText">XAML d'entrée, en tant que chaîne de texte unique.</param>
        <param name="parserContext">Informations de contexte utilisées par l'analyseur.</param>
        <summary>Lit le balisage XAML dans la chaîne de texte spécifiée (à l'aide d'un <see cref="T:System.Windows.Markup.ParserContext" /> spécifié) et retourne un objet qui correspond à la racine du balisage indiqué.</summary>
        <returns>Racine de l'arborescence d'objets créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation appelle <xref:System.Windows.Markup.XamlReader.Load%2A> en interne après la création d’un flux de données à partir de la chaîne. Consultez <xref:System.Windows.Markup.XamlReader.Load%2A> pour plus d’informations telles que les exceptions possibles.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>