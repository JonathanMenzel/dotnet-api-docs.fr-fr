<Type Name="TypeBuilder" FullName="System.Reflection.Emit.TypeBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ea8c2e4359e8a9dc956ea6766b3b8d38ed283a88" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39985096" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class TypeBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit TypeBuilder extends System.Reflection.TypeInfo implements class System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.TypeBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeBuilder&#xA;Inherits TypeInfo&#xA;Implements _TypeBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeBuilder sealed : System::Reflection::TypeInfo, System::Runtime::InteropServices::_TypeBuilder" />
  <TypeSignature Language="F#" Value="type TypeBuilder = class&#xA;    inherit TypeInfo&#xA;    interface _TypeBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0">System.Type</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._TypeBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._TypeBuilder))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="18d9c-101">Définit et crée des instances de classes pendant l’exécution.</span>
      <span class="sxs-lookup">
        <span data-stu-id="18d9c-101">Defines and creates new instances of classes during run time.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-102"><xref:System.Reflection.Emit.TypeBuilder> la classe racine permet de contrôler la création de classes dynamiques dans le runtime.</span><span class="sxs-lookup"><span data-stu-id="18d9c-102"><xref:System.Reflection.Emit.TypeBuilder> is the root class used to control the creation of dynamic classes in the runtime.</span></span> <span data-ttu-id="18d9c-103">Il fournit un ensemble de routines qui sont utilisées pour définir des classes, ajouter des champs et méthodes et créer la classe à l’intérieur d’un module.</span><span class="sxs-lookup"><span data-stu-id="18d9c-103">It provides a set of routines that are used to define classes, add methods and fields, and create the class inside a module.</span></span> <span data-ttu-id="18d9c-104">Un nouveau <xref:System.Reflection.Emit.TypeBuilder> peuvent être créés à partir d’un module dynamique en appelant le <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> (méthode), qui retourne un <xref:System.Reflection.Emit.TypeBuilder> objet.</span><span class="sxs-lookup"><span data-stu-id="18d9c-104">A new <xref:System.Reflection.Emit.TypeBuilder> can be created from a dynamic module by calling the <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> method, which returns a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="18d9c-105">L’émission de réflexion fournit les options suivantes pour définir des types :</span><span class="sxs-lookup"><span data-stu-id="18d9c-105">Reflection emit provides the following options for defining types:</span></span>  
  
-   <span data-ttu-id="18d9c-106">Définir une classe ou interface portant le nom spécifié.</span><span class="sxs-lookup"><span data-stu-id="18d9c-106">Define a class or interface with the given name.</span></span>  
  
-   <span data-ttu-id="18d9c-107">Définir une classe ou une interface avec les attributs et le nom donné.</span><span class="sxs-lookup"><span data-stu-id="18d9c-107">Define a class or interface with the given name and attributes.</span></span>  
  
-   <span data-ttu-id="18d9c-108">Définir une classe avec le nom donné, attributs et la classe de base.</span><span class="sxs-lookup"><span data-stu-id="18d9c-108">Define a class with the given name, attributes, and base class.</span></span>  
  
-   <span data-ttu-id="18d9c-109">Définissez une classe avec le nom donné, attributs, la classe de base et le jeu d’interfaces que la classe implémente.</span><span class="sxs-lookup"><span data-stu-id="18d9c-109">Define a class with the given name, attributes, base class, and the set of interfaces that the class implements.</span></span>  
  
-   <span data-ttu-id="18d9c-110">Définir une classe avec le nom donné, des attributs, la classe de base et taille de compression.</span><span class="sxs-lookup"><span data-stu-id="18d9c-110">Define a class with the given name, attributes, base class, and packing size.</span></span>  
  
-   <span data-ttu-id="18d9c-111">Définissez une classe avec le nom donné, attributs, la classe de base et la taille de la classe dans son ensemble.</span><span class="sxs-lookup"><span data-stu-id="18d9c-111">Define a class with the given name, attributes, base class, and the class size as a whole.</span></span>  
  
-   <span data-ttu-id="18d9c-112">Définissez une classe avec le nom donné, attributs, la classe de base, taille de compression et la taille de la classe dans son ensemble.</span><span class="sxs-lookup"><span data-stu-id="18d9c-112">Define a class with the given name, attributes, base class, packing size, and the class size as a whole.</span></span>  
  
 <span data-ttu-id="18d9c-113">Pour créer un type de tableau, type pointeur ou un type byref pour un type incomplet qui est représenté par un <xref:System.Reflection.Emit.TypeBuilder> de l’objet, utilisez le <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> (méthode), <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> (méthode), ou <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> (méthode), respectivement.</span><span class="sxs-lookup"><span data-stu-id="18d9c-113">To create an array type, pointer type, or byref type for an incomplete type that is represented by a <xref:System.Reflection.Emit.TypeBuilder> object, use the <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> method, or <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> method, respectively.</span></span>  
  
 <span data-ttu-id="18d9c-114">Avant qu’un type est utilisé, le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> méthode doit être appelée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-114">Before a type is used, the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> method must be called.</span></span> <span data-ttu-id="18d9c-115">**CreateType** termine la création du type.</span><span class="sxs-lookup"><span data-stu-id="18d9c-115">**CreateType** completes the creation of the type.</span></span> <span data-ttu-id="18d9c-116">Après l’appel de **CreateType**, l’appelant peut instancier le type à l’aide de la <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (méthode) et appeler des membres du type à l’aide de la <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-116">Following the call to **CreateType**, the caller can instantiate the type by using the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and invoke members of the type by using the <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="18d9c-117">Il est erroné d’appeler des méthodes qui modifient l’implémentation d’un type après **CreateType** a été appelée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-117">It is an error to invoke methods that change the implementation of a type after **CreateType** has been called.</span></span> <span data-ttu-id="18d9c-118">Par exemple, le common language runtime lève une exception si l’appelant tente d’ajouter de nouveaux membres à un type.</span><span class="sxs-lookup"><span data-stu-id="18d9c-118">For example, the common language runtime throws an exception if the caller tries to add new members to a type.</span></span>  
  
 <span data-ttu-id="18d9c-119">Un initialiseur de classe est créé à l’aide de la <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-119">A class initializer is created by using the <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="18d9c-120">**DefineTypeInitializer** retourne un <xref:System.Reflection.Emit.ConstructorBuilder> objet.</span><span class="sxs-lookup"><span data-stu-id="18d9c-120">**DefineTypeInitializer** returns a <xref:System.Reflection.Emit.ConstructorBuilder> object.</span></span>  
  
 <span data-ttu-id="18d9c-121">Les types imbriqués sont définis en appelant une de le <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> méthodes.</span><span class="sxs-lookup"><span data-stu-id="18d9c-121">Nested types are defined by calling one of the <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> methods.</span></span>  
  
## <a name="attributes"></a><span data-ttu-id="18d9c-122">Attributs</span><span class="sxs-lookup"><span data-stu-id="18d9c-122">Attributes</span></span>  
 <span data-ttu-id="18d9c-123">Le <xref:System.Reflection.Emit.TypeBuilder> classe utilise le <xref:System.Reflection.TypeAttributes> énumération pour spécifier les caractéristiques du type à créer :</span><span class="sxs-lookup"><span data-stu-id="18d9c-123">The <xref:System.Reflection.Emit.TypeBuilder> class uses the <xref:System.Reflection.TypeAttributes> enumeration to further specify the characteristics of the type to be created:</span></span>  
  
-   <span data-ttu-id="18d9c-124">Les interfaces sont spécifiées à l’aide de la <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> et <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> attributs.</span><span class="sxs-lookup"><span data-stu-id="18d9c-124">Interfaces are specified using the <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> and <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> attributes.</span></span>  
  
-   <span data-ttu-id="18d9c-125">Les classes concrètes (les classes qui ne peuvent pas être étendus) sont spécifiés à l’aide de la <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> attribut.</span><span class="sxs-lookup"><span data-stu-id="18d9c-125">Concrete classes (classes that cannot be extended) are specified using the <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="18d9c-126">Plusieurs attributs déterminent la visibilité du type.</span><span class="sxs-lookup"><span data-stu-id="18d9c-126">Several attributes determine type visibility.</span></span> <span data-ttu-id="18d9c-127">Consultez la description de la <xref:System.Reflection.TypeAttributes> énumération.</span><span class="sxs-lookup"><span data-stu-id="18d9c-127">See the description of the <xref:System.Reflection.TypeAttributes> enumeration.</span></span>  
  
-   <span data-ttu-id="18d9c-128">Si <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> est spécifié, le chargeur de classes dispose les champs dans l’ordre de leur lecture à partir des métadonnées.</span><span class="sxs-lookup"><span data-stu-id="18d9c-128">If <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is specified, the class loader lays out fields in the order they are read from metadata.</span></span> <span data-ttu-id="18d9c-129">Le chargeur de classes prend en compte la taille de compression spécifié, mais il ignore tout offset de champ spécifié.</span><span class="sxs-lookup"><span data-stu-id="18d9c-129">The class loader considers the specified packing size but ignores any specified field offsets.</span></span> <span data-ttu-id="18d9c-130">Les métadonnées conservent l’ordre dans lequel les définitions de champ sont émises.</span><span class="sxs-lookup"><span data-stu-id="18d9c-130">The metadata preserves the order in which the field definitions are emitted.</span></span> <span data-ttu-id="18d9c-131">Même à travers une fusion, les métadonnées ne réorganisent pas les définitions de champ.</span><span class="sxs-lookup"><span data-stu-id="18d9c-131">Even across a merge, the metadata will not reorder the field definitions.</span></span> <span data-ttu-id="18d9c-132">Le chargeur honorera l’offsets de champ spécifié uniquement si <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> est spécifié.</span><span class="sxs-lookup"><span data-stu-id="18d9c-132">The loader will honor the specified field offsets only if <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is specified.</span></span>  
  
## <a name="known-issues"></a><span data-ttu-id="18d9c-133">Problèmes connus</span><span class="sxs-lookup"><span data-stu-id="18d9c-133">Known Issues</span></span>  
  
-   <span data-ttu-id="18d9c-134">L’émission de réflexion ne vérifie pas si une classe non abstraite qui implémente une interface a implémenté toutes les méthodes déclarées dans l’interface.</span><span class="sxs-lookup"><span data-stu-id="18d9c-134">Reflection emit does not verify whether a non-abstract class that implements an interface has implemented all the methods declared in the interface.</span></span> <span data-ttu-id="18d9c-135">Toutefois, si la classe n’implémente pas toutes les méthodes déclarées dans une interface, le runtime ne charge pas de la classe.</span><span class="sxs-lookup"><span data-stu-id="18d9c-135">However, if the class does not implement all the methods declared in an interface, the runtime does not load the class.</span></span>  
  
-   <span data-ttu-id="18d9c-136">Bien que <xref:System.Reflection.Emit.TypeBuilder> est dérivée de <xref:System.Type>, certaines des méthodes abstraites définies dans le <xref:System.Type> classe ne sont pas totalement implémentées dans le <xref:System.Reflection.Emit.TypeBuilder> classe.</span><span class="sxs-lookup"><span data-stu-id="18d9c-136">Although <xref:System.Reflection.Emit.TypeBuilder> is derived from <xref:System.Type>, some of the abstract methods defined in the <xref:System.Type> class are not fully implemented in the <xref:System.Reflection.Emit.TypeBuilder> class.</span></span> <span data-ttu-id="18d9c-137">Appels à ces <xref:System.Reflection.Emit.TypeBuilder> méthodes lèvent une <xref:System.NotSupportedException> exception.</span><span class="sxs-lookup"><span data-stu-id="18d9c-137">Calls to these <xref:System.Reflection.Emit.TypeBuilder> methods throw a <xref:System.NotSupportedException> exception.</span></span> <span data-ttu-id="18d9c-138">La fonctionnalité souhaitée peut être obtenue en récupérant le type créé à l’aide de la <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-138">The desired functionality can be obtained by retrieving the created type using the <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and reflecting on the retrieved type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-139">Cette section contient deux exemples de code.</span><span class="sxs-lookup"><span data-stu-id="18d9c-139">This section contains two code examples.</span></span> <span data-ttu-id="18d9c-140">Le premier exemple montre comment créer un type dynamique avec un champ, un constructeur, une propriété et une méthode.</span><span class="sxs-lookup"><span data-stu-id="18d9c-140">The first example shows how to create a dynamic type with a field, constructor, property, and method.</span></span> <span data-ttu-id="18d9c-141">Le deuxième exemple génère une méthode dynamique à partir de l’entrée d’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="18d9c-141">The second example builds a method dynamically from user input.</span></span>  
  
 <span data-ttu-id="18d9c-142">**Exemple 1**</span><span class="sxs-lookup"><span data-stu-id="18d9c-142">**Example one**</span></span>  
  
 <span data-ttu-id="18d9c-143">L’exemple de code suivant montre comment définir un assembly dynamique avec un seul module.</span><span class="sxs-lookup"><span data-stu-id="18d9c-143">The following code example shows how to define a dynamic assembly with one module.</span></span> <span data-ttu-id="18d9c-144">Le module dans l’assembly de l’exemple contient un seul type, `MyDynamicType`, qui a un champ privé, une propriété qui obtient et définit le champ privé, les constructeurs qui initialisent le champ privé et une méthode qui multiplie un nombre fourni par l’utilisateur par le champ privé valeur et retourne le résultat.</span><span class="sxs-lookup"><span data-stu-id="18d9c-144">The module in the example assembly contains one type, `MyDynamicType`, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user-supplied number by the private field value and returns the result.</span></span>  
  
 <span data-ttu-id="18d9c-145">Le <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> champ est spécifié lors de la création de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="18d9c-145">The <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> field is specified when the assembly is created.</span></span> <span data-ttu-id="18d9c-146">Le code d’assembly est immédiatement utilisé, et l’assembly est également enregistré sur disque afin qu’il peut être examinée avec [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) ou utilisées dans un autre programme.</span><span class="sxs-lookup"><span data-stu-id="18d9c-146">The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) or used in another program.</span></span>  
  
 [!code-cpp[AssemblyBuilderClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 <span data-ttu-id="18d9c-147">**Le deuxième exemple**</span><span class="sxs-lookup"><span data-stu-id="18d9c-147">**Example two**</span></span>  
  
 <span data-ttu-id="18d9c-148">L’exemple de code suivant montre comment générer un type dynamique à l’aide de `TypeBuilder`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-148">The following code sample demonstrates how to build a dynamic type by using `TypeBuilder`.</span></span>  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberSignature Language="F#" Value="member this.AddDeclarativeSecurity : System.Security.Permissions.SecurityAction * System.Security.PermissionSet -&gt; unit" Usage="typeBuilder.AddDeclarativeSecurity (action, pset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">
          <span data-ttu-id="18d9c-149">Action de sécurité à prendre telle que Demand, Assert, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-149">The security action to be taken such as Demand, Assert, and so on.</span>
          </span>
        </param>
        <param name="pset">
          <span data-ttu-id="18d9c-150">Jeu d’autorisations auquel la mesure s’applique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-150">The set of permissions the action applies to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-151">Ajoute la sécurité déclarative à ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-151">Adds declarative security to this type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-152">`AddDeclarativeSecurity` peut être appelée plusieurs fois à chaque appel spécifiant une action de sécurité (telle que Demand, Assert ou Deny) et un jeu d’autorisations qui s’appliquent à l’action.</span><span class="sxs-lookup"><span data-stu-id="18d9c-152">`AddDeclarativeSecurity` may be called several times with each call specifying a security action (such as Demand, Assert, or Deny) and a set of permissions that apply to the action.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-153">Dans les versions 1.0, 1.1 et 2.0 du .NET Framework, les attributs de sécurité déclarative appliqués à un type à l’aide de cette méthode sont stockés dans l’ancien format de métadonnées XML.</span><span class="sxs-lookup"><span data-stu-id="18d9c-153">In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a type by using this method are stored in the old XML metadata format.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-154">L’exemple suivant illustre l’utilisation de la `AddDeclarativeSecurity` méthode pour ajouter une demande de sécurité pour <xref:System.Security.Permissions.SecurityPermission> avec la <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> indicateur pour un type dynamique nommé `MyDynamicClass`, dans un assembly nommé EmittedExample.dll.</span><span class="sxs-lookup"><span data-stu-id="18d9c-154">The following example demonstrates the use of the `AddDeclarativeSecurity` method to add a security demand for <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag to a dynamic type named `MyDynamicClass`, in an assembly named EmittedExample.dll.</span></span> <span data-ttu-id="18d9c-155">L’exemple ne produit aucune sortie de console ; une fois que vous l’exécutez, vous pouvez utiliser [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner EmittedExample.dll.</span><span class="sxs-lookup"><span data-stu-id="18d9c-155">The example produces no console output; after you run it, you can use [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine EmittedExample.dll.</span></span> <span data-ttu-id="18d9c-156">Dans `MyDynamicClass`, ouvrez le `.class public auto ansi` instruction pour afficher l’autorisation déclarative.</span><span class="sxs-lookup"><span data-stu-id="18d9c-156">In `MyDynamicClass`, open the `.class public auto ansi` statement to see the declarative permission.</span></span>  
  
 [!code-cpp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CPP/typebuilder_adddeclarativesecurity.cpp#1)]
 [!code-csharp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CS/typebuilder_adddeclarativesecurity.cs#1)]
 [!code-vb[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/VB/typebuilder_adddeclarativesecurity.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="18d9c-157">L’<paramref name="action" /> n’est pas valide (<see langword="RequestMinimum" />, <see langword="RequestOptional" /> et <see langword="RequestRefuse" /> ne sont pas valides).</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-157">The <paramref name="action" /> is invalid (<see langword="RequestMinimum" />, <see langword="RequestOptional" />, and <see langword="RequestRefuse" /> are invalid).</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-158">Le type conteneur a été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-158">The containing type has been created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="18d9c-159">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-159">-or-</span>
          </span>
          <span data-ttu-id="18d9c-160">Le jeu d’autorisations <paramref name="pset" /> contient une action qui a déjà été ajoutée par <see langword="AddDeclarativeSecurity" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-160">The permission set <paramref name="pset" /> contains an action that was added earlier by <see langword="AddDeclarativeSecurity" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-161">
            <paramref name="pset" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-161">
              <paramref name="pset" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AddInterfaceImplementation">
      <MemberSignature Language="C#" Value="public void AddInterfaceImplementation (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInterfaceImplementation(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddInterfaceImplementation (interfaceType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddInterfaceImplementation(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="member this.AddInterfaceImplementation : Type -&gt; unit" Usage="typeBuilder.AddInterfaceImplementation interfaceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <span data-ttu-id="18d9c-162">Interface implémentée par ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-162">The interface that this type implements.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-163">Ajoute une interface implémentée par ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-163">Adds an interface that this type implements.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="18d9c-164">L’exemple de code suivant montre l’implémentation d’une interface sur un type créé dynamiquement à l’aide `AddInterfaceImplementation`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-164">The following code sample demonstrates the implementation of an interface on a dynamically created type using `AddInterfaceImplementation`.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#3)]
 [!code-csharp[TypeBuilder_Sample_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#3)]
 [!code-vb[TypeBuilder_Sample_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-165">
            <paramref name="interfaceType" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-165">
              <paramref name="interfaceType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-166">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-166">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-167">Récupère l’assembly dynamique qui contient la définition de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-167">Retrieves the dynamic assembly that contains this type definition.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-168">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-168">Read-only.</span>
          </span>
          <span data-ttu-id="18d9c-169">Récupère l’assembly dynamique qui contient la définition de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-169">Retrieves the dynamic assembly that contains this type definition.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-170">Retourne le nom complet de ce type, qualifié par le nom complet de l'assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-170">Returns the full name of this type qualified by the display name of the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-171">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-171">Read-only.</span>
          </span>
          <span data-ttu-id="18d9c-172">Nom complet de ce type qualifié par le nom complet de l'assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-172">The full name of this type qualified by the display name of the assembly.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-173">Le format de la chaîne retournée est la concaténation du nom complet du type (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) et le nom complet de l’assembly (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), séparés par une virgule et un espace.</span><span class="sxs-lookup"><span data-stu-id="18d9c-173">The format of the returned string is the concatenation of the full name of the type (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) and the display name of the assembly (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), separated by a comma and a space.</span></span>  
  
 <span data-ttu-id="18d9c-174">Consultez <xref:System.Reflection.AssemblyName> pour obtenir une description du format du nom complet d’un assembly.</span><span class="sxs-lookup"><span data-stu-id="18d9c-174">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="18d9c-175">Informations sur la version</span><span class="sxs-lookup"><span data-stu-id="18d9c-175">Version Information</span></span>  
 <span data-ttu-id="18d9c-176">Dans les versions 1.0 et 1.1 du .NET Framework, la valeur de cette propriété n’inclut pas la culture ou la clé publique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-176">In the .NET Framework versions 1.0 and 1.1, the value of this property does not include the culture or public key.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-177">Récupère le type de base de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-177">Retrieves the base type of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-178">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-178">Read-only.</span>
          </span>
          <span data-ttu-id="18d9c-179">Récupère le type de base de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-179">Retrieves the base type of this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateType">
      <MemberSignature Language="C#" Value="public Type CreateType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type CreateType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateType" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ CreateType();" />
      <MemberSignature Language="F#" Value="member this.CreateType : unit -&gt; Type" Usage="typeBuilder.CreateType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-180">Crée un objet <see cref="T:System.Type" /> pour la classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-180">Creates a <see cref="T:System.Type" /> object for the class.</span>
          </span>
          <span data-ttu-id="18d9c-181">Après avoir défini les champs et les méthodes sur la classe, <see langword="CreateType" /> est appelé pour charger son objet <see langword="Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-181">After defining fields and methods on the class, <see langword="CreateType" /> is called in order to load its <see langword="Type" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-182">Retourne le nouvel objet <see cref="T:System.Type" /> pour cette classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-182">Returns the new <see cref="T:System.Type" /> object for this class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-183">Si ce type est un type imbriqué, le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode doit être appelée sur le type englobant avant son appel sur le type imbriqué.</span><span class="sxs-lookup"><span data-stu-id="18d9c-183">If this type is a nested type, the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method must be called on the enclosing type before it is called on the nested type.</span></span>  
  
 <span data-ttu-id="18d9c-184">Si le type actuel dérive d’un type incomplet ou implémente des interfaces incomplètes, appelez le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode sur le type de parent et les types d’interface avant de l’appeler sur le type actuel.</span><span class="sxs-lookup"><span data-stu-id="18d9c-184">If the current type derives from an incomplete type or implements incomplete interfaces, call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on the parent type and the interface types before calling it on the current type.</span></span>  
  
 <span data-ttu-id="18d9c-185">Si le type englobant contient un champ qui est un type de valeur défini comme un type imbriqué (par exemple, un champ qui est une énumération définie comme un type imbriqué), l’appel la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode sur le type englobant génère un <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> événement.</span><span class="sxs-lookup"><span data-stu-id="18d9c-185">If the enclosing type contains a field that is a value type defined as a nested type (for example, a field that is an enumeration defined as a nested type), calling the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on the enclosing type will generate a <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="18d9c-186">Il s’agit, car le chargeur ne peut pas déterminer la taille du type englobant jusqu'à ce que le type imbriqué a été effectué.</span><span class="sxs-lookup"><span data-stu-id="18d9c-186">This is because the loader cannot determine the size of the enclosing type until the nested type has been completed.</span></span> <span data-ttu-id="18d9c-187">L’appelant doit définir un gestionnaire pour le <xref:System.AppDomain.TypeResolve> événement pour terminer la définition du type imbriqué en appelant <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> sur la <xref:System.Reflection.Emit.TypeBuilder> objet qui représente le type imbriqué.</span><span class="sxs-lookup"><span data-stu-id="18d9c-187">The caller should define a handler for the <xref:System.AppDomain.TypeResolve> event to complete the definition of the nested type by calling <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> on the <xref:System.Reflection.Emit.TypeBuilder> object that represents the nested type.</span></span> <span data-ttu-id="18d9c-188">L’exemple de code pour cette rubrique montre comment définir un tel gestionnaire d’événements.</span><span class="sxs-lookup"><span data-stu-id="18d9c-188">The code example for this topic shows how to define such an event handler.</span></span>  
  
 <span data-ttu-id="18d9c-189">Un type est créé qu’une seule fois, quel nombre de fois où le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-189">A type is created only once, no matter how many times the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span> <span data-ttu-id="18d9c-190">Tous les appels retournent le même <xref:System.Type> objet.</span><span class="sxs-lookup"><span data-stu-id="18d9c-190">All calls return the same <xref:System.Type> object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-191">L’exemple de code suivant montre comment définir un gestionnaire d’événements pour le <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> événement, afin d’appeler le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode sur un type imbriqué pendant un <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> appeler sur le type englobant.</span><span class="sxs-lookup"><span data-stu-id="18d9c-191">The following code example shows how to define an event handler for the <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> event, in order to call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on a nested type during a <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> call on the enclosing type.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CPP/nestedenum.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CS/nestedenum.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/VB/nestedenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-192">Le type englobant n’a pas été créé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-192">The enclosing type has not been created.</span>
          </span>
          <span data-ttu-id="18d9c-193">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-193">-or-</span>
          </span>
          <span data-ttu-id="18d9c-194">Ce type est non abstrait et contient une méthode abstraite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-194">This type is non-abstract and contains an abstract method.</span>
          </span>
          <span data-ttu-id="18d9c-195">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-195">-or-</span>
          </span>
          <span data-ttu-id="18d9c-196">Ce type n’est pas une classe abstraite ni une interface et contient une méthode sans corps de méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-196">This type is not an abstract class or an interface and has a method without a method body.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-197">Le type contient un code MSIL (Microsoft Intermediate Language) non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-197">The type contains invalid Microsoft intermediate language (MSIL) code.</span>
          </span>
          <span data-ttu-id="18d9c-198">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-198">-or-</span>
          </span>
          <span data-ttu-id="18d9c-199">La cible de branche est spécifiée à l’aide d’un offset de 1 octet, mais la cible est à une distance supérieure à 127 octets de la branche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-199">The branch target is specified using a 1-byte offset, but the target is at a distance greater than 127 bytes from the branch.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="18d9c-200">Impossible de charger le type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-200">The type cannot be loaded.</span>
          </span>
          <span data-ttu-id="18d9c-201">Par exemple, il contient une méthode <see langword="static" /> avec la convention d’appel <see cref="F:System.Reflection.CallingConventions.HasThis" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-201">For example, it contains a <see langword="static" /> method that has the calling convention <see cref="F:System.Reflection.CallingConventions.HasThis" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTypeInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeInfo CreateTypeInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.TypeInfo CreateTypeInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateTypeInfo () As TypeInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::TypeInfo ^ CreateTypeInfo();" />
      <MemberSignature Language="F#" Value="member this.CreateTypeInfo : unit -&gt; System.Reflection.TypeInfo" Usage="typeBuilder.CreateTypeInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-202">Obtient un objet <see cref="T:System.Reflection.TypeInfo" /> qui représente ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-202">Gets a <see cref="T:System.Reflection.TypeInfo" /> object that represents this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-203">Objet qui représente ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-203">An object that represents this type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-204">Obtient la méthode qui a déclaré le paramètre de type générique actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-204">Gets the method that declared the current generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-205">
            <see cref="T:System.Reflection.MethodBase" /> qui représente la méthode qui a déclaré le type actuel, si celui-ci est un paramètre de type générique ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-205">A <see cref="T:System.Reflection.MethodBase" /> that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-206">Lors de l’émission de code, un paramètre de type générique est représenté par un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objet plutôt que par un <xref:System.Reflection.Emit.TypeBuilder> objet.</span><span class="sxs-lookup"><span data-stu-id="18d9c-206">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-207">Retourne le type qui a déclaré ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-207">Returns the type that declared this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-208">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-208">Read-only.</span>
          </span>
          <span data-ttu-id="18d9c-209">Type qui a déclaré ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-209">The type that declared this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineConstructor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-210">Ajoute un nouveau constructeur au type dynamique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-210">Adds a new constructor to the dynamic type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineConstructor : System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type[] -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineConstructor (attributes, callingConvention, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="attributes">
          <span data-ttu-id="18d9c-211">Attributs du constructeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-211">The attributes of the constructor.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="18d9c-212">Convention d’appel du constructeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-212">The calling convention of the constructor.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="18d9c-213">Types de paramètre du constructeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-213">The parameter types of the constructor.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-214">Ajoute un nouveau constructeur au type avec les attributs donnés et la signature.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-214">Adds a new constructor to the type, with the given attributes and signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-215">Constructeur défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-215">The defined constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-216">Si vous ne définissez pas un constructeur pour votre type dynamique, un constructeur par défaut est fourni automatiquement, et il appelle le constructeur par défaut de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="18d9c-216">If you do not define a constructor for your dynamic type, a default constructor is provided automatically, and it calls the default constructor of the base class.</span></span>  
  
 <span data-ttu-id="18d9c-217">Si vous définissez un constructeur pour votre type dynamique, un constructeur par défaut n’est pas fourni.</span><span class="sxs-lookup"><span data-stu-id="18d9c-217">If you define a constructor for your dynamic type, a default constructor is not provided.</span></span> <span data-ttu-id="18d9c-218">Vous disposez des options suivantes pour fournir un constructeur par défaut en plus du constructeur que vous avez défini :</span><span class="sxs-lookup"><span data-stu-id="18d9c-218">You have the following options for providing a default constructor in addition to the constructor you defined:</span></span>  
  
-   <span data-ttu-id="18d9c-219">Si vous souhaitez un constructeur par défaut qui appelle simplement le constructeur par défaut de la classe de base, vous pouvez utiliser la <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> méthode à créer (et éventuellement restreindre l’accès).</span><span class="sxs-lookup"><span data-stu-id="18d9c-219">If you want a default constructor that simply calls the default constructor of the base class, you can use the <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> method to create one (and optionally restrict access to it).</span></span> <span data-ttu-id="18d9c-220">Ne fournissez pas d’implémentation pour ce constructeur par défaut.</span><span class="sxs-lookup"><span data-stu-id="18d9c-220">Do not provide an implementation for this default constructor.</span></span> <span data-ttu-id="18d9c-221">Si vous le faites, une exception est levée lorsque vous essayez d’utiliser le constructeur.</span><span class="sxs-lookup"><span data-stu-id="18d9c-221">If you do, an exception is thrown when you try to use the constructor.</span></span> <span data-ttu-id="18d9c-222">Aucune exception n’est levée lorsque le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-222">No exception is thrown when the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span>  
  
-   <span data-ttu-id="18d9c-223">Si vous souhaitez que le constructeur par défaut ne plus que simplement appeler le constructeur par défaut de la classe de base, qui appelle un autre constructeur de la classe de base, ou qu’il effectue quelque chose d’autre, vous devez utiliser le <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> pour créer un, méthode et fournissez votre propre implémentation.</span><span class="sxs-lookup"><span data-stu-id="18d9c-223">If you want a default constructor that does something more than simply calling the default constructor of the base class, or that calls another constructor of the base class, or that does something else entirely, you must use the <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> method to create one, and provide your own implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-224">L’exemple de code suivant illustre l’utilisation de `DefineConstructor` signature spécifique et les attributs d’un constructeur sur un type dynamique et retourner un <xref:System.Reflection.Emit.ConstructorBuilder> pour alimentation MSIL.</span><span class="sxs-lookup"><span data-stu-id="18d9c-224">The following code sample demonstrates the use of `DefineConstructor` to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref:System.Reflection.Emit.ConstructorBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-225">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-225">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes, class System.Type[][] requiredCustomModifiers, class System.Type[][] optionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type(), requiredCustomModifiers As Type()(), optionalCustomModifiers As Type()()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ requiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ optionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineConstructor : System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineConstructor (attributes, callingConvention, parameterTypes, requiredCustomModifiers, optionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="attributes">
          <span data-ttu-id="18d9c-226">Attributs du constructeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-226">The attributes of the constructor.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="18d9c-227">Convention d’appel du constructeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-227">The calling convention of the constructor.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="18d9c-228">Types de paramètres du constructeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-228">The parameter types of the constructor.</span>
          </span>
        </param>
        <param name="requiredCustomModifiers">
          <span data-ttu-id="18d9c-229">Tableau de tableaux de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-229">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="18d9c-230">Chaque tableau de types représente les modificateurs personnalisés obligatoires pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-230">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="18d9c-231">Si un paramètre particulier ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" /> plutôt qu’un tableau de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-231">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="18d9c-232">Si aucun paramètre ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-232">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="optionalCustomModifiers">
          <span data-ttu-id="18d9c-233">Tableau de tableaux de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-233">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="18d9c-234">Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-234">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="18d9c-235">Si un paramètre particulier ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" /> plutôt qu’un tableau de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-235">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="18d9c-236">Si aucun paramètre ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-236">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-237">Ajoute un nouveau constructeur au type, avec les attributs, la signature et les modificateurs personnalisés donnés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-237">Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-238">Constructeur défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-238">The defined constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-239">Cette surcharge est fournie pour les concepteurs de compilateurs managés.</span><span class="sxs-lookup"><span data-stu-id="18d9c-239">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-240">Pour plus d’informations sur les modificateurs personnalisés, consultez la documentation de métadonnées ECMA Partition II.</span><span class="sxs-lookup"><span data-stu-id="18d9c-240">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="18d9c-241">La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.</span><span class="sxs-lookup"><span data-stu-id="18d9c-241">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-242">La taille de <paramref name="requiredCustomModifiers" /> ou <paramref name="optionalCustomModifiers" /> n’est pas égale à la taille de <paramref name="parameterTypes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-242">The size of <paramref name="requiredCustomModifiers" /> or <paramref name="optionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-243">Le type a été créé précédemment à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-243">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="18d9c-244">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-244">-or-</span>
          </span>
          <span data-ttu-id="18d9c-245">Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-245">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDefaultConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor (System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor(valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDefaultConstructor (attributes As MethodAttributes) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineDefaultConstructor(System::Reflection::MethodAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDefaultConstructor : System.Reflection.MethodAttributes -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineDefaultConstructor attributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">
          <span data-ttu-id="18d9c-246">Objet <see langword="MethodAttributes" /> représentant les attributs à appliquer au constructeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-246">A <see langword="MethodAttributes" /> object representing the attributes to be applied to the constructor.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-247">Définit le constructeur par défaut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-247">Defines the default constructor.</span>
          </span>
          <span data-ttu-id="18d9c-248">Le constructeur défini ici appelle simplement le constructeur par défaut du parent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-248">The constructor defined here will simply call the default constructor of the parent.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-249">Retourne le constructeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-249">Returns the constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-250">Étant donné que le constructeur par défaut est défini automatiquement, il est nécessaire d’appeler cette méthode uniquement dans les situations suivantes :</span><span class="sxs-lookup"><span data-stu-id="18d9c-250">Because the default constructor is automatically defined, it is necessary to call this method only in the following situations:</span></span>  
  
-   <span data-ttu-id="18d9c-251">Vous avez défini un autre constructeur, et vous souhaitez également un constructeur par défaut qui appelle simplement le constructeur de classe de base.</span><span class="sxs-lookup"><span data-stu-id="18d9c-251">You have defined another constructor and you also want a default constructor that simply calls the base class constructor.</span></span>  
  
-   <span data-ttu-id="18d9c-252">Vous souhaitez définir les attributs du constructeur par défaut sur une valeur autre que <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, et <xref:System.Reflection.MethodAttributes.RTSpecialName>.</span><span class="sxs-lookup"><span data-stu-id="18d9c-252">You want to set the attributes on the default constructor to something other than <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, and <xref:System.Reflection.MethodAttributes.RTSpecialName>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-253">L’exemple de code suivant illustre l’utilisation de `DefineConstructor` signature spécifique et les attributs d’un constructeur sur un type dynamique et retourner un <xref:System.Reflection.Emit.ConstructorBuilder> pour alimentation MSIL.</span><span class="sxs-lookup"><span data-stu-id="18d9c-253">The following code sample demonstrates the use of `DefineConstructor` to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref:System.Reflection.Emit.ConstructorBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-254">Le type parent (type de base) n’a pas de constructeur par défaut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-254">The parent type (base type) does not have a default constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-255">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-255">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="18d9c-256">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-256">-or-</span>
          </span>
          <span data-ttu-id="18d9c-257">Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-257">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EventBuilder DefineEvent (string name, System.Reflection.EventAttributes attributes, Type eventtype);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EventBuilder DefineEvent(string name, valuetype System.Reflection.EventAttributes attributes, class System.Type eventtype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineEvent (name As String, attributes As EventAttributes, eventtype As Type) As EventBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::EventBuilder ^ DefineEvent(System::String ^ name, System::Reflection::EventAttributes attributes, Type ^ eventtype);" />
      <MemberSignature Language="F#" Value="member this.DefineEvent : string * System.Reflection.EventAttributes * Type -&gt; System.Reflection.Emit.EventBuilder" Usage="typeBuilder.DefineEvent (name, attributes, eventtype)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EventBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.EventAttributes" />
        <Parameter Name="eventtype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-258">Nom de l'événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-258">The name of the event.</span>
          </span>
          <span data-ttu-id="18d9c-259">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-259">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-260">Attributs de l’événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-260">The attributes of the event.</span>
          </span>
        </param>
        <param name="eventtype">
          <span data-ttu-id="18d9c-261">Type de l’événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-261">The type of the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-262">Ajoute un nouvel événement au type avec le nom, les attributs et le type d’événement donnés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-262">Adds a new event to the type, with the given name, attributes and event type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-263">Événement défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-263">The defined event.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-264">La longueur de <paramref name="name" /> est égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-264">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-265">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-265">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="18d9c-266">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-266">-or-</span>
          </span>
          <span data-ttu-id="18d9c-267">
            <paramref name="eventtype" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-267">
              <paramref name="eventtype" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-268">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-268">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-269">Ajoute un nouveau champ au type dynamique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-269">Adds a new field to the dynamic type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineField : string * Type * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineField (fieldName, type, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">
          <span data-ttu-id="18d9c-270">Nom du champ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-270">The name of the field.</span>
          </span>
          <span data-ttu-id="18d9c-271">
            <c>fieldName</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-271">
              <c>fieldName</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="18d9c-272">Type du champ</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-272">The type of the field</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-273">Attributs du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-273">The attributes of the field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-274">Ajoute un nouveau champ au type avec les nom, attributs et type de champ donnés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-274">Adds a new field to the type, with the given name, attributes, and field type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-275">Champ défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-275">The defined field.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-276">La longueur de <paramref name="fieldName" /> est égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-276">The length of <paramref name="fieldName" /> is zero.</span>
          </span>
          <span data-ttu-id="18d9c-277">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-277">-or-</span>
          </span>
          <span data-ttu-id="18d9c-278">
            <paramref name="type" /> est System.Void.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-278">
              <paramref name="type" /> is System.Void.</span>
          </span>
          <span data-ttu-id="18d9c-279">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-279">-or-</span>
          </span>
          <span data-ttu-id="18d9c-280">Une taille totale a été spécifiée pour la classe parente de ce champ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-280">A total size was specified for the parent class of this field.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-281">
            <paramref name="fieldName" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-281">
              <paramref name="fieldName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-282">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-282">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, class System.Type[] requiredCustomModifiers, class System.Type[] optionalCustomModifiers, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, cli::array &lt;Type ^&gt; ^ requiredCustomModifiers, cli::array &lt;Type ^&gt; ^ optionalCustomModifiers, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineField : string * Type * Type[] * Type[] * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineField (fieldName, type, requiredCustomModifiers, optionalCustomModifiers, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">
          <span data-ttu-id="18d9c-283">Nom du champ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-283">The name of the field.</span>
          </span>
          <span data-ttu-id="18d9c-284">
            <c>fieldName</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-284">
              <c>fieldName</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="18d9c-285">Type du champ</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-285">The type of the field</span>
          </span>
        </param>
        <param name="requiredCustomModifiers">
          <span data-ttu-id="18d9c-286">Tableau de types représentant les modificateurs personnalisés pour le champ, tels que <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-286">An array of types representing the required custom modifiers for the field, such as <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span>
          </span>
        </param>
        <param name="optionalCustomModifiers">
          <span data-ttu-id="18d9c-287">Tableau de types représentant les modificateurs personnalisés facultatifs pour le champ, tels que <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-287">An array of types representing the optional custom modifiers for the field, such as <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-288">Attributs du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-288">The attributes of the field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-289">Ajoute un nouveau champ au type avec le nom, les attributs, le type de champ et les modificateurs personnalisés donnés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-289">Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-290">Champ défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-290">The defined field.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-291">Cette surcharge est fournie pour les concepteurs de compilateurs managés.</span><span class="sxs-lookup"><span data-stu-id="18d9c-291">This overload is provided for designers of managed compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-292">La longueur de <paramref name="fieldName" /> est égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-292">The length of <paramref name="fieldName" /> is zero.</span>
          </span>
          <span data-ttu-id="18d9c-293">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-293">-or-</span>
          </span>
          <span data-ttu-id="18d9c-294">
            <paramref name="type" /> est System.Void.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-294">
              <paramref name="type" /> is System.Void.</span>
          </span>
          <span data-ttu-id="18d9c-295">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-295">-or-</span>
          </span>
          <span data-ttu-id="18d9c-296">Une taille totale a été spécifiée pour la classe parente de ce champ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-296">A total size was specified for the parent class of this field.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-297">
            <paramref name="fieldName" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-297">
              <paramref name="fieldName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-298">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-298">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberSignature Language="F#" Value="member this.DefineGenericParameters : string[] -&gt; System.Reflection.Emit.GenericTypeParameterBuilder[]" Usage="typeBuilder.DefineGenericParameters names" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">
          <span data-ttu-id="18d9c-299">Tableau de noms de paramètres de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-299">An array of names for the generic type parameters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-300">Définit les paramètres de type générique pour le type actuel, en spécifiant leur nombre et leurs noms, et retourne un tableau d’objets <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> pouvant être utilisés pour définir leurs contraintes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-300">Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to set their constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-301">Tableau d’objets <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> pouvant être utilisés pour définir les contraintes des paramètres de type générique pour le type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-301">An array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to define the constraints of the generic type parameters for the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-302">Appel de cette méthode rend le type actuel un type générique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-302">Calling this method makes the current type a generic type.</span></span> <span data-ttu-id="18d9c-303">Si la méthode est appelée à nouveau sur le même type, un <xref:System.InvalidOperationException> est levée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-303">If the method is called again on the same type, an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-304">L’exemple de code suivant crée un type générique avec deux paramètres de type et les enregistre dans l’assembly GenericEmitExample1.dll.</span><span class="sxs-lookup"><span data-stu-id="18d9c-304">The following code example creates a generic type with two type parameters and saves them in the assembly GenericEmitExample1.dll.</span></span> <span data-ttu-id="18d9c-305">Vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour afficher les types générés.</span><span class="sxs-lookup"><span data-stu-id="18d9c-305">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to view the generated types.</span></span> <span data-ttu-id="18d9c-306">Pour obtenir une explication plus détaillée des étapes impliquées dans la définition d’un type générique dynamique, consultez [Comment : définir un Type générique avec l’émission de réflexion](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="18d9c-306">For a more detailed explanation of the steps involved in defining a dynamic generic type, see [How to: Define a Generic Type with Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).</span></span>  
  
 [!code-cpp[EmitGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#1)]
 [!code-csharp[EmitGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#1)]
 [!code-vb[EmitGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-307">Des paramètres de type générique ont déjà été définis pour ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-307">Generic type parameters have already been defined for this type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-308">
            <paramref name="names" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-308">
              <paramref name="names" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="18d9c-309">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-309">-or-</span>
          </span>
          <span data-ttu-id="18d9c-310">Un élément de <paramref name="names" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-310">An element of <paramref name="names" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-311">
            <paramref name="names" /> est un tableau vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-311">
              <paramref name="names" /> is an empty array.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineInitializedData (name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineInitializedData(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineInitializedData : string * byte[] * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineInitializedData (name, data, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-312">Nom utilisé pour faire référence aux données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-312">The name used to refer to the data.</span>
          </span>
          <span data-ttu-id="18d9c-313">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-313">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="data">
          <span data-ttu-id="18d9c-314">Objet blob de données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-314">The blob of data.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-315">Attributs du champ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-315">The attributes for the field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-316">Définit un champ de données non initialisées dans la section .sdata du fichier exécutable portable (PE).</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-316">Defines initialized data field in the .sdata section of the portable executable (PE) file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-317">Champ pour référencer les données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-317">A field to reference the data.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-318">Le champ que vous créez avec cette méthode sera `static`, même si vous n’incluez pas `FieldAttributes.Static` dans le `attributes` paramètre.</span><span class="sxs-lookup"><span data-stu-id="18d9c-318">The field that you create with this method will be `static`, even if you do not include `FieldAttributes.Static` in the `attributes` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-319">La longueur de <paramref name="name" /> est égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-319">Length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="18d9c-320">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-320">-or-</span>
          </span>
          <span data-ttu-id="18d9c-321">La taille des données est inférieure ou égale à zéro, ou supérieure ou égale à 0x3f0000.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-321">The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-322">
            <paramref name="name" /> ou <paramref name="data" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-322">
              <paramref name="name" /> or <paramref name="data" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-323">
            <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelé précédemment.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-323">
              <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> has been previously called.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-324">Ajoute une méthode au type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-324">Adds a method to the type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-325">Nom de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-325">The name of the method.</span>
          </span>
          <span data-ttu-id="18d9c-326">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-326">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-327">Attributs de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-327">The attributes of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-328">Ajoute une nouvelle méthode au type, avec le nom et les attributs de méthode spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-328">Adds a new method to the type, with the specified name and method attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-329">
            <see cref="T:System.Reflection.Emit.MethodBuilder" /> représentant la méthode récemment définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-329">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-330">Utilisez cette surcharge de méthode lorsque vous ne connaissez pas la signature de méthode au moment où que vous définissez la méthode.</span><span class="sxs-lookup"><span data-stu-id="18d9c-330">Use this method overload when you do not know the method signature at the time you define the method.</span></span> <span data-ttu-id="18d9c-331">Par exemple, les types de paramètre et le type de retour d’une méthode générique peuvent être spécifiés par les paramètres de type générique de la méthode, qui doivent être définis une fois que la méthode a été ajoutée au type.</span><span class="sxs-lookup"><span data-stu-id="18d9c-331">For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</span></span> <span data-ttu-id="18d9c-332">Les paramètres et le type de retour de la méthode peuvent être définies ultérieurement à l’aide du <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-332">The parameters and return type of the method can be set later using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="18d9c-333">Cette surcharge de méthode définit une méthode avec <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="18d9c-333">This method overload defines a method with <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.</span></span> <span data-ttu-id="18d9c-334">Si vous devez définir une méthode sans signature, avec une autre convention d’appel, utilisez le <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="18d9c-334">If you need to define a method without a signature, with a different calling convention, use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-335">L’exemple de code suivant définit une méthode générique nommée `DemoMethod` dont le type de paramètre et type de retour sont spécifiés par ses paramètres de type générique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-335">The following code example defines a generic method named `DemoMethod` whose parameter type and return type are specified by its generic type parameters.</span></span> <span data-ttu-id="18d9c-336">La méthode est définie sans signature, à l’aide de la convention d’appel standard.</span><span class="sxs-lookup"><span data-stu-id="18d9c-336">The method is defined without a signature, using the standard calling convention.</span></span> <span data-ttu-id="18d9c-337">Le <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> méthode est utilisée pour rendre `DemoMethod` une méthode générique et les paramètres de type récemment définie sont ensuite utilisés pour la signature et le type de retour.</span><span class="sxs-lookup"><span data-stu-id="18d9c-337">The <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method is used to make `DemoMethod` a generic method, and the newly defined type parameters are then used for the signature and return type.</span></span>  
  
 <span data-ttu-id="18d9c-338">Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-338">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#4](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#4)]
 [!code-csharp[GenericMethodBuilder#4](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#4)]
 [!code-vb[GenericMethodBuilder#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#4)]  
[!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
[!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
[!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-339">La longueur de <paramref name="name" /> est égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-339">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="18d9c-340">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-340">-or-</span>
          </span>
          <span data-ttu-id="18d9c-341">Le type du parent de cette méthode est une interface, et cette méthode n’est pas virtuelle (<see langword="Overridable" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-341">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-342">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-342">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-343">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-343">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="18d9c-344">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-344">-or-</span>
          </span>
          <span data-ttu-id="18d9c-345">Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-345">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-346">Nom de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-346">The name of the method.</span>
          </span>
          <span data-ttu-id="18d9c-347">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-347">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-348">Attributs de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-348">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="18d9c-349">Convention d’appel de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-349">The calling convention of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-350">Ajoute une nouvelle méthode au type, avec le nom, les attributs de méthode et la convention d’appel spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-350">Adds a new method to the type, with the specified name, method attributes, and calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-351">
            <see cref="T:System.Reflection.Emit.MethodBuilder" /> représentant la méthode récemment définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-351">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-352">Utilisez cette surcharge de méthode lorsque vous ne connaissez pas la signature de méthode au moment où que vous définissez la méthode.</span><span class="sxs-lookup"><span data-stu-id="18d9c-352">Use this method overload when you do not know the method signature at the time you define the method.</span></span> <span data-ttu-id="18d9c-353">Par exemple, les types de paramètre et le type de retour d’une méthode générique peuvent être spécifiés par les paramètres de type générique de la méthode, qui doivent être définis une fois que la méthode a été ajoutée au type.</span><span class="sxs-lookup"><span data-stu-id="18d9c-353">For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</span></span> <span data-ttu-id="18d9c-354">Les paramètres et le type de retour de la méthode peuvent être définies ultérieurement à l’aide du <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-354">The parameters and return type of the method can be set later using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-355">La longueur de <paramref name="name" /> est égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-355">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="18d9c-356">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-356">-or-</span>
          </span>
          <span data-ttu-id="18d9c-357">Le type du parent de cette méthode est une interface, et cette méthode n’est pas virtuelle (<see langword="Overridable" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-357">The type of the parent of this method is an interface and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-358">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-358">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-359">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-359">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="18d9c-360">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-360">-or-</span>
          </span>
          <span data-ttu-id="18d9c-361">Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-361">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-362">Nom de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-362">The name of the method.</span>
          </span>
          <span data-ttu-id="18d9c-363">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-363">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-364">Attributs de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-364">The attributes of the method.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="18d9c-365">Type de retour de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-365">The return type of the method.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="18d9c-366">Types des paramètres de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-366">The types of the parameters of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-367">Ajoute une nouvelle méthode au type, avec le nom, les attributs de méthode et la signature de méthode spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-367">Adds a new method to the type, with the specified name, method attributes, and method signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-368">Méthode définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-368">The defined method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="18d9c-369">L’exemple de code suivant illustre l’utilisation de `DefineMethod` pour définir une signature spécifique et les attributs d’un constructeur sur un type dynamique et retourner un <xref:System.Reflection.Emit.MethodBuilder> pour alimentation MSIL.</span><span class="sxs-lookup"><span data-stu-id="18d9c-369">The following code sample demonstrates the use of `DefineMethod` to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref:System.Reflection.Emit.MethodBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-370">La longueur de <paramref name="name" /> est égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-370">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="18d9c-371">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-371">-or-</span>
          </span>
          <span data-ttu-id="18d9c-372">Le type du parent de cette méthode est une interface, et cette méthode n’est pas virtuelle (<see langword="Overridable" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-372">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-373">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-373">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-374">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-374">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="18d9c-375">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-375">-or-</span>
          </span>
          <span data-ttu-id="18d9c-376">Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-376">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-377">Nom de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-377">The name of the method.</span>
          </span>
          <span data-ttu-id="18d9c-378">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-378">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-379">Attributs de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-379">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="18d9c-380">Convention d’appel de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-380">The calling convention of the method.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="18d9c-381">Type de retour de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-381">The return type of the method.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="18d9c-382">Types des paramètres de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-382">The types of the parameters of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-383">Ajoute une nouvelle méthode au type, avec le nom, les attributs de méthode, la convention d’appel et la signature de méthode spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-383">Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-384">
            <see cref="T:System.Reflection.Emit.MethodBuilder" /> représentant la méthode récemment définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-384">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="18d9c-385">L’exemple de code suivant illustre l’utilisation de `DefineMethod` pour définir une signature spécifique et les attributs d’un constructeur sur un type dynamique et retourner un <xref:System.Reflection.Emit.MethodBuilder> pour alimentation MSIL.</span><span class="sxs-lookup"><span data-stu-id="18d9c-385">The following code sample demonstrates the use of `DefineMethod` to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref:System.Reflection.Emit.MethodBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-386">La longueur de <paramref name="name" /> est égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-386">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="18d9c-387">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-387">-or-</span>
          </span>
          <span data-ttu-id="18d9c-388">Le type du parent de cette méthode est une interface, et cette méthode n’est pas virtuelle (<see langword="Overridable" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-388">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-389">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-389">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-390">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-390">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="18d9c-391">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-391">-or-</span>
          </span>
          <span data-ttu-id="18d9c-392">Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-392">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-393">Nom de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-393">The name of the method.</span>
          </span>
          <span data-ttu-id="18d9c-394">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-394">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-395">Attributs de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-395">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="18d9c-396">Convention d’appel de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-396">The calling convention of the method.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="18d9c-397">Type de retour de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-397">The return type of the method.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="18d9c-398">Tableau de types représentant les modificateurs personnalisés requis, tels qu’<see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-398">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="18d9c-399">Si le type de retour ne possède pas de modificateur personnalisé requis, spécifiez <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-399">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="18d9c-400">Tableau de types représentant les modificateurs personnalisés facultatifs, tels qu’<see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-400">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="18d9c-401">Si le type de retour ne possède pas de modificateur personnalisé facultatif, spécifiez <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-401">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="18d9c-402">Types des paramètres de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-402">The types of the parameters of the method.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="18d9c-403">Tableau de tableaux de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-403">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="18d9c-404">Chaque tableau de types représente les modificateurs personnalisés obligatoires pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-404">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="18d9c-405">Si un paramètre particulier ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" /> plutôt qu’un tableau de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-405">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="18d9c-406">Si aucun paramètre ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-406">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="18d9c-407">Tableau de tableaux de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-407">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="18d9c-408">Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-408">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="18d9c-409">Si un paramètre particulier ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" /> plutôt qu’un tableau de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-409">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="18d9c-410">Si aucun paramètre ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-410">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-411">Ajoute une nouvelle méthode au type avec les nom, attributs de méthode, convention d’appel, signature de méthode et modificateurs personnalisés spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-411">Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-412">Objet <see cref="T:System.Reflection.Emit.MethodBuilder" /> représentant la nouvelle méthode ajoutée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-412">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> object representing the newly added method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-413">Utilisez cette surcharge si vous devez spécifier des modificateurs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="18d9c-413">Use this overload if you need to specify custom modifiers.</span></span> <span data-ttu-id="18d9c-414">Si vous devez spécifier des modificateurs personnalisés une fois que la méthode a été créée, comme vous le feriez, par exemple, avec une méthode générique dont les types de paramètre sont spécifiés par ses paramètres de type générique, vous pouvez utiliser la <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> ou <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> pour définir des surcharges de méthode la méthode, puis utiliser le <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> méthode pour définir le paramètre et retourner des types avec des modificateurs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="18d9c-414">If you need to specify custom modifiers after the method has been created, as you would, for example, with a generic method whose parameter types are specified by its generic type parameters, you can use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> or <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> method overloads to define the method and then use the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method to define the parameter and return types with custom modifiers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-415">Pour plus d’informations sur les modificateurs personnalisés, consultez la documentation de métadonnées ECMA Partition II.</span><span class="sxs-lookup"><span data-stu-id="18d9c-415">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="18d9c-416">La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.</span><span class="sxs-lookup"><span data-stu-id="18d9c-416">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-417">La longueur de <paramref name="name" /> est égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-417">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="18d9c-418">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-418">-or-</span>
          </span>
          <span data-ttu-id="18d9c-419">Le type du parent de cette méthode est une interface, et cette méthode n’est pas virtuelle (<see langword="Overridable" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-419">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
          <span data-ttu-id="18d9c-420">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-420">-or-</span>
          </span>
          <span data-ttu-id="18d9c-421">La taille de <paramref name="parameterTypeRequiredCustomModifiers" /> ou <paramref name="parameterTypeOptionalCustomModifiers" /> n’est pas égale à la taille de <paramref name="parameterTypes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-421">The size of <paramref name="parameterTypeRequiredCustomModifiers" /> or <paramref name="parameterTypeOptionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-422">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-422">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-423">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-423">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="18d9c-424">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-424">-or-</span>
          </span>
          <span data-ttu-id="18d9c-425">Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-425">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethodOverride">
      <MemberSignature Language="C#" Value="public void DefineMethodOverride (System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineMethodOverride(class System.Reflection.MethodInfo methodInfoBody, class System.Reflection.MethodInfo methodInfoDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineMethodOverride (methodInfoBody As MethodInfo, methodInfoDeclaration As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineMethodOverride(System::Reflection::MethodInfo ^ methodInfoBody, System::Reflection::MethodInfo ^ methodInfoDeclaration);" />
      <MemberSignature Language="F#" Value="member this.DefineMethodOverride : System.Reflection.MethodInfo * System.Reflection.MethodInfo -&gt; unit" Usage="typeBuilder.DefineMethodOverride (methodInfoBody, methodInfoDeclaration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodInfoBody" Type="System.Reflection.MethodInfo" />
        <Parameter Name="methodInfoDeclaration" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="methodInfoBody">
          <span data-ttu-id="18d9c-426">Corps de méthode à utiliser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-426">The method body to be used.</span>
          </span>
          <span data-ttu-id="18d9c-427">Il doit s’agir d’un objet <see langword="MethodBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-427">This should be a <see langword="MethodBuilder" /> object.</span>
          </span>
        </param>
        <param name="methodInfoDeclaration">
          <span data-ttu-id="18d9c-428">Méthode dont la déclaration doit être utilisée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-428">The method whose declaration is to be used.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-429">Spécifie un corps de méthode donné qui implémente une déclaration de méthode donnée, éventuellement avec un nom différent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-429">Specifies a given method body that implements a given method declaration, potentially with a different name.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-430">N’utilisez pas cette méthode pour émettre des substitutions de méthode ou des implémentations d’interface.</span><span class="sxs-lookup"><span data-stu-id="18d9c-430">Do not use this method to emit method overrides or interface implementations.</span></span> <span data-ttu-id="18d9c-431">Pour substituer une méthode de classe de base ou pour implémenter une méthode d’une interface, émettez simplement une méthode avec le même nom et la même signature que la méthode à être substituées ou implémentées, comme illustré dans l’exemple de code.</span><span class="sxs-lookup"><span data-stu-id="18d9c-431">To override a method of a base class or to implement a method of an interface, simply emit a method with the same name and signature as the method to be overridden or implemented, as demonstrated in the code example.</span></span>  
  
 <span data-ttu-id="18d9c-432">Le <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> méthode est utilisée quand un corps de méthode et une déclaration de méthode ont des noms différents.</span><span class="sxs-lookup"><span data-stu-id="18d9c-432">The <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method is used when a method body and a method declaration have different names.</span></span> <span data-ttu-id="18d9c-433">Par exemple, une classe peut substituer une méthode de classe de base et également fournir une implémentation distincte pour un membre d’interface portant le même nom, comme illustré dans l’exemple de code.</span><span class="sxs-lookup"><span data-stu-id="18d9c-433">For example, a class might override a base class method and also provide a separate implementation for an interface member with the same name, as demonstrated in the code example.</span></span>  
  
 <span data-ttu-id="18d9c-434">`DefineMethodOverride` définit un `methodimpl`, qui se compose d’une paire de jetons de métadonnées.</span><span class="sxs-lookup"><span data-stu-id="18d9c-434">`DefineMethodOverride` defines a `methodimpl`, which consists of a pair of metadata tokens.</span></span> <span data-ttu-id="18d9c-435">Un seul jeton pointe vers une implémentation et l’autre jeton pointe vers une déclaration qui implémente le corps.</span><span class="sxs-lookup"><span data-stu-id="18d9c-435">One token points to an implementation, and the other token points to a declaration that the body implements.</span></span> <span data-ttu-id="18d9c-436">Le corps doit être défini sur le type de la méthode impl est définie, et le corps doit être virtuel (`Overridable` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="18d9c-436">The body must be defined on the type the method impl is defined on, and the body must be virtual (`Overridable` in Visual Basic).</span></span> <span data-ttu-id="18d9c-437">La déclaration peut être faite à une méthode définie sur une interface implémentée par le type, une méthode sur une classe dérivée ou une méthode définie dans le type.</span><span class="sxs-lookup"><span data-stu-id="18d9c-437">The declaration can be made to a method defined on an interface implemented by the type, a method on a derived class, or a method defined in the type.</span></span> <span data-ttu-id="18d9c-438">Si la déclaration se trouve sur une interface uniquement, l’emplacement défini pour l’interface est modifié.</span><span class="sxs-lookup"><span data-stu-id="18d9c-438">If the declaration is on an interface only, the slot defined for the interface is altered.</span></span> <span data-ttu-id="18d9c-439">Si la déclaration est faite à une méthode sur un type de base, l’emplacement de la méthode est substitué et tous les doublons de la méthode substituée sont également remplacés.</span><span class="sxs-lookup"><span data-stu-id="18d9c-439">If the declaration is made to a method on a base type, the slot for the method is overridden and any duplicates for the overridden method are also replaced.</span></span> <span data-ttu-id="18d9c-440">La méthode substituée ne peut pas être la méthode réelle qui est déclarée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-440">The overridden method cannot be the actual method that is declared.</span></span> <span data-ttu-id="18d9c-441">Si la méthode est sur le même type, l’emplacement est remplacé, et tous les doublons des méthodes remplacées sont substitués.</span><span class="sxs-lookup"><span data-stu-id="18d9c-441">If the method is on the same type, the slot is replaced and any duplicates for the replaced methods are overridden.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-442">Pour plus d’informations sur les méthodes impl, consultez `MethodImpl` dans la documentation de métadonnées ECMA Partition II.</span><span class="sxs-lookup"><span data-stu-id="18d9c-442">For more information about method impls, see `MethodImpl` in the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="18d9c-443">La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.</span><span class="sxs-lookup"><span data-stu-id="18d9c-443">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="18d9c-444">Après le <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> méthode est appelée, certaines fonctionnalités de `methodInfoBody` ne peut pas être modifié.</span><span class="sxs-lookup"><span data-stu-id="18d9c-444">After the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method is called, some features of `methodInfoBody` cannot be changed.</span></span> <span data-ttu-id="18d9c-445">Par exemple, vous ne pouvez pas appliquer un attribut à un paramètre de type générique de `methodInfoBody` à l’aide de la <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-445">For example, you cannot apply an attribute to a generic type parameter of `methodInfoBody` by using the <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> method.</span></span> <span data-ttu-id="18d9c-446">Si vous devez utiliser le <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> (méthode), faire une fois toutes les caractéristiques de `methodInfoBody` ont été définies.</span><span class="sxs-lookup"><span data-stu-id="18d9c-446">If you must use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method, do so after all characteristics of `methodInfoBody` have been defined.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-447">L’exemple de code suivant contient une interface `I` avec une méthode `M()`, une classe de base `A` qui implémente l’interface et une classe dérivée `C` qui substitue l’implémentation de classe de base de `M()` et également Fournit une implémentation distincte et explicite de `I.M()`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-447">The following code example contains an interface `I` with a method `M()`, a base class `A` that implements the interface, and a derived class `C` that overrides the base class implementation of `M()` and also provides a separate explicit implementation of `I.M()`.</span></span>  
  
 <span data-ttu-id="18d9c-448">Le `main()` méthode de l’exemple de code montre comment émettre la classe dérivée `C`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-448">The `main()` method of the code example shows how to emit the derived class `C`.</span></span> <span data-ttu-id="18d9c-449">La substitution de `A.M()` s’effectue simplement en émettant une méthode `M()` avec la même signature.</span><span class="sxs-lookup"><span data-stu-id="18d9c-449">The override of `A.M()` is accomplished simply by emitting a method `M()` with the same signature.</span></span> <span data-ttu-id="18d9c-450">Toutefois, pour fournir une implémentation distincte de `I.M()`, vous devez définir un corps de méthode, puis utiliser le <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> méthode pour associer ce corps de méthode avec un <xref:System.Reflection.MethodInfo> représentant `I.M()`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-450">However, to provide a separate implementation of `I.M()`, you must define a method body and then use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method to associate that method body with a <xref:System.Reflection.MethodInfo> representing `I.M()`.</span></span> <span data-ttu-id="18d9c-451">Le nom du corps de méthode n’a pas d’importance.</span><span class="sxs-lookup"><span data-stu-id="18d9c-451">The name of the method body does not matter.</span></span>  
  
 <span data-ttu-id="18d9c-452">L’exemple de code crée une instance de la classe émise.</span><span class="sxs-lookup"><span data-stu-id="18d9c-452">The code example creates an instance of the emitted class.</span></span> <span data-ttu-id="18d9c-453">Il obtient un <xref:System.Reflection.MethodInfo> pour l’objet `I.M()`, et l’utilise pour appeler la classe émise explicite de la mise en œuvre de l’interface.</span><span class="sxs-lookup"><span data-stu-id="18d9c-453">It obtains a <xref:System.Reflection.MethodInfo> object for `I.M()`, and uses it to invoke the emitted class's explicit interface implementation.</span></span> <span data-ttu-id="18d9c-454">Il obtient ensuite un <xref:System.Reflection.MethodInfo> pour l’objet `A.M()`et l’utilise pour appeler la substitution de la classe émis de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="18d9c-454">It then obtains a <xref:System.Reflection.MethodInfo> object for `A.M()`, and uses it to invoke the emitted class's override of that method.</span></span>  
  
 [!code-cpp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cpp/source.cpp#1)]
 [!code-csharp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cs/source.cs#1)]
 [!code-vb[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-455">
            <paramref name="methodInfoBody" /> n’appartient pas à cette classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-455">
              <paramref name="methodInfoBody" /> does not belong to this class.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-456">
            <paramref name="methodInfoBody" /> ou <paramref name="methodInfoDeclaration" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-456">
              <paramref name="methodInfoBody" /> or <paramref name="methodInfoDeclaration" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-457">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-457">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="18d9c-458">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-458">-or-</span>
          </span>
          <span data-ttu-id="18d9c-459">Le type déclarant de <paramref name="methodInfoBody" /> n’est pas le type représenté par ce <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-459">The declaring type of <paramref name="methodInfoBody" /> is not the type represented by this <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineNestedType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-460">Définit un type imbriqué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-460">Defines a nested type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-461">Nom court du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-461">The short name of the type.</span>
          </span>
          <span data-ttu-id="18d9c-462">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-462">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-463">Définit un type imbriqué, en fonction de son nom.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-463">Defines a nested type, given its name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-464">Type imbriqué défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-464">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-465">Cette méthode peut être utilisée pour créer une prédiction imbriquée types même après la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode a été appelée sur le type englobant.</span><span class="sxs-lookup"><span data-stu-id="18d9c-465">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="18d9c-466">Le type imbriqué doit être terminées avant que vous pouvez refléter dessus à l’aide de <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="18d9c-466">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="18d9c-467">Consultez la description de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> pour l’ordre dans lequel les types imbriqués et imbrication doit être effectuée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-467">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="18d9c-468">Un nom en double n’est pas nécessairement créé si `name` est identique au nom d’un type défini précédemment ou d’un type imbriqué.</span><span class="sxs-lookup"><span data-stu-id="18d9c-468">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="18d9c-469">Pour être des doublons, le nom complet doit être identique, y compris l’espace de noms et tous les types d’imbrication.</span><span class="sxs-lookup"><span data-stu-id="18d9c-469">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-470">La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-470">Length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="18d9c-471">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-471">-or-</span>
          </span>
          <span data-ttu-id="18d9c-472">Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-472">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-473">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-473">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-474">Nom court du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-474">The short name of the type.</span>
          </span>
          <span data-ttu-id="18d9c-475">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-475">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="18d9c-476">Attributs du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-476">The attributes of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-477">Définit un type imbriqué, en fonction de son nom et de ses attributs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-477">Defines a nested type, given its name and attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-478">Type imbriqué défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-478">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-479">Cette méthode peut être utilisée pour créer une prédiction imbriquée types même après la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode a été appelée sur le type englobant.</span><span class="sxs-lookup"><span data-stu-id="18d9c-479">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="18d9c-480">Le type imbriqué doit être terminées avant que vous pouvez refléter dessus à l’aide de <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="18d9c-480">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="18d9c-481">Consultez la description de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> pour l’ordre dans lequel les types imbriqués et imbrication doit être effectuée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-481">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="18d9c-482">Un nom en double n’est pas nécessairement créé si `name` est identique au nom d’un type défini précédemment ou d’un type imbriqué.</span><span class="sxs-lookup"><span data-stu-id="18d9c-482">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="18d9c-483">Pour être des doublons, le nom complet doit être identique, y compris l’espace de noms et tous les types d’imbrication.</span><span class="sxs-lookup"><span data-stu-id="18d9c-483">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-484">L’attribut imbriqué n’est pas spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-484">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="18d9c-485">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-485">-or-</span>
          </span>
          <span data-ttu-id="18d9c-486">Ce type est scellé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-486">This type is sealed.</span>
          </span>
          <span data-ttu-id="18d9c-487">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-487">-or-</span>
          </span>
          <span data-ttu-id="18d9c-488">Ce type est un tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-488">This type is an array.</span>
          </span>
          <span data-ttu-id="18d9c-489">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-489">-or-</span>
          </span>
          <span data-ttu-id="18d9c-490">Ce type est une interface, mais le type imbriqué n’est pas une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-490">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="18d9c-491">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-491">-or-</span>
          </span>
          <span data-ttu-id="18d9c-492">La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1 023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-492">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="18d9c-493">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-493">-or-</span>
          </span>
          <span data-ttu-id="18d9c-494">Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-494">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-495">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-495">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-496">Nom court du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-496">The short name of the type.</span>
          </span>
          <span data-ttu-id="18d9c-497">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-497">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="18d9c-498">Attributs du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-498">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="18d9c-499">Type étendu par le type imbriqué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-499">The type that the nested type extends.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-500">Définit un type imbriqué, en fonction de son nom, de ses attributs et du type qu’il étend.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-500">Defines a nested type, given its name, attributes, and the type that it extends.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-501">Type imbriqué défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-501">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-502">Cette méthode peut être utilisée pour créer une prédiction imbriquée types même après la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode a été appelée sur le type englobant.</span><span class="sxs-lookup"><span data-stu-id="18d9c-502">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="18d9c-503">Le type imbriqué doit être terminées avant que vous pouvez refléter dessus à l’aide de <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="18d9c-503">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="18d9c-504">Consultez la description de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> pour l’ordre dans lequel les types imbriqués et imbrication doit être effectuée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-504">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="18d9c-505">Un nom en double n’est pas nécessairement créé si `name` est identique au nom d’un type défini précédemment ou d’un type imbriqué.</span><span class="sxs-lookup"><span data-stu-id="18d9c-505">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="18d9c-506">Pour être des doublons, le nom complet doit être identique, y compris l’espace de noms et tous les types d’imbrication.</span><span class="sxs-lookup"><span data-stu-id="18d9c-506">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-507">L’attribut imbriqué n’est pas spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-507">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="18d9c-508">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-508">-or-</span>
          </span>
          <span data-ttu-id="18d9c-509">Ce type est scellé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-509">This type is sealed.</span>
          </span>
          <span data-ttu-id="18d9c-510">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-510">-or-</span>
          </span>
          <span data-ttu-id="18d9c-511">Ce type est un tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-511">This type is an array.</span>
          </span>
          <span data-ttu-id="18d9c-512">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-512">-or-</span>
          </span>
          <span data-ttu-id="18d9c-513">Ce type est une interface, mais le type imbriqué n’est pas une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-513">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="18d9c-514">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-514">-or-</span>
          </span>
          <span data-ttu-id="18d9c-515">La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1 023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-515">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="18d9c-516">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-516">-or-</span>
          </span>
          <span data-ttu-id="18d9c-517">Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-517">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-518">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-518">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, int typeSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, typeSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-519">Nom court du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-519">The short name of the type.</span>
          </span>
          <span data-ttu-id="18d9c-520">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-520">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="18d9c-521">Attributs du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-521">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="18d9c-522">Type étendu par le type imbriqué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-522">The type that the nested type extends.</span>
          </span>
        </param>
        <param name="typeSize">
          <span data-ttu-id="18d9c-523">Taille totale du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-523">The total size of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-524">Définit un type imbriqué, en fonction de son nom, de ses attributs, de la taille totale du type et du type qu’il étend.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-524">Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-525">Type imbriqué défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-525">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-526">Cette méthode peut être utilisée pour créer une prédiction imbriquée types même après la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode a été appelée sur le type englobant.</span><span class="sxs-lookup"><span data-stu-id="18d9c-526">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="18d9c-527">Le type imbriqué doit être terminées avant que vous pouvez refléter dessus à l’aide de <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="18d9c-527">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="18d9c-528">Consultez la description de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> pour l’ordre dans lequel les types imbriqués et imbrication doit être effectuée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-528">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="18d9c-529">Un nom en double n’est pas nécessairement créé si `name` est identique au nom d’un type défini précédemment ou d’un type imbriqué.</span><span class="sxs-lookup"><span data-stu-id="18d9c-529">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="18d9c-530">Pour être des doublons, le nom complet doit être identique, y compris l’espace de noms et tous les types d’imbrication.</span><span class="sxs-lookup"><span data-stu-id="18d9c-530">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-531">L’attribut imbriqué n’est pas spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-531">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="18d9c-532">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-532">-or-</span>
          </span>
          <span data-ttu-id="18d9c-533">Ce type est scellé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-533">This type is sealed.</span>
          </span>
          <span data-ttu-id="18d9c-534">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-534">-or-</span>
          </span>
          <span data-ttu-id="18d9c-535">Ce type est un tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-535">This type is an array.</span>
          </span>
          <span data-ttu-id="18d9c-536">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-536">-or-</span>
          </span>
          <span data-ttu-id="18d9c-537">Ce type est une interface, mais le type imbriqué n’est pas une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-537">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="18d9c-538">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-538">-or-</span>
          </span>
          <span data-ttu-id="18d9c-539">La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1 023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-539">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="18d9c-540">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-540">-or-</span>
          </span>
          <span data-ttu-id="18d9c-541">Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-541">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-542">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-542">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, packSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-543">Nom court du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-543">The short name of the type.</span>
          </span>
          <span data-ttu-id="18d9c-544">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-544">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="18d9c-545">Attributs du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-545">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="18d9c-546">Type étendu par le type imbriqué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-546">The type that the nested type extends.</span>
          </span>
        </param>
        <param name="packSize">
          <span data-ttu-id="18d9c-547">Taille de compression du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-547">The packing size of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-548">Définit un type imbriqué, en fonction de son nom, de ses attributs, du type qu’il étend et de la taille de compression.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-548">Defines a nested type, given its name, attributes, the type that it extends, and the packing size.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-549">Type imbriqué défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-549">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-550">Cette méthode peut être utilisée pour créer une prédiction imbriquée types même après la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode a été appelée sur le type englobant.</span><span class="sxs-lookup"><span data-stu-id="18d9c-550">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="18d9c-551">Le type imbriqué doit être terminées avant que vous pouvez refléter dessus à l’aide de <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="18d9c-551">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="18d9c-552">Consultez la description de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> pour l’ordre dans lequel les types imbriqués et imbrication doit être effectuée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-552">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="18d9c-553">Un nom en double n’est pas nécessairement créé si `name` est identique au nom d’un type défini précédemment ou d’un type imbriqué.</span><span class="sxs-lookup"><span data-stu-id="18d9c-553">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="18d9c-554">Pour être des doublons, le nom complet doit être identique, y compris l’espace de noms et tous les types d’imbrication.</span><span class="sxs-lookup"><span data-stu-id="18d9c-554">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-555">L’attribut imbriqué n’est pas spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-555">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="18d9c-556">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-556">-or-</span>
          </span>
          <span data-ttu-id="18d9c-557">Ce type est scellé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-557">This type is sealed.</span>
          </span>
          <span data-ttu-id="18d9c-558">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-558">-or-</span>
          </span>
          <span data-ttu-id="18d9c-559">Ce type est un tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-559">This type is an array.</span>
          </span>
          <span data-ttu-id="18d9c-560">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-560">-or-</span>
          </span>
          <span data-ttu-id="18d9c-561">Ce type est une interface, mais le type imbriqué n’est pas une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-561">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="18d9c-562">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-562">-or-</span>
          </span>
          <span data-ttu-id="18d9c-563">La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1 023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-563">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="18d9c-564">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-564">-or-</span>
          </span>
          <span data-ttu-id="18d9c-565">Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-565">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-566">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-566">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, cli::array &lt;Type ^&gt; ^ interfaces);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * Type[] -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, interfaces)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-567">Nom court du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-567">The short name of the type.</span>
          </span>
          <span data-ttu-id="18d9c-568">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-568">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="18d9c-569">Attributs du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-569">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="18d9c-570">Type étendu par le type imbriqué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-570">The type that the nested type extends.</span>
          </span>
        </param>
        <param name="interfaces">
          <span data-ttu-id="18d9c-571">Interfaces implémentées par le type imbriqué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-571">The interfaces that the nested type implements.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-572">Définit un type imbriqué, en fonction de son nom, de ses attributs, du type qu’il étend et des interfaces qu’il implémente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-572">Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-573">Type imbriqué défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-573">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-574">Cette méthode peut être utilisée pour créer une prédiction imbriquée types même après la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode a été appelée sur le type englobant.</span><span class="sxs-lookup"><span data-stu-id="18d9c-574">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="18d9c-575">Le type imbriqué doit être terminées avant que vous pouvez refléter dessus à l’aide de <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="18d9c-575">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="18d9c-576">Consultez la description de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> pour l’ordre dans lequel les types imbriqués et imbrication doit être effectuée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-576">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="18d9c-577">Un nom en double n’est pas nécessairement créé si `name` est identique au nom d’un type défini précédemment ou d’un type imbriqué.</span><span class="sxs-lookup"><span data-stu-id="18d9c-577">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="18d9c-578">Pour être des doublons, le nom complet doit être identique, y compris l’espace de noms et tous les types d’imbrication.</span><span class="sxs-lookup"><span data-stu-id="18d9c-578">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-579">L’attribut imbriqué n’est pas spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-579">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="18d9c-580">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-580">-or-</span>
          </span>
          <span data-ttu-id="18d9c-581">Ce type est scellé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-581">This type is sealed.</span>
          </span>
          <span data-ttu-id="18d9c-582">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-582">-or-</span>
          </span>
          <span data-ttu-id="18d9c-583">Ce type est un tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-583">This type is an array.</span>
          </span>
          <span data-ttu-id="18d9c-584">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-584">-or-</span>
          </span>
          <span data-ttu-id="18d9c-585">Ce type est une interface, mais le type imbriqué n’est pas une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-585">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="18d9c-586">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-586">-or-</span>
          </span>
          <span data-ttu-id="18d9c-587">La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1 023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-587">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="18d9c-588">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-588">-or-</span>
          </span>
          <span data-ttu-id="18d9c-589">Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-589">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-590">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-590">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="18d9c-591">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-591">-or-</span>
          </span>
          <span data-ttu-id="18d9c-592">Un élément du tableau <paramref name="interfaces" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-592">An element of the <paramref name="interfaces" /> array is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize, int typeSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, packSize, typeSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-593">Nom court du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-593">The short name of the type.</span>
          </span>
          <span data-ttu-id="18d9c-594">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-594">
              <c>name</c> cannot contain embedded null values.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="18d9c-595">Attributs du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-595">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="18d9c-596">Type étendu par le type imbriqué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-596">The type that the nested type extends.</span>
          </span>
        </param>
        <param name="packSize">
          <span data-ttu-id="18d9c-597">Taille de compactage du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-597">The packing size of the type.</span>
          </span>
        </param>
        <param name="typeSize">
          <span data-ttu-id="18d9c-598">Taille totale du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-598">The total size of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-599">Définit un type imbriqué, en fonction de ses nom, attributs, taille et du type qu’il étend.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-599">Defines a nested type, given its name, attributes, size, and the type that it extends.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-600">Type imbriqué défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-600">The defined nested type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefinePInvokeMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-601">Définit une méthode <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-601">Defines a <see langword="PInvoke" /> method.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-602">Nom de la méthode <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-602">The name of the <see langword="PInvoke" /> method.</span>
          </span>
          <span data-ttu-id="18d9c-603">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-603">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="dllName">
          <span data-ttu-id="18d9c-604">Nom de la DLL dans laquelle la méthode <see langword="PInvoke" /> est définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-604">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-605">Attributs de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-605">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="18d9c-606">Convention d’appel de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-606">The method's calling convention.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="18d9c-607">Type de retour de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-607">The method's return type.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="18d9c-608">Types des paramètres de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-608">The types of the method's parameters.</span>
          </span>
        </param>
        <param name="nativeCallConv">
          <span data-ttu-id="18d9c-609">Convention d’appel native.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-609">The native calling convention.</span>
          </span>
        </param>
        <param name="nativeCharSet">
          <span data-ttu-id="18d9c-610">Jeu de caractères natif de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-610">The method's native character set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-611">Définit une méthode <see langword="PInvoke" /> en fonction de son nom, du nom de la DLL dans laquelle elle est définie, des attributs de la méthode, de sa convention d’appel, de son type de retour, des types de ses paramètres et des indicateurs <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-611">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <see langword="PInvoke" /> flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-612">Méthode <see langword="PInvoke" /> définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-612">The defined <see langword="PInvoke" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-613">Attributs d’importation de certaines DLL (consultez la description de <xref:System.Runtime.InteropServices.DllImportAttribute>) ne peut pas être spécifié en tant qu’arguments à cette méthode.</span><span class="sxs-lookup"><span data-stu-id="18d9c-613">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="18d9c-614">Par exemple, la DLL Importer attribut <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> doit être ajouté après le `PInvoke` méthode est créée, si la méthode retourne une valeur.</span><span class="sxs-lookup"><span data-stu-id="18d9c-614">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="18d9c-615">L’exemple montre comment effectuer cette opération.</span><span class="sxs-lookup"><span data-stu-id="18d9c-615">The example shows how to do this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-616">L’exemple suivant montre comment utiliser le <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> méthode pour créer un `PInvoke` (méthode) et comment ajouter la <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> indicateur pour les indicateurs d’implémentation de méthode après avoir créé le <xref:System.Reflection.Emit.MethodBuilder>, à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> et <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>méthodes.</span><span class="sxs-lookup"><span data-stu-id="18d9c-616">The following example demonstrates how to use the <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="18d9c-617">Pour obtenir une valeur de retour différente de zéro, vous devez ajouter le <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> indicateur.</span><span class="sxs-lookup"><span data-stu-id="18d9c-617">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="18d9c-618">L’exemple crée un assembly dynamique avec un module dynamique et un type unique, `MyType`, qui contient le `PInvoke` (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-618">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="18d9c-619">Le `PInvoke` méthode représente Win32 `GetTickCount` (fonction).</span><span class="sxs-lookup"><span data-stu-id="18d9c-619">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
 <span data-ttu-id="18d9c-620">Lorsque l’exemple est exécuté, il exécute le `PInvoke` (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-620">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="18d9c-621">Elle enregistre également l’assembly dynamique comme PInvokeTest.dll.</span><span class="sxs-lookup"><span data-stu-id="18d9c-621">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="18d9c-622">Vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner le `MyType` classe et le `static` (`Shared` en Visual Basic) `PInvoke` méthode qu’il contient.</span><span class="sxs-lookup"><span data-stu-id="18d9c-622">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="18d9c-623">Vous pouvez compiler un programme Visual Basic ou c# qui utilise la méthode statique `MyType.GetTickCount` méthode en incluant une référence à la DLL lorsque vous exécutez csc.exe ou vbc.exe ; par exemple, `/r:PInvokeTest.dll`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-623">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-624">La méthode n’est pas statique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-624">The method is not static.</span>
          </span>
          <span data-ttu-id="18d9c-625">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-625">-or-</span>
          </span>
          <span data-ttu-id="18d9c-626">Le type parent est une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-626">The parent type is an interface.</span>
          </span>
          <span data-ttu-id="18d9c-627">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-627">-or-</span>
          </span>
          <span data-ttu-id="18d9c-628">La méthode est de type abstract.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-628">The method is abstract.</span>
          </span>
          <span data-ttu-id="18d9c-629">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-629">-or-</span>
          </span>
          <span data-ttu-id="18d9c-630">La méthode a déjà été définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-630">The method was previously defined.</span>
          </span>
          <span data-ttu-id="18d9c-631">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-631">-or-</span>
          </span>
          <span data-ttu-id="18d9c-632">La longueur de <paramref name="name" /> ou <paramref name="dllName" /> est de zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-632">The length of <paramref name="name" /> or <paramref name="dllName" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-633">
            <paramref name="name" /> ou <paramref name="dllName" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-633">
              <paramref name="name" /> or <paramref name="dllName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-634">Le type conteneur a déjà été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-634">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-635">Nom de la méthode <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-635">The name of the <see langword="PInvoke" /> method.</span>
          </span>
          <span data-ttu-id="18d9c-636">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-636">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="dllName">
          <span data-ttu-id="18d9c-637">Nom de la DLL dans laquelle la méthode <see langword="PInvoke" /> est définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-637">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span>
          </span>
        </param>
        <param name="entryName">
          <span data-ttu-id="18d9c-638">Nom du point d’entrée dans la DLL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-638">The name of the entry point in the DLL.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-639">Attributs de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-639">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="18d9c-640">Convention d’appel de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-640">The method's calling convention.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="18d9c-641">Type de retour de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-641">The method's return type.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="18d9c-642">Types des paramètres de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-642">The types of the method's parameters.</span>
          </span>
        </param>
        <param name="nativeCallConv">
          <span data-ttu-id="18d9c-643">Convention d’appel native.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-643">The native calling convention.</span>
          </span>
        </param>
        <param name="nativeCharSet">
          <span data-ttu-id="18d9c-644">Jeu de caractères natif de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-644">The method's native character set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-645">Définit une méthode <see langword="PInvoke" /> en fonction de son nom, du nom de la DLL dans laquelle elle est définie, du nom du point d’entrée, des attributs de la méthode, de sa convention d’appel, de son type de retour, des types de ses paramètres et des indicateurs <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-645">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <see langword="PInvoke" /> flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-646">Méthode <see langword="PInvoke" /> définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-646">The defined <see langword="PInvoke" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-647">Attributs d’importation de certaines DLL (consultez la description de <xref:System.Runtime.InteropServices.DllImportAttribute>) ne peut pas être spécifié en tant qu’arguments à cette méthode.</span><span class="sxs-lookup"><span data-stu-id="18d9c-647">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="18d9c-648">Par exemple, la DLL Importer attribut <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> doit être ajouté après le `PInvoke` méthode est créée, si la méthode retourne une valeur.</span><span class="sxs-lookup"><span data-stu-id="18d9c-648">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="18d9c-649">L’exemple montre comment effectuer cette opération.</span><span class="sxs-lookup"><span data-stu-id="18d9c-649">The example shows how to do this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-650">L’exemple de code suivant montre comment utiliser le <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> méthode pour créer un `PInvoke` (méthode) et comment ajouter la <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> indicateur pour les indicateurs d’implémentation de méthode après avoir créé le <xref:System.Reflection.Emit.MethodBuilder>, à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> et <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> méthodes.</span><span class="sxs-lookup"><span data-stu-id="18d9c-650">The following code example demonstrates how to use the <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="18d9c-651">Pour obtenir une valeur de retour différente de zéro, vous devez ajouter le <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> indicateur.</span><span class="sxs-lookup"><span data-stu-id="18d9c-651">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="18d9c-652">L’exemple crée un assembly dynamique avec un module dynamique et un type unique, `MyType`, qui contient le `PInvoke` (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-652">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="18d9c-653">Le `PInvoke` méthode représente Win32 `GetTickCount` (fonction).</span><span class="sxs-lookup"><span data-stu-id="18d9c-653">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
 <span data-ttu-id="18d9c-654">Lorsque l’exemple est exécuté, il exécute le `PInvoke` (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-654">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="18d9c-655">Elle enregistre également l’assembly dynamique comme PInvokeTest.dll.</span><span class="sxs-lookup"><span data-stu-id="18d9c-655">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="18d9c-656">Vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner le `MyType` classe et le `static` (`Shared` en Visual Basic) `PInvoke` méthode qu’il contient.</span><span class="sxs-lookup"><span data-stu-id="18d9c-656">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="18d9c-657">Vous pouvez compiler un programme Visual Basic ou c# qui utilise la méthode statique `MyType.GetTickCount` méthode en incluant une référence à la DLL lorsque vous exécutez csc.exe ou vbc.exe ; par exemple, `/r:PInvokeTest.dll`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-657">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-658">La méthode n’est pas statique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-658">The method is not static.</span>
          </span>
          <span data-ttu-id="18d9c-659">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-659">-or-</span>
          </span>
          <span data-ttu-id="18d9c-660">Le type parent est une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-660">The parent type is an interface.</span>
          </span>
          <span data-ttu-id="18d9c-661">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-661">-or-</span>
          </span>
          <span data-ttu-id="18d9c-662">La méthode est de type abstract.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-662">The method is abstract.</span>
          </span>
          <span data-ttu-id="18d9c-663">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-663">-or-</span>
          </span>
          <span data-ttu-id="18d9c-664">La méthode a déjà été définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-664">The method was previously defined.</span>
          </span>
          <span data-ttu-id="18d9c-665">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-665">-or-</span>
          </span>
          <span data-ttu-id="18d9c-666">La longueur de <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> est égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-666">The length of <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-667">
            <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-667">
              <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-668">Le type conteneur a déjà été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-668">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-669">Nom de la méthode <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-669">The name of the <see langword="PInvoke" /> method.</span>
          </span>
          <span data-ttu-id="18d9c-670">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-670">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="dllName">
          <span data-ttu-id="18d9c-671">Nom de la DLL dans laquelle la méthode <see langword="PInvoke" /> est définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-671">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span>
          </span>
        </param>
        <param name="entryName">
          <span data-ttu-id="18d9c-672">Nom du point d’entrée dans la DLL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-672">The name of the entry point in the DLL.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-673">Attributs de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-673">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="18d9c-674">Convention d’appel de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-674">The method's calling convention.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="18d9c-675">Type de retour de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-675">The method's return type.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="18d9c-676">Tableau de types représentant les modificateurs personnalisés requis, tels qu’<see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-676">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="18d9c-677">Si le type de retour ne possède pas de modificateur personnalisé requis, spécifiez <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-677">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="18d9c-678">Tableau de types représentant les modificateurs personnalisés facultatifs, tels qu’<see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-678">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="18d9c-679">Si le type de retour ne possède pas de modificateur personnalisé facultatif, spécifiez <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-679">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="18d9c-680">Types des paramètres de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-680">The types of the method's parameters.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="18d9c-681">Tableau de tableaux de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-681">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="18d9c-682">Chaque tableau de types représente les modificateurs personnalisés obligatoires pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-682">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="18d9c-683">Si un paramètre particulier ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" /> plutôt qu’un tableau de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-683">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="18d9c-684">Si aucun paramètre ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-684">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="18d9c-685">Tableau de tableaux de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-685">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="18d9c-686">Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-686">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="18d9c-687">Si un paramètre particulier ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" /> plutôt qu’un tableau de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-687">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="18d9c-688">Si aucun paramètre ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-688">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="nativeCallConv">
          <span data-ttu-id="18d9c-689">Convention d’appel native.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-689">The native calling convention.</span>
          </span>
        </param>
        <param name="nativeCharSet">
          <span data-ttu-id="18d9c-690">Jeu de caractères natif de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-690">The method's native character set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-691">Définit une méthode <see langword="PInvoke" /> en fonction de son nom, du nom de la DLL dans laquelle elle est définie, du nom du point d’entrée, des attributs de la méthode, de sa convention d’appel, de son type de retour, des types de ses paramètres, des indicateurs <see langword="PInvoke" /> et des modificateurs personnalisés des paramètres et du type de retour.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-691">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, the <see langword="PInvoke" /> flags, and custom modifiers for the parameters and return type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-692">
            <see cref="T:System.Reflection.Emit.MethodBuilder" /> représentant la méthode <see langword="PInvoke" /> définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-692">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the defined <see langword="PInvoke" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-693">Attributs d’importation de certaines DLL (consultez la description de <xref:System.Runtime.InteropServices.DllImportAttribute>) ne peut pas être spécifié en tant qu’arguments à cette méthode.</span><span class="sxs-lookup"><span data-stu-id="18d9c-693">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="18d9c-694">Par exemple, la DLL Importer attribut <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> doit être ajouté après le `PInvoke` méthode est créée, si la méthode retourne une valeur.</span><span class="sxs-lookup"><span data-stu-id="18d9c-694">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="18d9c-695">L’exemple montre comment effectuer cette opération.</span><span class="sxs-lookup"><span data-stu-id="18d9c-695">The example shows how to do this.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-696">Pour plus d’informations sur les modificateurs personnalisés, consultez la documentation de métadonnées ECMA Partition II.</span><span class="sxs-lookup"><span data-stu-id="18d9c-696">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="18d9c-697">La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.</span><span class="sxs-lookup"><span data-stu-id="18d9c-697">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-698">L’exemple de code suivant montre comment utiliser le [\], Type\[\], Type\[\], Type\[\]\[\], Type\[ \] \<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A > méthode pour créer un `PInvoke` (méthode) et comment ajouter la <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> indicateur pour les indicateurs d’implémentation de méthode après avoir créé le <xref:System.Reflection.Emit.MethodBuilder>, à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> et <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> méthodes.</span><span class="sxs-lookup"><span data-stu-id="18d9c-698">The following code example demonstrates how to use the [\], Type\[\], Type\[\], Type\[\]\[\], Type\[\]\<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="18d9c-699">L’exemple crée un assembly dynamique avec un module dynamique et un type unique, `MyType`, qui contient le `PInvoke` (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-699">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="18d9c-700">Le `PInvoke` méthode représente Win32 `GetTickCount` (fonction).</span><span class="sxs-lookup"><span data-stu-id="18d9c-700">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="18d9c-701">Pour obtenir une valeur de retour différente de zéro, vous devez ajouter le <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> indicateur.</span><span class="sxs-lookup"><span data-stu-id="18d9c-701">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-702">L’exemple utilise une surcharge qui ne spécifie pas de modificateur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="18d9c-702">The example uses an overload that does not specify custom modifiers.</span></span> <span data-ttu-id="18d9c-703">Pour spécifier des modificateurs personnalisés, modifiez l’exemple de code pour utiliser cette surcharge de méthode à la place.</span><span class="sxs-lookup"><span data-stu-id="18d9c-703">To specify custom modifiers, change the example code to use this method overload instead.</span></span>  
  
 <span data-ttu-id="18d9c-704">Lorsque l’exemple est exécuté, il exécute le `PInvoke` (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-704">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="18d9c-705">Elle enregistre également l’assembly dynamique comme PInvokeTest.dll.</span><span class="sxs-lookup"><span data-stu-id="18d9c-705">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="18d9c-706">Vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner le `MyType` classe et le `static` (`Shared` en Visual Basic) `PInvoke` méthode qu’il contient.</span><span class="sxs-lookup"><span data-stu-id="18d9c-706">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="18d9c-707">Vous pouvez compiler un programme Visual Basic ou c# qui utilise la méthode statique `MyType.GetTickCount` méthode en incluant une référence à la DLL lorsque vous exécutez csc.exe ou vbc.exe ; par exemple, `/r:PInvokeTest.dll`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-707">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-708">La méthode n’est pas statique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-708">The method is not static.</span>
          </span>
          <span data-ttu-id="18d9c-709">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-709">-or-</span>
          </span>
          <span data-ttu-id="18d9c-710">Le type parent est une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-710">The parent type is an interface.</span>
          </span>
          <span data-ttu-id="18d9c-711">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-711">-or-</span>
          </span>
          <span data-ttu-id="18d9c-712">La méthode est de type abstract.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-712">The method is abstract.</span>
          </span>
          <span data-ttu-id="18d9c-713">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-713">-or-</span>
          </span>
          <span data-ttu-id="18d9c-714">La méthode a déjà été définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-714">The method was previously defined.</span>
          </span>
          <span data-ttu-id="18d9c-715">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-715">-or-</span>
          </span>
          <span data-ttu-id="18d9c-716">La longueur de <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> est égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-716">The length of <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is zero.</span>
          </span>
          <span data-ttu-id="18d9c-717">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-717">-or-</span>
          </span>
          <span data-ttu-id="18d9c-718">La taille de <paramref name="parameterTypeRequiredCustomModifiers" /> ou <paramref name="parameterTypeOptionalCustomModifiers" /> n’est pas égale à la taille de <paramref name="parameterTypes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-718">The size of <paramref name="parameterTypeRequiredCustomModifiers" /> or <paramref name="parameterTypeOptionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-719">
            <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-719">
              <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-720">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-720">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="18d9c-721">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-721">-or-</span>
          </span>
          <span data-ttu-id="18d9c-722">Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-722">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineProperty">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-723">Ajoute une nouvelle propriété au type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-723">Adds a new property to the type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * Type * Type[] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-724">Nom de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-724">The name of the property.</span>
          </span>
          <span data-ttu-id="18d9c-725">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-725">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-726">Attributs de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-726">The attributes of the property.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="18d9c-727">Type de retour de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-727">The return type of the property.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="18d9c-728">Types des paramètres de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-728">The types of the parameters of the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-729">Ajoute une nouvelle propriété au type avec le nom et la signature de propriété donnés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-729">Adds a new property to the type, with the given name and property signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-730">Propriété définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-730">The defined property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="18d9c-731">L’exemple de code suivant montre comment définir une propriété dynamique et obtenir un <xref:System.Reflection.Emit.PropertyBuilder> pour la spécification.</span><span class="sxs-lookup"><span data-stu-id="18d9c-731">The following code sample demonstrates how to define a dynamic property and obtain a <xref:System.Reflection.Emit.PropertyBuilder> for specification.</span></span> <span data-ttu-id="18d9c-732">Notez qu’un `PropertyBuilder` doit également correspondre un <xref:System.Reflection.Emit.MethodBuilder>, ce qui va héberger la logique de langage intermédiaire pour la propriété.</span><span class="sxs-lookup"><span data-stu-id="18d9c-732">Note that a `PropertyBuilder` must also have a corresponding <xref:System.Reflection.Emit.MethodBuilder>, which will house the IL logic for the property.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-733">La longueur de <paramref name="name" /> est égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-733">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-734">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-734">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="18d9c-735">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-735">-or-</span>
          </span>
          <span data-ttu-id="18d9c-736">Un des éléments du tableau <paramref name="parameterTypes" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-736">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-737">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-737">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-738">Nom de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-738">The name of the property.</span>
          </span>
          <span data-ttu-id="18d9c-739">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-739">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-740">Attributs de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-740">The attributes of the property.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="18d9c-741">Convention d’appel des accesseurs de propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-741">The calling convention of the property accessors.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="18d9c-742">Type de retour de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-742">The return type of the property.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="18d9c-743">Types des paramètres de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-743">The types of the parameters of the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-744">Ajoute une nouvelle propriété au type avec le nom, les attributs, la convention d’appel et la signature de propriété spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-744">Adds a new property to the type, with the given name, attributes, calling convention, and property signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-745">Propriété définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-745">The defined property.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-746">La longueur de <paramref name="name" /> est égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-746">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-747">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-747">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="18d9c-748">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-748">-or-</span>
          </span>
          <span data-ttu-id="18d9c-749">Un des éléments du tableau <paramref name="parameterTypes" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-749">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-750">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-750">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-751">Nom de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-751">The name of the property.</span>
          </span>
          <span data-ttu-id="18d9c-752">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-752">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-753">Attributs de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-753">The attributes of the property.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="18d9c-754">Type de retour de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-754">The return type of the property.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="18d9c-755">Tableau de types représentant les modificateurs personnalisés obligatoires, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-755">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span>
          </span>
          <span data-ttu-id="18d9c-756">Si le type de retour ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-756">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="18d9c-757">Tableau de types représentant les modificateurs personnalisés facultatifs, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-757">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span>
          </span>
          <span data-ttu-id="18d9c-758">Si le type de retour ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-758">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="18d9c-759">Types des paramètres de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-759">The types of the parameters of the property.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="18d9c-760">Tableau de tableaux de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-760">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="18d9c-761">Chaque tableau de types représente les modificateurs personnalisés obligatoires pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-761">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="18d9c-762">Si un paramètre particulier ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" /> plutôt qu’un tableau de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-762">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="18d9c-763">Si aucun paramètre ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-763">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="18d9c-764">Tableau de tableaux de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-764">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="18d9c-765">Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-765">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="18d9c-766">Si un paramètre particulier ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" /> plutôt qu’un tableau de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-766">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="18d9c-767">Si aucun paramètre ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-767">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-768">Ajoute une nouvelle propriété au type, avec le nom, la signature de propriété et les modificateurs personnalisés donnés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-768">Adds a new property to the type, with the given name, property signature, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-769">Propriété définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-769">The defined property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-770">Cette surcharge est fournie pour les concepteurs de compilateurs managés.</span><span class="sxs-lookup"><span data-stu-id="18d9c-770">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-771">Pour plus d’informations sur les modificateurs personnalisés, consultez la documentation de métadonnées ECMA Partition II.</span><span class="sxs-lookup"><span data-stu-id="18d9c-771">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="18d9c-772">La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.</span><span class="sxs-lookup"><span data-stu-id="18d9c-772">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-773">La longueur de <paramref name="name" /> est égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-773">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-774">
            <paramref name="name" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-774">
              <paramref name="name" /> is <see langword="null" /></span>
          </span>
          <span data-ttu-id="18d9c-775">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-775">-or-</span>
          </span>
          <span data-ttu-id="18d9c-776">Un des éléments du tableau <paramref name="parameterTypes" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-776">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" /></span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-777">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-777">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-778">Nom de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-778">The name of the property.</span>
          </span>
          <span data-ttu-id="18d9c-779">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-779">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-780">Attributs de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-780">The attributes of the property.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="18d9c-781">Convention d’appel des accesseurs de propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-781">The calling convention of the property accessors.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="18d9c-782">Type de retour de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-782">The return type of the property.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="18d9c-783">Tableau de types représentant les modificateurs personnalisés obligatoires, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-783">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span>
          </span>
          <span data-ttu-id="18d9c-784">Si le type de retour ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-784">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="18d9c-785">Tableau de types représentant les modificateurs personnalisés facultatifs, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-785">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span>
          </span>
          <span data-ttu-id="18d9c-786">Si le type de retour ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-786">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="18d9c-787">Types des paramètres de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-787">The types of the parameters of the property.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="18d9c-788">Tableau de tableaux de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-788">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="18d9c-789">Chaque tableau de types représente les modificateurs personnalisés obligatoires pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-789">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="18d9c-790">Si un paramètre particulier ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" /> plutôt qu’un tableau de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-790">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="18d9c-791">Si aucun paramètre ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-791">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="18d9c-792">Tableau de tableaux de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-792">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="18d9c-793">Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-793">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="18d9c-794">Si un paramètre particulier ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" /> plutôt qu’un tableau de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-794">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="18d9c-795">Si aucun paramètre ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-795">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-796">Ajoute une nouvelle propriété au type avec le nom, la convention d’appel, la signature de propriété et les modificateurs personnalisés spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-796">Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-797">Propriété définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-797">The defined property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-798">Cette surcharge est fournie pour les concepteurs de compilateurs managés.</span><span class="sxs-lookup"><span data-stu-id="18d9c-798">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-799">Pour plus d’informations sur les modificateurs personnalisés, consultez la documentation de métadonnées ECMA Partition II.</span><span class="sxs-lookup"><span data-stu-id="18d9c-799">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="18d9c-800">La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.</span><span class="sxs-lookup"><span data-stu-id="18d9c-800">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="18d9c-801">Cette surcharge de méthode a été introduite dans le [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="18d9c-801">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-802">La longueur de <paramref name="name" /> est égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-802">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-803">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-803">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="18d9c-804">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-804">-or-</span>
          </span>
          <span data-ttu-id="18d9c-805">Un des éléments du tableau <paramref name="parameterTypes" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-805">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-806">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-806">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineTypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineTypeInitializer () As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineTypeInitializer();" />
      <MemberSignature Language="F#" Value="member this.DefineTypeInitializer : unit -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineTypeInitializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-807">Définit l’initialiseur de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-807">Defines the initializer for this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-808">Retourne un initialiseur de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-808">Returns a type initializer.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-809">L’initialiseur créé est toujours public.</span><span class="sxs-lookup"><span data-stu-id="18d9c-809">The initializer created is always public.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-810">L’exemple de code suivant montre comment créer un constructeur d’initialisation à l’aide `DefineTypeInitializer`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-810">The following code sample demonstrates how to create an initialization constructor using `DefineTypeInitializer`.</span></span>  
  
 [!code-cpp[TypeBuilder_Properties1#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Properties1/CPP/typebuilder_properties.cpp#3)]
 [!code-csharp[TypeBuilder_Properties1#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Properties1/CS/typebuilder_properties.cs#3)]
 [!code-vb[TypeBuilder_Properties1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Properties1/VB/typebuilder_properties.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-811">Le type conteneur a déjà été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-811">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineUninitializedData (name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineUninitializedData(System::String ^ name, int size, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineUninitializedData : string * int * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineUninitializedData (name, size, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-812">Nom utilisé pour faire référence aux données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-812">The name used to refer to the data.</span>
          </span>
          <span data-ttu-id="18d9c-813">
            <c>name</c> ne peut pas contenir de valeurs null incorporées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-813">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="18d9c-814">Taille du champ de données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-814">The size of the data field.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="18d9c-815">Attributs du champ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-815">The attributes for the field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-816">Définit un champ de données non initialisé dans la section <see langword=".sdata" /> du fichier exécutable portable (PE).</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-816">Defines an uninitialized data field in the <see langword=".sdata" /> section of the portable executable (PE) file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-817">Champ pour référencer les données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-817">A field to reference the data.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-818">Le champ que vous créez avec cette méthode sera `static`, même si vous n’incluez pas `FieldAttributes.Static` dans le `attributes` paramètre.</span><span class="sxs-lookup"><span data-stu-id="18d9c-818">The field that you create with this method will be `static`, even if you do not include `FieldAttributes.Static` in the `attributes` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-819">L’exemple de code suivant illustre l’utilisation de `DefineUninitializedData` pour créer un champ de données non initialisé dans un type dynamique :</span><span class="sxs-lookup"><span data-stu-id="18d9c-819">The following code sample demonstrates the use of `DefineUninitializedData` to create an uninitialized data field in a dynamic type:</span></span>  
  
 [!code-cpp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CPP/typebuilder_defineuninitializeddata.cpp#1)]
 [!code-csharp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CS/typebuilder_defineuninitializeddata.cs#1)]
 [!code-vb[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/VB/typebuilder_defineuninitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-820">La longueur de <paramref name="name" /> est égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-820">Length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="18d9c-821">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-821">-or-</span>
          </span>
          <span data-ttu-id="18d9c-822">
            <paramref name="size" /> est inférieur ou égal à zéro, ou supérieur ou égal à 0x003f0000.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-822">
              <paramref name="size" /> is less than or equal to zero, or greater than or equal to 0x003f0000.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-823">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-823">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-824">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-824">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-825">Récupère le chemin complet de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-825">Retrieves the full path of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-826">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-826">Read-only.</span>
          </span>
          <span data-ttu-id="18d9c-827">Récupère le chemin complet de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-827">Retrieves the full path of this type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-828">Le format retourné est « NomCompletTypeEnglobant + NomTypeImbriqué » pour les types imbriqués et « typeName » pour les types non imbriqués.</span><span class="sxs-lookup"><span data-stu-id="18d9c-828">The returned format is "enclosingTypeFullName+nestedTypeName" for nested types and "typeName" for non-nested types.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-829">Obtient une valeur qui indique la covariance et les contraintes spéciales du paramètre de type générique actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-829">Gets a value that indicates the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-830">Combinaison d'opérations de bits de valeurs <see cref="T:System.Reflection.GenericParameterAttributes" /> qui décrit la covariance et les contraintes spéciales du paramètre de type générique actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-830">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-831">Lors de l’émission de code, un paramètre de type générique est représenté par un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objet plutôt que par un <xref:System.Reflection.Emit.TypeBuilder> objet.</span><span class="sxs-lookup"><span data-stu-id="18d9c-831">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public override int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-832">Obtient la position d’un paramètre de type dans la liste des paramètres de type du type générique qui a déclaré le paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-832">Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-833">Si l’objet courant <see cref="T:System.Reflection.Emit.TypeBuilder" /> représente un paramètre de type générique, la position du paramètre de type dans la liste des paramètres de type du type générique qui a déclaré le paramètre ; sinon, non défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-833">If the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-834">Lors de l’émission de code, un paramètre de type générique est représenté par un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objet plutôt que par un <xref:System.Reflection.Emit.TypeBuilder> objet.</span><span class="sxs-lookup"><span data-stu-id="18d9c-834">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="18d9c-835">Si actuel <xref:System.Reflection.Emit.TypeBuilder> ne représente pas un paramètre de type générique, la valeur de cette propriété n’est pas définie.</span><span class="sxs-lookup"><span data-stu-id="18d9c-835">If the current <xref:System.Reflection.Emit.TypeBuilder> does not represent a generic type parameter, the value of this property is undefined.</span></span> <span data-ttu-id="18d9c-836">Utilisez le <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> propriété afin de déterminer si actuel <xref:System.Reflection.Emit.TypeBuilder> représente un paramètre de type générique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-836">Use the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> property to determine whether the current <xref:System.Reflection.Emit.TypeBuilder> represents a generic type parameter.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public override Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public override int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetArrayRank();" />
      <MemberSignature Language="F#" Value="override this.GetArrayRank : unit -&gt; int" Usage="typeBuilder.GetArrayRank " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="override this.GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="typeBuilder.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public static System.Reflection.ConstructorInfo GetConstructor (Type type, System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.ConstructorInfo GetConstructor(class System.Type type, class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::ConstructorInfo ^ GetConstructor(Type ^ type, System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberSignature Language="F#" Value="static member GetConstructor : Type * System.Reflection.ConstructorInfo -&gt; System.Reflection.ConstructorInfo" Usage="System.Reflection.Emit.TypeBuilder.GetConstructor (type, constructor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="18d9c-837">Type générique construit dont le constructeur est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-837">The constructed generic type whose constructor is returned.</span>
          </span>
        </param>
        <param name="constructor">
          <span data-ttu-id="18d9c-838">Constructeur sur la définition de type générique de <c>type</c>, qui spécifie le constructeur de <c>type</c> à retourner.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-838">A constructor on the generic type definition of <c>type</c>, which specifies which constructor of <c>type</c> to return.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-839">Retourne le constructeur du type générique construit spécifié qui correspond au constructeur spécifié de la définition de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-839">Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-840">Objet <see cref="T:System.Reflection.ConstructorInfo" /> qui représente le constructeur de <paramref name="type" /> correspondant à <paramref name="constructor" />, qui spécifie un constructeur appartenant à la définition de type générique de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-840">A <see cref="T:System.Reflection.ConstructorInfo" /> object that represents the constructor of <paramref name="type" /> corresponding to <paramref name="constructor" />, which specifies a constructor belonging to the generic type definition of <paramref name="type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-841">Le <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> méthode fournit un moyen pour obtenir un <xref:System.Reflection.ConstructorInfo> objet qui représente un constructeur d’un type générique construit dont la définition de type générique est représentée par un <xref:System.Reflection.Emit.TypeBuilder> objet.</span><span class="sxs-lookup"><span data-stu-id="18d9c-841">The <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method provides a way to get a <xref:System.Reflection.ConstructorInfo> object that represents a constructor of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="18d9c-842">Par exemple, supposons que vous ayez un <xref:System.Reflection.Emit.TypeBuilder> objet qui représente le type `G<T>` en syntaxe c# (`G(Of T)` en Visual Basic, `generic <T> ref class G` en C++) et un <xref:System.Reflection.Emit.ConstructorBuilder> objet qui représente un constructeur de `G<T>`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-842">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.ConstructorBuilder> object that represents a constructor of `G<T>`.</span></span> <span data-ttu-id="18d9c-843">Supposons que `G<T>` a une méthode générique avec un paramètre de type `U` qui crée une instance du type construit `G<U>`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-843">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>`.</span></span> <span data-ttu-id="18d9c-844">Pour émettre le code pour créer une instance du type construit, vous avez besoin une <xref:System.Reflection.ConstructorInfo> construire l’objet qui représente le constructeur de ce type, en d’autres termes, qui crée une instance de `G<U>`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-844">In order to emit the code to create an instance of the constructed type, you need a <xref:System.Reflection.ConstructorInfo> object that represents the constructor of this constructed type — in other words, that creates an instance of `G<U>`.</span></span> <span data-ttu-id="18d9c-845">Pour ce faire, appelez d’abord la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode sur le <xref:System.Reflection.Emit.TypeBuilder> de l’objet, en spécifiant le <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objet qui représente `U` comme argument de type.</span><span class="sxs-lookup"><span data-stu-id="18d9c-845">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="18d9c-846">Appelez ensuite la <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> méthode avec la valeur de retour de la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode en tant que paramètre `type` et le <xref:System.Reflection.Emit.ConstructorBuilder> objet qui représente le constructeur de `G<U>` en tant que paramètre `constructor`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-846">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.ConstructorBuilder> object that represents the constructor of `G<U>` as parameter `constructor`.</span></span> <span data-ttu-id="18d9c-847">La valeur de retour est le <xref:System.Reflection.ConstructorInfo> vous avez besoin émettre l’appel de fonction de l’objet.</span><span class="sxs-lookup"><span data-stu-id="18d9c-847">The return value is the <xref:System.Reflection.ConstructorInfo> object you need to emit the function call.</span></span> <span data-ttu-id="18d9c-848">L’exemple de code illustre ce scénario.</span><span class="sxs-lookup"><span data-stu-id="18d9c-848">The code example demonstrates this scenario.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-849">L’exemple de code suivant contient le code source pour une classe générique nommée `Sample` qui a un paramètre de type nommé `T`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-849">The following code example contains source code for a generic class named `Sample` that has a type parameter named `T`.</span></span> <span data-ttu-id="18d9c-850">La classe possède un champ nommé `Field`, de type `T`et une méthode générique nommée `GM` avec son propre paramètre de type nommé `U`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-850">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="18d9c-851">Méthode `GM` crée une instance de `Sample`, en remplaçant son propre paramètre de type `U` pour le paramètre de type de `Sample`et stocke son paramètre d’entrée dans `Field`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-851">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="18d9c-852">Ce code source est compilé mais pas utilisé ; Vous pouvez l’afficher avec le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) et la comparer au code émis par la classe `Example`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-852">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="18d9c-853">Le code de classe `Example` illustre l’utilisation de la <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> méthode d’émettre du code générique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-853">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method to emit generic code.</span></span> <span data-ttu-id="18d9c-854">Le `Main` méthode de classe `Example` crée un assembly dynamique qui contient une classe nommée `Sample` et utilise le <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> méthode pour le rendre générique en ajoutant un paramètre de type nommé `T`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-854">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample` and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="18d9c-855">Un constructeur par défaut et un champ nommé `Field`, de type `T`, sont ajoutés à la classe `Sample`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-855">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="18d9c-856">Une méthode `GM` est ajoutée et transformée en une méthode générique à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-856">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="18d9c-857">Le paramètre de type `GM` est nommé `U`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-857">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="18d9c-858">Une fois que le paramètre de type est défini, la signature de `GM` est ajouté à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-858">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="18d9c-859">Il y a aucun type de retour et non nécessaires ou de modificateurs personnalisés, par conséquent, tous les paramètres de cette méthode sont `null` sauf `parameterTypes`; `parameterTypes` définit le type de seul paramètre la méthode `U`, paramètre de type générique de la méthode.</span><span class="sxs-lookup"><span data-stu-id="18d9c-859">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="18d9c-860">Le corps de la méthode crée une instance du type construit `Sample<U>` (`Sample(Of U)` en Visual Basic), affecte le paramètre de la méthode `Field`, puis imprime la valeur de `Field`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-860">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="18d9c-861">Le <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> méthode est utilisée pour créer un <xref:System.Reflection.ConstructorInfo> qui représente le constructeur par défaut du type générique construit `Sample<U>` dans le <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> instruction qui crée l’instance.</span><span class="sxs-lookup"><span data-stu-id="18d9c-861">The <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method is used to create a <xref:System.Reflection.ConstructorInfo> that represents the default constructor of the constructed generic type `Sample<U>` in the <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> instruction that creates the instance.</span></span>  
  
 <span data-ttu-id="18d9c-862">Un type factice est défini pour contenir la méthode de point d’entrée `Main`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-862">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="18d9c-863">Dans le corps de `Main`, statiques `GM` méthode est appelée sur le type générique construit `Sample<int>` (`Sample(Of Integer)` en Visual Basic), avec le type <xref:System.String> remplacé par `U`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-863">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span>  
  
 <span data-ttu-id="18d9c-864">Lorsque l’exemple de code est exécuté, il enregistre l’assembly émis en tant que TypeBuilderGetFieldExample.exe.</span><span class="sxs-lookup"><span data-stu-id="18d9c-864">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="18d9c-865">Vous pouvez exécuter TypeBuilderGetFieldExample.exe, et vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour comparer le code émis avec le code pour le `Sample` classe qui est compilé dans l’exemple de code lui-même.</span><span class="sxs-lookup"><span data-stu-id="18d9c-865">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-866">
            <paramref name="type" /> ne représente pas un type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-866">
              <paramref name="type" /> does not represent a generic type.</span>
          </span>
          <span data-ttu-id="18d9c-867">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-867">-or-</span>
          </span>
          <span data-ttu-id="18d9c-868">
            <paramref name="type" /> n'est pas de type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-868">
              <paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
          <span data-ttu-id="18d9c-869">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-869">-or-</span>
          </span>
          <span data-ttu-id="18d9c-870">Le type déclarant de <paramref name="constructor" /> n’est pas une définition de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-870">The declaring type of <paramref name="constructor" /> is not a generic type definition.</span>
          </span>
          <span data-ttu-id="18d9c-871">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-871">-or-</span>
          </span>
          <span data-ttu-id="18d9c-872">Le type déclarant de <paramref name="constructor" /> n’est pas la définition de type générique de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-872">The declaring type of <paramref name="constructor" /> is not the generic type definition of <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="typeBuilder.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="typeBuilder.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="18d9c-873">Il doit s'agir d'un bit indicateur de <see cref="T:System.Reflection.BindingFlags" />, comme dans <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-873">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-874">Retourne un tableau d'objets <see cref="T:System.Reflection.ConstructorInfo" /> représentant les constructeurs publics et non publics définis pour cette classe, comme spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-874">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing the public and non-public constructors defined for this class, as specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-875">Retourne un tableau d'objets <see cref="T:System.Reflection.ConstructorInfo" /> représentant les constructeurs spécifiés définis pour cette classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-875">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing the specified constructors defined for this class.</span>
          </span>
          <span data-ttu-id="18d9c-876">Si aucun constructeur n’est défini, un tableau vide est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-876">If no constructors are defined, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-877">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-877">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-878">Cette méthode n’est pas implémentée pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-878">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-879">Retourne les attributs personnalisés définis pour ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-879">Returns the custom attributes defined for this type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="typeBuilder.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <span data-ttu-id="18d9c-880">Spécifie s’il faut rechercher les attributs dans la chaîne d’héritage de ce membre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-880">Specifies whether to search this member's inheritance chain to find the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-881">Retourne tous les attributs personnalisés définis pour ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-881">Returns all the custom attributes defined for this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-882">Retourne un tableau d’objets représentant tous les attributs personnalisés de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-882">Returns an array of objects representing all the custom attributes of this type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-883">Cette méthode n’est pas prise en charge actuellement pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-883">This method is not currently supported for incomplete types.</span>
          </span>
          <span data-ttu-id="18d9c-884">Vous pouvez récupérer le type à l'aide de <see cref="M:System.Type.GetType" />, puis appeler <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> sur le <see cref="T:System.Type" /> retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-884">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="typeBuilder.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="18d9c-885">Type d’attribut à rechercher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-885">The type of attribute to search for.</span>
          </span>
          <span data-ttu-id="18d9c-886">Seuls les attributs qui peuvent être assignés à ce type sont retournés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-886">Only attributes that are assignable to this type are returned.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="18d9c-887">Spécifie s’il faut rechercher les attributs dans la chaîne d’héritage de ce membre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-887">Specifies whether to search this member's inheritance chain to find the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-888">Retourne tous les attributs personnalisés du type actuel qui peuvent être assignés à un type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-888">Returns all the custom attributes of the current type that are assignable to a specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-889">Tableau d’attributs personnalisés définis sur le type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-889">An array of custom attributes defined on the current type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-890">Cette méthode n’est pas prise en charge actuellement pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-890">This method is not currently supported for incomplete types.</span>
          </span>
          <span data-ttu-id="18d9c-891">Vous pouvez récupérer le type à l'aide de <see cref="M:System.Type.GetType" />, puis appeler <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> sur le <see cref="T:System.Type" /> retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-891">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-892">
            <paramref name="attributeType" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-892">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-893">Le type doit être un type fourni par le système runtime sous-jacent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-893">The type must be a type provided by the underlying runtime system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="override this.GetElementType : unit -&gt; Type" Usage="typeBuilder.GetElementType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-894">L'appel de cette méthode lève toujours <see cref="T:System.NotSupportedException" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-894">Calling this method always throws <see cref="T:System.NotSupportedException" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-895">Cette méthode n'est pas prise en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-895">This method is not supported.</span>
          </span>
          <span data-ttu-id="18d9c-896">Aucune valeur n'est retournée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-896">No value is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-897">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-897">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-898">Cette méthode n'est pas prise en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-898">This method is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="typeBuilder.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-899">Nom de l’événement à rechercher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-899">The name of the event to search for.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="18d9c-900">Combinaison d'opérations de bits de valeurs <see cref="T:System.Reflection.BindingFlags" /> qui limite la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-900">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limits the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-901">Retourne l’événement avec le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-901">Returns the event with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-902">Objet <see cref="T:System.Reflection.EventInfo" /> représentant l'événement déclaré ou hérité par ce type avec le nom spécifié, ou <see langword="null" /> s'il n'existe aucune correspondance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-902">An <see cref="T:System.Reflection.EventInfo" /> object representing the event declared or inherited by this type with the specified name, or <see langword="null" /> if there are no matches.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-903">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-903">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-904">Cette méthode n’est pas implémentée pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-904">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-905">Retourne les événements définis par le <see cref="T:System.Reflection.Emit.TypeBuilder" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-905">Returns the events defined by the current <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="typeBuilder.GetEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-906">Retourne les événements publics déclarés ou hérités par ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-906">Returns the public events declared or inherited by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-907">Retourne un tableau d'objets <see cref="T:System.Reflection.EventInfo" /> représentant les événements publics déclarés ou hérités par ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-907">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing the public events declared or inherited by this type.</span>
          </span>
          <span data-ttu-id="18d9c-908">Un tableau vide est retourné s’il n’existe aucun événement public.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-908">An empty array is returned if there are no public events.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-909">Récupérer le type à l’aide <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetType%2A> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-909">Retrieve the type using <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetType%2A> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-910">Cette méthode n’est pas implémentée pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-910">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="typeBuilder.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="18d9c-911">Combinaison d'opérations de bits de valeurs <see cref="T:System.Reflection.BindingFlags" /> qui limite la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-911">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limits the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-912">Retourne les événements publics et non publics déclarés par ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-912">Returns the public and non-public events that are declared by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-913">Retourne un tableau d'objets <see cref="T:System.Reflection.EventInfo" /> représentant les événements déclarés ou hérités par ce type qui correspondent aux indicateurs de liaisons spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-913">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing the events declared or inherited by this type that match the specified binding flags.</span>
          </span>
          <span data-ttu-id="18d9c-914">Un tableau vide est retourné s’il n’existe aucun événement correspondant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-914">An empty array is returned if there are no matching events.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-915">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-915">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-916">Cette méthode n’est pas implémentée pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-916">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-917">Retourne un champ défini par le <see cref="T:System.Reflection.Emit.TypeBuilder" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-917">Returns a field defined by the current <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="typeBuilder.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-918">Nom du champ à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-918">The name of the field to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="18d9c-919">Il doit s'agir d'un bit indicateur de <see cref="T:System.Reflection.BindingFlags" />, comme dans <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-919">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-920">Retourne le champ spécifié par le nom donné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-920">Returns the field specified by the given name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-921">Retourne l'objet <see cref="T:System.Reflection.FieldInfo" /> représentant le champ déclaré ou hérité par ce type, avec le nom et le modificateur public ou non public spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-921">Returns the <see cref="T:System.Reflection.FieldInfo" /> object representing the field declared or inherited by this type with the specified name and public or non-public modifier.</span>
          </span>
          <span data-ttu-id="18d9c-922">En l'absence de correspondances, <see langword="null" /> est retournée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-922">If there are no matches then <see langword="null" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-923">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-923">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-924">Cette méthode n’est pas implémentée pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-924">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetField (Type type, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetField(class System.Type type, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetField(Type ^ type, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="static member GetField : Type * System.Reflection.FieldInfo -&gt; System.Reflection.FieldInfo" Usage="System.Reflection.Emit.TypeBuilder.GetField (type, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="18d9c-925">Type générique construit dont la méthode est retournée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-925">The constructed generic type whose field is returned.</span>
          </span>
        </param>
        <param name="field">
          <span data-ttu-id="18d9c-926">Champ sur la définition de type générique de <c>type</c>, qui spécifie le champ de <c>type</c> à retourner.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-926">A field on the generic type definition of <c>type</c>, which specifies which field of <c>type</c> to return.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-927">Retourne le champ du type générique construit spécifié qui correspond au champ spécifié de la définition de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-927">Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-928">Objet <see cref="T:System.Reflection.FieldInfo" /> qui représente le champ de <paramref name="type" /> correspondant à <paramref name="field" />, qui spécifie un champ appartenant à la définition de type générique de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-928">A <see cref="T:System.Reflection.FieldInfo" /> object that represents the field of <paramref name="type" /> corresponding to <paramref name="field" />, which specifies a field belonging to the generic type definition of <paramref name="type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-929">Le <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> méthode fournit un moyen pour obtenir un <xref:System.Reflection.FieldInfo> objet qui représente un champ d’un type générique construit dont la définition de type générique est représentée par un <xref:System.Reflection.Emit.TypeBuilder> objet.</span><span class="sxs-lookup"><span data-stu-id="18d9c-929">The <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method provides a way to get a <xref:System.Reflection.FieldInfo> object that represents a field of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="18d9c-930">Par exemple, supposons que vous ayez un <xref:System.Reflection.Emit.TypeBuilder> objet qui représente le type `G<T>` en syntaxe c# (`G(Of T)` en Visual Basic, `generic <T> ref class G` en C++) et un <xref:System.Reflection.Emit.FieldBuilder> objet qui représente un champ `public T F` en syntaxe c# (`Public F As T`en Visual Basic, `public: T F` en C++) qui est défini par `G<T>`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-930">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.FieldBuilder> object that represents a field `public T F` in C# syntax (`Public F As T` in Visual Basic, `public: T F` in C++) that is defined by `G<T>`.</span></span> <span data-ttu-id="18d9c-931">Supposons que `G<T>` a une méthode générique avec un paramètre de type `U` qui crée une instance du type construit `G<U>` et appelle le champ `F` sur cette instance.</span><span class="sxs-lookup"><span data-stu-id="18d9c-931">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>` and calls field `F` on that instance.</span></span> <span data-ttu-id="18d9c-932">Pour émettre l’appel de fonction, vous devez un <xref:System.Reflection.FieldInfo> objet qui représente `F` sur le type construit — en d’autres termes, qui est de type `U` au lieu de taper `T`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-932">In order to emit the function call, you need a <xref:System.Reflection.FieldInfo> object that represents `F` on the constructed type — in other words, that is of type `U` rather than type `T`.</span></span> <span data-ttu-id="18d9c-933">Pour ce faire, appelez d’abord la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode sur le <xref:System.Reflection.Emit.TypeBuilder> de l’objet, en spécifiant le <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objet qui représente `U` comme argument de type.</span><span class="sxs-lookup"><span data-stu-id="18d9c-933">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="18d9c-934">Appelez ensuite la <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> méthode avec la valeur de retour de la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode en tant que paramètre `type` et le <xref:System.Reflection.Emit.FieldBuilder> objet qui représente `F` en tant que paramètre `field`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-934">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.FieldBuilder> object that represents `F` as parameter `field`.</span></span> <span data-ttu-id="18d9c-935">La valeur de retour est le <xref:System.Reflection.FieldInfo> vous avez besoin émettre l’appel de fonction de l’objet.</span><span class="sxs-lookup"><span data-stu-id="18d9c-935">The return value is the <xref:System.Reflection.FieldInfo> object you need to emit the function call.</span></span> <span data-ttu-id="18d9c-936">L’exemple de code illustre ce scénario.</span><span class="sxs-lookup"><span data-stu-id="18d9c-936">The code example demonstrates this scenario.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-937">L’exemple de code suivant contient le code source pour une classe générique nommée Sample qui possède un paramètre de type nommé `T`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-937">The following code example contains source code for a generic class named Sample that has a type parameter named `T`.</span></span> <span data-ttu-id="18d9c-938">La classe possède un champ nommé `Field`, de type `T`et une méthode générique nommée `GM` avec son propre paramètre de type nommé `U`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-938">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="18d9c-939">Méthode `GM` crée une instance de `Sample`, en remplaçant son propre paramètre de type `U` pour le paramètre de type de `Sample`et stocke son paramètre d’entrée dans `Field`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-939">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="18d9c-940">Ce code source est compilé mais pas utilisé ; Vous pouvez l’afficher avec le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) et la comparer au code émis par la classe `Example`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-940">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="18d9c-941">Le code de classe `Example` illustre l’utilisation de la <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> méthode d’émettre du code générique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-941">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method to emit generic code.</span></span> <span data-ttu-id="18d9c-942">Le `Main` méthode de classe `Example` crée un assembly dynamique qui contient une classe nommée `Sample`et utilise le <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> méthode pour le rendre générique en ajoutant un paramètre de type nommé `T`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-942">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample`, and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="18d9c-943">Un constructeur par défaut et un champ nommé `Field`, de type `T`, sont ajoutés à la classe `Sample`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-943">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="18d9c-944">Une méthode `GM` est ajoutée et transformée en une méthode générique à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-944">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="18d9c-945">Le paramètre de type `GM` est nommé `U`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-945">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="18d9c-946">Une fois que le paramètre de type est défini, la signature de `GM` est ajouté à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-946">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="18d9c-947">Il y a aucun type de retour et non nécessaires ou de modificateurs personnalisés, par conséquent, tous les paramètres de cette méthode sont `null` sauf `parameterTypes`; `parameterTypes` définit le type de seul paramètre la méthode `U`, paramètre de type générique de la méthode.</span><span class="sxs-lookup"><span data-stu-id="18d9c-947">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="18d9c-948">Le corps de la méthode crée une instance du type construit `Sample<U>` (`Sample(Of U)` en Visual Basic), affecte le paramètre de la méthode `Field`, puis imprime la valeur de `Field`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-948">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="18d9c-949">Le <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> méthode est utilisée pour créer un <xref:System.Reflection.FieldInfo> qui représente le champ du type générique construit `Sample<U>` dans le <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> et <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> obtenir des instructions.</span><span class="sxs-lookup"><span data-stu-id="18d9c-949">The <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method is used to create a <xref:System.Reflection.FieldInfo> that represents the field of the constructed generic type `Sample<U>` in the <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> and <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> instructions.</span></span>  
  
 <span data-ttu-id="18d9c-950">Un type factice est défini pour contenir la méthode de point d’entrée `Main`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-950">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="18d9c-951">Dans le corps de `Main`, statiques `GM` méthode est appelée sur le type générique construit `Sample<int>` (`Sample(Of Integer)` en Visual Basic), avec le type <xref:System.String> remplacé par `U`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-951">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span>  
  
 <span data-ttu-id="18d9c-952">Lorsque l’exemple de code est exécuté, il enregistre l’assembly émis en tant que TypeBuilderGetFieldExample.exe.</span><span class="sxs-lookup"><span data-stu-id="18d9c-952">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="18d9c-953">Vous pouvez exécuter TypeBuilderGetFieldExample.exe, et vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour comparer le code émis avec le code pour le `Sample` classe qui est compilé dans l’exemple de code lui-même.</span><span class="sxs-lookup"><span data-stu-id="18d9c-953">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-954">
            <paramref name="type" /> ne représente pas un type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-954">
              <paramref name="type" /> does not represent a generic type.</span>
          </span>
          <span data-ttu-id="18d9c-955">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-955">-or-</span>
          </span>
          <span data-ttu-id="18d9c-956">
            <paramref name="type" /> n'est pas de type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-956">
              <paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
          <span data-ttu-id="18d9c-957">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-957">-or-</span>
          </span>
          <span data-ttu-id="18d9c-958">Le type déclarant de <paramref name="field" /> n’est pas une définition de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-958">The declaring type of <paramref name="field" /> is not a generic type definition.</span>
          </span>
          <span data-ttu-id="18d9c-959">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-959">-or-</span>
          </span>
          <span data-ttu-id="18d9c-960">Le type déclarant de <paramref name="field" /> n’est pas la définition de type générique de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-960">The declaring type of <paramref name="field" /> is not the generic type definition of <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="typeBuilder.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="18d9c-961">Il doit s'agir d'un bit indicateur de <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-961">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-962">Retourne les champs publics et non publics déclarés par ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-962">Returns the public and non-public fields that are declared by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-963">Retourne un tableau d'objets <see cref="T:System.Reflection.FieldInfo" /> représentant les champs publics et non publics déclarés ou hérités par ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-963">Returns an array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the public and non-public fields declared or inherited by this type.</span>
          </span>
          <span data-ttu-id="18d9c-964">Un tableau vide est retourné s’il n’existe aucun champ, comme indiqué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-964">An empty array is returned if there are no fields, as specified.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-965">Le <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> méthode ne retourne pas les champs dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="18d9c-965">The <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="18d9c-966">Votre code ne doit pas dépendent de l’ordre dans lequel les champs sont retournés, car cet ordre peut varier.</span><span class="sxs-lookup"><span data-stu-id="18d9c-966">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 <span data-ttu-id="18d9c-967">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-967">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-968">Cette méthode n’est pas implémentée pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-968">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="override this.GetGenericArguments : unit -&gt; Type[]" Usage="typeBuilder.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-969">Retourne un tableau d'objets <see cref="T:System.Type" /> qui représentent les arguments de type d'un type générique ou les paramètres de type d'une définition de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-969">Returns an array of <see cref="T:System.Type" /> objects representing the type arguments of a generic type or the type parameters of a generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-970">Tableau d'objets <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-970">An array of <see cref="T:System.Type" /> objects.</span>
          </span>
          <span data-ttu-id="18d9c-971">Les éléments du tableau représentent les arguments de type d’un type générique ou les paramètres de type d’une définition de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-971">The elements of the array represent the type arguments of a generic type or the type parameters of a generic type definition.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-972">Les éléments du tableau retourné sont dans l’ordre dans lequel ils apparaissent dans la liste des paramètres de type pour la définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-972">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic type definition.</span></span>  
  
 <span data-ttu-id="18d9c-973">Un <xref:System.Reflection.Emit.TypeBuilder> objet représente une définition de type générique si le <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> méthode a été utilisée afin de lui donner des paramètres de type générique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-973">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="18d9c-974">Cette méthode récupère le <xref:System.Reflection.Emit.GenericTypeParameterBuilder> les objets qui représentent les paramètres de type générique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-974">This method retrieves the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objects that represent the generic type parameters.</span></span>  
  
 <span data-ttu-id="18d9c-975">Pour plus d’informations sur les types génériques dans la réflexion et une liste des conditions invariables des termes utilisés dans la réflexion générique, consultez le <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="18d9c-975">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericArguments" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="typeBuilder.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="typeBuilder.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-976">Retourne un objet <see cref="T:System.Type" /> qui représente une définition de type générique à partir de laquelle le type actuel peut être obtenu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-976">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current type can be obtained.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-977">Objet <see cref="T:System.Type" /> qui représente une définition de type générique à partir de laquelle le type actuel peut être obtenu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-977">A <see cref="T:System.Type" /> object representing a generic type definition from which the current type can be obtained.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-978">Si vous appelez le <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> méthode sur un <xref:System.Reflection.Emit.TypeBuilder> objet pour lequel le <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> retourne de la propriété `true`, le <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> propriété retourne l’instance actuelle.</span><span class="sxs-lookup"><span data-stu-id="18d9c-978">If you call the <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> object for which the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> property returns `true`, the <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> property returns the current instance.</span></span> <span data-ttu-id="18d9c-979">A <xref:System.Reflection.Emit.TypeBuilder> que représente un type générique est toujours une définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-979">A <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type is always a generic type definition.</span></span>  
  
 <span data-ttu-id="18d9c-980">Si vous avez utilisé le <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode pour construire un type générique à partir d’un <xref:System.Reflection.Emit.TypeBuilder> objet qui représente une définition de type générique, à l’aide de la <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> méthode sur le type construit reçoit en retour le <xref:System.Reflection.Emit.TypeBuilder> objet qui représente le type générique définition.</span><span class="sxs-lookup"><span data-stu-id="18d9c-980">If you used the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method to construct a generic type from a <xref:System.Reflection.Emit.TypeBuilder> object that represents a generic type definition, using the <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> method on the constructed type gets back the <xref:System.Reflection.Emit.TypeBuilder> object that represents the generic type definition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-981">Le type actuel n’est pas générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-981">The current type is not generic.</span>
          </span>
          <span data-ttu-id="18d9c-982">Autrement dit, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> retourne <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-982">That is, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetInterface : string * bool -&gt; Type" Usage="typeBuilder.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-983">Nom de l’interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-983">The name of the interface.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="18d9c-984">Si <see langword="true" />, la recherche ne respecte pas la casse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-984">If <see langword="true" />, the search is case-insensitive.</span>
          </span>
          <span data-ttu-id="18d9c-985">Si <see langword="false" />, la recherche respecte la casse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-985">If <see langword="false" />, the search is case-sensitive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-986">Retourne l’interface implémentée (directement ou indirectement) par cette classe avec le nom qualifié complet correspondant au nom de l’interface donnée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-986">Returns the interface implemented (directly or indirectly) by this class with the fully qualified name matching the given interface name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-987">Retourne un objet <see cref="T:System.Type" /> représentant l'interface implémentée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-987">Returns a <see cref="T:System.Type" /> object representing the implemented interface.</span>
          </span>
          <span data-ttu-id="18d9c-988">Retourne null si aucun nom d’interface correspondant n’est trouvé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-988">Returns null if no interface matching name is found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-989">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-989">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-990">Cette méthode n’est pas implémentée pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-990">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="typeBuilder.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <span data-ttu-id="18d9c-991">
            <see cref="T:System.Type" /> de l'interface dont le mappage doit être récupéré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-991">The <see cref="T:System.Type" /> of the interface for which the mapping is to be retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-992">Retourne un mappage d’interface pour l’interface demandée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-992">Returns an interface mapping for the requested interface.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-993">Retourne le mappage d’interface demandé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-993">Returns the requested interface mapping.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-994">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-994">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-995">Cette méthode n’est pas implémentée pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-995">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="override this.GetInterfaces : unit -&gt; Type[]" Usage="typeBuilder.GetInterfaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-996">Retourne un tableau de toutes les interfaces implémentées sur ce type et ses types de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-996">Returns an array of all the interfaces implemented on this type and its base types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-997">Retourne un tableau d'objets <see cref="T:System.Type" /> représentant les interfaces implémentées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-997">Returns an array of <see cref="T:System.Type" /> objects representing the implemented interfaces.</span>
          </span>
          <span data-ttu-id="18d9c-998">Si aucune interface n’est définie, un tableau vide est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-998">If none are defined, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="typeBuilder.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-999">Nom du membre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-999">The name of the member.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="18d9c-1000">Type du membre à retourner.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1000">The type of the member to return.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="18d9c-1001">Il doit s'agir d'un bit indicateur de <see cref="T:System.Reflection.BindingFlags" />, comme dans <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1001">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1002">Retourne tous les membres publics et non publics déclarés ou hérités par ce type, comme indiqué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1002">Returns all the public and non-public members declared or inherited by this type, as specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1003">Retourne un tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant les membres publics et non publics définis sur ce type si <paramref name="nonPublic" /> est utilisé ; sinon, seuls les membres publics sont retournés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1003">Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public and non-public members defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public members are returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1004">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1004">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-1005">Cette méthode n’est pas implémentée pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1005">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="typeBuilder.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="18d9c-1006">Il doit s'agir d'un indicateur binaire de <see cref="T:System.Reflection.BindingFlags" />, tel que <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1006">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, such as <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1007">Retourne les membres publics et non publics déclarés ou hérités par ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1007">Returns the members for the public and non-public members declared or inherited by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1008">Retourne un tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant les membres publics et non publics déclarés ou hérités par ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1008">Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public and non-public members declared or inherited by this type.</span>
          </span>
          <span data-ttu-id="18d9c-1009">Un tableau vide est retourné s’il n’existe aucun membre correspondant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1009">An empty array is returned if there are no matching members.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1010">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1010">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-1011">Cette méthode n’est pas implémentée pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1011">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodInfo GetMethod (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodInfo GetMethod(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodInfo ^ GetMethod(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GetMethod : Type * System.Reflection.MethodInfo -&gt; System.Reflection.MethodInfo" Usage="System.Reflection.Emit.TypeBuilder.GetMethod (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="18d9c-1012">Type générique construit dont la méthode est retournée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1012">The constructed generic type whose method is returned.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="18d9c-1013">Méthode sur la définition de type générique de <c>type</c>, qui spécifie la méthode de <c>type</c> à retourner.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1013">A method on the generic type definition of <c>type</c>, which specifies which method of <c>type</c> to return.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1014">Retourne la méthode du type générique construit spécifié qui correspond à la méthode spécifiée de la définition de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1014">Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1015">Objet <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode de <paramref name="type" /> correspondant à <paramref name="method" />, qui spécifie une méthode appartenant à la définition de type générique de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1015">A <see cref="T:System.Reflection.MethodInfo" /> object that represents the method of <paramref name="type" /> corresponding to <paramref name="method" />, which specifies a method belonging to the generic type definition of <paramref name="type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1016">Le <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> méthode fournit un moyen pour obtenir un <xref:System.Reflection.MethodInfo> objet qui représente une méthode d’un type générique construit dont la définition de type générique est représentée par un <xref:System.Reflection.Emit.TypeBuilder> objet.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1016">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method provides a way to get a <xref:System.Reflection.MethodInfo> object that represents a method of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="18d9c-1017">Par exemple, supposons que vous ayez un <xref:System.Reflection.Emit.TypeBuilder> objet qui représente le type `G<T>` en syntaxe c# (`G(Of T)` en Visual Basic, `generic <T> ref class G` en C++) et un <xref:System.Reflection.Emit.MethodBuilder> objet qui représente une méthode `T M()` en syntaxe c# (`Function M() As T`en Visual Basic, `T M()` en C++) qui est défini par `G<T>`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1017">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.MethodBuilder> object that represents a method `T M()` in C# syntax (`Function M() As T` in Visual Basic, `T M()` in C++) that is defined by `G<T>`.</span></span> <span data-ttu-id="18d9c-1018">Supposons que `G<T>` a une méthode générique avec un paramètre de type `U` qui crée une instance du type construit `G<U>` et appelle la méthode `M` sur cette instance.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1018">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>` and calls method `M` on that instance.</span></span> <span data-ttu-id="18d9c-1019">Pour émettre l’appel de fonction, vous devez un <xref:System.Reflection.MethodInfo> objet qui représente `M` sur le type construit — en d’autres termes, qui retourne le type `U` au lieu de taper `T`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1019">In order to emit the function call, you need a <xref:System.Reflection.MethodInfo> object that represents `M` on the constructed type — in other words, that returns type `U` rather than type `T`.</span></span> <span data-ttu-id="18d9c-1020">Pour ce faire, appelez d’abord la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode sur le <xref:System.Reflection.Emit.TypeBuilder> de l’objet, en spécifiant le <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objet qui représente `U` comme argument de type.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1020">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="18d9c-1021">Appelez ensuite la <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> méthode avec la valeur de retour de la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode en tant que paramètre `type` et le <xref:System.Reflection.Emit.MethodBuilder> objet qui représente `T M()` en tant que paramètre `method`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1021">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.MethodBuilder> object that represents `T M()` as parameter `method`.</span></span> <span data-ttu-id="18d9c-1022">La valeur de retour est le <xref:System.Reflection.MethodInfo> vous avez besoin émettre l’appel de fonction de l’objet.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1022">The return value is the <xref:System.Reflection.MethodInfo> object you need to emit the function call.</span></span> <span data-ttu-id="18d9c-1023">L’exemple de code illustre un scénario semblable à celle-ci.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1023">The code example demonstrates a scenario similar to this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-1024">L’exemple de code suivant contient le code source pour une classe générique nommée `Sample` qui a un paramètre de type nommé `T`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1024">The following code example contains source code for a generic class named `Sample` that has a type parameter named `T`.</span></span> <span data-ttu-id="18d9c-1025">La classe possède un champ nommé `Field`, de type `T`et une méthode générique nommée `GM` avec son propre paramètre de type nommé `U`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1025">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="18d9c-1026">Méthode `GM` crée une instance de `Sample`, en remplaçant son propre paramètre de type `U` pour le paramètre de type de `Sample`et stocke son paramètre d’entrée dans `Field`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1026">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="18d9c-1027">Ce code source est compilé mais pas utilisé ; Vous pouvez l’afficher avec le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) et la comparer au code émis par la classe `Example`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1027">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="18d9c-1028">Le code de classe `Example` illustre l’utilisation de la <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> méthode d’émettre du code générique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1028">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method to emit generic code.</span></span> <span data-ttu-id="18d9c-1029">Le `Main` méthode de classe `Example` crée un assembly dynamique qui contient une classe nommée `Sample` et utilise le <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> méthode pour le rendre générique en ajoutant un paramètre de type nommé `T`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1029">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample` and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="18d9c-1030">Un constructeur par défaut et un champ nommé `Field`, de type `T`, sont ajoutés à la classe `Sample`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1030">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="18d9c-1031">Une méthode `GM` est ajoutée et transformée en une méthode générique à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1031">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="18d9c-1032">Le paramètre de type `GM` est nommé `U`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1032">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="18d9c-1033">Une fois que le paramètre de type est défini, la signature de `GM` est ajouté à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1033">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="18d9c-1034">Il y a aucun type de retour et non nécessaires ou de modificateurs personnalisés, par conséquent, tous les paramètres de cette méthode sont `null` sauf `parameterTypes`; `parameterTypes` définit le type de seul paramètre la méthode `U`, paramètre de type générique de la méthode.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1034">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="18d9c-1035">Le corps de la méthode crée une instance du type construit `Sample<U>` (`Sample(Of U)` en Visual Basic), affecte le paramètre de la méthode `Field`, puis imprime la valeur de `Field`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1035">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="18d9c-1036">Un type factice est défini pour contenir la méthode de point d’entrée `Main`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1036">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="18d9c-1037">Dans le corps de `Main`, statiques `GM` méthode est appelée sur le type générique construit `Sample<int>` (`Sample(Of Integer)` en Visual Basic), avec le type <xref:System.String> remplacé par `U`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1037">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span> <span data-ttu-id="18d9c-1038">Le <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> méthode est utilisée pour créer un <xref:System.Reflection.MethodInfo> pour la méthode statique `GM` méthode du type générique construit `Sample<U>`et le <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> méthode est ensuite utilisée pour créer un <xref:System.Reflection.MethodInfo> pouvant être émis dans un appel de méthode.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1038">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method is used to create a <xref:System.Reflection.MethodInfo> for the static `GM` method of the constructed generic type `Sample<U>`, and the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method is then used to create a <xref:System.Reflection.MethodInfo> that can emitted in a method call.</span></span>  
  
 <span data-ttu-id="18d9c-1039">Lorsque l’exemple de code est exécuté, il enregistre l’assembly émis en tant que TypeBuilderGetFieldExample.exe.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1039">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="18d9c-1040">Vous pouvez exécuter TypeBuilderGetFieldExample.exe, et vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour comparer le code émis avec le code pour le `Sample` classe qui est compilé dans l’exemple de code lui-même.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1040">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-1041">
            <paramref name="method" /> est une méthode générique qui n’est pas une définition de méthode générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1041">
              <paramref name="method" /> is a generic method that is not a generic method definition.</span>
          </span>
          <span data-ttu-id="18d9c-1042">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1042">-or-</span>
          </span>
          <span data-ttu-id="18d9c-1043">
            <paramref name="type" /> ne représente pas un type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1043">
              <paramref name="type" /> does not represent a generic type.</span>
          </span>
          <span data-ttu-id="18d9c-1044">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1044">-or-</span>
          </span>
          <span data-ttu-id="18d9c-1045">
            <paramref name="type" /> n'est pas de type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1045">
              <paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
          <span data-ttu-id="18d9c-1046">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1046">-or-</span>
          </span>
          <span data-ttu-id="18d9c-1047">Le type déclarant de <paramref name="method" /> n’est pas une définition de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1047">The declaring type of <paramref name="method" /> is not a generic type definition.</span>
          </span>
          <span data-ttu-id="18d9c-1048">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1048">-or-</span>
          </span>
          <span data-ttu-id="18d9c-1049">Le type déclarant de <paramref name="method" /> n’est pas la définition de type générique de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1049">The declaring type of <paramref name="method" /> is not the generic type definition of <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="typeBuilder.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="typeBuilder.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="18d9c-1050">Il doit s'agir d'un bit indicateur de <see cref="T:System.Reflection.BindingFlags" />, comme dans <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1050">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1051">Retourne toutes les méthodes publiques et non publiques déclarées ou héritées par ce type, comme spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1051">Returns all the public and non-public methods declared or inherited by this type, as specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1052">Retourne un tableau d'objets <see cref="T:System.Reflection.MethodInfo" /> représentant les méthodes publiques et non publiques définies sur ce type si <paramref name="nonPublic" /> est utilisé ; sinon, seules les méthodes publiques sont retournées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1052">Returns an array of <see cref="T:System.Reflection.MethodInfo" /> objects representing the public and non-public methods defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public methods are returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1053">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1053">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-1054">Cette méthode n’est pas implémentée pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1054">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="typeBuilder.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-1055">
            <see cref="T:System.String" /> contenant le nom du type imbriqué à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1055">The <see cref="T:System.String" /> containing the name of the nested type to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="18d9c-1056">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1056">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="18d9c-1057">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1057">-or-</span>
          </span>
          <span data-ttu-id="18d9c-1058">Zéro, pour rechercher les méthodes publiques en respectant la casse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1058">Zero, to conduct a case-sensitive search for public methods.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1059">Retourne les types imbriqués publics et non publics déclarés par ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1059">Returns the public and non-public nested types that are declared by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1060">Objet <see cref="T:System.Type" /> qui représente le type imbriqué correspondant aux critères spécifiés, s'il existe ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1060">A <see cref="T:System.Type" /> object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1061">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1061">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 <span data-ttu-id="18d9c-1062">Si ce type est complète, par exemple, si `CreateType` a été appelé sur ce type, mais il existe des types imbriqués ne sont pas terminées, puis `GetNestedTypes` retourne uniquement les types imbriqués pour lesquels `CreateType` a été appelée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1062">If this type is complete, for example, if `CreateType` has been called on this type, but there are nested types that are not complete, then `GetNestedTypes` will only return those nested types for which `CreateType` has been called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-1063">Cette méthode n’est pas implémentée pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1063">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="typeBuilder.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="18d9c-1064">Il doit s'agir d'un bit indicateur de <see cref="T:System.Reflection.BindingFlags" />, comme dans <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1064">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1065">Retourne les types imbriqués publics et non publics déclarés ou hérités par ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1065">Returns the public and non-public nested types that are declared or inherited by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1066">Tableau d'objets <see cref="T:System.Type" /> représentant tous les types imbriqués du <see cref="T:System.Type" /> en cours qui correspondent aux contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1066">An array of <see cref="T:System.Type" /> objects representing all the types nested within the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="18d9c-1067">Tableau vide de type <see cref="T:System.Type" /> s'il n'existe aucun type imbriqué dans <see cref="T:System.Type" /> en cours ou si aucun des types imbriqués ne correspond aux contraintes de liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1067">An empty array of type <see cref="T:System.Type" />, if no types are nested within the current <see cref="T:System.Type" />, or if none of the nested types match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1068">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1068">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 <span data-ttu-id="18d9c-1069">Si ce type est complète, par exemple, si `CreateType` a été appelé sur ce type, mais il existe des types imbriqués ne sont pas terminées, puis `GetNestedTypes` retourne uniquement les types imbriqués pour lesquels `CreateType` a été appelée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1069">If this type is complete, for example, if `CreateType` has been called on this type, but there are nested types that are not complete, then `GetNestedTypes` will only return those nested types for which `CreateType` has been called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-1070">Cette méthode n’est pas implémentée pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1070">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="typeBuilder.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="18d9c-1071">Attribut de cet appel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1071">This invocation attribute.</span>
          </span>
          <span data-ttu-id="18d9c-1072">Il doit s'agir d'un bit indicateur de <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1072">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1073">Retourne toutes les propriétés publiques et non publiques déclarées ou héritées par ce type, comme spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1073">Returns all the public and non-public properties declared or inherited by this type, as specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1074">Retourne un tableau d'objets <see langword="PropertyInfo" /> représentant les propriétés publiques et non publiques définies sur ce type si <paramref name="nonPublic" /> est utilisé ; sinon, seules les propriétés publiques sont retournées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1074">Returns an array of <see langword="PropertyInfo" /> objects representing the public and non-public properties defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public properties are returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1075">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1075">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-1076">Cette méthode n’est pas implémentée pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1076">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="typeBuilder.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1077">Récupère le GUID de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1077">Retrieves the GUID of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1078">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1078">Read-only.</span>
          </span>
          <span data-ttu-id="18d9c-1079">Récupère le GUID de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1079">Retrieves the GUID of this type</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1080">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1080">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-1081">Cette méthode n’est pas prise en charge actuellement pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1081">This method is not currently supported for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="override this.HasElementTypeImpl : unit -&gt; bool" Usage="typeBuilder.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="typeBuilder.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="18d9c-1082">Nom du membre à appeler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1082">The name of the member to invoke.</span>
          </span>
          <span data-ttu-id="18d9c-1083">Il peut s’agir d’un constructeur, d’une méthode, d’une propriété ou d’un champ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1083">This can be a constructor, method, property, or field.</span>
          </span>
          <span data-ttu-id="18d9c-1084">Un attribut d’appel approprié doit être spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1084">A suitable invocation attribute must be specified.</span>
          </span>
          <span data-ttu-id="18d9c-1085">Notez qu’il est possible d’appeler le membre par défaut d’une classe en passant une chaîne vide comme nom du membre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1085">Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="18d9c-1086">Attribut d’appel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1086">The invocation attribute.</span>
          </span>
          <span data-ttu-id="18d9c-1087">Il doit s'agir d'un bit indicateur de <see langword="BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1087">This must be a bit flag from <see langword="BindingFlags" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="18d9c-1088">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see langword="MemberInfo" /> par le biais de la réflexion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1088">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects using reflection.</span>
          </span>
          <span data-ttu-id="18d9c-1089">Si le binder est <see langword="null" />, le binder par défaut est utilisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1089">If binder is <see langword="null" />, the default binder is used.</span>
          </span>
          <span data-ttu-id="18d9c-1090">Consultez <see cref="T:System.Reflection.Binder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1090">See <see cref="T:System.Reflection.Binder" />.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="18d9c-1091">Objet sur lequel appeler le membre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1091">The object on which to invoke the specified member.</span>
          </span>
          <span data-ttu-id="18d9c-1092">Si le membre est statique, ce paramètre est ignoré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1092">If the member is static, this parameter is ignored.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="18d9c-1093">Liste d’arguments.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1093">An argument list.</span>
          </span>
          <span data-ttu-id="18d9c-1094">Il s’agit d’un tableau d’objets contenant le nombre, l’ordre et le type des paramètres du membre à appeler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1094">This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked.</span>
          </span>
          <span data-ttu-id="18d9c-1095">En l’absence de paramètres, il doit avoir la valeur null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1095">If there are no parameters this should be null.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="18d9c-1096">Tableau de même longueur que <c>args</c> avec des éléments qui représentent les attributs associés aux arguments du membre à appeler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1096">An array of the same length as <c>args</c> with elements that represent the attributes associated with the arguments of the member to be invoked.</span>
          </span>
          <span data-ttu-id="18d9c-1097">Un paramètre est associé à des attributs dans les métadonnées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1097">A parameter has attributes associated with it in the metadata.</span>
          </span>
          <span data-ttu-id="18d9c-1098">Ils sont utilisés par divers services d’interopérabilité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1098">They are used by various interoperability services.</span>
          </span>
          <span data-ttu-id="18d9c-1099">Pour plus d’informations, consultez les spécifications des métadonnées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1099">See the metadata specs for more details.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="18d9c-1100">Instance de <see langword="CultureInfo" /> utilisée pour régir la contrainte des types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1100">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span>
          </span>
          <span data-ttu-id="18d9c-1101">Si la valeur est null, <see langword="CultureInfo" /> du thread en cours est utilisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1101">If this is null, the <see langword="CultureInfo" /> for the current thread is used.</span>
          </span>
          <span data-ttu-id="18d9c-1102">(Notez que cela est nécessaire pour, par exemple, convertir une chaîne représentant 1000 en valeur double, car 1000 est représenté de différentes manières selon la culture.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1102">(Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.)</span>
          </span>
        </param>
        <param name="namedParameters">
          <span data-ttu-id="18d9c-1103">Chaque paramètre dans le tableau <c>namedParameters</c> obtient la valeur de l’élément correspondant dans le tableau <c>args</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1103">Each parameter in the <c>namedParameters</c> array gets the value in the corresponding element in the <c>args</c> array.</span>
          </span>
          <span data-ttu-id="18d9c-1104">Si la longueur de <c>args</c> est supérieure à la longueur de <c>namedParameters</c>, les valeurs d’argument restantes sont passées dans l’ordre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1104">If the length of <c>args</c> is greater than the length of <c>namedParameters</c>, the remaining argument values are passed in order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1105">Appelle le membre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1105">Invokes the specified member.</span>
          </span>
          <span data-ttu-id="18d9c-1106">La méthode à appeler doit être accessible et fournir la correspondance la plus spécifique avec la liste d’arguments spécifiée, sous les contraintes des attributs de binder et d’appel spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1106">The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1107">Retourne la valeur de retour du membre appelé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1107">Returns the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1108">Une méthode est appelée si le nombre de paramètres dans la déclaration de méthode est égal au nombre d’arguments dans la liste d’arguments spécifiée et le type de chaque argument peut être converti par le classeur vers le type du paramètre.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1108">A method will be invoked if the number of parameters in the method declaration equals the number of arguments in the specified argument list, and the type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="18d9c-1109">Le binder va trouver toutes les méthodes correspondantes.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1109">The binder will find all of the matching methods.</span></span> <span data-ttu-id="18d9c-1110">Ces méthodes sont disponibles selon le type de liaison demandé (BindingFlags.InvokeMethod, BindingFlags.GetProperties et ainsi de suite.).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1110">These methods are found based on the type of binding requested (BindingFlags.InvokeMethod, BindingFlags.GetProperties, and so on.).</span></span> <span data-ttu-id="18d9c-1111">L’ensemble de méthodes est filtré par le nom, nombre d’arguments et un jeu de modificateurs de recherche définis dans le classeur.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1111">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span> <span data-ttu-id="18d9c-1112">Une fois que la méthode est sélectionnée, elle sera appelée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1112">After the method is selected, it will be invoked.</span></span> <span data-ttu-id="18d9c-1113">Accessibilité est vérifiée à ce stade.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1113">Accessibility is checked at that point.</span></span> <span data-ttu-id="18d9c-1114">La recherche peut contrôler quel ensemble de méthodes sont recherchés en fonction de l’attribut d’accessibilité associé à la méthode.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1114">The search can control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="18d9c-1115">Le `IBinder.BindToMethod` méthode est responsable de la sélection de la méthode à appeler.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1115">The `IBinder.BindToMethod` method is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="18d9c-1116">Le binder par défaut sélectionne la correspondance la plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1116">The default binder selects the most specific match.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-1117">Restrictions d’accès sont ignorées pour le code totalement approuvé.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1117">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="18d9c-1118">Autrement dit, propriétés, méthodes, champs et constructeurs privés sont accessibles et appelé à l’aide de la réflexion chaque fois que le code est entièrement fiable.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1118">That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="18d9c-1119">Cette méthode n’est pas prise en charge pour l’instant.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1119">This method is not currently supported.</span></span> <span data-ttu-id="18d9c-1120">Vous pouvez récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1120">You can retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-1121">Cette méthode n’est pas prise en charge actuellement pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1121">This method is not currently supported for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="override this.IsArrayImpl : unit -&gt; bool" Usage="typeBuilder.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAssignableFrom">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1122">Détermine si un type spécifié peut être affecté à cet objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1122">Determines whether a specified type can be assigned to this object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(System::Reflection::TypeInfo ^ typeInfo);" />
      <MemberSignature Language="F#" Value="override this.IsAssignableFrom : System.Reflection.TypeInfo -&gt; bool" Usage="typeBuilder.IsAssignableFrom typeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">
          <span data-ttu-id="18d9c-1123">Objet à tester.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1123">The object to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1124">Obtient une valeur qui indique si un objet <see cref="T:System.Reflection.TypeInfo" /> spécifié peut être affecté à cet objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1124">Gets a value that indicates whether a specified <see cref="T:System.Reflection.TypeInfo" /> object can be assigned to this object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1125">
            <see langword="true" /> si <paramref name="typeInfo" /> peut être affecté à cet objet ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1125">
              <see langword="true" /> if <paramref name="typeInfo" /> can be assigned to this object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="override this.IsAssignableFrom : Type -&gt; bool" Usage="typeBuilder.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="18d9c-1126">Objet à tester.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1126">The object to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1127">Obtient une valeur qui indique si un objet <see cref="T:System.Type" /> spécifié peut être assigné à cet objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1127">Gets a value that indicates whether a specified <see cref="T:System.Type" /> can be assigned to this object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1128">
            <see langword="true" /> si le paramètre <paramref name="c" /> et le type en cours représentent le même type, ou si le type en cours se trouve dans la hiérarchie d'héritage de <paramref name="c" /> ou si le type en cours est une interface prise en charge par <paramref name="c" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1128">
              <see langword="true" /> if the <paramref name="c" /> parameter and the current type represent the same type, or if the current type is in the inheritance hierarchy of <paramref name="c" />, or if the current type is an interface that <paramref name="c" /> supports.</span>
          </span>
          <span data-ttu-id="18d9c-1129">
            <see langword="false" /> si aucune de ces conditions sont valides, ou si <paramref name="c" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1129">
              <see langword="false" /> if none of these conditions are valid, or if <paramref name="c" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="override this.IsByRefImpl : unit -&gt; bool" Usage="typeBuilder.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public override bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="override this.IsCOMObjectImpl : unit -&gt; bool" Usage="typeBuilder.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1130">Obtient une valeur qui indique si cet objet représente un type générique construit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1130">Gets a value that indicates whether this object represents a constructed generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1131">
            <see langword="true" /> si cet objet représente un type générique construit ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1131">
              <see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCreated">
      <MemberSignature Language="C#" Value="public bool IsCreated ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsCreated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCreated" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCreated () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsCreated();" />
      <MemberSignature Language="F#" Value="member this.IsCreated : unit -&gt; bool" Usage="typeBuilder.IsCreated " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1132">Retourne une valeur qui indique si le type dynamique actuel a été créé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1132">Returns a value that indicates whether the current dynamic type has been created.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1133">
            <see langword="true" /> si la méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelée ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1133">
              <see langword="true" /> if the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has been called; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1134">Après le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode a été appelée, le type représenté par le <xref:System.Reflection.Emit.TypeBuilder> objet est terminé.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1134">After the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called, the type represented by the <xref:System.Reflection.Emit.TypeBuilder> object is complete.</span></span> <span data-ttu-id="18d9c-1135">Exceptions sont levées sur toute nouvelle tentative d’ajouter des membres ou modifier d’autres caractéristiques du type.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1135">Exceptions are thrown on any further attempts to add members or change other characteristics of the type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="typeBuilder.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="18d9c-1136">Type d’attribut à rechercher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1136">The type of attribute to search for.</span>
          </span>
          <span data-ttu-id="18d9c-1137">Seuls les attributs qui peuvent être assignés à ce type sont retournés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1137">Only attributes that are assignable to this type are returned.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="18d9c-1138">Spécifie s’il faut rechercher les attributs dans la chaîne d’héritage de ce membre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1138">Specifies whether to search this member's inheritance chain to find the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1139">Détermine si un attribut personnalisé est appliqué au type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1139">Determines whether a custom attribute is applied to the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1140">
            <see langword="true" /> si une ou plusieurs instances de <paramref name="attributeType" />, ou un attribut dérivé de <paramref name="attributeType" />, sont définis sur ce type ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1140">
              <see langword="true" /> if one or more instances of <paramref name="attributeType" />, or an attribute derived from <paramref name="attributeType" />, is defined on this type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1141">Cette méthode n’est pas pris en charge pour les paramètres de type générique incomplets.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1141">This method is not supported for incomplete generic type parameters.</span></span> <span data-ttu-id="18d9c-1142">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1142">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-1143">Cette méthode n’est pas prise en charge actuellement pour les types incomplets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1143">This method is not currently supported for incomplete types.</span>
          </span>
          <span data-ttu-id="18d9c-1144">Vous pouvez récupérer le type à l'aide de <see cref="M:System.Type.GetType" />, puis appeler <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> sur le <see cref="T:System.Type" /> retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1144">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-1145">
            <paramref name="attributeType" />n'est pas défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1145">
              <paramref name="attributeType" /> is not defined.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-1146">
            <paramref name="attributeType" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1146">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public override bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1147">Obtient une valeur indiquant si le type actuel est un paramètre de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1147">Gets a value indicating whether the current type is a generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1148">
            <see langword="true" /> si l’objet <see cref="T:System.Reflection.Emit.TypeBuilder" /> actuel représente un paramètre de type générique ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1148">
              <see langword="true" /> if the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type parameter; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-1149">Lors de l’émission de code, un paramètre de type générique est représenté par un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objet plutôt que par un <xref:System.Reflection.Emit.TypeBuilder> objet.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1149">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public override bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1150">Obtient une valeur indiquant si le type actuel est un type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1150">Gets a value indicating whether the current type is a generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1151">
            <see langword="true" /> si le type représenté par l’objet <see cref="T:System.Reflection.Emit.TypeBuilder" /> actuel est générique ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1151">
              <see langword="true" /> if the type represented by the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object is generic; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1152">Un <xref:System.Reflection.Emit.TypeBuilder> objet représente une définition de type générique si le <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> méthode a été utilisée afin de lui donner des paramètres de type générique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1152">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="18d9c-1153">Une instance de la <xref:System.Reflection.Emit.TypeBuilder> classe générique est toujours une définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1153">An instance of the <xref:System.Reflection.Emit.TypeBuilder> class that is generic is always a generic type definition.</span></span>  
  
 <span data-ttu-id="18d9c-1154">Pour plus d’informations sur les types génériques dans la réflexion et une liste des conditions invariables des termes utilisés dans la réflexion générique, consultez le <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1154">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1155">Obtient une valeur qui indique si le <see cref="T:System.Reflection.Emit.TypeBuilder" /> actuel représente une définition de type générique, à partir de laquelle d’autres types génériques peuvent être construits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1155">Gets a value indicating whether the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> represents a generic type definition from which other generic types can be constructed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1156">
            <see langword="true" /> si cet objet <see cref="T:System.Reflection.Emit.TypeBuilder" /> représente une définition de type générique ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1156">
              <see langword="true" /> if this <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type definition; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1157">Un <xref:System.Reflection.Emit.TypeBuilder> objet représente une définition de type générique si le <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> méthode a été utilisée afin de lui donner des paramètres de type générique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1157">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="18d9c-1158">Une instance de la <xref:System.Reflection.Emit.TypeBuilder> classe générique est toujours une définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1158">An instance of the <xref:System.Reflection.Emit.TypeBuilder> class that is generic is always a generic type definition.</span></span>  
  
 <span data-ttu-id="18d9c-1159">Un <xref:System.Reflection.Emit.TypeBuilder> peut être utilisé pour générer des définitions de type générique, mais pas des types génériques construits.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1159">A <xref:System.Reflection.Emit.TypeBuilder> can be used to build generic type definitions, but not constructed generic types.</span></span> <span data-ttu-id="18d9c-1160">Pour obtenir un type générique construit, appelez le <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode sur un <xref:System.Reflection.Emit.TypeBuilder> qui représente une définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1160">To get a constructed generic type, call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type definition.</span></span>  
  
 <span data-ttu-id="18d9c-1161">Pour plus d’informations sur les types génériques dans la réflexion et une liste des conditions invariables des termes utilisés dans la réflexion générique, consultez le <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1161">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="override this.IsPointerImpl : unit -&gt; bool" Usage="typeBuilder.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="override this.IsPrimitiveImpl : unit -&gt; bool" Usage="typeBuilder.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1162">Obtient une valeur qui indique si le type actuel est critique de sécurité (security-critical) ou critique sécurisé (security-safe-critical), et peut donc effectuer des opérations critiques.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1162">Gets a value that indicates whether the current type is security-critical or security-safe-critical, and therefore can perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1163">
            <see langword="true" /> si le type actuel est critique de sécurité ou critique sécurisé ; <see langword="false" /> s'il est transparent de sécurité (security-transparent).</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1163">
              <see langword="true" /> if the current type is security-critical or security-safe-critical; <see langword="false" /> if it is transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1164">Le <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, et <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence du type, tel que déterminé par le common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1164">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="18d9c-1165">Les combinaisons de ces propriétés sont affichées dans le tableau suivant :</span><span class="sxs-lookup"><span data-stu-id="18d9c-1165">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="18d9c-1166">Niveau de sécurité</span><span class="sxs-lookup"><span data-stu-id="18d9c-1166">Security level</span></span>|<span data-ttu-id="18d9c-1167">EstCritiqueDeSécurité</span><span class="sxs-lookup"><span data-stu-id="18d9c-1167">IsSecurityCritical</span></span>|<span data-ttu-id="18d9c-1168">EstCritiqueSécurisé</span><span class="sxs-lookup"><span data-stu-id="18d9c-1168">IsSecuritySafeCritical</span></span>|<span data-ttu-id="18d9c-1169">EstTransparentDeSécurité</span><span class="sxs-lookup"><span data-stu-id="18d9c-1169">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="18d9c-1170">Critique</span><span class="sxs-lookup"><span data-stu-id="18d9c-1170">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="18d9c-1171">Critique sécurisé</span><span class="sxs-lookup"><span data-stu-id="18d9c-1171">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="18d9c-1172">Transparent</span><span class="sxs-lookup"><span data-stu-id="18d9c-1172">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="18d9c-1173">L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1173">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="18d9c-1174">Le runtime commence à évaluer les niveaux de transparence à l’assembly.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1174">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="18d9c-1175">Par exemple, si l’assembly dynamique est critique de sécurité, les annotations sur les types sont ignorées, et tous les types sont critiques de sécurité.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1175">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="18d9c-1176">Par défaut, un assembly dynamique hérite de la transparence de l’assembly qui l’émet.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1176">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="18d9c-1177">Vous pouvez remplacer cette valeur par défaut à l’aide de la <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, ou <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> surcharge de méthode et en spécifiant les attributs de sécurité.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1177">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="18d9c-1178">Vous ne peut pas élever les niveaux de sécurité en faisant ceci ; Autrement dit, le code transparent ne peut pas émettre du code critique de sécurité ou critique sécurisé.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1178">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="18d9c-1179">Attributs doivent être spécifiés lorsque l’assembly dynamique est créé, ou ils ne prennent pas effet tant que l’assembly a été enregistré sur le disque et rechargé.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1179">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-1180">L’héritage par défaut est limitée à l’évaluation du runtime de transparence.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1180">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="18d9c-1181">Aucun attribut n’est appliquées à l’assembly dynamique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1181">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="18d9c-1182">Si vous souhaitez ajouter des attributs de sécurité, vous devez les appliquer vous-même.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1182">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="18d9c-1183">Pour plus d’informations sur la réflexion émettre et la transparence, consultez [problèmes de sécurité dans l’émission de réflexion](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1183">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="18d9c-1184">Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1184">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-1185">Le type dynamique actuel n'a pas été créé en appelant la méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1185">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1186">Obtient une valeur qui indique si le type actuel est critique sécurisé, autrement dit s’il peut effectuer des opérations critiques et s’il est accessible par du code transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1186">Gets a value that indicates whether the current type is security-safe-critical; that is, whether it can perform critical operations and can be accessed by transparent code.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1187">
            <see langword="true" /> si le type actuel est critique sécurisé ; <see langword="false" /> s'il est critique de sécurité ou transparent de sécurité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1187">
              <see langword="true" /> if the current type is security-safe-critical; <see langword="false" /> if it is security-critical or transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1188">Le <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, et <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence du type, tel que déterminé par le common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1188">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="18d9c-1189">Les combinaisons de ces propriétés sont affichées dans le tableau suivant :</span><span class="sxs-lookup"><span data-stu-id="18d9c-1189">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="18d9c-1190">Niveau de sécurité</span><span class="sxs-lookup"><span data-stu-id="18d9c-1190">Security level</span></span>|<span data-ttu-id="18d9c-1191">EstCritiqueDeSécurité</span><span class="sxs-lookup"><span data-stu-id="18d9c-1191">IsSecurityCritical</span></span>|<span data-ttu-id="18d9c-1192">EstCritiqueSécurisé</span><span class="sxs-lookup"><span data-stu-id="18d9c-1192">IsSecuritySafeCritical</span></span>|<span data-ttu-id="18d9c-1193">EstTransparentDeSécurité</span><span class="sxs-lookup"><span data-stu-id="18d9c-1193">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="18d9c-1194">Critique</span><span class="sxs-lookup"><span data-stu-id="18d9c-1194">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="18d9c-1195">Critique sécurisé</span><span class="sxs-lookup"><span data-stu-id="18d9c-1195">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="18d9c-1196">Transparent</span><span class="sxs-lookup"><span data-stu-id="18d9c-1196">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="18d9c-1197">L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1197">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="18d9c-1198">Le runtime commence à évaluer les niveaux de transparence à l’assembly.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1198">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="18d9c-1199">Par exemple, si l’assembly dynamique est critique de sécurité, les annotations sur les types sont ignorées, et tous les types sont critiques de sécurité.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1199">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="18d9c-1200">Par défaut, un assembly dynamique hérite de la transparence de l’assembly qui l’émet.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1200">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="18d9c-1201">Vous pouvez remplacer cette valeur par défaut à l’aide de la <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, ou <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> surcharge de méthode et en spécifiant les attributs de sécurité.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1201">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="18d9c-1202">Vous ne peut pas élever les niveaux de sécurité en faisant ceci ; Autrement dit, le code transparent ne peut pas émettre du code critique de sécurité ou critique sécurisé.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1202">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="18d9c-1203">Attributs doivent être spécifiés lorsque l’assembly dynamique est créé, ou ils ne prennent pas effet tant que l’assembly a été enregistré sur le disque et rechargé.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1203">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-1204">L’héritage par défaut est limitée à l’évaluation du runtime de transparence.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1204">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="18d9c-1205">Aucun attribut n’est appliquées à l’assembly dynamique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1205">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="18d9c-1206">Si vous souhaitez ajouter des attributs de sécurité, vous devez les appliquer vous-même.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1206">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="18d9c-1207">Pour plus d’informations sur la réflexion émettre et la transparence, consultez [problèmes de sécurité dans l’émission de réflexion](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1207">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="18d9c-1208">Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1208">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-1209">Le type dynamique actuel n'a pas été créé en appelant la méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1209">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1210">Obtient une valeur qui indique si le type actuel est transparent et s’il ne peut donc pas effectuer d’opérations critiques.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1210">Gets a value that indicates whether the current type is transparent, and therefore cannot perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1211">
            <see langword="true" /> si le type est transparent de sécurité ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1211">
              <see langword="true" /> if the type is security-transparent; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1212">Le <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, et <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence du type, tel que déterminé par le common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1212">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="18d9c-1213">Les combinaisons de ces propriétés sont affichées dans le tableau suivant :</span><span class="sxs-lookup"><span data-stu-id="18d9c-1213">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="18d9c-1214">Niveau de sécurité</span><span class="sxs-lookup"><span data-stu-id="18d9c-1214">Security level</span></span>|<span data-ttu-id="18d9c-1215">EstCritiqueDeSécurité</span><span class="sxs-lookup"><span data-stu-id="18d9c-1215">IsSecurityCritical</span></span>|<span data-ttu-id="18d9c-1216">EstCritiqueSécurisé</span><span class="sxs-lookup"><span data-stu-id="18d9c-1216">IsSecuritySafeCritical</span></span>|<span data-ttu-id="18d9c-1217">EstTransparentDeSécurité</span><span class="sxs-lookup"><span data-stu-id="18d9c-1217">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="18d9c-1218">Critique</span><span class="sxs-lookup"><span data-stu-id="18d9c-1218">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="18d9c-1219">Critique sécurisé</span><span class="sxs-lookup"><span data-stu-id="18d9c-1219">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="18d9c-1220">Transparent</span><span class="sxs-lookup"><span data-stu-id="18d9c-1220">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="18d9c-1221">L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1221">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="18d9c-1222">Le runtime commence à évaluer les niveaux de transparence à l’assembly.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1222">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="18d9c-1223">Par exemple, si l’assembly dynamique est critique de sécurité, les annotations sur les types sont ignorées, et tous les types sont critiques de sécurité.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1223">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="18d9c-1224">Par défaut, un assembly dynamique hérite de la transparence de l’assembly qui l’émet.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1224">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="18d9c-1225">Vous pouvez remplacer cette valeur par défaut à l’aide de la <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, ou <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> surcharge de méthode et en spécifiant les attributs de sécurité.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1225">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="18d9c-1226">Vous ne peut pas élever les niveaux de sécurité en faisant ceci ; Autrement dit, le code transparent ne peut pas émettre du code critique de sécurité ou critique sécurisé.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1226">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="18d9c-1227">Attributs doivent être spécifiés lorsque l’assembly dynamique est créé, ou ils ne prennent pas effet tant que l’assembly a été enregistré sur le disque et rechargé.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1227">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-1228">L’héritage par défaut est limitée à l’évaluation du runtime de transparence.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1228">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="18d9c-1229">Aucun attribut n’est appliquées à l’assembly dynamique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1229">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="18d9c-1230">Si vous souhaitez ajouter des attributs de sécurité, vous devez les appliquer vous-même.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1230">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="18d9c-1231">Pour plus d’informations sur la réflexion émettre et la transparence, consultez [problèmes de sécurité dans l’émission de réflexion](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1231">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="18d9c-1232">Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1232">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-1233">Le type dynamique actuel n'a pas été créé en appelant la méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1233">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public override bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public override bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="override this.IsSubclassOf : Type -&gt; bool" Usage="typeBuilder.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="18d9c-1234">
            <see cref="T:System.Type" /> à vérifier</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1234">A <see cref="T:System.Type" /> that is to be checked.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1235">Détermine si ce type est dérivé d’un type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1235">Determines whether this type is derived from a specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1236">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1236">Read-only.</span>
          </span>
          <span data-ttu-id="18d9c-1237">Retourne <see langword="true" /> si ce type est identique au type <paramref name="c" /> ou s'il est un sous-type du type <paramref name="c" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1237">Returns <see langword="true" /> if this type is the same as the type <paramref name="c" />, or is a subtype of type <paramref name="c" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="override this.IsValueTypeImpl : unit -&gt; bool" Usage="typeBuilder.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1238">Retourne un objet <see cref="T:System.Type" /> qui représente un tableau du type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1238">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="override this.MakeArrayType : unit -&gt; Type" Usage="typeBuilder.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1239">Retourne un objet <see cref="T:System.Type" /> qui représente un tableau unidimensionnel du type actuel, avec une limite inférieure de zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1239">Returns a <see cref="T:System.Type" /> object that represents a one-dimensional array of the current type, with a lower bound of zero.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1240">Objet <see cref="T:System.Type" /> représentant un type de tableau unidimensionnel dont le type d’élément est le type actuel, avec une limite inférieure de zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1240">A <see cref="T:System.Type" /> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1241">Le <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> méthode fournit un moyen de générer un type de tableau avec n’importe quel type d’élément possible, y compris les types génériques.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1241">The <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method provides a way to generate an array type with any possible element type, including generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-1242">L’exemple de code suivant crée un module dynamique, un type abstrait nommé `Sample`et une méthode abstraite nommée `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1242">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="18d9c-1243">`TestMethod` prend un `ref` paramètre (`ByRef` en Visual Basic) de type `Sample`, un pointeur vers un type `Sample`et un tableau de type `Sample`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1243">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="18d9c-1244">Elle retourne un tableau à deux dimensions de type `Sample`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1244">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="18d9c-1245">L’exemple de code enregistre le module dynamique sur disque, afin de pouvoir examiner avec le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1245">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="override this.MakeArrayType : int -&gt; Type" Usage="typeBuilder.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">
          <span data-ttu-id="18d9c-1246">Nombre de dimensions pour le tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1246">The number of dimensions for the array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1247">Retourne un objet <see cref="T:System.Type" /> qui représente un tableau du type actuel, avec le nombre spécifié de dimensions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1247">Returns a <see cref="T:System.Type" /> object that represents an array of the current type, with the specified number of dimensions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1248">Objet <see cref="T:System.Type" /> qui représente un tableau unidimensionnel du type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1248">A <see cref="T:System.Type" /> object that represents a one-dimensional array of the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1249">Le <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> méthode fournit un moyen de générer un type de tableau avec n’importe quel type d’élément possible, y compris les types génériques.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1249">The <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method provides a way to generate an array type with any possible element type, including generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-1250">L’exemple de code suivant crée un module dynamique, un type abstrait nommé `Sample`et une méthode abstraite nommée `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1250">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="18d9c-1251">`TestMethod` prend un `ref` paramètre (`ByRef` en Visual Basic) de type `Sample`, un pointeur vers un type `Sample`et un tableau de type `Sample`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1251">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="18d9c-1252">Elle retourne un tableau à deux dimensions de type `Sample`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1252">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="18d9c-1253">L’exemple de code enregistre le module dynamique sur disque, afin de pouvoir examiner avec le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1253">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="18d9c-1254">
            <paramref name="rank" /> n’est pas une dimension de tableau valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1254">
              <paramref name="rank" /> is not a valid array dimension.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public override Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="override this.MakeByRefType : unit -&gt; Type" Usage="typeBuilder.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1255">Retourne un objet <see cref="T:System.Type" /> qui représente le type actuel quand il est passé en tant que paramètre <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1255">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1256">Objet <see cref="T:System.Type" /> qui représente le type actuel quand il est passé en tant que paramètre <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1256">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1257">Le <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> méthode fournit un moyen de générer `ref` types (`ByRef` en Visual Basic) pour le paramètre répertorie.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1257">The <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-1258">À l’aide de la syntaxe de Microsoft intermediate language (MSIL), si actuel <xref:System.Reflection.Emit.TypeBuilder> représente `MyType`, le type retourné par cette méthode serait `MyType&`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1258">Using Microsoft intermediate language (MSIL) syntax, if the current <xref:System.Reflection.Emit.TypeBuilder> represents `MyType`, then the type returned by this method would be `MyType&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-1259">L’exemple de code suivant crée un module dynamique, un type abstrait nommé `Sample`et une méthode abstraite nommée `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1259">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="18d9c-1260">`TestMethod` prend un `ref` paramètre (`ByRef` en Visual Basic) de type `Sample`, un pointeur vers un type `Sample`et un tableau de type `Sample`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1260">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="18d9c-1261">Elle retourne un tableau à deux dimensions de type `Sample`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1261">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="18d9c-1262">L’exemple de code enregistre le module dynamique sur disque, afin de pouvoir examiner avec le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1262">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public override Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="override this.MakeGenericType : Type[] -&gt; Type" Usage="typeBuilder.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">
          <span data-ttu-id="18d9c-1263">Tableau de types à substituer aux paramètres de type de la définition du type générique actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1263">An array of types to be substituted for the type parameters of the current generic type definition.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1264">Substitue les éléments d’un tableau de types aux paramètres de type de la définition du type générique actuel et retourne le type construit résultant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1264">Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1265">
            <see cref="T:System.Type" /> représentant le type construit formé en substituant les éléments de <paramref name="typeArguments" /> pour les paramètres de type du type générique actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1265">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1266">Utilisez cette méthode lorsque votre code émis nécessite un type construit à partir de la définition de type générique actuel.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1266">Use this method when your emitted code requires a type constructed from the current generic type definition.</span></span> <span data-ttu-id="18d9c-1267">Il n’est pas nécessaire d’appeler le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode avant d’appeler le <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode sur un <xref:System.Reflection.Emit.TypeBuilder> qui représente une définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1267">It is not necessary to call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method before calling the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type definition.</span></span> <span data-ttu-id="18d9c-1268">Si actuel <xref:System.Reflection.Emit.TypeBuilder> ne représente pas la définition d’un type générique, un <xref:System.InvalidOperationException> est levée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1268">If the current <xref:System.Reflection.Emit.TypeBuilder> does not represent the definition of a generic type, an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 <span data-ttu-id="18d9c-1269">L’objet retourné par cette méthode fonctionne comme un espace réservé pour un type générique construit dans votre code émis.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1269">The object returned by this method functions as a placeholder for a constructed generic type in your emitted code.</span></span> <span data-ttu-id="18d9c-1270">C’est une instance d’une classe dérivée de <xref:System.Type> qui a des capacités limitées.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1270">It is an instance of a class derived from <xref:System.Type> that has limited capabilities.</span></span> <span data-ttu-id="18d9c-1271">En particulier :</span><span class="sxs-lookup"><span data-stu-id="18d9c-1271">In particular:</span></span>  
  
-   <span data-ttu-id="18d9c-1272">Pour obtenir les méthodes, champs et constructeurs pour ces types génériques construits, utilisez le <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, et <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> surcharges de méthode.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1272">To get methods, fields, and constructors for these constructed generic types, use the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, and <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> method overloads.</span></span>  
  
-   <span data-ttu-id="18d9c-1273">Deux instances qui représentent le même type construit ne pas considérée comme égale.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1273">Two instances that represent the same constructed type do not compare as equal.</span></span> <span data-ttu-id="18d9c-1274">Par exemple, dans le code suivant `t1.Equals(t2)` retourne `false`:</span><span class="sxs-lookup"><span data-stu-id="18d9c-1274">For example, in the following code `t1.Equals(t2)` returns `false`:</span></span>  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/vb/remarks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-1275">Le type actuel ne représente pas la définition d’un type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1275">The current type does not represent the definition of a generic type.</span>
          </span>
          <span data-ttu-id="18d9c-1276">Autrement dit, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> retourne <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1276">That is, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-1277">
            <paramref name="typeArguments" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1277">
              <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="18d9c-1278">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1278">-or-</span>
          </span>
          <span data-ttu-id="18d9c-1279">Tout élément de <paramref name="typeArguments" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1279">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-1280">La propriété <see cref="P:System.Type.Module" /> de n’importe quel élément de <paramref name="typeArguments" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1280">The <see cref="P:System.Type.Module" /> property of any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="18d9c-1281">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1281">-or-</span>
          </span>
          <span data-ttu-id="18d9c-1282">La propriété <see cref="P:System.Reflection.Module.Assembly" /> du module de n’importe quel élément de <paramref name="typeArguments" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1282">The <see cref="P:System.Reflection.Module.Assembly" /> property of the module of any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public override Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="override this.MakePointerType : unit -&gt; Type" Usage="typeBuilder.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1283">Retourne un objet <see cref="T:System.Type" /> qui représente le type d’un pointeur non managé vers le type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1283">Returns a <see cref="T:System.Type" /> object that represents the type of an unmanaged pointer to the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1284">Objet <see cref="T:System.Type" /> qui représente le type d’un pointeur non managé vers le type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1284">A <see cref="T:System.Type" /> object that represents the type of an unmanaged pointer to the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1285">Le <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> méthode fournit un moyen pour générer des types pointeur pour les listes de paramètres.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1285">The <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-1286">À l’aide de la syntaxe de Microsoft intermediate language (MSIL), si actuel <xref:System.Reflection.Emit.TypeBuilder> représente `MyType`, le type retourné par cette méthode serait `MyType*`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1286">Using Microsoft intermediate language (MSIL) syntax, if the current <xref:System.Reflection.Emit.TypeBuilder> represents `MyType`, then the type returned by this method would be `MyType*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18d9c-1287">L’exemple de code suivant crée un module dynamique, un type abstrait nommé `Sample`et une méthode abstraite nommée `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1287">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="18d9c-1288">`TestMethod` prend un `ref` paramètre (`ByRef` en Visual Basic) de type `Sample`, un pointeur vers un type `Sample`et un tableau de type `Sample`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1288">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="18d9c-1289">Elle retourne un tableau à deux dimensions de type `Sample`.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1289">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="18d9c-1290">L’exemple de code enregistre le module dynamique sur disque, afin de pouvoir examiner avec le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1290">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.TypeBuilder.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1291">Récupère le module dynamique qui contient la définition de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1291">Retrieves the dynamic module that contains this type definition.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1292">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1292">Read-only.</span>
          </span>
          <span data-ttu-id="18d9c-1293">Récupère le module dynamique qui contient la définition de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1293">Retrieves the dynamic module that contains this type definition.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.TypeBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1294">Récupère le nom de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1294">Retrieves the name of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1295">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1295">Read-only.</span>
          </span>
          <span data-ttu-id="18d9c-1296">Récupère le nom <see cref="T:System.String" /> de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1296">Retrieves the <see cref="T:System.String" /> name of this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1297">Récupère l’espace de noms dans lequel ce <see langword="TypeBuilder" /> est défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1297">Retrieves the namespace where this <see langword="TypeBuilder" /> is defined.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1298">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1298">Read-only.</span>
          </span>
          <span data-ttu-id="18d9c-1299">Récupère l’espace de noms dans lequel ce <see langword="TypeBuilder" /> est défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1299">Retrieves the namespace where this <see langword="TypeBuilder" /> is defined.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PackingSize">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PackingSize PackingSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.PackingSize PackingSize" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackingSize As PackingSize" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::PackingSize PackingSize { System::Reflection::Emit::PackingSize get(); };" />
      <MemberSignature Language="F#" Value="member this.PackingSize : System.Reflection.Emit.PackingSize" Usage="System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PackingSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1300">Récupère la taille de compactage de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1300">Retrieves the packing size of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1301">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1301">Read-only.</span>
          </span>
          <span data-ttu-id="18d9c-1302">Récupère la taille de compactage de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1302">Retrieves the packing size of this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1303">Retourne le type qui a été utilisé pour obtenir ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1303">Returns the type that was used to obtain this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1304">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1304">Read-only.</span>
          </span>
          <span data-ttu-id="18d9c-1305">Type qui a été utilisé pour obtenir ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1305">The type that was used to obtain this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1306">Définit un attribut personnalisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1306">Sets a custom attribute.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.Emit.CustomAttributeBuilder -&gt; unit" Usage="typeBuilder.SetCustomAttribute customBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">
          <span data-ttu-id="18d9c-1307">Instance d’une classe d’assistance pour définir l’attribut personnalisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1307">An instance of a helper class to define the custom attribute.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1308">Définit un attribut personnalisé à l’aide d’un générateur d’attributs personnalisés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1308">Set a custom attribute using a custom attribute builder.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-1309">En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ce membre n’a plus besoin <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> indicateur.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1309">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="18d9c-1310">(Consultez [des problèmes de sécurité dans la réflexion émission](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1310">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-1311">
            <paramref name="customBuilder" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1311">
              <paramref name="customBuilder" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-1312">Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1312">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.ConstructorInfo * byte[] -&gt; unit" Usage="typeBuilder.SetCustomAttribute (con, binaryAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">
          <span data-ttu-id="18d9c-1313">Le constructeur de l’attribut personnalisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1313">The constructor for the custom attribute.</span>
          </span>
        </param>
        <param name="binaryAttribute">
          <span data-ttu-id="18d9c-1314">Objet blob d’octets représentant les attributs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1314">A byte blob representing the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1315">Définit un attribut personnalisé à l’aide d’un objet blob d’attribut personnalisé spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1315">Sets a custom attribute using a specified custom attribute blob.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1316">Pour plus d’informations sur la façon de mettre en forme `binaryAttribute`, consultez la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="18d9c-1316">For more information on how to format `binaryAttribute`, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="18d9c-1317">La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1317">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18d9c-1318">En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ce membre n’a plus besoin <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> indicateur.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1318">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="18d9c-1319">(Consultez [des problèmes de sécurité dans la réflexion émission](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1319">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="18d9c-1320">
            <paramref name="con" /> ou <paramref name="binaryAttribute" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1320">
              <paramref name="con" /> or <paramref name="binaryAttribute" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-1321">Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1321">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetParent">
      <MemberSignature Language="C#" Value="public void SetParent (Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParent(class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParent (parent As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParent(Type ^ parent);" />
      <MemberSignature Language="F#" Value="member this.SetParent : Type -&gt; unit" Usage="typeBuilder.SetParent parent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parent">
          <span data-ttu-id="18d9c-1322">Nouveau type de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1322">The new base type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1323">Définit le type de base du type actuellement en cours d’élaboration.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1323">Sets the base type of the type currently under construction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1324">Si `parent` est `null`, <xref:System.Object> est utilisé comme type de base.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1324">If `parent` is `null`, <xref:System.Object> is used as the base type.</span></span>  
  
 <span data-ttu-id="18d9c-1325">Dans les versions 1.0 et 1.1 du .NET Framework, aucune exception n’est levée si `parent` est un type interface, mais un <xref:System.TypeLoadException> est levée lorsque le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1325">In the .NET Framework versions 1.0 and 1.1, no exception is thrown if `parent` is an interface type, but a <xref:System.TypeLoadException> is thrown when the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span>  
  
 <span data-ttu-id="18d9c-1326">Le <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> méthode ne vérifie pas la plupart des types de parent non valide.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1326">The <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> method does not check for most invalid parent types.</span></span> <span data-ttu-id="18d9c-1327">Par exemple, il ne rejette pas un type de parent qui n’a aucun constructeur par défaut lorsque le type actuel possède un constructeur par défaut, il ne rejette pas les types sealed, et il ne rejette pas le <xref:System.Delegate> type.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1327">For example, it does not reject a parent type that has no default constructor when the current type has a default constructor, it does not reject sealed types, and it does not reject the <xref:System.Delegate> type.</span></span> <span data-ttu-id="18d9c-1328">Dans tous ces cas, les exceptions sont levées par le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="18d9c-1328">In all these cases, exceptions are thrown by the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-1329">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1329">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="18d9c-1330">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1330">-or-</span>
          </span>
          <span data-ttu-id="18d9c-1331">
            <paramref name="parent" /> a la valeur <see langword="null" />, et l’instance actuelle représente une interface dont les attributs n’incluent pas <see cref="F:System.Reflection.TypeAttributes.Abstract" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1331">
              <paramref name="parent" /> is <see langword="null" />, and the current instance represents an interface whose attributes do not include <see cref="F:System.Reflection.TypeAttributes.Abstract" />.</span>
          </span>
          <span data-ttu-id="18d9c-1332">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1332">-or-</span>
          </span>
          <span data-ttu-id="18d9c-1333">Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1333">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="18d9c-1334">
            <paramref name="parent" /> est une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1334">
              <paramref name="parent" /> is an interface.</span>
          </span>
          <span data-ttu-id="18d9c-1335">Cette condition d’exception est une nouveauté de .NET Framework version 2.0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1335">This exception condition is new in the .NET Framework version 2.0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Size { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Size : int" Usage="System.Reflection.Emit.TypeBuilder.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1336">Récupère la taille totale d’un type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1336">Retrieves the total size of a type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1337">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1337">Read-only.</span>
          </span>
          <span data-ttu-id="18d9c-1338">Récupère la taille totale de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1338">Retrieves this type’s total size.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _TypeBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_TypeBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(System.Guid,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="18d9c-1339">Réservé à un usage ultérieur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1339">Reserved for future use.</span>
          </span>
          <span data-ttu-id="18d9c-1340">Doit être IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1340">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="18d9c-1341">Tableau passé des noms à mapper.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1341">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="18d9c-1342">Compte des noms à mapper.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1342">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="18d9c-1343">Contexte des paramètres régionaux dans lequel interpréter les noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1343">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="18d9c-1344">Tableau alloué par l'appelant et recevant les ID qui correspondent aux noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1344">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1345">Mappe un jeu de noms avec un jeu correspondant d'identificateurs de dispatch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1345">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1346">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1346">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="18d9c-1347">Pour plus d’informations sur `IDispatch::GetIDsOfNames`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1347">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="18d9c-1348">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1348">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _TypeBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="18d9c-1349">Informations de type à retourner.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1349">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="18d9c-1350">Identificateur des paramètres régionaux pour les informations de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1350">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="18d9c-1351">Reçoit un pointeur vers l'objet d'informations de type demandé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1351">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1352">Récupère les informations de type pour un objet, qui peuvent être utilisées ensuite pour obtenir les informations de type d'une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1352">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1353">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1353">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="18d9c-1354">Pour plus d’informations sur `IDispatch::GetTypeInfo`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1354">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="18d9c-1355">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1355">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _TypeBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(System.UInt32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="18d9c-1356">Pointe vers un emplacement qui reçoit le nombre d'interfaces d'informations de type fourni par l'objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1356">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1357">Récupère le nombre d'interfaces d'informations de type fourni par un objet (0 ou 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1357">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1358">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1358">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="18d9c-1359">Pour plus d’informations sur `IDispatch::GetTypeInfoCount`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1359">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="18d9c-1360">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1360">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _TypeBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _TypeBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_TypeBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.Invoke(System.UInt32,System.Guid,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="18d9c-1361">Identifie le membre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1361">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="18d9c-1362">Réservé à un usage ultérieur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1362">Reserved for future use.</span>
          </span>
          <span data-ttu-id="18d9c-1363">Doit être IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1363">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="18d9c-1364">Contexte des paramètres régionaux dans lequel interpréter les arguments.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1364">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="18d9c-1365">Indicateurs décrivant le contexte de l'appel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1365">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="18d9c-1366">Pointeur vers une structure qui contient un tableau d’arguments, un tableau d’arguments DISPID pour les arguments nommés et le nombre d’éléments de chaque tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1366">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="18d9c-1367">Pointeur vers l'emplacement où le résultat doit être stocké.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1367">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="18d9c-1368">Pointeur vers une structure qui contient les informations sur les exceptions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1368">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="18d9c-1369">Index du premier argument comportant une erreur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1369">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18d9c-1370">Fournit l'accès aux propriétés et aux méthodes exposées par un objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1370">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1371">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1371">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="18d9c-1372">Pour plus d’informations sur `IDispatch::Invoke`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1372">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="18d9c-1373">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1373">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="typeBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1374">Retourne le nom du type sans l’espace de noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1374">Returns the name of the type excluding the namespace.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18d9c-1375">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1375">Read-only.</span>
          </span>
          <span data-ttu-id="18d9c-1376">Nom du type sans l’espace de noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1376">The name of the type excluding the namespace.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1377">Non pris en charge dans les modules dynamiques.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1377">Not supported in dynamic modules.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1378">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1378">Read-only.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18d9c-1379">Récupérer le type à l’aide <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.</span><span class="sxs-lookup"><span data-stu-id="18d9c-1379">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="18d9c-1380">Non pris en charge dans les modules dynamiques.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1380">Not supported in dynamic modules.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken TypeToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.TypeToken TypeToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeToken As TypeToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::TypeToken TypeToken { System::Reflection::Emit::TypeToken get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeToken : System.Reflection.Emit.TypeToken" Usage="System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1381">Retourne le jeton de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1381">Returns the type token of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1382">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1382">Read-only.</span>
          </span>
          <span data-ttu-id="18d9c-1383">Retourne <see langword="TypeToken" /> de ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1383">Returns the <see langword="TypeToken" /> of this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-1384">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1384">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1385">Retourne le type de système sous-jacent pour ce <see langword="TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1385">Returns the underlying system type for this <see langword="TypeBuilder" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18d9c-1386">Lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1386">Read-only.</span>
          </span>
          <span data-ttu-id="18d9c-1387">Retourne le type de système sous-jacent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1387">Returns the underlying system type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18d9c-1388">Ce type est une énumération, mais il n’y a pas de type de système sous-jacent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1388">This type is an enumeration, but there is no underlying system type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UnspecifiedTypeSize">
      <MemberSignature Language="C#" Value="public const int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 UnspecifiedTypeSize = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberSignature Language="VB.NET" Value="Public Const UnspecifiedTypeSize As Integer  = 0" />
      <MemberSignature Language="C++ CLI" Value="public: int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="F#" Value="val mutable UnspecifiedTypeSize : int" Usage="System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="18d9c-1389">Signifie que la taille totale du type n’est pas spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18d9c-1389">Represents that total size for the type is not specified.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>