<Type Name="TypeBuilder" FullName="System.Reflection.Emit.TypeBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0a3d455de9bd4fc2bafe3221ec13aeb7bd4ade87" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30471003" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class TypeBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit TypeBuilder extends System.Reflection.TypeInfo implements class System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.TypeBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeBuilder&#xA;Inherits TypeInfo&#xA;Implements _TypeBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeBuilder sealed : System::Reflection::TypeInfo, System::Runtime::InteropServices::_TypeBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0">System.Type</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._TypeBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._TypeBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Définit et crée des instances de classes pendant l’exécution.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder> la classe racine est utilisée pour contrôler la création de classes dynamiques dans le runtime. Il fournit un ensemble de routines qui sont utilisées pour définir des classes, ajouter des méthodes et des champs et créer la classe à l’intérieur d’un module. Un nouveau <xref:System.Reflection.Emit.TypeBuilder> peuvent être créés à partir d’un module dynamique en appelant le <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> (méthode), qui retourne un <xref:System.Reflection.Emit.TypeBuilder> objet.  
  
 Émission de réflexion fournit les options suivantes pour définir des types :  
  
-   Définissez une classe ou une interface avec le nom donné.  
  
-   Définissez une classe ou une interface avec le nom et les attributs.  
  
-   Définissez une classe avec le nom, attributs et la classe de base.  
  
-   Définissez une classe avec le nom donné, attributs, la classe de base et le jeu d’interfaces que la classe implémente.  
  
-   Définissez une classe avec le nom, attributs, la classe de base et taille de compression.  
  
-   Définissez une classe avec le nom donné, attributs, la classe de base et la taille de la classe dans son ensemble.  
  
-   Définissez une classe avec le nom donné, attributs, la classe de base, taille de compression et la taille de la classe dans son ensemble.  
  
 Pour créer un type tableau, un type pointeur ou un type byref pour un type incomplet représenté par un <xref:System.Reflection.Emit.TypeBuilder> de l’objet, utilisez le <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> (méthode), <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> (méthode), ou <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> (méthode), respectivement.  
  
 Avant d’utiliser un type, le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> méthode doit être appelée. **CreateType** complète la création du type. Après l’appel de **CreateType**, l’appelant peut instancier le type à l’aide de la <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (méthode) et d’appeler des membres du type à l’aide de la <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> (méthode). Il s’agit d’une erreur pour appeler des méthodes qui modifient l’implémentation d’un type après **CreateType** a été appelée. Par exemple, le common language runtime lève une exception si l’appelant tente d’ajouter de nouveaux membres à un type.  
  
 Un initialiseur de classe est créé à l’aide de la <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> (méthode). **DefineTypeInitializer** retourne un <xref:System.Reflection.Emit.ConstructorBuilder> objet.  
  
 Les types imbriqués sont définis en appelant une de le <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> méthodes.  
  
## <a name="attributes"></a>Attributs  
 Le <xref:System.Reflection.Emit.TypeBuilder> classe utilise le <xref:System.Reflection.TypeAttributes> énumération pour spécifier les caractéristiques du type à créer :  
  
-   Les interfaces sont spécifiées à l’aide de la <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> et <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> attributs.  
  
-   Les classes concrètes (les classes qui ne peuvent pas être étendus) sont spécifiés à l’aide de la <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> attribut.  
  
-   Plusieurs attributs déterminent la visibilité du type. Consultez la description de le <xref:System.Reflection.TypeAttributes> énumération.  
  
-   Si <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> est spécifié, le chargeur de classes dispose les champs dans l’ordre qu’ils sont lus à partir des métadonnées. Le chargeur de classes considère la taille de compression spécifiés, mais ignore tout offset de champ spécifié. Les métadonnées conservent l’ordre dans lequel les définitions de champ sont émises. Même à travers une fusion, les métadonnées ne réorganisent pas les définitions de champ. Le chargeur honorera l’offsets de champ spécifié uniquement si <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> est spécifié.  
  
## <a name="known-issues"></a>Problèmes connus  
  
-   Émission de réflexion ne vérifie pas si une classe non abstraite qui implémente une interface a implémenté toutes les méthodes déclarées dans l’interface. Toutefois, si la classe n’implémente pas toutes les méthodes déclarées dans une interface, le runtime ne charge pas la classe.  
  
-   Bien que <xref:System.Reflection.Emit.TypeBuilder> est dérivée de <xref:System.Type>, certaines des méthodes abstraites définies dans le <xref:System.Type> classe ne sont pas totalement implémentées dans le <xref:System.Reflection.Emit.TypeBuilder> classe. Les appels à ces <xref:System.Reflection.Emit.TypeBuilder> méthodes lèvent une <xref:System.NotSupportedException> exception. La fonctionnalité souhaitée peut être obtenue en extrayant le type créé à l’aide de la <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et de la réflexion sur le type récupéré.  
  
   
  
## Examples  
 Cette section contient deux exemples de code. Le premier exemple montre comment créer un type dynamique avec un champ, un constructeur, une propriété et une méthode. Le deuxième exemple crée une méthode dynamique à partir de l’entrée d’utilisateur.  
  
 **Exemple 1**  
  
 L’exemple de code suivant montre comment définir un assembly dynamique avec un seul module. Le module dans l’assembly de l’exemple contient un seul type, `MyDynamicType`, qui a un champ privé, une propriété qui obtient et définit le champ privé, constructeurs qui initialisent le champ privé et une méthode qui multiplie un nombre fourni par l’utilisateur par le champ privé valeur et retourne le résultat.  
  
 Le <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> champ est spécifié lors de la création de l’assembly. Le code assembleur est utilisé immédiatement, et l’assembly est également enregistré sur disque afin qu’il puisse être examiné par [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) ou utilisées dans un autre programme.  
  
 [!code-cpp[AssemblyBuilderClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 **Exemple deux**  
  
 L’exemple de code suivant montre comment générer un type dynamique à l’aide de `TypeBuilder`.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">Action de sécurité à prendre telle que Demand, Assert, etc.</param>
        <param name="pset">Jeu d’autorisations auquel la mesure s’applique.</param>
        <summary>Ajoute la sécurité déclarative à ce type.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `AddDeclarativeSecurity` peut être appelée plusieurs fois à chaque appel spécifiant une action de sécurité (par exemple, à la demande, Assert ou Deny) et un jeu d’autorisations qui s’appliquent à l’action.  
  
> [!NOTE]
>  Dans les versions 1.0, 1.1 et 2.0 du .NET Framework, les attributs de sécurité déclarative appliqués à un type à l’aide de cette méthode sont stockés dans l’ancien format de métadonnées XML.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la `AddDeclarativeSecurity` méthode pour ajouter une demande de sécurité <xref:System.Security.Permissions.SecurityPermission> avec la <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> indicateur à un type dynamique nommé `MyDynamicClass`, dans un assembly nommé EmittedExample.dll. L’exemple ne produit aucune sortie de console ; une fois que vous l’exécutez, vous pouvez utiliser [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner EmittedExample.dll. Dans `MyDynamicClass`, ouvrez le `.class public auto ansi` instruction pour vérifier l’autorisation déclarative.  
  
 [!code-cpp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CPP/typebuilder_adddeclarativesecurity.cpp#1)]
 [!code-csharp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CS/typebuilder_adddeclarativesecurity.cs#1)]
 [!code-vb[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/VB/typebuilder_adddeclarativesecurity.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L’<paramref name="action" /> n’est pas valide (<see langword="RequestMinimum" />, <see langword="RequestOptional" /> et <see langword="RequestRefuse" /> ne sont pas valides).</exception>
        <exception cref="T:System.InvalidOperationException">Le type conteneur a été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - ou -  
  
 Le jeu d’autorisations <paramref name="pset" /> contient une action qui a déjà été ajoutée par <see langword="AddDeclarativeSecurity" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pset" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddInterfaceImplementation">
      <MemberSignature Language="C#" Value="public void AddInterfaceImplementation (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInterfaceImplementation(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddInterfaceImplementation (interfaceType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddInterfaceImplementation(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Interface implémentée par ce type.</param>
        <summary>Ajoute une interface implémentée par ce type.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant illustre l’implémentation d’une interface sur un type créé dynamiquement à l’aide de `AddInterfaceImplementation`.  
  
 [!code-cpp[TypeBuilder_Sample_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#3)]
 [!code-csharp[TypeBuilder_Sample_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#3)]
 [!code-vb[TypeBuilder_Sample_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Récupère l’assembly dynamique qui contient la définition de ce type.</summary>
        <value>Lecture seule. Récupère l’assembly dynamique qui contient la définition de ce type.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne le nom complet de ce type, qualifié par le nom complet de l'assembly.</summary>
        <value>Lecture seule. Nom complet de ce type qualifié par le nom complet de l'assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le format de la chaîne retournée est la concaténation du nom complet du type (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) et le nom complet de l’assembly (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), séparés par une virgule et un espace.  
  
 Consultez <xref:System.Reflection.AssemblyName> pour obtenir une description du format du nom d’affichage d’un assembly.  
  
## <a name="version-information"></a>Informations sur la version  
 Dans les versions 1.0 et 1.1 du .NET Framework, la valeur de cette propriété n’inclut pas la culture ou la clé publique.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ BaseType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Récupère le type de base de ce type.</summary>
        <value>Lecture seule. Récupère le type de base de ce type.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateType">
      <MemberSignature Language="C#" Value="public Type CreateType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type CreateType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateType" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ CreateType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un objet <see cref="T:System.Type" /> pour la classe. Après avoir défini les champs et les méthodes sur la classe, <see langword="CreateType" /> est appelé pour charger son objet <see langword="Type" />.</summary>
        <returns>Retourne le nouvel objet <see cref="T:System.Type" /> pour cette classe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si ce type est un type imbriqué, le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode doit être appelée sur le type englobant avant qu’elle est appelée pour le type imbriqué.  
  
 Si le type actuel dérive d’un type incomplet ou implémente des interfaces incomplètes, appelez le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode sur le type parent et les types d’interfaces avant de l’appeler sur le type actuel.  
  
 Si le type englobant contient un champ qui est un type de valeur défini comme un type imbriqué (par exemple, un champ qui est une énumération définie comme un type imbriqué), appel de la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode sur le type englobant génère un <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> événement. Il s’agit, car le chargeur ne peut pas déterminer la taille du type englobant jusqu'à ce que le type imbriqué a été effectué. L’appelant doit définir un gestionnaire pour le <xref:System.AppDomain.TypeResolve> événement de fin de la définition du type imbriqué en appelant <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> sur la <xref:System.Reflection.Emit.TypeBuilder> objet qui représente le type imbriqué. L’exemple de code de cette rubrique montre comment définir cet un gestionnaire d’événements.  
  
 Un type est créé qu’une seule fois, quelle que soit la procédure autant de fois la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode est appelée. Tous les appels retournent le même <xref:System.Type> objet.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir un gestionnaire d’événements pour le <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> événement, afin d’appeler le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode sur un type imbriqué pendant un <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> appeler sur le type englobant.  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CPP/nestedenum.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CS/nestedenum.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/VB/nestedenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le type englobant n’a pas été créé.  
  
 - ou -  
  
 Ce type est non abstrait et contient une méthode abstraite.  
  
 - ou -  
  
 Ce type n’est pas une classe abstraite ni une interface et contient une méthode sans corps de méthode.</exception>
        <exception cref="T:System.NotSupportedException">Le type contient un code MSIL (Microsoft Intermediate Language) non valide.  
  
 - ou -  
  
 La cible de branche est spécifiée à l’aide d’un offset de 1 octet, mais la cible est à une distance supérieure à 127 octets de la branche.</exception>
        <exception cref="T:System.TypeLoadException">Impossible de charger le type. Par exemple, il contient une méthode <see langword="static" /> avec la convention d’appel <see cref="F:System.Reflection.CallingConventions.HasThis" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTypeInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeInfo CreateTypeInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.TypeInfo CreateTypeInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateTypeInfo () As TypeInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::TypeInfo ^ CreateTypeInfo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Reflection.TypeInfo" /> qui représente ce type.</summary>
        <returns>Objet qui représente ce type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la méthode qui a déclaré le paramètre de type générique actuel.</summary>
        <value>
          <see cref="T:System.Reflection.MethodBase" /> qui représente la méthode qui a déclaré le type actuel, si celui-ci est un paramètre de type générique ; sinon, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Lors de l’émission de code, un paramètre de type générique est représenté par un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objet plutôt que par un <xref:System.Reflection.Emit.TypeBuilder> objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne le type qui a déclaré ce type.</summary>
        <value>Lecture seule. Type qui a déclaré ce type.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineConstructor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute un nouveau constructeur au type dynamique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="attributes">Attributs du constructeur.</param>
        <param name="callingConvention">Convention d’appel du constructeur.</param>
        <param name="parameterTypes">Types de paramètre du constructeur.</param>
        <summary>Ajoute un nouveau constructeur au type avec les attributs donnés et la signature.</summary>
        <returns>Constructeur défini.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous ne définissez pas un constructeur pour votre type dynamique, un constructeur par défaut est fourni automatiquement, et il appelle le constructeur par défaut de la classe de base.  
  
 Si vous définissez un constructeur pour votre type dynamique, un constructeur par défaut n’est pas fourni. Vous disposez des options suivantes pour fournir un constructeur par défaut, outre le constructeur que vous avez défini :  
  
-   Si vous souhaitez un constructeur par défaut qui appelle simplement le constructeur par défaut de la classe de base, vous pouvez utiliser la <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> méthode à créer (et éventuellement y restreindre l’accès). Ne fournissez pas d’implémentation pour ce constructeur par défaut. Si vous le faites, une exception est levée lorsque vous essayez d’utiliser le constructeur. Aucune exception n’est levée lorsque la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode est appelée.  
  
-   Si vous souhaitez que le constructeur par défaut ne plus que simplement appeler le constructeur par défaut de la classe de base, qui appelle un autre constructeur de la classe de base, ou qu’il effectue quelque chose d’autre, vous devez utiliser le <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> pour créer un, méthode et fournir votre propre implémentation.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de `DefineConstructor` signature spécifique et les attributs d’un constructeur sur un type dynamique et retourner un <xref:System.Reflection.Emit.ConstructorBuilder> pour alimentation MSIL.  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes, class System.Type[][] requiredCustomModifiers, class System.Type[][] optionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type(), requiredCustomModifiers As Type()(), optionalCustomModifiers As Type()()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ requiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ optionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="attributes">Attributs du constructeur.</param>
        <param name="callingConvention">Convention d’appel du constructeur.</param>
        <param name="parameterTypes">Types de paramètres du constructeur.</param>
        <param name="requiredCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés obligatoires pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
        <param name="optionalCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
        <summary>Ajoute un nouveau constructeur au type, avec les attributs, la signature et les modificateurs personnalisés donnés.</summary>
        <returns>Constructeur défini.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est fournie pour les concepteurs de compilateurs managés.  
  
> [!NOTE]
>  Pour plus d’informations sur les modificateurs personnalisés, consultez la documentation de métadonnées ECMA Partition II. La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La taille de <paramref name="requiredCustomModifiers" /> ou <paramref name="optionalCustomModifiers" /> n’est pas égale à la taille de <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a été créé précédemment à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - ou -  
  
 Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDefaultConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor (System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor(valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDefaultConstructor (attributes As MethodAttributes) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineDefaultConstructor(System::Reflection::MethodAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">Objet <see langword="MethodAttributes" /> représentant les attributs à appliquer au constructeur.</param>
        <summary>Définit le constructeur par défaut. Le constructeur défini ici appelle simplement le constructeur par défaut du parent.</summary>
        <returns>Retourne le constructeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné que le constructeur par défaut est défini automatiquement, il est nécessaire d’appeler cette méthode uniquement dans les situations suivantes :  
  
-   Vous avez défini un autre constructeur et que vous souhaitez également un constructeur par défaut qui appelle simplement le constructeur de classe de base.  
  
-   Vous souhaitez définir les attributs du constructeur par défaut à un élément autre que <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, et <xref:System.Reflection.MethodAttributes.RTSpecialName>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de `DefineConstructor` signature spécifique et les attributs d’un constructeur sur un type dynamique et retourner un <xref:System.Reflection.Emit.ConstructorBuilder> pour alimentation MSIL.  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le type parent (type de base) n’a pas de constructeur par défaut.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - ou -  
  
 Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EventBuilder DefineEvent (string name, System.Reflection.EventAttributes attributes, Type eventtype);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EventBuilder DefineEvent(string name, valuetype System.Reflection.EventAttributes attributes, class System.Type eventtype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineEvent (name As String, attributes As EventAttributes, eventtype As Type) As EventBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::EventBuilder ^ DefineEvent(System::String ^ name, System::Reflection::EventAttributes attributes, Type ^ eventtype);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EventBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.EventAttributes" />
        <Parameter Name="eventtype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l'événement. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="attributes">Attributs de l’événement.</param>
        <param name="eventtype">Type de l’événement.</param>
        <summary>Ajoute un nouvel événement au type avec le nom, les attributs et le type d’événement donnés.</summary>
        <returns>Événement défini.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="eventtype" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute un nouveau champ au type dynamique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">Nom du champ. <c>fieldName</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="type">Type du champ</param>
        <param name="attributes">Attributs du type.</param>
        <summary>Ajoute un nouveau champ au type avec les nom, attributs et type de champ donnés.</summary>
        <returns>Champ défini.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="fieldName" /> est égale à zéro.  
  
 - ou -  
  
 <paramref name="type" /> est System.Void.  
  
 - ou -  
  
 Une taille totale a été spécifiée pour la classe parente de ce champ.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fieldName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, class System.Type[] requiredCustomModifiers, class System.Type[] optionalCustomModifiers, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, cli::array &lt;Type ^&gt; ^ requiredCustomModifiers, cli::array &lt;Type ^&gt; ^ optionalCustomModifiers, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">Nom du champ. <c>fieldName</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="type">Type du champ</param>
        <param name="requiredCustomModifiers">Tableau de types représentant les modificateurs personnalisés pour le champ, tels que <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
        <param name="optionalCustomModifiers">Tableau de types représentant les modificateurs personnalisés facultatifs pour le champ, tels que <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
        <param name="attributes">Attributs du type.</param>
        <summary>Ajoute un nouveau champ au type avec le nom, les attributs, le type de champ et les modificateurs personnalisés donnés.</summary>
        <returns>Champ défini.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est fournie pour les concepteurs de compilateurs managés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="fieldName" /> est égale à zéro.  
  
 - ou -  
  
 <paramref name="type" /> est System.Void.  
  
 - ou -  
  
 Une taille totale a été spécifiée pour la classe parente de ce champ.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fieldName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">Tableau de noms de paramètres de type générique.</param>
        <summary>Définit les paramètres de type générique pour le type actuel, en spécifiant leur nombre et leurs noms, et retourne un tableau d’objets <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> pouvant être utilisés pour définir leurs contraintes.</summary>
        <returns>Tableau d’objets <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> pouvant être utilisés pour définir les contraintes des paramètres de type générique pour le type actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette méthode rend le type actuel un type générique. Si la méthode est appelée à nouveau sur le même type, un <xref:System.InvalidOperationException> est levée.  
  
   
  
## Examples  
 L’exemple de code suivant crée un type générique avec deux paramètres de type et les enregistre dans l’assembly GenericEmitExample1.dll. Vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour afficher les types générés. Pour obtenir une explication plus détaillée des étapes impliquées dans la définition d’un type générique dynamique, consultez [Comment : définir un Type générique avec l’émission de réflexion](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).  
  
 [!code-cpp[EmitGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#1)]
 [!code-csharp[EmitGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#1)]
 [!code-vb[EmitGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Des paramètres de type générique ont déjà été définis pour ce type.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="names" /> est <see langword="null" />.  
  
 - ou -  
  
 Un élément de <paramref name="names" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="names" /> est un tableau vide.</exception>
        <altmember cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineInitializedData (name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineInitializedData(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Nom utilisé pour faire référence aux données. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="data">Objet blob de données.</param>
        <param name="attributes">Attributs du champ.</param>
        <summary>Définit un champ de données non initialisées dans la section .sdata du fichier exécutable portable (PE).</summary>
        <returns>Champ pour référencer les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le champ que vous créez avec cette méthode est `static`, même si vous n’incluez pas `FieldAttributes.Static` dans le `attributes` paramètre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.  
  
 - ou -  
  
 La taille des données est inférieure ou égale à zéro, ou supérieure ou égale à 0x3f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ou <paramref name="data" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelé précédemment.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute une méthode au type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la méthode. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="attributes">Attributs de la méthode.</param>
        <summary>Ajoute une nouvelle méthode au type, avec le nom et les attributs de méthode spécifiés.</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.MethodBuilder" /> représentant la méthode récemment définie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge de méthode lorsque vous ne connaissez pas la signature de méthode au moment que vous définissez la méthode. Par exemple, les types de paramètre et le type de retour d’une méthode générique peuvent être spécifiés par les paramètres de type générique de la méthode, qui doivent être définis une fois que la méthode a été ajoutée au type. Les paramètres et le type de retour de la méthode peuvent être définies ultérieurement à l’aide du <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> (méthode).  
  
 Cette surcharge de méthode définit une méthode avec <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>. Si vous avez besoin de définir une méthode sans signature, avec une autre convention d’appel, utiliser le <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> surcharge de méthode.  
  
   
  
## Examples  
 L’exemple de code suivant définit une méthode générique nommée `DemoMethod` dont le type de paramètre et type de retour sont spécifiés par ses paramètres de type générique. La méthode est définie sans signature, à l’aide de la convention d’appel standard. Le <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> méthode est utilisée pour rendre `DemoMethod` une méthode générique et les paramètres de type récemment définie sont ensuite utilisés pour la signature et le type de retour.  
  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> (méthode).  
  
 [!code-cpp[GenericMethodBuilder#4](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#4)]
 [!code-csharp[GenericMethodBuilder#4](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#4)]
 [!code-vb[GenericMethodBuilder#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#4)]  
[!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
[!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
[!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.  
  
 - ou -  
  
 Le type du parent de cette méthode est une interface, et cette méthode n’est pas virtuelle (<see langword="Overridable" /> en Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - ou -  
  
 Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la méthode. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="attributes">Attributs de la méthode.</param>
        <param name="callingConvention">Convention d’appel de la méthode.</param>
        <summary>Ajoute une nouvelle méthode au type, avec le nom, les attributs de méthode et la convention d’appel spécifiés.</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.MethodBuilder" /> représentant la méthode récemment définie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge de méthode lorsque vous ne connaissez pas la signature de méthode au moment que vous définissez la méthode. Par exemple, les types de paramètre et le type de retour d’une méthode générique peuvent être spécifiés par les paramètres de type générique de la méthode, qui doivent être définis une fois que la méthode a été ajoutée au type. Les paramètres et le type de retour de la méthode peuvent être définies ultérieurement à l’aide du <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.  
  
 - ou -  
  
 Le type du parent de cette méthode est une interface, et cette méthode n’est pas virtuelle (<see langword="Overridable" /> en Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - ou -  
  
 Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la méthode. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="attributes">Attributs de la méthode.</param>
        <param name="returnType">Type de retour de la méthode.</param>
        <param name="parameterTypes">Types des paramètres de la méthode.</param>
        <summary>Ajoute une nouvelle méthode au type, avec le nom, les attributs de méthode et la signature de méthode spécifiés.</summary>
        <returns>Méthode définie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de `DefineMethod` pour définir une signature spécifique et les attributs d’un constructeur sur un type dynamique et retourner un <xref:System.Reflection.Emit.MethodBuilder> pour alimentation MSIL.  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.  
  
 - ou -  
  
 Le type du parent de cette méthode est une interface, et cette méthode n’est pas virtuelle (<see langword="Overridable" /> en Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - ou -  
  
 Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la méthode. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="attributes">Attributs de la méthode.</param>
        <param name="callingConvention">Convention d’appel de la méthode.</param>
        <param name="returnType">Type de retour de la méthode.</param>
        <param name="parameterTypes">Types des paramètres de la méthode.</param>
        <summary>Ajoute une nouvelle méthode au type, avec le nom, les attributs de méthode, la convention d’appel et la signature de méthode spécifiés.</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.MethodBuilder" /> représentant la méthode récemment définie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de `DefineMethod` pour définir une signature spécifique et les attributs d’un constructeur sur un type dynamique et retourner un <xref:System.Reflection.Emit.MethodBuilder> pour alimentation MSIL.  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.  
  
 - ou -  
  
 Le type du parent de cette méthode est une interface, et cette méthode n’est pas virtuelle (<see langword="Overridable" /> en Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - ou -  
  
 Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la méthode. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="attributes">Attributs de la méthode.</param>
        <param name="callingConvention">Convention d’appel de la méthode.</param>
        <param name="returnType">Type de retour de la méthode.</param>
        <param name="returnTypeRequiredCustomModifiers">Tableau de types représentant les modificateurs personnalisés requis, tels qu’<see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la méthode. Si le type de retour ne possède pas de modificateur personnalisé requis, spécifiez <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Tableau de types représentant les modificateurs personnalisés facultatifs, tels qu’<see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la méthode. Si le type de retour ne possède pas de modificateur personnalisé facultatif, spécifiez <see langword="null" />.</param>
        <param name="parameterTypes">Types des paramètres de la méthode.</param>
        <param name="parameterTypeRequiredCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés obligatoires pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
        <param name="parameterTypeOptionalCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
        <summary>Ajoute une nouvelle méthode au type avec les nom, attributs de méthode, convention d’appel, signature de méthode et modificateurs personnalisés spécifiés.</summary>
        <returns>Objet <see cref="T:System.Reflection.Emit.MethodBuilder" /> représentant la nouvelle méthode ajoutée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge si vous devez spécifier des modificateurs personnalisés. Si vous devez spécifier des modificateurs personnalisés une fois que la méthode a été créée, comme vous le feriez pour, par exemple, avec une méthode générique dont les types de paramètre sont spécifiés par ses paramètres de type générique, vous pouvez utiliser la <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> ou <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> pour définir les surcharges de méthode la méthode, puis utiliser le <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> méthode pour définir le paramètre et retourner les types avec des modificateurs personnalisés.  
  
> [!NOTE]
>  Pour plus d’informations sur les modificateurs personnalisés, consultez la documentation de métadonnées ECMA Partition II. La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.  
  
 - ou -  
  
 Le type du parent de cette méthode est une interface, et cette méthode n’est pas virtuelle (<see langword="Overridable" /> en Visual Basic).  
  
 - ou -  
  
 La taille de <paramref name="parameterTypeRequiredCustomModifiers" /> ou <paramref name="parameterTypeOptionalCustomModifiers" /> n’est pas égale à la taille de <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - ou -  
  
 Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethodOverride">
      <MemberSignature Language="C#" Value="public void DefineMethodOverride (System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineMethodOverride(class System.Reflection.MethodInfo methodInfoBody, class System.Reflection.MethodInfo methodInfoDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineMethodOverride (methodInfoBody As MethodInfo, methodInfoDeclaration As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineMethodOverride(System::Reflection::MethodInfo ^ methodInfoBody, System::Reflection::MethodInfo ^ methodInfoDeclaration);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodInfoBody" Type="System.Reflection.MethodInfo" />
        <Parameter Name="methodInfoDeclaration" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="methodInfoBody">Corps de méthode à utiliser. Il doit s’agir d’un objet <see langword="MethodBuilder" />.</param>
        <param name="methodInfoDeclaration">Méthode dont la déclaration doit être utilisée.</param>
        <summary>Spécifie un corps de méthode donné qui implémente une déclaration de méthode donnée, éventuellement avec un nom différent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 N’utilisez pas cette méthode pour émettre des substitutions de méthodes ou des implémentations d’interface. Pour substituer une méthode de classe de base ou d’implémenter une méthode d’une interface, émettez simplement une méthode avec le même nom et la même signature que la méthode substituée ou implémentée, comme illustré dans l’exemple de code.  
  
 Le <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> méthode est utilisée lorsque le corps d’une méthode et une déclaration de méthode ont des noms différents. Par exemple, une classe peut substituer une méthode de classe de base et également fournir une implémentation distincte pour un membre d’interface portant le même nom, comme illustré dans l’exemple de code.  
  
 `DefineMethodOverride` définit un `methodimpl`, qui se compose d’une paire de jetons de métadonnées. Un jeton pointe vers une implémentation et l’autre jeton pointe vers une déclaration implémentée par le corps. Le corps doit être défini sur le type de la méthode impl est définie, et le corps doit être virtuel (`Overridable` en Visual Basic). La déclaration peut être faite à une méthode définie sur une interface implémentée par le type, une méthode sur une classe dérivée ou une méthode définie dans le type. Si la déclaration se trouve sur une interface uniquement, l’emplacement défini pour l’interface est modifié. Si la déclaration est effectuée à une méthode sur un type de base, l’emplacement de la méthode est substitué et tous les doublons de la méthode substituée sont également remplacés. La méthode substituée ne peut pas être la méthode actuelle qui est déclarée. Si la méthode est sur le même type, l’emplacement est remplacé, et tous les doublons des méthodes remplacées sont substitués.  
  
> [!NOTE]
>  Pour plus d’informations sur les méthodes impl, consultez `MethodImpl` dans la documentation de métadonnées ECMA Partition II. La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
> [!IMPORTANT]
>  Après le <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> méthode est appelée, certaines fonctionnalités de `methodInfoBody` ne peut pas être modifié. Par exemple, vous ne peut pas appliquer un attribut à un paramètre de type générique de `methodInfoBody` à l’aide de la <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> (méthode). Si vous devez utiliser le <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> (méthode), faire une fois toutes les caractéristiques de `methodInfoBody` ont été définies.  
  
   
  
## Examples  
 L’exemple de code suivant contient une interface `I` avec une méthode `M()`, une classe de base `A` qui implémente l’interface et une classe dérivée `C` qui substitue l’implémentation de classe de base de `M()` et également Fournit une implémentation distincte et explicite de `I.M()`.  
  
 Le `main()` méthode de l’exemple de code montre comment émettre la classe dérivée `C`. La substitution de `A.M()` est accomplie en émettant simplement une méthode `M()` avec la même signature. Toutefois, pour fournir une implémentation distincte de `I.M()`, vous devez définir un corps de méthode, puis utiliser le <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> méthode permet d’associer ce corps de méthode avec un <xref:System.Reflection.MethodInfo> représentant `I.M()`. Le nom du corps de méthode n’a pas d’importance.  
  
 L’exemple de code crée une instance de la classe émise. Il obtient un <xref:System.Reflection.MethodInfo> pour l’objet `I.M()`, et l’utilise pour appeler la classe émise explicite de la mise en œuvre de l’interface. Il obtient ensuite un <xref:System.Reflection.MethodInfo> pour l’objet `A.M()`et l’utilise pour appeler la substitution de cette méthode de la classe émise.  
  
 [!code-cpp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cpp/source.cpp#1)]
 [!code-csharp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cs/source.cs#1)]
 [!code-vb[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="methodInfoBody" /> n’appartient pas à cette classe.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="methodInfoBody" /> ou <paramref name="methodInfoDeclaration" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - ou -  
  
 Le type déclarant de <paramref name="methodInfoBody" /> n’est pas le type représenté par ce <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineNestedType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit un type imbriqué.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom court du type. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <summary>Définit un type imbriqué, en fonction de son nom.</summary>
        <returns>Type imbriqué défini.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour créer une prédiction imbriquée types même après la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode a été appelée sur le type englobant.  
  
 Le type imbriqué doit être terminée avant que vous pouvez réfléchir à l’aide de <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.  
  
 Consultez la description de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> pour l’ordre dans lequel les types imbriqués et imbrication doit être effectuée.  
  
 Un nom en double n’est pas nécessairement créé si `name` est identique au nom d’un type précédemment défini ou imbriqué. Pour être des doublons, le nom complet doit être identique, y compris l’espace de noms et tous les types d’imbrication.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1023.  
  
 - ou -  
  
 Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Nom court du type. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="attr">Attributs du type.</param>
        <summary>Définit un type imbriqué, en fonction de son nom et de ses attributs.</summary>
        <returns>Type imbriqué défini.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour créer une prédiction imbriquée types même après la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode a été appelée sur le type englobant.  
  
 Le type imbriqué doit être terminée avant que vous pouvez réfléchir à l’aide de <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.  
  
 Consultez la description de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> pour l’ordre dans lequel les types imbriqués et imbrication doit être effectuée.  
  
 Un nom en double n’est pas nécessairement créé si `name` est identique au nom d’un type précédemment défini ou imbriqué. Pour être des doublons, le nom complet doit être identique, y compris l’espace de noms et tous les types d’imbrication.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’attribut imbriqué n’est pas spécifié.  
  
 - ou -  
  
 Ce type est scellé.  
  
 - ou -  
  
 Ce type est un tableau.  
  
 - ou -  
  
 Ce type est une interface, mais le type imbriqué n’est pas une interface.  
  
 - ou -  
  
 La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1 023.  
  
 - ou -  
  
 Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nom court du type. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="attr">Attributs du type.</param>
        <param name="parent">Type étendu par le type imbriqué.</param>
        <summary>Définit un type imbriqué, en fonction de son nom, de ses attributs et du type qu’il étend.</summary>
        <returns>Type imbriqué défini.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour créer une prédiction imbriquée types même après la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode a été appelée sur le type englobant.  
  
 Le type imbriqué doit être terminée avant que vous pouvez réfléchir à l’aide de <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.  
  
 Consultez la description de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> pour l’ordre dans lequel les types imbriqués et imbrication doit être effectuée.  
  
 Un nom en double n’est pas nécessairement créé si `name` est identique au nom d’un type précédemment défini ou imbriqué. Pour être des doublons, le nom complet doit être identique, y compris l’espace de noms et tous les types d’imbrication.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’attribut imbriqué n’est pas spécifié.  
  
 - ou -  
  
 Ce type est scellé.  
  
 - ou -  
  
 Ce type est un tableau.  
  
 - ou -  
  
 Ce type est une interface, mais le type imbriqué n’est pas une interface.  
  
 - ou -  
  
 La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1 023.  
  
 - ou -  
  
 Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, int typeSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Nom court du type. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="attr">Attributs du type.</param>
        <param name="parent">Type étendu par le type imbriqué.</param>
        <param name="typeSize">Taille totale du type.</param>
        <summary>Définit un type imbriqué, en fonction de son nom, de ses attributs, de la taille totale du type et du type qu’il étend.</summary>
        <returns>Type imbriqué défini.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour créer une prédiction imbriquée types même après la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode a été appelée sur le type englobant.  
  
 Le type imbriqué doit être terminée avant que vous pouvez réfléchir à l’aide de <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.  
  
 Consultez la description de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> pour l’ordre dans lequel les types imbriqués et imbrication doit être effectuée.  
  
 Un nom en double n’est pas nécessairement créé si `name` est identique au nom d’un type précédemment défini ou imbriqué. Pour être des doublons, le nom complet doit être identique, y compris l’espace de noms et tous les types d’imbrication.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’attribut imbriqué n’est pas spécifié.  
  
 - ou -  
  
 Ce type est scellé.  
  
 - ou -  
  
 Ce type est un tableau.  
  
 - ou -  
  
 Ce type est une interface, mais le type imbriqué n’est pas une interface.  
  
 - ou -  
  
 La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1 023.  
  
 - ou -  
  
 Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">Nom court du type. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="attr">Attributs du type.</param>
        <param name="parent">Type étendu par le type imbriqué.</param>
        <param name="packSize">Taille de compression du type.</param>
        <summary>Définit un type imbriqué, en fonction de son nom, de ses attributs, du type qu’il étend et de la taille de compression.</summary>
        <returns>Type imbriqué défini.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour créer une prédiction imbriquée types même après la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode a été appelée sur le type englobant.  
  
 Le type imbriqué doit être terminée avant que vous pouvez réfléchir à l’aide de <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.  
  
 Consultez la description de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> pour l’ordre dans lequel les types imbriqués et imbrication doit être effectuée.  
  
 Un nom en double n’est pas nécessairement créé si `name` est identique au nom d’un type précédemment défini ou imbriqué. Pour être des doublons, le nom complet doit être identique, y compris l’espace de noms et tous les types d’imbrication.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’attribut imbriqué n’est pas spécifié.  
  
 - ou -  
  
 Ce type est scellé.  
  
 - ou -  
  
 Ce type est un tableau.  
  
 - ou -  
  
 Ce type est une interface, mais le type imbriqué n’est pas une interface.  
  
 - ou -  
  
 La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1 023.  
  
 - ou -  
  
 Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, cli::array &lt;Type ^&gt; ^ interfaces);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nom court du type. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="attr">Attributs du type.</param>
        <param name="parent">Type étendu par le type imbriqué.</param>
        <param name="interfaces">Interfaces implémentées par le type imbriqué.</param>
        <summary>Définit un type imbriqué, en fonction de son nom, de ses attributs, du type qu’il étend et des interfaces qu’il implémente.</summary>
        <returns>Type imbriqué défini.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour créer une prédiction imbriquée types même après la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode a été appelée sur le type englobant.  
  
 Le type imbriqué doit être terminée avant que vous pouvez réfléchir à l’aide de <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.  
  
 Consultez la description de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> pour l’ordre dans lequel les types imbriqués et imbrication doit être effectuée.  
  
 Un nom en double n’est pas nécessairement créé si `name` est identique au nom d’un type précédemment défini ou imbriqué. Pour être des doublons, le nom complet doit être identique, y compris l’espace de noms et tous les types d’imbrication.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’attribut imbriqué n’est pas spécifié.  
  
 - ou -  
  
 Ce type est scellé.  
  
 - ou -  
  
 Ce type est un tableau.  
  
 - ou -  
  
 Ce type est une interface, mais le type imbriqué n’est pas une interface.  
  
 - ou -  
  
 La longueur de <paramref name="name" /> est égale à zéro ou supérieure à 1 023.  
  
 - ou -  
  
 Cette opération permet de créer un type avec un <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> en double dans l’assembly actuel.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.  
  
 - ou -  
  
 Un élément du tableau <paramref name="interfaces" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize, int typeSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Nom court du type. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="attr">Attributs du type.</param>
        <param name="parent">Type étendu par le type imbriqué.</param>
        <param name="packSize">Taille de compactage du type.</param>
        <param name="typeSize">Taille totale du type.</param>
        <summary>Définit un type imbriqué, en fonction de ses nom, attributs, taille et du type qu’il étend.</summary>
        <returns>Type imbriqué défini.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefinePInvokeMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit une méthode <see langword="PInvoke" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la méthode <see langword="PInvoke" />. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="dllName">Nom de la DLL dans laquelle la méthode <see langword="PInvoke" /> est définie.</param>
        <param name="attributes">Attributs de la méthode.</param>
        <param name="callingConvention">Convention d’appel de la méthode.</param>
        <param name="returnType">Type de retour de la méthode.</param>
        <param name="parameterTypes">Types des paramètres de la méthode.</param>
        <param name="nativeCallConv">Convention d’appel native.</param>
        <param name="nativeCharSet">Jeu de caractères natif de la méthode.</param>
        <summary>Définit une méthode <see langword="PInvoke" /> en fonction de son nom, du nom de la DLL dans laquelle elle est définie, des attributs de la méthode, de sa convention d’appel, de son type de retour, des types de ses paramètres et des indicateurs <see langword="PInvoke" />.</summary>
        <returns>Méthode <see langword="PInvoke" /> définie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attributs d’importation de certaines DLL (consultez la description de <xref:System.Runtime.InteropServices.DllImportAttribute>) ne peut pas être spécifié en tant qu’arguments à cette méthode. Par exemple, la DLL Importer attribut <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> doit être ajouté après le `PInvoke` méthode est créée, si la méthode retourne une valeur. L’exemple montre comment effectuer cette opération.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> méthode pour créer un `PInvoke` (méthode) et comment ajouter la <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> indicateur pour les indicateurs d’implémentation de méthode après avoir créé le <xref:System.Reflection.Emit.MethodBuilder>, à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> et <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>méthodes.  
  
> [!IMPORTANT]
>  Pour obtenir une valeur de retour différente de zéro, vous devez ajouter le <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> indicateur.  
  
 L’exemple crée un assembly dynamique avec un module dynamique et un type unique, `MyType`, qui contient le `PInvoke` (méthode). Le `PInvoke` méthode représente Win32 `GetTickCount` (fonction).  
  
 Lorsque l’exemple est exécuté, il exécute la `PInvoke` (méthode). Elle enregistre également l’assembly dynamique comme PInvokeTest.dll. Vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner la `MyType` classe et le `static` (`Shared` en Visual Basic) `PInvoke` méthode qu’il contient. Vous pouvez compiler un programme Visual Basic ou c# qui utilise la méthode statique `MyType.GetTickCount` méthode en incluant une référence à la DLL lorsque vous exécutez csc.exe ou vbc.exe ; par exemple, `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La méthode n’est pas statique.  
  
 - ou -  
  
 Le type parent est une interface.  
  
 - ou -  
  
 La méthode est de type abstract.  
  
 - ou -  
  
 La méthode a déjà été définie.  
  
 - ou -  
  
 La longueur de <paramref name="name" /> ou <paramref name="dllName" /> est de zéro.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ou <paramref name="dllName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type conteneur a déjà été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la méthode <see langword="PInvoke" />. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="dllName">Nom de la DLL dans laquelle la méthode <see langword="PInvoke" /> est définie.</param>
        <param name="entryName">Nom du point d’entrée dans la DLL.</param>
        <param name="attributes">Attributs de la méthode.</param>
        <param name="callingConvention">Convention d’appel de la méthode.</param>
        <param name="returnType">Type de retour de la méthode.</param>
        <param name="parameterTypes">Types des paramètres de la méthode.</param>
        <param name="nativeCallConv">Convention d’appel native.</param>
        <param name="nativeCharSet">Jeu de caractères natif de la méthode.</param>
        <summary>Définit une méthode <see langword="PInvoke" /> en fonction de son nom, du nom de la DLL dans laquelle elle est définie, du nom du point d’entrée, des attributs de la méthode, de sa convention d’appel, de son type de retour, des types de ses paramètres et des indicateurs <see langword="PInvoke" />.</summary>
        <returns>Méthode <see langword="PInvoke" /> définie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attributs d’importation de certaines DLL (consultez la description de <xref:System.Runtime.InteropServices.DllImportAttribute>) ne peut pas être spécifié en tant qu’arguments à cette méthode. Par exemple, la DLL Importer attribut <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> doit être ajouté après le `PInvoke` méthode est créée, si la méthode retourne une valeur. L’exemple montre comment effectuer cette opération.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> méthode pour créer un `PInvoke` (méthode) et comment ajouter la <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> indicateur pour les indicateurs d’implémentation de méthode après avoir créé le <xref:System.Reflection.Emit.MethodBuilder>, à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> et <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> méthodes.  
  
> [!IMPORTANT]
>  Pour obtenir une valeur de retour différente de zéro, vous devez ajouter le <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> indicateur.  
  
 L’exemple crée un assembly dynamique avec un module dynamique et un type unique, `MyType`, qui contient le `PInvoke` (méthode). Le `PInvoke` méthode représente Win32 `GetTickCount` (fonction).  
  
 Lorsque l’exemple est exécuté, il exécute la `PInvoke` (méthode). Elle enregistre également l’assembly dynamique comme PInvokeTest.dll. Vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner la `MyType` classe et le `static` (`Shared` en Visual Basic) `PInvoke` méthode qu’il contient. Vous pouvez compiler un programme Visual Basic ou c# qui utilise la méthode statique `MyType.GetTickCount` méthode en incluant une référence à la DLL lorsque vous exécutez csc.exe ou vbc.exe ; par exemple, `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La méthode n’est pas statique.  
  
 - ou -  
  
 Le type parent est une interface.  
  
 - ou -  
  
 La méthode est de type abstract.  
  
 - ou -  
  
 La méthode a déjà été définie.  
  
 - ou -  
  
 La longueur de <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> est égale à zéro.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type conteneur a déjà été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la méthode <see langword="PInvoke" />. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="dllName">Nom de la DLL dans laquelle la méthode <see langword="PInvoke" /> est définie.</param>
        <param name="entryName">Nom du point d’entrée dans la DLL.</param>
        <param name="attributes">Attributs de la méthode.</param>
        <param name="callingConvention">Convention d’appel de la méthode.</param>
        <param name="returnType">Type de retour de la méthode.</param>
        <param name="returnTypeRequiredCustomModifiers">Tableau de types représentant les modificateurs personnalisés requis, tels qu’<see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la méthode. Si le type de retour ne possède pas de modificateur personnalisé requis, spécifiez <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Tableau de types représentant les modificateurs personnalisés facultatifs, tels qu’<see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la méthode. Si le type de retour ne possède pas de modificateur personnalisé facultatif, spécifiez <see langword="null" />.</param>
        <param name="parameterTypes">Types des paramètres de la méthode.</param>
        <param name="parameterTypeRequiredCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés obligatoires pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
        <param name="parameterTypeOptionalCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
        <param name="nativeCallConv">Convention d’appel native.</param>
        <param name="nativeCharSet">Jeu de caractères natif de la méthode.</param>
        <summary>Définit une méthode <see langword="PInvoke" /> en fonction de son nom, du nom de la DLL dans laquelle elle est définie, du nom du point d’entrée, des attributs de la méthode, de sa convention d’appel, de son type de retour, des types de ses paramètres, des indicateurs <see langword="PInvoke" /> et des modificateurs personnalisés des paramètres et du type de retour.</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.MethodBuilder" /> représentant la méthode <see langword="PInvoke" /> définie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attributs d’importation de certaines DLL (consultez la description de <xref:System.Runtime.InteropServices.DllImportAttribute>) ne peut pas être spécifié en tant qu’arguments à cette méthode. Par exemple, la DLL Importer attribut <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> doit être ajouté après le `PInvoke` méthode est créée, si la méthode retourne une valeur. L’exemple montre comment effectuer cette opération.  
  
> [!NOTE]
>  Pour plus d’informations sur les modificateurs personnalisés, consultez la documentation de métadonnées ECMA Partition II. La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser la [\], Type\[\], Type\[\], Type\[\]\[\], Type\[ \] \<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A > pour créer un `PInvoke` (méthode) et comment ajouter la <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> indicateur pour les indicateurs d’implémentation de méthode après avoir créé le <xref:System.Reflection.Emit.MethodBuilder>, à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> et <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> méthodes.  
  
 L’exemple crée un assembly dynamique avec un module dynamique et un type unique, `MyType`, qui contient le `PInvoke` (méthode). Le `PInvoke` méthode représente Win32 `GetTickCount` (fonction).  
  
> [!IMPORTANT]
>  Pour obtenir une valeur de retour différente de zéro, vous devez ajouter le <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> indicateur.  
  
> [!NOTE]
>  L’exemple utilise une surcharge qui ne spécifie pas de modificateurs personnalisés. Pour spécifier des modificateurs personnalisés, modifiez l’exemple de code pour utiliser cette surcharge de méthode à la place.  
  
 Lorsque l’exemple est exécuté, il exécute la `PInvoke` (méthode). Elle enregistre également l’assembly dynamique comme PInvokeTest.dll. Vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner la `MyType` classe et le `static` (`Shared` en Visual Basic) `PInvoke` méthode qu’il contient. Vous pouvez compiler un programme Visual Basic ou c# qui utilise la méthode statique `MyType.GetTickCount` méthode en incluant une référence à la DLL lorsque vous exécutez csc.exe ou vbc.exe ; par exemple, `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La méthode n’est pas statique.  
  
 - ou -  
  
 Le type parent est une interface.  
  
 - ou -  
  
 La méthode est de type abstract.  
  
 - ou -  
  
 La méthode a déjà été définie.  
  
 - ou -  
  
 La longueur de <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> est égale à zéro.  
  
 - ou -  
  
 La taille de <paramref name="parameterTypeRequiredCustomModifiers" /> ou <paramref name="parameterTypeOptionalCustomModifiers" /> n’est pas égale à la taille de <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - ou -  
  
 Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineProperty">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute une nouvelle propriété au type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la propriété. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="attributes">Attributs de la propriété.</param>
        <param name="returnType">Type de retour de la propriété.</param>
        <param name="parameterTypes">Types des paramètres de la propriété.</param>
        <summary>Ajoute une nouvelle propriété au type avec le nom et la signature de propriété donnés.</summary>
        <returns>Propriété définie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment définir une propriété dynamique et obtenir un <xref:System.Reflection.Emit.PropertyBuilder> pour la spécification. Notez qu’un `PropertyBuilder` doit également correspondre à une <xref:System.Reflection.Emit.MethodBuilder>, qui hébergera la logique IL de la propriété.  
  
 [!code-cpp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.  
  
 - ou -  
  
 Un des éléments du tableau <paramref name="parameterTypes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la propriété. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="attributes">Attributs de la propriété.</param>
        <param name="callingConvention">Convention d’appel des accesseurs de propriété.</param>
        <param name="returnType">Type de retour de la propriété.</param>
        <param name="parameterTypes">Types des paramètres de la propriété.</param>
        <summary>Ajoute une nouvelle propriété au type avec le nom, les attributs, la convention d’appel et la signature de propriété spécifiés.</summary>
        <returns>Propriété définie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.  
  
 - ou -  
  
 Un des éléments du tableau <paramref name="parameterTypes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la propriété. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="attributes">Attributs de la propriété.</param>
        <param name="returnType">Type de retour de la propriété.</param>
        <param name="returnTypeRequiredCustomModifiers">Tableau de types représentant les modificateurs personnalisés obligatoires, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la propriété. Si le type de retour ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Tableau de types représentant les modificateurs personnalisés facultatifs, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la propriété. Si le type de retour ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" />.</param>
        <param name="parameterTypes">Types des paramètres de la propriété.</param>
        <param name="parameterTypeRequiredCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés obligatoires pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
        <param name="parameterTypeOptionalCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
        <summary>Ajoute une nouvelle propriété au type, avec le nom, la signature de propriété et les modificateurs personnalisés donnés.</summary>
        <returns>Propriété définie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est fournie pour les concepteurs de compilateurs managés.  
  
> [!NOTE]
>  Pour plus d’informations sur les modificateurs personnalisés, consultez la documentation de métadonnées ECMA Partition II. La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Un des éléments du tableau <paramref name="parameterTypes" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la propriété. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="attributes">Attributs de la propriété.</param>
        <param name="callingConvention">Convention d’appel des accesseurs de propriété.</param>
        <param name="returnType">Type de retour de la propriété.</param>
        <param name="returnTypeRequiredCustomModifiers">Tableau de types représentant les modificateurs personnalisés obligatoires, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la propriété. Si le type de retour ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Tableau de types représentant les modificateurs personnalisés facultatifs, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />, pour le type de retour de la propriété. Si le type de retour ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" />.</param>
        <param name="parameterTypes">Types des paramètres de la propriété.</param>
        <param name="parameterTypeRequiredCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés obligatoires pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés obligatoires, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé requis, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
        <param name="parameterTypeOptionalCustomModifiers">Tableau de tableaux de types. Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant, comme <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un paramètre particulier ne possède pas de modificateurs personnalisés facultatifs, spécifiez <see langword="null" /> plutôt qu’un tableau de types. Si aucun paramètre ne possède de modificateur personnalisé facultatif, spécifiez <see langword="null" /> plutôt qu’un tableau de tableaux.</param>
        <summary>Ajoute une nouvelle propriété au type avec le nom, la convention d’appel, la signature de propriété et les modificateurs personnalisés spécifiés.</summary>
        <returns>Propriété définie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est fournie pour les concepteurs de compilateurs managés.  
  
> [!NOTE]
>  Pour plus d’informations sur les modificateurs personnalisés, consultez la documentation de métadonnées ECMA Partition II. La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 Cette surcharge de méthode a été introduite dans le [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.  
  
 - ou -  
  
 Un des éléments du tableau <paramref name="parameterTypes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineTypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineTypeInitializer () As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineTypeInitializer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Définit l’initialiseur de ce type.</summary>
        <returns>Retourne un initialiseur de type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’initialiseur créé est toujours public.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer un constructeur d’initialisation à l’aide `DefineTypeInitializer`.  
  
 [!code-cpp[TypeBuilder_Properties1#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Properties1/CPP/typebuilder_properties.cpp#3)]
 [!code-csharp[TypeBuilder_Properties1#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Properties1/CS/typebuilder_properties.cs#3)]
 [!code-vb[TypeBuilder_Properties1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Properties1/VB/typebuilder_properties.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le type conteneur a déjà été créé à l’aide de <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineUninitializedData (name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineUninitializedData(System::String ^ name, int size, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Nom utilisé pour faire référence aux données. <c>name</c> ne peut pas contenir de valeurs null incorporées.</param>
        <param name="size">Taille du champ de données.</param>
        <param name="attributes">Attributs du champ.</param>
        <summary>Définit un champ de données non initialisé dans la section <see langword=".sdata" /> du fichier exécutable portable (PE).</summary>
        <returns>Champ pour référencer les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le champ que vous créez avec cette méthode est `static`, même si vous n’incluez pas `FieldAttributes.Static` dans le `attributes` paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de `DefineUninitializedData` pour créer un champ de données non initialisé dans un type dynamique :  
  
 [!code-cpp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CPP/typebuilder_defineuninitializeddata.cpp#1)]
 [!code-csharp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CS/typebuilder_defineuninitializeddata.cs#1)]
 [!code-vb[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/VB/typebuilder_defineuninitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="name" /> est égale à zéro.  
  
 - ou -  
  
 <paramref name="size" /> est inférieur ou égal à zéro, ou supérieur ou égal à 0x003f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Récupère le chemin complet de ce type.</summary>
        <value>Lecture seule. Récupère le chemin complet de ce type.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le format retourné est « NomCompletTypeEnglobant + NomTypeImbriqué » pour les types imbriqués et « NomType » pour les types non imbriqués.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique la covariance et les contraintes spéciales du paramètre de type générique actuel.</summary>
        <value>Combinaison d'opérations de bits de valeurs <see cref="T:System.Reflection.GenericParameterAttributes" /> qui décrit la covariance et les contraintes spéciales du paramètre de type générique actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Lors de l’émission de code, un paramètre de type générique est représenté par un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objet plutôt que par un <xref:System.Reflection.Emit.TypeBuilder> objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public override int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la position d’un paramètre de type dans la liste des paramètres de type du type générique qui a déclaré le paramètre.</summary>
        <value>Si l’objet courant <see cref="T:System.Reflection.Emit.TypeBuilder" /> représente un paramètre de type générique, la position du paramètre de type dans la liste des paramètres de type du type générique qui a déclaré le paramètre ; sinon, non défini.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Lors de l’émission de code, un paramètre de type générique est représenté par un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objet plutôt que par un <xref:System.Reflection.Emit.TypeBuilder> objet.  
  
 Si le courant <xref:System.Reflection.Emit.TypeBuilder> ne représente pas un paramètre de type générique, la valeur de cette propriété n’est pas définie. Utilisez le <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> propriété pour déterminer si actuel <xref:System.Reflection.Emit.TypeBuilder> représente un paramètre de type générique.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public override Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public override int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetArrayRank();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public static System.Reflection.ConstructorInfo GetConstructor (Type type, System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.ConstructorInfo GetConstructor(class System.Type type, class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::ConstructorInfo ^ GetConstructor(Type ^ type, System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="type">Type générique construit dont le constructeur est retourné.</param>
        <param name="constructor">Constructeur sur la définition de type générique de <c>type</c>, qui spécifie le constructeur de <c>type</c> à retourner.</param>
        <summary>Retourne le constructeur du type générique construit spécifié qui correspond au constructeur spécifié de la définition de type générique.</summary>
        <returns>Objet <see cref="T:System.Reflection.ConstructorInfo" /> qui représente le constructeur de <paramref name="type" /> correspondant à <paramref name="constructor" />, qui spécifie un constructeur appartenant à la définition de type générique de <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> méthode offre un moyen pour obtenir un <xref:System.Reflection.ConstructorInfo> objet qui représente un constructeur d’un type générique construit dont la définition de type générique est représentée par un <xref:System.Reflection.Emit.TypeBuilder> objet.  
  
 Par exemple, supposons que vous ayez un <xref:System.Reflection.Emit.TypeBuilder> objet qui représente le type `G<T>` en syntaxe c# (`G(Of T)` en Visual Basic, `generic <T> ref class G` en C++) et un <xref:System.Reflection.Emit.ConstructorBuilder> objet qui représente un constructeur de `G<T>`. Supposons que `G<T>` possède une méthode générique avec un paramètre de type `U` qui crée une instance du type construit `G<U>`. Pour émettre le code pour créer une instance du type construit, vous avez besoin une <xref:System.Reflection.ConstructorInfo> de construire l’objet qui représente le constructeur de ce type, en d’autres termes, qui crée une instance de `G<U>`. Pour ce faire, appelez d’abord la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode sur le <xref:System.Reflection.Emit.TypeBuilder> de l’objet, en spécifiant le <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objet qui représente `U` comme argument de type. Puis appelez le <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> méthode avec la valeur de retour de la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode en tant que paramètre `type` et <xref:System.Reflection.Emit.ConstructorBuilder> objet qui représente le constructeur de `G<U>` en tant que paramètre `constructor`. La valeur de retour est la <xref:System.Reflection.ConstructorInfo> vous avez besoin émettre l’appel de fonction de l’objet. L’exemple de code illustre ce scénario.  
  
   
  
## Examples  
 L’exemple de code suivant contient le code source pour une classe générique nommée `Sample` qui a un paramètre de type nommé `T`. La classe possède un champ nommé `Field`, de type `T`et une méthode générique nommée `GM` avec son propre paramètre de type nommé `U`. Méthode `GM` crée une instance de `Sample`, en remplaçant son propre paramètre de type `U` pour le paramètre de type `Sample`, puis stocke son paramètre d’entrée dans `Field`. Ce code source est compilé mais pas utilisé ; Vous pouvez l’afficher avec les [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) et la comparer au code émis par la classe `Example`.  
  
 Le code de classe `Example` illustre l’utilisation de la <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> méthode d’émettre du code générique. Le `Main` méthode de classe `Example` crée un assembly dynamique qui contient une classe nommée `Sample` et utilise le <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> méthode pour le rendre générique en ajoutant un paramètre de type nommé `T`. Un constructeur par défaut et un champ nommé `Field`, de type `T`, sont ajoutés à la classe `Sample`. Une méthode `GM` est ajoutée et transformée en une méthode générique à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> (méthode). Le paramètre de type `GM` est nommé `U`. Une fois que le paramètre de type est défini, la signature de `GM` est ajouté à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> (méthode). Il y a aucun type de retour et non nécessaires ou de modificateurs personnalisés, par conséquent, tous les paramètres de cette méthode sont `null` sauf `parameterTypes`; `parameterTypes` définit le type de seul paramètre la méthode `U`, paramètre de type générique de la méthode. Le corps de la méthode crée une instance du type construit `Sample<U>` (`Sample(Of U)` en Visual Basic), affecte le paramètre de la méthode à `Field`, puis imprime la valeur de `Field`. Le <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> méthode est utilisée pour créer un <xref:System.Reflection.ConstructorInfo> qui représente le constructeur par défaut du type générique construit `Sample<U>` dans la <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> instruction qui crée l’instance.  
  
 Un type factice est défini pour contenir la méthode de point d’entrée `Main`. Dans le corps de `Main`, statiques `GM` méthode est appelée sur le type générique construit `Sample<int>` (`Sample(Of Integer)` en Visual Basic), avec le type <xref:System.String> substitué par `U`.  
  
 Lorsque l’exemple de code est exécuté, il enregistre l’assembly émis en tant que TypeBuilderGetFieldExample.exe. Vous pouvez exécuter TypeBuilderGetFieldExample.exe, et vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour comparer le code émis avec le code pour le `Sample` classe qui est compilé dans l’exemple de code lui-même.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> ne représente pas un type générique.  
  
 - ou -  
  
 <paramref name="type" /> n'est pas de type <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 - ou -  
  
 Le type déclarant de <paramref name="constructor" /> n’est pas une définition de type générique.  
  
 - ou -  
  
 Le type déclarant de <paramref name="constructor" /> n’est pas la définition de type générique de <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Il doit s'agir d'un bit indicateur de <see cref="T:System.Reflection.BindingFlags" />, comme dans <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
        <summary>Retourne un tableau d'objets <see cref="T:System.Reflection.ConstructorInfo" /> représentant les constructeurs publics et non publics définis pour cette classe, comme spécifié.</summary>
        <returns>Retourne un tableau d'objets <see cref="T:System.Reflection.ConstructorInfo" /> représentant les constructeurs spécifiés définis pour cette classe. Si aucun constructeur n’est défini, un tableau vide est retourné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne les attributs personnalisés définis pour ce type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Spécifie s’il faut rechercher les attributs dans la chaîne d’héritage de ce membre.</param>
        <summary>Retourne tous les attributs personnalisés définis pour ce type.</summary>
        <returns>Retourne un tableau d’objets représentant tous les attributs personnalisés de ce type.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge actuellement pour les types incomplets. Vous pouvez récupérer le type à l'aide de <see cref="M:System.Type.GetType" />, puis appeler <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> sur le <see cref="T:System.Type" /> retourné.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Type d’attribut à rechercher. Seuls les attributs qui peuvent être assignés à ce type sont retournés.</param>
        <param name="inherit">Spécifie s’il faut rechercher les attributs dans la chaîne d’héritage de ce membre.</param>
        <summary>Retourne tous les attributs personnalisés du type actuel qui peuvent être assignés à un type spécifié.</summary>
        <returns>Tableau d’attributs personnalisés définis sur le type actuel.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge actuellement pour les types incomplets. Vous pouvez récupérer le type à l'aide de <see cref="M:System.Type.GetType" />, puis appeler <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> sur le <see cref="T:System.Type" /> retourné.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le type doit être un type fourni par le système runtime sous-jacent.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetElementType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>L'appel de cette méthode lève toujours <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Cette méthode n'est pas prise en charge. Aucune valeur n'est retournée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l’événement à rechercher.</param>
        <param name="bindingAttr">Combinaison d'opérations de bits de valeurs <see cref="T:System.Reflection.BindingFlags" /> qui limite la recherche.</param>
        <summary>Retourne l’événement avec le nom spécifié.</summary>
        <returns>Objet <see cref="T:System.Reflection.EventInfo" /> représentant l'événement déclaré ou hérité par ce type avec le nom spécifié, ou <see langword="null" /> s'il n'existe aucune correspondance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne les événements définis par le <see cref="T:System.Reflection.Emit.TypeBuilder" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne les événements publics déclarés ou hérités par ce type.</summary>
        <returns>Retourne un tableau d'objets <see cref="T:System.Reflection.EventInfo" /> représentant les événements publics déclarés ou hérités par ce type. Un tableau vide est retourné s’il n’existe aucun événement public.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetType%2A> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Combinaison d'opérations de bits de valeurs <see cref="T:System.Reflection.BindingFlags" /> qui limite la recherche.</param>
        <summary>Retourne les événements publics et non publics déclarés par ce type.</summary>
        <returns>Retourne un tableau d'objets <see cref="T:System.Reflection.EventInfo" /> représentant les événements déclarés ou hérités par ce type qui correspondent aux indicateurs de liaisons spécifiés. Un tableau vide est retourné s’il n’existe aucun événement correspondant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un champ défini par le <see cref="T:System.Reflection.Emit.TypeBuilder" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Nom du champ à obtenir.</param>
        <param name="bindingAttr">Il doit s'agir d'un bit indicateur de <see cref="T:System.Reflection.BindingFlags" />, comme dans <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
        <summary>Retourne le champ spécifié par le nom donné.</summary>
        <returns>Retourne l'objet <see cref="T:System.Reflection.FieldInfo" /> représentant le champ déclaré ou hérité par ce type, avec le nom et le modificateur public ou non public spécifiés. En l'absence de correspondances, <see langword="null" /> est retournée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetField (Type type, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetField(class System.Type type, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetField(Type ^ type, System::Reflection::FieldInfo ^ field);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="type">Type générique construit dont la méthode est retournée.</param>
        <param name="field">Champ sur la définition de type générique de <c>type</c>, qui spécifie le champ de <c>type</c> à retourner.</param>
        <summary>Retourne le champ du type générique construit spécifié qui correspond au champ spécifié de la définition de type générique.</summary>
        <returns>Objet <see cref="T:System.Reflection.FieldInfo" /> qui représente le champ de <paramref name="type" /> correspondant à <paramref name="field" />, qui spécifie un champ appartenant à la définition de type générique de <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> méthode offre un moyen pour obtenir un <xref:System.Reflection.FieldInfo> objet qui représente un champ d’un type générique construit dont la définition de type générique est représentée par un <xref:System.Reflection.Emit.TypeBuilder> objet.  
  
 Par exemple, supposons que vous ayez un <xref:System.Reflection.Emit.TypeBuilder> objet qui représente le type `G<T>` en syntaxe c# (`G(Of T)` en Visual Basic, `generic <T> ref class G` en C++) et un <xref:System.Reflection.Emit.FieldBuilder> objet qui représente un champ `public T F` en syntaxe c# (`Public F As T`en Visual Basic, `public: T F` en C++) qui est défini par `G<T>`. Supposons que `G<T>` possède une méthode générique avec un paramètre de type `U` qui crée une instance du type construit `G<U>` et appelle le champ `F` sur cette instance. Pour émettre l’appel de fonction, vous avez besoin une <xref:System.Reflection.FieldInfo> objet qui représente `F` sur le type construit : en d’autres termes, qui est de type `U` plutôt que de type `T`. Pour ce faire, appelez d’abord la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode sur le <xref:System.Reflection.Emit.TypeBuilder> de l’objet, en spécifiant le <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objet qui représente `U` comme argument de type. Puis appelez le <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> méthode avec la valeur de retour de la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode en tant que paramètre `type` et <xref:System.Reflection.Emit.FieldBuilder> objet qui représente `F` en tant que paramètre `field`. La valeur de retour est la <xref:System.Reflection.FieldInfo> vous avez besoin émettre l’appel de fonction de l’objet. L’exemple de code illustre ce scénario.  
  
   
  
## Examples  
 L’exemple de code suivant contient le code source pour une classe générique nommée Sample qui possède un paramètre de type nommé `T`. La classe possède un champ nommé `Field`, de type `T`et une méthode générique nommée `GM` avec son propre paramètre de type nommé `U`. Méthode `GM` crée une instance de `Sample`, en remplaçant son propre paramètre de type `U` pour le paramètre de type `Sample`, puis stocke son paramètre d’entrée dans `Field`. Ce code source est compilé mais pas utilisé ; Vous pouvez l’afficher avec les [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) et la comparer au code émis par la classe `Example`.  
  
 Le code de classe `Example` illustre l’utilisation de la <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> méthode d’émettre du code générique. Le `Main` méthode de classe `Example` crée un assembly dynamique qui contient une classe nommée `Sample`et utilise le <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> méthode pour le rendre générique en ajoutant un paramètre de type nommé `T`. Un constructeur par défaut et un champ nommé `Field`, de type `T`, sont ajoutés à la classe `Sample`. Une méthode `GM` est ajoutée et transformée en une méthode générique à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> (méthode). Le paramètre de type `GM` est nommé `U`. Une fois que le paramètre de type est défini, la signature de `GM` est ajouté à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> (méthode). Il y a aucun type de retour et non nécessaires ou de modificateurs personnalisés, par conséquent, tous les paramètres de cette méthode sont `null` sauf `parameterTypes`; `parameterTypes` définit le type de seul paramètre la méthode `U`, paramètre de type générique de la méthode. Le corps de la méthode crée une instance du type construit `Sample<U>` (`Sample(Of U)` en Visual Basic), affecte le paramètre de la méthode à `Field`, puis imprime la valeur de `Field`. Le <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> méthode est utilisée pour créer un <xref:System.Reflection.FieldInfo> qui représente le champ du type générique construit `Sample<U>` dans les <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> et <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> des instructions.  
  
 Un type factice est défini pour contenir la méthode de point d’entrée `Main`. Dans le corps de `Main`, statiques `GM` méthode est appelée sur le type générique construit `Sample<int>` (`Sample(Of Integer)` en Visual Basic), avec le type <xref:System.String> substitué par `U`.  
  
 Lorsque l’exemple de code est exécuté, il enregistre l’assembly émis en tant que TypeBuilderGetFieldExample.exe. Vous pouvez exécuter TypeBuilderGetFieldExample.exe, et vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour comparer le code émis avec le code pour le `Sample` classe qui est compilé dans l’exemple de code lui-même.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> ne représente pas un type générique.  
  
 - ou -  
  
 <paramref name="type" /> n'est pas de type <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 - ou -  
  
 Le type déclarant de <paramref name="field" /> n’est pas une définition de type générique.  
  
 - ou -  
  
 Le type déclarant de <paramref name="field" /> n’est pas la définition de type générique de <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Il doit s'agir d'un bit indicateur de <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
        <summary>Retourne les champs publics et non publics déclarés par ce type.</summary>
        <returns>Retourne un tableau d'objets <see cref="T:System.Reflection.FieldInfo" /> représentant les champs publics et non publics déclarés ou hérités par ce type. Un tableau vide est retourné s’il n’existe aucun champ, comme indiqué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> méthode ne retourne pas les champs dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent de l’ordre dans lequel les champs sont retournés, car cet ordre peut varier.  
  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un tableau d'objets <see cref="T:System.Type" /> qui représentent les arguments de type d'un type générique ou les paramètres de type d'une définition de type générique.</summary>
        <returns>Tableau d'objets <see cref="T:System.Type" />. Les éléments du tableau représentent les arguments de type d’un type générique ou les paramètres de type d’une définition de type générique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments du tableau retourné sont dans l’ordre dans lequel elles apparaissent dans la liste des paramètres de type pour la définition de type générique.  
  
 A <xref:System.Reflection.Emit.TypeBuilder> objet représente une définition de type générique, si le <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> méthode a été utilisée afin de lui donner des paramètres de type générique. Cette méthode récupère le <xref:System.Reflection.Emit.GenericTypeParameterBuilder> les objets qui représentent les paramètres de type générique.  
  
 Pour plus d’informations sur les types génériques dans la réflexion et une liste des conditions invariantes pour les termes utilisés dans la réflexion générique, consultez la <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericArguments" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetGenericTypeDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Type" /> qui représente une définition de type générique à partir de laquelle le type actuel peut être obtenu.</summary>
        <returns>Objet <see cref="T:System.Type" /> qui représente une définition de type générique à partir de laquelle le type actuel peut être obtenu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous appelez le <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> méthode sur un <xref:System.Reflection.Emit.TypeBuilder> objet pour lequel le <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> propriété renvoie `true`, le <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> propriété retourne l’instance actuelle. A <xref:System.Reflection.Emit.TypeBuilder> que représente un type générique est toujours une définition de type générique.  
  
 Si vous avez utilisé le <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode pour construire un type générique à partir d’un <xref:System.Reflection.Emit.TypeBuilder> objet qui représente une définition de type générique, à l’aide de la <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> méthode sur le type construit récupère le <xref:System.Reflection.Emit.TypeBuilder> objet qui représente le type générique définition.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le type actuel n’est pas générique. Autrement dit, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> retourne <see langword="false" />.</exception>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l’interface.</param>
        <param name="ignoreCase">Si <see langword="true" />, la recherche ne respecte pas la casse. Si <see langword="false" />, la recherche respecte la casse.</param>
        <summary>Retourne l’interface implémentée (directement ou indirectement) par cette classe avec le nom qualifié complet correspondant au nom de l’interface donnée.</summary>
        <returns>Retourne un objet <see cref="T:System.Type" /> représentant l'interface implémentée. Retourne null si aucun nom d’interface correspondant n’est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <see cref="T:System.Type" /> de l'interface dont le mappage doit être récupéré.</param>
        <summary>Retourne un mappage d’interface pour l’interface demandée.</summary>
        <returns>Retourne le mappage d’interface demandé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un tableau de toutes les interfaces implémentées sur ce type et ses types de base.</summary>
        <returns>Retourne un tableau d'objets <see cref="T:System.Type" /> représentant les interfaces implémentées. Si aucune interface n’est définie, un tableau vide est retourné.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Nom du membre.</param>
        <param name="type">Type du membre à retourner.</param>
        <param name="bindingAttr">Il doit s'agir d'un bit indicateur de <see cref="T:System.Reflection.BindingFlags" />, comme dans <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
        <summary>Retourne tous les membres publics et non publics déclarés ou hérités par ce type, comme indiqué.</summary>
        <returns>Retourne un tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant les membres publics et non publics définis sur ce type si <paramref name="nonPublic" /> est utilisé ; sinon, seuls les membres publics sont retournés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Il doit s'agir d'un indicateur binaire de <see cref="T:System.Reflection.BindingFlags" />, tel que <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
        <summary>Retourne les membres publics et non publics déclarés ou hérités par ce type.</summary>
        <returns>Retourne un tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant les membres publics et non publics déclarés ou hérités par ce type. Un tableau vide est retourné s’il n’existe aucun membre correspondant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodInfo GetMethod (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodInfo GetMethod(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodInfo ^ GetMethod(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">Type générique construit dont la méthode est retournée.</param>
        <param name="method">Méthode sur la définition de type générique de <c>type</c>, qui spécifie la méthode de <c>type</c> à retourner.</param>
        <summary>Retourne la méthode du type générique construit spécifié qui correspond à la méthode spécifiée de la définition de type générique.</summary>
        <returns>Objet <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode de <paramref name="type" /> correspondant à <paramref name="method" />, qui spécifie une méthode appartenant à la définition de type générique de <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> méthode offre un moyen pour obtenir un <xref:System.Reflection.MethodInfo> objet qui représente une méthode d’un type générique construit dont la définition de type générique est représentée par un <xref:System.Reflection.Emit.TypeBuilder> objet.  
  
 Par exemple, supposons que vous ayez un <xref:System.Reflection.Emit.TypeBuilder> objet qui représente le type `G<T>` en syntaxe c# (`G(Of T)` en Visual Basic, `generic <T> ref class G` en C++) et un <xref:System.Reflection.Emit.MethodBuilder> objet qui représente une méthode `T M()` en syntaxe c# (`Function M() As T`en Visual Basic, `T M()` en C++) qui est défini par `G<T>`. Supposons que `G<T>` possède une méthode générique avec un paramètre de type `U` qui crée une instance du type construit `G<U>` et appelle la méthode `M` sur cette instance. Pour émettre l’appel de fonction, vous avez besoin une <xref:System.Reflection.MethodInfo> objet qui représente `M` sur le type construit : en d’autres termes, qui retourne le type `U` plutôt que de type `T`. Pour ce faire, appelez d’abord la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode sur le <xref:System.Reflection.Emit.TypeBuilder> de l’objet, en spécifiant le <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objet qui représente `U` comme argument de type. Puis appelez le <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> méthode avec la valeur de retour de la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode en tant que paramètre `type` et <xref:System.Reflection.Emit.MethodBuilder> objet qui représente `T M()` en tant que paramètre `method`. La valeur de retour est la <xref:System.Reflection.MethodInfo> vous avez besoin émettre l’appel de fonction de l’objet. L’exemple de code illustre un scénario semblable à celle-ci.  
  
   
  
## Examples  
 L’exemple de code suivant contient le code source pour une classe générique nommée `Sample` qui a un paramètre de type nommé `T`. La classe possède un champ nommé `Field`, de type `T`et une méthode générique nommée `GM` avec son propre paramètre de type nommé `U`. Méthode `GM` crée une instance de `Sample`, en remplaçant son propre paramètre de type `U` pour le paramètre de type `Sample`, puis stocke son paramètre d’entrée dans `Field`. Ce code source est compilé mais pas utilisé ; Vous pouvez l’afficher avec les [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) et la comparer au code émis par la classe `Example`.  
  
 Le code de classe `Example` illustre l’utilisation de la <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> méthode d’émettre du code générique. Le `Main` méthode de classe `Example` crée un assembly dynamique qui contient une classe nommée `Sample` et utilise le <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> méthode pour le rendre générique en ajoutant un paramètre de type nommé `T`. Un constructeur par défaut et un champ nommé `Field`, de type `T`, sont ajoutés à la classe `Sample`. Une méthode `GM` est ajoutée et transformée en une méthode générique à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> (méthode). Le paramètre de type `GM` est nommé `U`. Une fois que le paramètre de type est défini, la signature de `GM` est ajouté à l’aide de la <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> (méthode). Il y a aucun type de retour et non nécessaires ou de modificateurs personnalisés, par conséquent, tous les paramètres de cette méthode sont `null` sauf `parameterTypes`; `parameterTypes` définit le type de seul paramètre la méthode `U`, paramètre de type générique de la méthode. Le corps de la méthode crée une instance du type construit `Sample<U>` (`Sample(Of U)` en Visual Basic), affecte le paramètre de la méthode à `Field`, puis imprime la valeur de `Field`. Un type factice est défini pour contenir la méthode de point d’entrée `Main`. Dans le corps de `Main`, statiques `GM` méthode est appelée sur le type générique construit `Sample<int>` (`Sample(Of Integer)` en Visual Basic), avec le type <xref:System.String> substitué par `U`. Le <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> méthode est utilisée pour créer un <xref:System.Reflection.MethodInfo> pour la méthode statique `GM` méthode du type générique construit `Sample<U>`et le <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> méthode est ensuite utilisée pour créer un <xref:System.Reflection.MethodInfo> pouvant être émis dans un appel de méthode.  
  
 Lorsque l’exemple de code est exécuté, il enregistre l’assembly émis en tant que TypeBuilderGetFieldExample.exe. Vous pouvez exécuter TypeBuilderGetFieldExample.exe, et vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour comparer le code émis avec le code pour le `Sample` classe qui est compilé dans l’exemple de code lui-même.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> est une méthode générique qui n’est pas une définition de méthode générique.  
  
 - ou -  
  
 <paramref name="type" /> ne représente pas un type générique.  
  
 - ou -  
  
 <paramref name="type" /> n'est pas de type <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 - ou -  
  
 Le type déclarant de <paramref name="method" /> n’est pas une définition de type générique.  
  
 - ou -  
  
 Le type déclarant de <paramref name="method" /> n’est pas la définition de type générique de <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Il doit s'agir d'un bit indicateur de <see cref="T:System.Reflection.BindingFlags" />, comme dans <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
        <summary>Retourne toutes les méthodes publiques et non publiques déclarées ou héritées par ce type, comme spécifié.</summary>
        <returns>Retourne un tableau d'objets <see cref="T:System.Reflection.MethodInfo" /> représentant les méthodes publiques et non publiques définies sur ce type si <paramref name="nonPublic" /> est utilisé ; sinon, seules les méthodes publiques sont retournées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> contenant le nom du type imbriqué à obtenir.</param>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
 - ou -  
  
 Zéro, pour rechercher les méthodes publiques en respectant la casse.</param>
        <summary>Retourne les types imbriqués publics et non publics déclarés par ce type.</summary>
        <returns>Objet <see cref="T:System.Type" /> qui représente le type imbriqué correspondant aux critères spécifiés, s'il existe ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 Si ce type est terminé, par exemple, si `CreateType` a été appelé sur ce type, mais il existe des types imbriqués ne sont pas terminées, puis `GetNestedTypes` retourne uniquement les types imbriqués pour lesquels `CreateType` a été appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Il doit s'agir d'un bit indicateur de <see cref="T:System.Reflection.BindingFlags" />, comme dans <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
        <summary>Retourne les types imbriqués publics et non publics déclarés ou hérités par ce type.</summary>
        <returns>Tableau d'objets <see cref="T:System.Type" /> représentant tous les types imbriqués du <see cref="T:System.Type" /> en cours qui correspondent aux contraintes de liaison spécifiées.  
  
 Tableau vide de type <see cref="T:System.Type" /> s'il n'existe aucun type imbriqué dans <see cref="T:System.Type" /> en cours ou si aucun des types imbriqués ne correspond aux contraintes de liaison.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 Si ce type est terminé, par exemple, si `CreateType` a été appelé sur ce type, mais il existe des types imbriqués ne sont pas terminées, puis `GetNestedTypes` retourne uniquement les types imbriqués pour lesquels `CreateType` a été appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Attribut de cet appel. Il doit s'agir d'un bit indicateur de <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
        <summary>Retourne toutes les propriétés publiques et non publiques déclarées ou héritées par ce type, comme spécifié.</summary>
        <returns>Retourne un tableau d'objets <see langword="PropertyInfo" /> représentant les propriétés publiques et non publiques définies sur ce type si <paramref name="nonPublic" /> est utilisé ; sinon, seules les propriétés publiques sont retournées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas implémentée pour les types incomplets.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid GUID { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Récupère le GUID de ce type.</summary>
        <value>Lecture seule. Récupère le GUID de ce type.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge actuellement pour les types incomplets.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool HasElementTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">Nom du membre à appeler. Il peut s’agir d’un constructeur, d’une méthode, d’une propriété ou d’un champ. Un attribut d’appel approprié doit être spécifié. Notez qu’il est possible d’appeler le membre par défaut d’une classe en passant une chaîne vide comme nom du membre.</param>
        <param name="invokeAttr">Attribut d’appel. Il doit s'agir d'un bit indicateur de <see langword="BindingFlags" />.</param>
        <param name="binder">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see langword="MemberInfo" /> par le biais de la réflexion. Si le binder est <see langword="null" />, le binder par défaut est utilisé. Consultez <see cref="T:System.Reflection.Binder" />.</param>
        <param name="target">Objet sur lequel appeler le membre spécifié. Si le membre est statique, ce paramètre est ignoré.</param>
        <param name="args">Liste d’arguments. Il s’agit d’un tableau d’objets contenant le nombre, l’ordre et le type des paramètres du membre à appeler. En l’absence de paramètres, il doit avoir la valeur null.</param>
        <param name="modifiers">Tableau de même longueur que <c>args</c> avec des éléments qui représentent les attributs associés aux arguments du membre à appeler. Un paramètre est associé à des attributs dans les métadonnées. Ils sont utilisés par divers services d’interopérabilité. Pour plus d’informations, consultez les spécifications des métadonnées.</param>
        <param name="culture">Instance de <see langword="CultureInfo" /> utilisée pour régir la contrainte des types. Si la valeur est null, <see langword="CultureInfo" /> du thread en cours est utilisé. (Notez que cela est nécessaire pour, par exemple, convertir une chaîne représentant 1000 en valeur double, car 1000 est représenté de différentes manières selon la culture.)</param>
        <param name="namedParameters">Chaque paramètre dans le tableau <c>namedParameters</c> obtient la valeur de l’élément correspondant dans le tableau <c>args</c>. Si la longueur de <c>args</c> est supérieure à la longueur de <c>namedParameters</c>, les valeurs d’argument restantes sont passées dans l’ordre.</param>
        <summary>Appelle le membre spécifié. La méthode à appeler doit être accessible et fournir la correspondance la plus spécifique avec la liste d’arguments spécifiée, sous les contraintes des attributs de binder et d’appel spécifiés.</summary>
        <returns>Retourne la valeur de retour du membre appelé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une méthode est appelée si le nombre de paramètres dans la déclaration de méthode est égal au nombre d’arguments dans la liste d’arguments spécifiés, et le type de chaque argument peut être converti par le binder pour le type du paramètre.  
  
 Le binder va trouver toutes les méthodes correspondantes. Ces méthodes sont recherchées en fonction du type de liaison demandé (BindingFlags.InvokeMethod, BindingFlags.GetProperties et ainsi de suite.). L’ensemble de méthodes est filtré par le nom, nombre d’arguments et un ensemble de modificateurs de recherche définis dans le classeur. Une fois que la méthode est sélectionnée, elle sera appelée. Accessibilité est vérifiée à ce stade. La recherche peut contrôler quel ensemble de méthodes est analysé en fonction de l’attribut d’accessibilité associé à la méthode. Le `IBinder.BindToMethod` méthode est chargée de sélectionner la méthode à appeler. Le binder par défaut sélectionne la correspondance la plus spécifique.  
  
> [!NOTE]
>  Restrictions d’accès sont ignorées pour le code de confiance totale. Autrement dit, propriétés, méthodes, champs et constructeurs privés sont accessibles et appelé à l’aide de la réflexion lorsque le code est entièrement fiable.  
  
 Cette méthode n’est pas prise en charge pour l’instant. Vous pouvez récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge actuellement pour les types incomplets.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsArrayImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAssignableFrom">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si un type spécifié peut être affecté à cet objet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(System::Reflection::TypeInfo ^ typeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">Objet à tester.</param>
        <summary>Obtient une valeur qui indique si un objet <see cref="T:System.Reflection.TypeInfo" /> spécifié peut être affecté à cet objet.</summary>
        <returns>
          <see langword="true" /> si <paramref name="typeInfo" /> peut être affecté à cet objet ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(Type ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Objet à tester.</param>
        <summary>Obtient une valeur qui indique si un objet <see cref="T:System.Type" /> spécifié peut être assigné à cet objet.</summary>
        <returns>
          <see langword="true" /> si le paramètre <paramref name="c" /> et le type en cours représentent le même type, ou si le type en cours se trouve dans la hiérarchie d'héritage de <paramref name="c" /> ou si le type en cours est une interface prise en charge par <paramref name="c" />. <see langword="false" /> si aucune de ces conditions sont valides, ou si <paramref name="c" /> est <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public override bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsCOMObjectImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si cet objet représente un type générique construit.</summary>
        <value>
          <see langword="true" /> si cet objet représente un type générique construit ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCreated">
      <MemberSignature Language="C#" Value="public bool IsCreated ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsCreated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCreated" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCreated () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsCreated();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si le type dynamique actuel a été créé.</summary>
        <returns>
          <see langword="true" /> si la méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> a été appelée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Après le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode a été appelée, le type représenté par la <xref:System.Reflection.Emit.TypeBuilder> objet est terminé. Les exceptions levées sur toute nouvelle tentative d’ajouter des membres ou modifier d’autres caractéristiques du type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Type d’attribut à rechercher. Seuls les attributs qui peuvent être assignés à ce type sont retournés.</param>
        <param name="inherit">Spécifie s’il faut rechercher les attributs dans la chaîne d’héritage de ce membre.</param>
        <summary>Détermine si un attribut personnalisé est appliqué au type actuel.</summary>
        <returns>
          <see langword="true" /> si une ou plusieurs instances de <paramref name="attributeType" />, ou un attribut dérivé de <paramref name="attributeType" />, sont définis sur ce type ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’est pas prise en charge pour les paramètres de type générique incomplets. Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n’est pas prise en charge actuellement pour les types incomplets. Vous pouvez récupérer le type à l'aide de <see cref="M:System.Type.GetType" />, puis appeler <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> sur le <see cref="T:System.Type" /> retourné.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />n'est pas défini.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public override bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le type actuel est un paramètre de type générique.</summary>
        <value>
          <see langword="true" /> si l’objet <see cref="T:System.Reflection.Emit.TypeBuilder" /> actuel représente un paramètre de type générique ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Lors de l’émission de code, un paramètre de type générique est représenté par un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objet plutôt que par un <xref:System.Reflection.Emit.TypeBuilder> objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public override bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le type actuel est un type générique.</summary>
        <value>
          <see langword="true" /> si le type représenté par l’objet <see cref="T:System.Reflection.Emit.TypeBuilder" /> actuel est générique ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Reflection.Emit.TypeBuilder> objet représente une définition de type générique, si le <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> méthode a été utilisée afin de lui donner des paramètres de type générique. Une instance de la <xref:System.Reflection.Emit.TypeBuilder> classe générique est toujours une définition de type générique.  
  
 Pour plus d’informations sur les types génériques dans la réflexion et une liste des conditions invariantes pour les termes utilisés dans la réflexion générique, consultez la <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le <see cref="T:System.Reflection.Emit.TypeBuilder" /> actuel représente une définition de type générique, à partir de laquelle d’autres types génériques peuvent être construits.</summary>
        <value>
          <see langword="true" /> si cet objet <see cref="T:System.Reflection.Emit.TypeBuilder" /> représente une définition de type générique ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Reflection.Emit.TypeBuilder> objet représente une définition de type générique, si le <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> méthode a été utilisée afin de lui donner des paramètres de type générique. Une instance de la <xref:System.Reflection.Emit.TypeBuilder> classe générique est toujours une définition de type générique.  
  
 Un <xref:System.Reflection.Emit.TypeBuilder> peut être utilisée pour générer des définitions de type générique, mais pas des types génériques construits. Pour obtenir un type générique construit, appelez le <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode sur un <xref:System.Reflection.Emit.TypeBuilder> qui représente une définition de type générique.  
  
 Pour plus d’informations sur les types génériques dans la réflexion et une liste des conditions invariantes pour les termes utilisés dans la réflexion générique, consultez la <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPointerImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPrimitiveImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le type actuel est critique de sécurité (security-critical) ou critique sécurisé (security-safe-critical), et peut donc effectuer des opérations critiques.</summary>
        <value>
          <see langword="true" /> si le type actuel est critique de sécurité ou critique sécurisé ; <see langword="false" /> s'il est transparent de sécurité (security-transparent).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, et <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence du type, tel que déterminé par le common language runtime (CLR). Les combinaisons de ces propriétés sont répertoriées dans le tableau suivant :  
  
|Niveau de sécurité|EstCritiqueDeSécurité|EstCritiqueSécurisé|EstTransparentDeSécurité|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critique|`true`|`false`|`false`|  
|Critique sécurisé|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.  
  
 Le runtime commence à évaluer les niveaux de transparence au niveau de l’assembly. Par exemple, si l’assembly dynamique est critique de sécurité, les annotations sur les types sont ignorées, et tous les types sont critiques de sécurité.  
  
 Par défaut, un assembly dynamique hérite de la transparence de l’assembly qui l’émet. Vous pouvez remplacer cette valeur par défaut à l’aide de la <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, ou <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> surcharge de méthode et en spécifiant les attributs de sécurité. Vous ne peut pas élever les niveaux de sécurité cela ; Autrement dit, le code transparent ne peut pas émettre du code critique de sécurité ou critique sécurisé. Attributs doivent être spécifiés lorsque l’assembly dynamique est créé, ou ils ne prennent pas effet tant que l’assembly a été enregistré sur le disque et rechargé.  
  
> [!NOTE]
>  L’héritage par défaut est limitée à l’évaluation de la transparence du runtime. Aucuns attributs ne sont appliqués à l’assembly dynamique. Si vous souhaitez ajouter des attributs de sécurité, vous devez les appliquer vous-même.  
  
 Pour plus d’informations sur la réflexion d’émission et la transparence, consultez [des problèmes de sécurité dans l’émission de réflexion](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le type dynamique actuel n'a pas été créé en appelant la méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le type actuel est critique sécurisé, autrement dit s’il peut effectuer des opérations critiques et s’il est accessible par du code transparent.</summary>
        <value>
          <see langword="true" /> si le type actuel est critique sécurisé ; <see langword="false" /> s'il est critique de sécurité ou transparent de sécurité.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, et <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence du type, tel que déterminé par le common language runtime (CLR). Les combinaisons de ces propriétés sont répertoriées dans le tableau suivant :  
  
|Niveau de sécurité|EstCritiqueDeSécurité|EstCritiqueSécurisé|EstTransparentDeSécurité|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critique|`true`|`false`|`false`|  
|Critique sécurisé|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.  
  
 Le runtime commence à évaluer les niveaux de transparence au niveau de l’assembly. Par exemple, si l’assembly dynamique est critique de sécurité, les annotations sur les types sont ignorées, et tous les types sont critiques de sécurité.  
  
 Par défaut, un assembly dynamique hérite de la transparence de l’assembly qui l’émet. Vous pouvez remplacer cette valeur par défaut à l’aide de la <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, ou <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> surcharge de méthode et en spécifiant les attributs de sécurité. Vous ne peut pas élever les niveaux de sécurité cela ; Autrement dit, le code transparent ne peut pas émettre du code critique de sécurité ou critique sécurisé. Attributs doivent être spécifiés lorsque l’assembly dynamique est créé, ou ils ne prennent pas effet tant que l’assembly a été enregistré sur le disque et rechargé.  
  
> [!NOTE]
>  L’héritage par défaut est limitée à l’évaluation de la transparence du runtime. Aucuns attributs ne sont appliqués à l’assembly dynamique. Si vous souhaitez ajouter des attributs de sécurité, vous devez les appliquer vous-même.  
  
 Pour plus d’informations sur la réflexion d’émission et la transparence, consultez [des problèmes de sécurité dans l’émission de réflexion](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le type dynamique actuel n'a pas été créé en appelant la méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le type actuel est transparent et s’il ne peut donc pas effectuer d’opérations critiques.</summary>
        <value>
          <see langword="true" /> si le type est transparent de sécurité ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, et <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence du type, tel que déterminé par le common language runtime (CLR). Les combinaisons de ces propriétés sont répertoriées dans le tableau suivant :  
  
|Niveau de sécurité|EstCritiqueDeSécurité|EstCritiqueSécurisé|EstTransparentDeSécurité|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critique|`true`|`false`|`false`|  
|Critique sécurisé|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.  
  
 Le runtime commence à évaluer les niveaux de transparence au niveau de l’assembly. Par exemple, si l’assembly dynamique est critique de sécurité, les annotations sur les types sont ignorées, et tous les types sont critiques de sécurité.  
  
 Par défaut, un assembly dynamique hérite de la transparence de l’assembly qui l’émet. Vous pouvez remplacer cette valeur par défaut à l’aide de la <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, ou <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> surcharge de méthode et en spécifiant les attributs de sécurité. Vous ne peut pas élever les niveaux de sécurité cela ; Autrement dit, le code transparent ne peut pas émettre du code critique de sécurité ou critique sécurisé. Attributs doivent être spécifiés lorsque l’assembly dynamique est créé, ou ils ne prennent pas effet tant que l’assembly a été enregistré sur le disque et rechargé.  
  
> [!NOTE]
>  L’héritage par défaut est limitée à l’évaluation de la transparence du runtime. Aucuns attributs ne sont appliqués à l’assembly dynamique. Si vous souhaitez ajouter des attributs de sécurité, vous devez les appliquer vous-même.  
  
 Pour plus d’informations sur la réflexion d’émission et la transparence, consultez [des problèmes de sécurité dans l’émission de réflexion](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le type dynamique actuel n'a pas été créé en appelant la méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public override bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public override bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubclassOf(Type ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <see cref="T:System.Type" /> à vérifier</param>
        <summary>Détermine si ce type est dérivé d’un type spécifié.</summary>
        <returns>Lecture seule. Retourne <see langword="true" /> si ce type est identique au type <paramref name="c" /> ou s'il est un sous-type du type <paramref name="c" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsValueTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Type" /> qui représente un tableau du type actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Type" /> qui représente un tableau unidimensionnel du type actuel, avec une limite inférieure de zéro.</summary>
        <returns>Objet <see cref="T:System.Type" /> représentant un type de tableau unidimensionnel dont le type d’élément est le type actuel, avec une limite inférieure de zéro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> méthode fournit un moyen de générer un type de tableau avec n’importe quel type d’élément possible, y compris les types génériques.  
  
   
  
## Examples  
 L’exemple de code suivant crée un module dynamique, un type abstrait nommé `Sample`et une méthode abstraite nommée `TestMethod`. `TestMethod` prend un `ref` paramètre (`ByRef` en Visual Basic) de type `Sample`, un pointeur vers le type `Sample`et un tableau de type `Sample`. Elle retourne un tableau à deux dimensions de type `Sample`. L’exemple de code enregistre le module dynamique sur le disque, afin de pouvoir examiner avec le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType(int rank);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">Nombre de dimensions pour le tableau.</param>
        <summary>Retourne un objet <see cref="T:System.Type" /> qui représente un tableau du type actuel, avec le nombre spécifié de dimensions.</summary>
        <returns>Objet <see cref="T:System.Type" /> qui représente un tableau unidimensionnel du type actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> méthode fournit un moyen de générer un type de tableau avec n’importe quel type d’élément possible, y compris les types génériques.  
  
   
  
## Examples  
 L’exemple de code suivant crée un module dynamique, un type abstrait nommé `Sample`et une méthode abstraite nommée `TestMethod`. `TestMethod` prend un `ref` paramètre (`ByRef` en Visual Basic) de type `Sample`, un pointeur vers le type `Sample`et un tableau de type `Sample`. Elle retourne un tableau à deux dimensions de type `Sample`. L’exemple de code enregistre le module dynamique sur le disque, afin de pouvoir examiner avec le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> n’est pas une dimension de tableau valide.</exception>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public override Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeByRefType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Type" /> qui représente le type actuel quand il est passé en tant que paramètre <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</summary>
        <returns>Objet <see cref="T:System.Type" /> qui représente le type actuel quand il est passé en tant que paramètre <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> méthode fournit un moyen de générer `ref` types (`ByRef` en Visual Basic) pour le paramètre répertorie.  
  
> [!NOTE]
>  À l’aide de la syntaxe de Microsoft intermediate language (MSIL), si le courant <xref:System.Reflection.Emit.TypeBuilder> représente `MyType`, le type retourné par cette méthode est `MyType&`.  
  
   
  
## Examples  
 L’exemple de code suivant crée un module dynamique, un type abstrait nommé `Sample`et une méthode abstraite nommée `TestMethod`. `TestMethod` prend un `ref` paramètre (`ByRef` en Visual Basic) de type `Sample`, un pointeur vers le type `Sample`et un tableau de type `Sample`. Elle retourne un tableau à deux dimensions de type `Sample`. L’exemple de code enregistre le module dynamique sur le disque, afin de pouvoir examiner avec le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public override Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Tableau de types à substituer aux paramètres de type de la définition du type générique actuel.</param>
        <summary>Substitue les éléments d’un tableau de types aux paramètres de type de la définition du type générique actuel et retourne le type construit résultant.</summary>
        <returns>
          <see cref="T:System.Type" /> représentant le type construit formé en substituant les éléments de <paramref name="typeArguments" /> pour les paramètres de type du type générique actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode lorsque votre code émis requiert un type construit à partir de la définition de type générique actuel. Il n’est pas nécessaire d’appeler le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode avant d’appeler le <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> méthode sur un <xref:System.Reflection.Emit.TypeBuilder> qui représente une définition de type générique. Si le courant <xref:System.Reflection.Emit.TypeBuilder> ne représente pas la définition d’un type générique, un <xref:System.InvalidOperationException> est levée.  
  
 L’objet retourné par cette méthode fonctionne comme un espace réservé pour un type générique construit dans votre code émis. Il s’agit d’une instance d’une classe dérivée de <xref:System.Type> qui dispose de fonctionnalités limitées. En particulier :  
  
-   Pour obtenir les méthodes, champs et des constructeurs pour ces types génériques construits, utilisez le <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, et <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> surcharges de méthode.  
  
-   Deux instances qui représentent le même type construit ne comparent pas égales. Par exemple, dans le code suivant `t1.Equals(t2)` retourne `false`:  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/vb/remarks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le type actuel ne représente pas la définition d’un type générique. Autrement dit, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> retourne <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> est <see langword="null" />.  
  
 - ou -  
  
 Tout élément de <paramref name="typeArguments" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Type.Module" /> de n’importe quel élément de <paramref name="typeArguments" /> est <see langword="null" />.  
  
 - ou -  
  
 La propriété <see cref="P:System.Reflection.Module.Assembly" /> du module de n’importe quel élément de <paramref name="typeArguments" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public override Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakePointerType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Type" /> qui représente le type d’un pointeur non managé vers le type actuel.</summary>
        <returns>Objet <see cref="T:System.Type" /> qui représente le type d’un pointeur non managé vers le type actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> méthode fournit un moyen de générer des types pointeur pour les listes de paramètres.  
  
> [!NOTE]
>  À l’aide de la syntaxe de Microsoft intermediate language (MSIL), si le courant <xref:System.Reflection.Emit.TypeBuilder> représente `MyType`, le type retourné par cette méthode est `MyType*`.  
  
   
  
## Examples  
 L’exemple de code suivant crée un module dynamique, un type abstrait nommé `Sample`et une méthode abstraite nommée `TestMethod`. `TestMethod` prend un `ref` paramètre (`ByRef` en Visual Basic) de type `Sample`, un pointeur vers le type `Sample`et un tableau de type `Sample`. Elle retourne un tableau à deux dimensions de type `Sample`. L’exemple de code enregistre le module dynamique sur le disque, afin de pouvoir examiner avec le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Récupère le module dynamique qui contient la définition de ce type.</summary>
        <value>Lecture seule. Récupère le module dynamique qui contient la définition de ce type.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Récupère le nom de ce type.</summary>
        <value>Lecture seule. Récupère le nom <see cref="T:System.String" /> de ce type.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Récupère l’espace de noms dans lequel ce <see langword="TypeBuilder" /> est défini.</summary>
        <value>Lecture seule. Récupère l’espace de noms dans lequel ce <see langword="TypeBuilder" /> est défini.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PackingSize">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PackingSize PackingSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.PackingSize PackingSize" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackingSize As PackingSize" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::PackingSize PackingSize { System::Reflection::Emit::PackingSize get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PackingSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Récupère la taille de compactage de ce type.</summary>
        <value>Lecture seule. Récupère la taille de compactage de ce type.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne le type qui a été utilisé pour obtenir ce type.</summary>
        <value>Lecture seule. Type qui a été utilisé pour obtenir ce type.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit un attribut personnalisé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">Instance d’une classe d’assistance pour définir l’attribut personnalisé.</param>
        <summary>Définit un attribut personnalisé à l’aide d’un générateur d’attributs personnalisés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ce membre n’a plus besoin <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> indicateur. (Consultez [émettre des problèmes de sécurité dans la réflexion](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customBuilder" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">Le constructeur de l’attribut personnalisé.</param>
        <param name="binaryAttribute">Objet blob d’octets représentant les attributs.</param>
        <summary>Définit un attribut personnalisé à l’aide d’un objet blob d’attribut personnalisé spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la mise en forme `binaryAttribute`, consultez la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ». La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ce membre n’a plus besoin <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> indicateur. (Consultez [émettre des problèmes de sécurité dans la réflexion](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> ou <paramref name="binaryAttribute" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetParent">
      <MemberSignature Language="C#" Value="public void SetParent (Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParent(class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParent (parent As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParent(Type ^ parent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parent">Nouveau type de base.</param>
        <summary>Définit le type de base du type actuellement en cours d’élaboration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `parent` est `null`, <xref:System.Object> est utilisé comme type de base.  
  
 Dans les versions 1.0 et 1.1 du .NET Framework, aucune exception n’est levée si `parent` est un type interface, mais un <xref:System.TypeLoadException> est levée lorsque la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> méthode est appelée.  
  
 Le <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> méthode ne vérifie pas la plupart des types de parent non valide. Par exemple, il ne rejette pas un type de parent qui n’a aucun constructeur par défaut lorsque le type actuel possède un constructeur par défaut, il ne rejette pas les types sealed et il ne rejette pas le <xref:System.Delegate> type. Dans tous ces cas, les exceptions sont levées par le <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - ou -  
  
 <paramref name="parent" /> a la valeur <see langword="null" />, et l’instance actuelle représente une interface dont les attributs n’incluent pas <see cref="F:System.Reflection.TypeAttributes.Abstract" />.  
  
 - ou -  
  
 Pour le type dynamique actuel, la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> a la valeur <see langword="true" />, mais la propriété <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> a la valeur <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="parent" /> est une interface. Cette condition d’exception est une nouveauté de .NET Framework version 2.0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Size { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Récupère la taille totale d’un type.</summary>
        <value>Lecture seule. Récupère la taille totale de ce type.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _TypeBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_TypeBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Réservé à un usage ultérieur. Doit être IID_NULL.</param>
        <param name="rgszNames">Tableau passé des noms à mapper.</param>
        <param name="cNames">Compte des noms à mapper.</param>
        <param name="lcid">Contexte des paramètres régionaux dans lequel interpréter les noms.</param>
        <param name="rgDispId">Tableau alloué par l'appelant et recevant les ID qui correspondent aux noms.</param>
        <summary>Mappe un jeu de noms avec un jeu correspondant d'identificateurs de dispatch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetIDsOfNames`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _TypeBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informations de type à retourner.</param>
        <param name="lcid">Identificateur des paramètres régionaux pour les informations de type.</param>
        <param name="ppTInfo">Reçoit un pointeur vers l'objet d'informations de type demandé.</param>
        <summary>Récupère les informations de type pour un objet, qui peuvent être utilisées ensuite pour obtenir les informations de type d'une interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetTypeInfo`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _TypeBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Pointe vers un emplacement qui reçoit le nombre d'interfaces d'informations de type fourni par l'objet.</param>
        <summary>Récupère le nombre d'interfaces d'informations de type fourni par un objet (0 ou 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetTypeInfoCount`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _TypeBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _TypeBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_TypeBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifie le membre.</param>
        <param name="riid">Réservé à un usage ultérieur. Doit être IID_NULL.</param>
        <param name="lcid">Contexte des paramètres régionaux dans lequel interpréter les arguments.</param>
        <param name="wFlags">Indicateurs décrivant le contexte de l'appel.</param>
        <param name="pDispParams">Pointeur vers une structure qui contient un tableau d’arguments, un tableau d’arguments DISPID pour les arguments nommés et le nombre d’éléments de chaque tableau.</param>
        <param name="pVarResult">Pointeur vers l'emplacement où le résultat doit être stocké.</param>
        <param name="pExcepInfo">Pointeur vers une structure qui contient les informations sur les exceptions.</param>
        <param name="puArgErr">Index du premier argument comportant une erreur.</param>
        <summary>Fournit l'accès aux propriétés et aux méthodes exposées par un objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::Invoke`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le nom du type sans l’espace de noms.</summary>
        <returns>Lecture seule. Nom du type sans l’espace de noms.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Non pris en charge dans les modules dynamiques.</summary>
        <value>Lecture seule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupérer le type à l’aide de <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> et utiliser la réflexion sur le type récupéré.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Non pris en charge dans les modules dynamiques.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken TypeToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.TypeToken TypeToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeToken As TypeToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::TypeToken TypeToken { System::Reflection::Emit::TypeToken get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne le jeton de ce type.</summary>
        <value>Lecture seule. Retourne <see langword="TypeToken" /> de ce type.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Le type a déjà été créé en utilisant <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne le type de système sous-jacent pour ce <see langword="TypeBuilder" />.</summary>
        <value>Lecture seule. Retourne le type de système sous-jacent.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Ce type est une énumération, mais il n’y a pas de type de système sous-jacent.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnspecifiedTypeSize">
      <MemberSignature Language="C#" Value="public const int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 UnspecifiedTypeSize = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberSignature Language="VB.NET" Value="Public Const UnspecifiedTypeSize As Integer  = 0" />
      <MemberSignature Language="C++ CLI" Value="public: int UnspecifiedTypeSize = 0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Signifie que la taille totale du type n’est pas spécifiée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>