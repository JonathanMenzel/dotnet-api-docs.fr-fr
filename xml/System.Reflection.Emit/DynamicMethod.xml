<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="35c0aa81822cef717c3eb7e88f03c08bebcb3c23" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39778542" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <TypeSignature Language="F#" Value="type DynamicMethod = class&#xA;    inherit MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Définit et représente une méthode dynamique qui peut être compilée, exécutée et ignorée. Les méthodes ignorées sont disponibles pour le garbage collection.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser la <xref:System.Reflection.Emit.DynamicMethod> classe pour générer et exécuter une méthode en cours d’exécution, sans avoir à générer un assembly dynamique et un type dynamique pour contenir la méthode. Le code exécutable créé par le compilateur juste-à-temps (JIT) est libéré lorsque la <xref:System.Reflection.Emit.DynamicMethod> objet est récupéré. Les méthodes dynamiques sont le moyen le plus efficace pour générer et exécuter de petites quantités de code.  
  
 Une méthode dynamique peut être hébergée anonymement, ou il peut être logiquement associée à un module ou à un type.  
  
-   Si la méthode dynamique est hébergée anonymement, il se trouve dans un assembly fourni par le système et par conséquent est isolé du reste du code. Par défaut, il n’a pas accès à toutes les données non publics. Une méthode dynamique hébergée anonymement peut avoir restreint la possibilité d’ignorer les contrôles de visibilité du compilateur JIT, si elle a été accordée <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur. Le niveau de confiance de l’assembly dont les membres non publics sont accessibles par la méthode dynamique doit être égal à, ou un sous-ensemble de niveau de confiance de la pile des appels qui a émis la méthode dynamique. Pour plus d’informations sur les méthodes dynamiques hébergées anonymement, consultez [procédure pas à pas : émission de Code dans les scénarios de confiance partielle](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md).  
  
-   Si la méthode dynamique est associée à un module que vous spécifiez, la méthode dynamique est effectivement globale pour ce module. Il peut accéder à tous les types dans le module et tous les `internal` (`Friend` en Visual Basic) membres des types. Vous pouvez associer un dynamique méthode avec n’importe quel module, indépendamment de si vous avez créé le module, pourvu qu’une demande pour <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> indicateur peut être satisfait par la pile des appels qui contient votre code. Si le <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> indicateur est inclus dans l’octroi, la méthode dynamique peut ignorer les contrôles de visibilité du compilateur JIT et accéder aux données de tous les types déclarés dans le module ou dans tout autre module de n’importe quel assembly privées.  
  
    > [!NOTE]
    >  Lorsque vous spécifiez le module auquel une méthode dynamique est associée, ce module ne doit pas être dans l’assembly fourni par le système qui est utilisé pour l’hébergement anonyme.  
  
-   Si la méthode dynamique est associée à un type que vous spécifiez, il a accès à tous les membres du type, quel que soit le niveau d’accès. En outre, les contrôles de visibilité JIT peuvent être ignorées. Ainsi, la méthode dynamique l’accès aux données privées d’autres types déclarés dans le même module ou dans tout autre module de n’importe quel assembly. Vous pouvez associer une méthode dynamique à n’importe quel type, mais votre code doit disposer de <xref:System.Security.Permissions.ReflectionPermission> avec à la fois le <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> et <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> indicateurs.  
  
 Le tableau suivant indique les types et membres sont accessibles à une méthode dynamique hébergée de manière anonyme, avec et sans contrôles de visibilité JIT, selon que <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> indicateur est accordé.  
  
||Sans <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|Avec <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|  
|-|-|-|  
|Sans ignorer les contrôles de visibilité JIT|Membres publics de types publics dans n’importe quel assembly.|Membres publics de types publics dans n’importe quel assembly.|  
|Ignorer le JIT les contrôles de visibilité, avec des restrictions|Membres publics de types publics dans n’importe quel assembly.|Tous les membres de tous les types, uniquement dans les assemblys dont les niveaux de confiance sont le niveau de confiance de l’assembly qui a émis la méthode dynamique, inférieur ou égal à.|  
  
> [!NOTE]
>  Avant la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], générant le code requis <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> indicateur. Cette autorisation est incluse par défaut dans le FullTrust et LocalIntranet jeux d’autorisations nommés, mais pas dans l’Internet jeu d’autorisations. Par conséquent, dans les versions antérieures de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] une bibliothèque peut être utilisée avec des autorisations Internet uniquement si elle possède le <xref:System.Security.SecurityCriticalAttribute> d’attribut et exécute également une <xref:System.Security.PermissionSet.Assert%2A> pour <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>. Ces bibliothèques nécessitent une revue minutieuse de la sécurité, car les erreurs de codage peuvent entraîner des failles de sécurité. Le [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] permet au code d’être émis dans des scénarios de confiance partielle sans émettre de demandes de sécurité, car la génération de code n’est pas fondamentalement une opération nécessitant des privilèges. Autrement dit, le code généré n'a pas plus d'autorisations que l'assembly qui l'émet. Ceci permet aux bibliothèques qui émettent du code d'être transparentes de sécurité et supprime la nécessité de déclarer <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, ce qui simplifie l'écriture d'une bibliothèque sécurisée. Pour utiliser cette fonctionnalité, votre application doit cibler le [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 Le tableau suivant indique les types et membres sont accessibles à une méthode dynamique qui est associé à un module ou à un type dans un module.  
  
||Associé au module|Associé au type|  
|-|-|-|  
|Sans ignorer les contrôles de visibilité JIT|Membres publics et internes de types publics, internes et privés dans le module.<br /><br /> Membres publics de types publics dans n’importe quel assembly.|Tous les membres du type associé. Membres publics et internes de tous les autres types dans le module.<br /><br /> Membres publics de types publics dans n’importe quel assembly.|  
|Contrôles de visibilité JIT est ignorés|Tous les membres de tous les types dans un assembly.|Tous les membres de tous les types dans un assembly.|  
  
 Une méthode dynamique qui est associée à un module a les autorisations de ce module. Une méthode dynamique qui est associée à un type a les autorisations du module contenant ce type.  
  
 Méthodes dynamiques et leurs paramètres n’ont pas d’être nommé, mais vous pouvez spécifier des noms pour faciliter le débogage. Attributs personnalisés ne sont pas pris en charge sur les méthodes dynamiques ou leurs paramètres.  
  
 Bien que les méthodes dynamiques sont `static` méthodes (`Shared` méthodes en Visual Basic), les règles assouplies pour la liaison de délégués introduites dans le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] autorisent une méthode dynamique doit être lié à un objet, afin qu’il agisse comme une méthode d’instance lorsque appelée à l’aide de cette instance de délégué. Un exemple illustrant cette approche est fourni pour le <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> surcharge de méthode.  
  
> [!NOTE]
>  Dans le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], les méthodes dynamiques ne gèrent pas les informations de symbole, autrement dit, noms de variables locales et le mappage de numéro de ligne. Cette limitation peut être supprimée dans une future version. Vous pouvez utiliser <xref:System.Reflection.Emit.AssemblyBuilder> pendant le développement pour simplifier le débogage du langage intermédiaire Microsoft généré (MSIL), puis basculer sur les méthodes dynamiques pendant le déploiement final, étant donné que le <xref:System.Reflection.Emit.ILGenerator> appels sont les mêmes dans les deux cas.  
  
## <a name="verification"></a>Vérification  
 La liste suivante résume les conditions sous lesquelles les méthodes dynamiques peuvent contenir du code non vérifiable. (Par exemple, une méthode dynamique est non vérifiable si son <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> propriété est définie sur `false`.)  
  
-   Une méthode dynamique qui est associée à un assembly critique de sécurité est également critique de sécurité et pouvez ignorer la vérification. Par exemple, un assembly sans attributs de sécurité qui est exécuté comme une application de bureau est traitée comme critique de sécurité par le runtime. Si vous associez une méthode dynamique à l’assembly, la méthode dynamique peut contenir du code non vérifiable.  
  
-   Si une méthode dynamique qui contient du code non vérifiable est associée à un assembly qui a la transparence de niveau 1, le compilateur juste-à-temps (JIT) injecte une demande de sécurité. La demande réussit uniquement si la méthode dynamique est exécutée par le code totalement approuvé. Consultez [Code Transparent de sécurité, niveau 1](~/docs/framework/misc/security-transparent-code-level-1.md).  
  
-   Si une méthode dynamique qui contient du code non vérifiable est associée à un assembly qui a la transparence de niveau 2 (tel que mscorlib.dll), elle lève une exception (injectée par le compilateur JIT) au lieu de faire une demande de sécurité. Consultez [Code Transparent de sécurité, niveau 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
-   Une méthode dynamique hébergée anonymement qui contient du code non vérifiable toujours lève une exception. Il peut ne jamais ignorer la vérification, même s’il est créé et exécuté par le code totalement approuvé.  
  
 L’exception est levée pour du code non vérifiable varie selon la façon dont la méthode dynamique est appelée. Si vous appelez une méthode dynamique à l’aide d’un délégué retourné par la <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> (méthode), un <xref:System.Security.VerificationException> est levée. Si vous appelez la méthode dynamique à l’aide de la <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (méthode), un <xref:System.Reflection.TargetInvocationException> est levée avec une exception interne <xref:System.Security.VerificationException>.  
  
   
  
## Examples  
 L’exemple de code suivant crée une méthode dynamique qui prend deux paramètres. L’exemple émet un corps de fonction simple qui imprime le premier paramètre de la console et l’exemple utilise le deuxième paramètre comme valeur de retour de la méthode. L’exemple exécute la méthode en créant un délégué, appelle le délégué avec des paramètres différents et enfin appelle la méthode dynamique à l’aide de la <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (méthode).  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une méthode dynamique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la méthode dynamique. Il peut s’agir d’une chaîne de longueur nulle, mais pas de <see langword="null" />.</param>
        <param name="returnType">Objet <see cref="T:System.Type" /> qui spécifie le type de retour de la méthode dynamique, ou <see langword="null" /> si la méthode n’a aucun type de retour.</param>
        <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> spécifiant les types des paramètres de la méthode dynamique, ou <see langword="null" /> si la méthode ne possède aucun paramètre.</param>
        <summary>Initialise une méthode dynamique hébergée de manière anonyme, en spécifiant le nom de la méthode, le type de retour et les types de paramètres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode dynamique qui est créée par ce constructeur est associée à un assembly anonyme au lieu d’un type existant ou un module. L’assembly anonyme existe uniquement pour fournir un environnement de bac à sable pour les méthodes dynamiques, autrement dit, pour les isoler du reste du code. Cet environnement sécurise la méthode dynamique être émis et exécuté par du code partiellement fiable.  
  
 Ce constructeur spécifie que juste-à-temps (JIT) les contrôles de visibilité seront appliqués pour le langage intermédiaire Microsoft (MSIL) de la méthode dynamique. Autrement dit, le code dans la méthode dynamique a accès aux méthodes publiques des classes publiques. Les exceptions sont levées si la méthode essaie d’accéder aux types ou membres qui sont `private`, `protected`, ou `internal` (`Friend` en Visual Basic). Pour créer une méthode dynamique qui a limité la possibilité d’ignorer les contrôles de visibilité JIT, utilisez le <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> constructeur.  
  
 Lorsqu’une méthode dynamique hébergée anonymement est construite, la pile des appels de l’assembly émetteur est incluse. Lorsque la méthode est appelée, les autorisations de l’assembly émetteur sont utilisées au lieu des autorisations de l’appelant réel. Par conséquent, la méthode dynamique ne peut pas s’exécuter à un niveau de privilège supérieur à celui de l’assembly qui a émis, même s’il est passé à et exécuté par un assembly qui a un niveau de confiance supérieur.  
  
 Ce constructeur spécifie les attributs de méthode <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> et <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>et la convention d’appel <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Ce constructeur a été introduit dans le [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un élément de <paramref name="parameterTypes" /> a la valeur <see langword="null" /> ou <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> est un type pour lequel <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, restrictedSkipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la méthode dynamique. Il peut s’agir d’une chaîne de longueur nulle, mais pas de <see langword="null" />.</param>
        <param name="returnType">Objet <see cref="T:System.Type" /> qui spécifie le type de retour de la méthode dynamique, ou <see langword="null" /> si la méthode n’a aucun type de retour.</param>
        <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> spécifiant les types des paramètres de la méthode dynamique, ou <see langword="null" /> si la méthode ne possède aucun paramètre.</param>
        <param name="restrictedSkipVisibility">
          <see langword="true" /> pour ignorer les contrôles de visibilité juste-à-temps pour les types et membres auxquels accède le langage MSIL de la méthode dynamique, avec cette restriction : le niveau d’approbation des assemblys qui contiennent ces types et membres doit être inférieur ou égal à celui de la pile des appels qui émet la méthode dynamique ; sinon, <see langword="false" />.</param>
        <summary>Initialise une méthode dynamique hébergée de façon anonyme, en spécifiant le nom de la méthode, le type de retour, les types de paramètre et si les contrôles de visibilité juste-à-temps (JIT) doivent être ignorés pour les types et membres auxquels accède le langage MSIL (Microsoft Intermediate Language) de la méthode dynamique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode dynamique qui est créée par ce constructeur est associée à un assembly anonyme au lieu d’un type existant ou un module. L’assembly anonyme existe uniquement pour fournir un environnement de bac à sable pour les méthodes dynamiques, autrement dit, pour les isoler du reste du code. Cet environnement sécurise la méthode dynamique être émis et exécuté par du code partiellement fiable.  
  
 Méthodes dynamiques hébergées anonymement n’ont pas automatiquement accès à tous les types ou membres qui sont `private`, `protected`, ou `internal` (`Friend` en Visual Basic). Cela diffère des méthodes dynamiques qui sont associés à un type existant ou un module, qui ont accès aux membres masqués dans la portée associée.  
  
 Spécifiez `true` pour `restrictedSkipVisibility` si votre méthode dynamique a accéder aux types ou membres qui sont `private`, `protected`, ou `internal`. Cela donne l’accès à la méthode dynamique restreint à ces membres. Autrement dit, les membres accessibles uniquement si les conditions suivantes sont remplies :  
  
-   Les membres de la cible appartient à un assembly qui a un niveau de confiance égale ou inférieure à la pile des appels qui émet la méthode dynamique.  
  
-   La pile des appels qui émet la méthode dynamique est accordée <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur. Cela est toujours vrai quand le code est exécuté avec une confiance totale. Pour du code partiellement fiable, il est vrai uniquement si l’hôte accorde explicitement l’autorisation.  
  
    > [!IMPORTANT]
    >  Si l’autorisation n’a pas été accordée, une exception de sécurité est levée lorsque <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> est appelée ou lorsque la méthode dynamique est appelée, pas lorsque ce constructeur est appelé. Aucune autorisation spéciale n’est requise pour émettre la méthode dynamique.  
  
 Par exemple, une méthode dynamique qui est créée avec `restrictedSkipVisibility` défini sur `true` peut accéder à un membre privé de tout assembly sur la pile des appels si l’accès membre restreint a été accordée à la pile des appels. Si la méthode dynamique est créée avec du code partiellement fiable sur la pile des appels, il ne peut pas accéder à un membre privé d’un type dans un [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] assembly, car ces assemblys sont entièrement fiables.  
  
 Si `restrictedSkipVisibility` est `false`, contrôles de visibilité JIT sont appliqués. Le code dans la méthode dynamique a accès aux méthodes publiques des classes publiques et les exceptions sont levées si elle tente d’accéder aux types ou membres qui sont `private`, `protected`, ou `internal`.  
  
 Lorsqu’une méthode dynamique hébergée anonymement est construite, la pile des appels de l’assembly émetteur est incluse. Lorsque la méthode est appelée, les autorisations de la pile des appels émettrice sont utilisées au lieu des autorisations de l’appelant réel. Par conséquent, la méthode dynamique ne peut pas s’exécuter à un niveau de privilège supérieur à celui de l’assembly qui a émis, même s’il est passé à et exécuté par un assembly qui a un niveau de confiance supérieur.  
  
 Ce constructeur spécifie les attributs de méthode <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> et <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>et la convention d’appel <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Ce constructeur a été introduit dans le [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un élément de <paramref name="parameterTypes" /> a la valeur <see langword="null" /> ou <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> est un type pour lequel <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la méthode dynamique. Il peut s’agir d’une chaîne de longueur nulle, mais pas de <see langword="null" />.</param>
        <param name="returnType">Objet <see cref="T:System.Type" /> qui spécifie le type de retour de la méthode dynamique, ou <see langword="null" /> si la méthode n’a aucun type de retour.</param>
        <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> spécifiant les types des paramètres de la méthode dynamique, ou <see langword="null" /> si la méthode ne possède aucun paramètre.</param>
        <param name="m">
          <see cref="T:System.Reflection.Module" /> représentant le module auquel la méthode dynamique doit être associée de manière logique.</param>
        <summary>Crée une méthode dynamique qui est globale pour un module, en spécifiant le nom de la méthode, le type de retour, les types de paramètres et le module.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur spécifie les attributs de méthode <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> et <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, convention d’appel <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>et n’ignore pas les contrôles de visibilité juste-à-temps (JIT).  
  
 La méthode dynamique créée avec ce constructeur a accès à public et `internal` (`Friend` en Visual Basic) les membres de tous les types contenus dans le module `m`.  
  
> [!NOTE]
>  Pour la compatibilité descendante, ce constructeur demande <xref:System.Security.Permissions.SecurityPermission> avec la <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> indicateur si les conditions suivantes sont toutes deux true : `m` est un module autre que le module appelant et de la demande pour <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> indicateur a échoué. Si la demande de <xref:System.Security.Permissions.SecurityPermission> réussit, l’opération est autorisée.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ce membre n’a plus besoin <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> indicateur. (Consultez [des problèmes de sécurité dans la réflexion émission](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
   
  
## Examples  
 L’exemple de code suivant crée une méthode dynamique qui prend deux paramètres. L’exemple émet un corps de fonction simple qui imprime le premier paramètre de la console et l’exemple utilise le deuxième paramètre comme valeur de retour de la méthode. L’exemple exécute la méthode en créant un délégué, appelle le délégué avec des paramètres différents et enfin appelle la méthode dynamique à l’aide de la <xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> (méthode).  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un élément de <paramref name="parameterTypes" /> a la valeur <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="m" /> est un module qui fournit l’hébergement anonyme pour les méthodes dynamiques.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="m" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> est un type pour lequel <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour associer la méthode dynamique à un module autre que le module appelant. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la méthode dynamique. Il peut s’agir d’une chaîne de longueur nulle, mais pas de <see langword="null" />.</param>
        <param name="returnType">Objet <see cref="T:System.Type" /> qui spécifie le type de retour de la méthode dynamique, ou <see langword="null" /> si la méthode n’a aucun type de retour.</param>
        <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> spécifiant les types des paramètres de la méthode dynamique, ou <see langword="null" /> si la méthode ne possède aucun paramètre.</param>
        <param name="owner">
          <see cref="T:System.Type" /> avec lequel la méthode dynamique est logiquement associée. La méthode dynamique a accès à tous les membres du type.</param>
        <summary>Crée une méthode dynamique, en spécifiant le nom de la méthode, le type de retour, les types de paramètres et le type avec lequel la méthode dynamique est logiquement associée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode dynamique créée avec ce constructeur a accès à tous les membres du type `owner`et public et `internal` (`Friend` en Visual Basic) de tous les autres types dans le module qui contient les membres `owner`.  
  
 Ce constructeur spécifie les attributs de méthode <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> et <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, convention d’appel <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>et n’ignore pas les contrôles de visibilité juste-à-temps (JIT).  
  
> [!NOTE]
>  Pour la compatibilité descendante, ce constructeur demande <xref:System.Security.Permissions.SecurityPermission> avec la <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> indicateur si les conditions suivantes sont toutes deux true : `owner` est dans un module autre que le module appelant et de la demande pour <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Échec de l’indicateur. Si la demande de <xref:System.Security.Permissions.SecurityPermission> réussit, l’opération est autorisée.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ce membre n’a plus besoin <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> indicateur. (Consultez [des problèmes de sécurité dans la réflexion émission](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Reflection.Emit.DynamicMethod> qui est logiquement associée à un type. Cette association de lui donne accès aux membres privés de ce type.  
  
 L’exemple de code définit une classe nommée `Example` avec un champ privé, une classe nommée `DerivedFromxample` qui dérive de la première classe, un type délégué nommé `UseLikeStatic` qui retourne <xref:System.Int32> et a des paramètres de type `Example` et <xref:System.Int32>et un type délégué nommé `UseLikeInstance` qui retourne <xref:System.Int32> et a un paramètre de type <xref:System.Int32>.  
  
 L’exemple de code crée ensuite un <xref:System.Reflection.Emit.DynamicMethod> qui modifie le champ privé d’une instance de `Example` et retourne la valeur précédente.  
  
> [!NOTE]
>  En règle générale, modifiant les champs internes de classes n’est pas une bonne pratique de programmation orientée objet.  
  
 L’exemple de code crée une instance de `Example` , puis crée deux délégués. Le premier est de type `UseLikeStatic`, qui a les mêmes paramètres que la méthode dynamique. La seconde est de type `UseLikeInstance`, qui ne possède pas le premier paramètre (de type `Example`). Ce délégué est créé à l’aide de la <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> surcharge de méthode ; le deuxième paramètre de cette surcharge de méthode est une instance de `Example`, dans ce cas l’instance venez de créer, qui est liée au délégué nouvellement créé. Chaque fois que ce délégué est appelé, la méthode dynamique agit sur l’instance liée de `Example`.  
  
> [!NOTE]
>  Voici un exemple des règles assouplies pour la liaison de délégués introduites dans le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], ainsi que de nouvelles surcharges de la <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> (méthode). Pour plus d'informations, consultez la classe <xref:System.Delegate>.  
  
 Le `UseLikeStatic` délégué est appelé, en passant l’instance de `Example` qui est lié à la `UseLikeInstance` déléguer. Le `UseLikeInstance` délégué est appelé, afin que les deux délégués agissent sur la même instance de `Example`. Les modifications dans les valeurs du champ interne sont affichées après chaque appel. Enfin, un `UseLikeInstance` délégué est lié à une instance de `DerivedFromxample`, et les appels de délégué sont répétés.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un élément de <paramref name="parameterTypes" /> a la valeur <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="owner" /> est une interface, un tableau, un type générique ouvert ou un paramètre de type d’un type générique ou d’une méthode.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="owner" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> a la valeur <see langword="null" /> ou est un type pour lequel <see cref="P:System.Type.IsByRef" /> renvoie <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour associer la méthode dynamique à un type dans un module autre que le module appelant. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la méthode dynamique. Il peut s’agir d’une chaîne de longueur nulle, mais pas de <see langword="null" />.</param>
        <param name="returnType">Objet <see cref="T:System.Type" /> qui spécifie le type de retour de la méthode dynamique, ou <see langword="null" /> si la méthode n’a aucun type de retour.</param>
        <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> spécifiant les types des paramètres de la méthode dynamique, ou <see langword="null" /> si la méthode ne possède aucun paramètre.</param>
        <param name="m">
          <see cref="T:System.Reflection.Module" /> représentant le module auquel la méthode dynamique doit être associée de manière logique.</param>
        <param name="skipVisibility">
          <see langword="true" /> pour ignorer les contrôles de visibilité JIT sur les types et les membres auxquels a accès le langage MSIL de la méthode dynamique.</param>
        <summary>Crée une méthode dynamique qui est globale pour un module, en spécifiant le nom de la méthode, le type de retour, les types de paramètre, le module et si les contrôles de visibilité juste-à-temps (JIT) doivent être ignorés pour les types et membres auxquels a accès le langage MSIL (Microsoft Intermediate Language) de la méthode dynamique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur spécifie les attributs de méthode <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> et <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>et la convention d’appel <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
 La méthode dynamique créée avec ce constructeur a accès à public et `internal` (`Friend` en Visual Basic) les membres de tous les types de contenus dans le module `m`. Ignorer la compilation JIT des contrôles de visibilité du compilateur autorise également la méthode dynamique accéder aux membres privés et protégés de tous les autres types. Cela est utile, par exemple, lors de l’écriture de code pour sérialiser des objets.  
  
> [!NOTE]
>  Pour la compatibilité descendante, ce constructeur demande <xref:System.Security.Permissions.SecurityPermission> avec la <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> indicateur si les conditions suivantes sont toutes deux true : `m` est un module autre que le module appelant et de la demande pour <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> indicateur a échoué. Si la demande de <xref:System.Security.Permissions.SecurityPermission> réussit, l’opération est autorisée.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ce membre n’a plus besoin <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> indicateur. (Consultez [des problèmes de sécurité dans la réflexion émission](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un élément de <paramref name="parameterTypes" /> a la valeur <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="m" /> est un module qui fournit l’hébergement anonyme pour les méthodes dynamiques.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="m" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> est un type pour lequel <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour associer la méthode dynamique à un module autre que le module appelant. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la méthode dynamique. Il peut s’agir d’une chaîne de longueur nulle, mais pas de <see langword="null" />.</param>
        <param name="returnType">Objet <see cref="T:System.Type" /> qui spécifie le type de retour de la méthode dynamique, ou <see langword="null" /> si la méthode n’a aucun type de retour.</param>
        <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> spécifiant les types des paramètres de la méthode dynamique, ou <see langword="null" /> si la méthode ne possède aucun paramètre.</param>
        <param name="owner">
          <see cref="T:System.Type" /> avec lequel la méthode dynamique est logiquement associée. La méthode dynamique a accès à tous les membres du type.</param>
        <param name="skipVisibility">
          <see langword="true" /> pour ignorer les contrôles de visibilité JIT sur les types et membres auxquels a accès le langage MSIL de la méthode dynamique ; sinon, <see langword="false" />.</param>
        <summary>Crée une méthode dynamique, en spécifiant le nom de la méthode, le type de retour, les types de paramètre, le type auquel la méthode dynamique est associée logiquement, et si les contrôles de visibilité juste-à-temps (JIT) doivent être ignorés pour les types et membres auxquels accède le langage MSIL (Microsoft Intermediate Language) de la méthode dynamique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode dynamique créée avec ce constructeur a accès à tous les membres du type `owner`et public et `internal` (`Friend` en Visual Basic) de tous les autres types dans le module qui contient les membres `owner`. Ignorer la compilation JIT des contrôles de visibilité du compilateur autorise également la méthode dynamique accéder aux membres privés et protégés de tous les autres types. Cela est utile, par exemple, lors de l’écriture de code pour sérialiser des objets.  
  
 Ce constructeur spécifie les attributs de méthode <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> et <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>et la convention d’appel <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Pour la compatibilité descendante, ce constructeur demande <xref:System.Security.Permissions.SecurityPermission> avec la <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> indicateur si les conditions suivantes sont toutes deux true : `owner` est dans un module autre que le module appelant et de la demande pour <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Échec de l’indicateur. Si la demande de <xref:System.Security.Permissions.SecurityPermission> réussit, l’opération est autorisée.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ce membre n’a plus besoin <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> indicateur. (Consultez [des problèmes de sécurité dans la réflexion émission](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un élément de <paramref name="parameterTypes" /> a la valeur <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="owner" /> est une interface, un tableau, un type générique ouvert ou un paramètre de type d’un type générique ou d’une méthode.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="owner" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> a la valeur <see langword="null" /> ou est un type pour lequel <see cref="P:System.Type.IsByRef" /> renvoie <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour associer la méthode dynamique à un type dans un module autre que le module appelant. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la méthode dynamique. Il peut s’agir d’une chaîne de longueur nulle, mais pas d’un <see langword="null" />.</param>
        <param name="attributes">Combinaison de bits de valeurs <see cref="T:System.Reflection.MethodAttributes" /> qui spécifie les attributs de la méthode dynamique. La seule combinaison autorisée est <see cref="F:System.Reflection.MethodAttributes.Public" /> et <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Convention d’appel de la méthode dynamique. Doit être <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
        <param name="returnType">Objet <see cref="T:System.Type" /> qui spécifie le type de retour de la méthode dynamique, ou <see langword="null" /> si la méthode n’a aucun type de retour.</param>
        <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> spécifiant les types des paramètres de la méthode dynamique, ou <see langword="null" /> si la méthode ne possède aucun paramètre.</param>
        <param name="m">To be added.</param>
        <param name="skipVisibility">
          <see langword="true" /> pour ignorer les contrôles de visibilité JIT sur les types et membres auxquels a accès le langage MSIL de la méthode dynamique ; sinon, <see langword="false" />.</param>
        <summary>Crée une méthode dynamique qui est globale pour un module, en spécifiant le nom de la méthode, les attributs, les conventions d'appel, le type de retour, les types de paramètres, le module et si les contrôles de visibilité juste-à-temps (JIT) doivent être ignorés pour les types et membres auxquels accède le langage Microsoft Intermediate Language (MSIL) de la méthode dynamique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode dynamique créée avec ce constructeur a accès à public et `internal` (`Friend` en Visual Basic) les membres de tous les types publics et internes contenus dans le module `m`.  
  
 Ignorer la compilation JIT des contrôles de visibilité du compilateur autorise également la méthode dynamique accéder aux membres privés et protégés de tous les autres types dans le module et dans tous les autres assemblys. Cela est utile, par exemple, lors de l’écriture de code pour sérialiser des objets.  
  
> [!NOTE]
>  Pour la compatibilité descendante, ce constructeur demande <xref:System.Security.Permissions.SecurityPermission> avec la <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> indicateur si les conditions suivantes sont toutes deux true : `m` est un module autre que le module appelant et de la demande pour <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> indicateur a échoué. Si la demande de <xref:System.Security.Permissions.SecurityPermission> réussit, l’opération est autorisée.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ce membre n’a plus besoin <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> indicateur. (Consultez [des problèmes de sécurité dans la réflexion émission](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un élément de <paramref name="parameterTypes" /> a la valeur <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="m" /> est un module qui fournit l’hébergement anonyme pour les méthodes dynamiques.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="m" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="attributes" /> est une combinaison d’indicateurs autre que <see cref="F:System.Reflection.MethodAttributes.Public" /> et <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
- ou - 
 <paramref name="callingConvention" /> n’est pas un <see cref="F:System.Reflection.CallingConventions.Standard" />.  
  
- ou - 
 <paramref name="returnType" /> est un type pour lequel <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour associer la méthode dynamique à un module autre que le module appelant. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Guide pratique pour définir et exécuter des méthodes dynamiques</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problèmes de sécurité dans l'émission de réflexion</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la méthode dynamique. Il peut s’agir d’une chaîne de longueur nulle, mais pas d’un <see langword="null" />.</param>
        <param name="attributes">Combinaison de bits de valeurs <see cref="T:System.Reflection.MethodAttributes" /> qui spécifie les attributs de la méthode dynamique. La seule combinaison autorisée est <see cref="F:System.Reflection.MethodAttributes.Public" /> et <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Convention d’appel de la méthode dynamique. Doit être <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
        <param name="returnType">Objet <see cref="T:System.Type" /> qui spécifie le type de retour de la méthode dynamique, ou <see langword="null" /> si la méthode n’a aucun type de retour.</param>
        <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> spécifiant les types des paramètres de la méthode dynamique, ou <see langword="null" /> si la méthode ne possède aucun paramètre.</param>
        <param name="owner">
          <see cref="T:System.Type" /> avec lequel la méthode dynamique est logiquement associée. La méthode dynamique a accès à tous les membres du type.</param>
        <param name="skipVisibility">
          <see langword="true" /> pour ignorer les contrôles de visibilité JIT sur les types et membres auxquels a accès le langage MSIL de la méthode dynamique ; sinon, <see langword="false" />.</param>
        <summary>Crée une méthode dynamique, en spécifiant le nom de la méthode, les attributs, la convention d’appel, le type de retour, les types de paramètre, le type auquel la méthode dynamique est associée logiquement, et si les contrôles de visibilité juste-à-temps (JIT) doivent être ignorés pour les types et membres auxquels accède le langage MSIL (Microsoft Intermediate Language) de la méthode dynamique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode dynamique est globale pour le module qui contient le type `owner`. Il a accès à tous les membres du type `owner`.  
  
 La méthode dynamique créée avec ce constructeur a accès à tous les membres du type `owner`et public et `internal` (`Friend` en Visual Basic) de tous les types contenus dans le module qui contient les membres `owner`. Ignorer la compilation JIT des contrôles de visibilité du compilateur autorise également la méthode dynamique accéder aux membres privés et protégés de tous les autres types. Cela est utile, par exemple, lors de l’écriture de code pour sérialiser des objets.  
  
> [!NOTE]
>  Pour la compatibilité descendante, ce constructeur demande <xref:System.Security.Permissions.SecurityPermission> avec la <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> indicateur si les conditions suivantes sont toutes deux true : `owner` est dans un module autre que le module appelant et de la demande pour <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Échec de l’indicateur. Si la demande de <xref:System.Security.Permissions.SecurityPermission> réussit, l’opération est autorisée.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ce membre n’a plus besoin <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> indicateur. (Consultez [des problèmes de sécurité dans la réflexion émission](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un élément de <paramref name="parameterTypes" /> a la valeur <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="owner" /> est une interface, un tableau, un type générique ouvert ou un paramètre de type d’un type générique ou d’une méthode.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="owner" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="attributes" /> est une combinaison d’indicateurs autre que <see cref="F:System.Reflection.MethodAttributes.Public" /> et <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
- ou - 
 <paramref name="callingConvention" /> n’est pas un <see cref="F:System.Reflection.CallingConventions.Standard" />.  
  
- ou - 
 <paramref name="returnType" /> est un type pour lequel <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour associer la méthode dynamique à un type dans un module autre que le module appelant. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les attributs qui ont été spécifiés quand la méthode dynamique a été créée.</summary>
        <value>Combinaison d’opérations de bits des valeurs <see cref="T:System.Reflection.MethodAttributes" /> représentant les attributs de la méthode.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuellement, les attributs de méthode pour une méthode dynamique sont toujours <xref:System.Reflection.MethodAttributes.Public> et <xref:System.Reflection.MethodAttributes.Static>.  
  
   
  
## Examples  
 L’exemple de code suivant affiche les attributs de méthode d’une méthode dynamique. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la convention d’appel qui a été spécifiée quand la méthode dynamique a été créée.</summary>
        <value>Une des valeurs de <see cref="T:System.Reflection.CallingConventions" /> qui indique la convention d’appel de la méthode.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuellement, la convention d’appel d’une méthode dynamique est toujours <xref:System.Reflection.CallingConventions.Standard>.  
  
   
  
## Examples  
 L’exemple de code suivant affiche la convention d’appel d’une méthode dynamique. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exécute la méthode dynamique et crée un délégué qui peut être utilisé pour l’exécuter.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">Type de délégué dont la signature correspond à celle de la méthode dynamique.</param>
        <summary>Exécute la méthode dynamique et crée un délégué qui peut être utilisé pour l’exécuter.</summary>
        <returns>Délégué du type spécifié, qui peut être utilisé pour exécuter la méthode dynamique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelant le <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> méthode ou le <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> méthode exécute la méthode dynamique. Tout davantage de tenter de modifier la méthode dynamique, telles que la modification des définitions de paramètres ou d’émission plus Microsoft intermediate language (MSIL), est ignorée ; aucune exception n’est levée.  
  
 Pour créer un corps de méthode pour une méthode dynamique si vous possédez votre propre générateur MSIL, appelez le <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> méthode pour obtenir un <xref:System.Reflection.Emit.DynamicILInfo> objet. Si vous n’avez pas votre propre générateur MSIL, appelez le <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> méthode pour obtenir un <xref:System.Reflection.Emit.ILGenerator> objet qui peut être utilisé pour générer le corps de méthode.  
  
   
  
## Examples  
 L’exemple de code suivant crée une méthode dynamique qui prend deux paramètres. L’exemple émet un corps de fonction simple qui imprime le premier paramètre de la console et l’exemple utilise le deuxième paramètre comme valeur de retour de la méthode. L’exemple exécute la méthode en créant un délégué, appelle le délégué avec des paramètres différents et enfin appelle la méthode dynamique à l’aide de la <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (méthode).  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La méthode dynamique ne possède aucun corps de méthode.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" /> possède un nombre erroné de paramètres ou des types de paramètre incorrects.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">Type de délégué dont la signature correspond à celle de la méthode dynamique, moins le premier paramètre.</param>
        <param name="target">Objet auquel le délégué est lié. Doit être du même type que le premier paramètre de la méthode dynamique.</param>
        <summary>Exécute la méthode dynamique et crée un délégué qui peut être utilisé pour l’exécuter, en spécifiant le type de délégué et un objet auquel le délégué est lié.</summary>
        <returns>Délégué du type spécifié, qui peut être utilisé pour exécuter la méthode dynamique avec l’objet cible spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de méthode crée un délégué lié à un objet particulier. Un délégué de ce type est dit être fermé sur son premier argument. Bien que la méthode est statique, elle agit comme s’il s’agissait d’une méthode d’instance ; l’instance est `target`.  
  
 Cette surcharge de méthode nécessite `target` du même type que le premier paramètre de la méthode dynamique, ou être assigné à ce type (par exemple, une classe dérivée).  La signature de `delegateType` possède tous les paramètres de la méthode dynamique, sauf le premier. Par exemple, si la méthode dynamique possède les paramètres <xref:System.String>, <xref:System.Int32>, et <xref:System.Byte>, puis `delegateType` possède les paramètres <xref:System.Int32> et <xref:System.Byte>; `target` est de type <xref:System.String>.  
  
 Appelant le <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> méthode ou le <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> méthode exécute la méthode dynamique. Tout davantage de tenter de modifier la méthode dynamique, telles que la modification des définitions de paramètres ou d’émission plus Microsoft intermediate language (MSIL), est ignorée ; aucune exception n’est levée.  
  
 Pour créer un corps de méthode pour une méthode dynamique si vous possédez votre propre générateur MSIL, appelez le <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> méthode pour obtenir un <xref:System.Reflection.Emit.DynamicILInfo> objet. Si vous n’avez pas votre propre générateur MSIL, appelez le <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> méthode pour obtenir un <xref:System.Reflection.Emit.ILGenerator> objet qui peut être utilisé pour générer le corps de méthode.  
  
   
  
## Examples  
 L’exemple de code suivant crée le délégué qui lie un <xref:System.Reflection.Emit.DynamicMethod> à une instance d’un type, afin que la méthode agit sur la même instance chaque fois qu’elle est appelée.  
  
 L’exemple de code définit une classe nommée `Example` avec un champ privé, une classe nommée `DerivedFromxample` qui dérive de la première classe, un type délégué nommé `UseLikeStatic` qui retourne <xref:System.Int32> et a des paramètres de type `Example` et <xref:System.Int32>et un type délégué nommé `UseLikeInstance` qui retourne <xref:System.Int32> et a un paramètre de type <xref:System.Int32>.  
  
 L’exemple de code crée ensuite un <xref:System.Reflection.Emit.DynamicMethod> qui modifie le champ privé d’une instance de `Example` et retourne la valeur précédente.  
  
> [!NOTE]
>  En règle générale, modifiant les champs internes de classes n’est pas une bonne pratique de programmation orientée objet.  
  
 L’exemple de code crée une instance de `Example` , puis crée deux délégués. Le premier est de type `UseLikeStatic`, qui a les mêmes paramètres que la méthode dynamique. La seconde est de type `UseLikeInstance`, qui ne possède pas le premier paramètre (de type `Example`). Ce délégué est créé à l’aide de la <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> surcharge de méthode ; le deuxième paramètre de cette surcharge de méthode est une instance de `Example`, dans ce cas l’instance venez de créer, qui est liée au délégué nouvellement créé. Chaque fois que ce délégué est appelé, la méthode dynamique agit sur l’instance liée de `Example`.  
  
> [!NOTE]
>  Voici un exemple des règles assouplies pour la liaison de délégués introduites dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], ainsi que de nouvelles surcharges de la <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> (méthode). Pour plus d'informations, consultez la classe <xref:System.Delegate>.  
  
 Le `UseLikeStatic` délégué est appelé, en passant l’instance de `Example` qui est lié à la `UseLikeInstance` déléguer. Le `UseLikeInstance` délégué est appelé, afin que les deux délégués agissent sur la même instance de `Example`. Les modifications dans les valeurs du champ interne sont affichées après chaque appel. Enfin, un `UseLikeInstance` délégué est lié à une instance de `DerivedFromxample`, et les appels de délégué sont répétés.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La méthode dynamique ne possède aucun corps de méthode.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> n’est pas du même type que le premier paramètre de la méthode dynamique et ne peut pas être assigné à ce type.  
  
- ou - 
 <paramref name="delegateType" /> possède un nombre erroné de paramètres ou des types de paramètre incorrects.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type qui déclare la méthode, qui est toujours <see langword="null" /> pour les méthodes dynamiques.</summary>
        <value>Toujours <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne toujours `null` pour les méthodes dynamiques. Même si une méthode dynamique est logiquement associée à un type, il n’est pas déclaré par le type.  
  
   
  
## Examples  
 L’exemple de code suivant affiche le type déclarant d’une méthode dynamique. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="dynamicMethod.DefineParameter (position, attributes, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">Position du paramètre dans la liste des paramètres. Les paramètres sont indexés en commençant par le numéro 1 pour le premier paramètre.</param>
        <param name="attributes">Combinaison de bits de valeurs <see cref="T:System.Reflection.ParameterAttributes" /> qui spécifie les attributs du paramètre.</param>
        <param name="parameterName">Nom du paramètre. Le nom peut être une chaîne de longueur égale à zéro.</param>
        <summary>Définit un paramètre de la méthode dynamique.</summary>
        <returns>Retourne toujours <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `position` est 0, le <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> méthode fait référence à la valeur de retour. Définition des informations de paramètre n’a aucun effet sur la valeur de retour.  
  
 Si la méthode dynamique a déjà été exécutée en appelant le <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> ou <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (méthode), le <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> méthode n’a aucun effet. Aucune exception n'est levée.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir les informations de paramètre pour une méthode dynamique. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La méthode n'a pas de paramètre.  
  
- ou - 
 <paramref name="position" /> est inférieur à 0.  
  
- ou - 
 <paramref name="position" /> est supérieur au nombre de paramètres de la méthode.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="dynamicMethod.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne l’implémentation de base pour la méthode.</summary>
        <returns>Implémentation de base de la méthode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne toujours en cours `DynamicMethod` objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne les attributs personnalisés appliqués à la méthode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <see langword="true" /> pour rechercher la chaîne d'héritage de la méthode afin de détecter les attributs personnalisés ; <see langword="false" /> pour vérifier uniquement la méthode actuelle.</param>
        <summary>Retourne tous les attributs personnalisés définis pour cette méthode.</summary>
        <returns>Tableau d’objets représentant tous les attributs personnalisés de cette méthode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les méthodes dynamiques, en spécifiant `true` pour `inherit` n’a aucun effet, car la méthode n’est pas déclarée dans un type.  
  
> [!NOTE]
>  Attributs personnalisés ne sont pas actuellement pris en charge sur les méthodes dynamiques. Le seul attribut retourné est <xref:System.Runtime.CompilerServices.MethodImplAttribute>; vous pouvez obtenir la méthode indicateurs d’implémentation plus facilement en utilisant le <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <see cref="T:System.Type" /> représentant le type d'attribut personnalisé à retourner.</param>
        <param name="inherit">
          <see langword="true" /> pour rechercher la chaîne d'héritage de la méthode afin de détecter les attributs personnalisés ; <see langword="false" /> pour vérifier uniquement la méthode actuelle.</param>
        <summary>Retourne les attributs personnalisés du type spécifié qui ont été appliqués à la méthode.</summary>
        <returns>Tableau d'objets représentant les attributs de la méthode qui sont de type <paramref name="attributeType" /> ou dérivés du type <paramref name="attributeType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les méthodes dynamiques, en spécifiant `true` pour `inherit` n’a aucun effet, car la méthode n’est pas déclarée dans un type.  
  
> [!NOTE]
>  Attributs personnalisés ne sont pas actuellement pris en charge sur les méthodes dynamiques. Le seul attribut retourné est <xref:System.Runtime.CompilerServices.MethodImplAttribute>; vous pouvez obtenir la méthode indicateurs d’implémentation plus facilement en utilisant le <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberSignature Language="F#" Value="member this.GetDynamicILInfo : unit -&gt; System.Reflection.Emit.DynamicILInfo" Usage="dynamicMethod.GetDynamicILInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> qui peut être utilisé pour générer un corps de méthode à partir de jetons de métadonnées, de portées et de flux MSIL (Microsoft Intermediate Language).</summary>
        <returns>Objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> qui peut être utilisé pour générer un corps de méthode à partir de jetons de métadonnées, de portées et de flux MSIL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Emit.DynamicILInfo> classe est fournie pour prendre en charge la génération de code non managé.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour exécuter du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un générateur MSIL qui peut être utilisé pour émettre un corps pour la méthode dynamique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un générateur de langage MSIL (Microsoft Intermediate Language) pour la méthode avec une taille de flux MSIL par défaut de 64 bits.</summary>
        <returns>Objet <see cref="T:System.Reflection.Emit.ILGenerator" /> pour la méthode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fois une méthode dynamique terminée, en appelant le <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> ou <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (méthode), toute tentative supplémentaire ajouter le code MSIL est ignorée. Aucune exception n'est levée.  
  
> [!NOTE]
>  Il existe des restrictions sur du code non vérifiable dans les méthodes dynamiques, même dans certains scénarios de confiance totale. Consultez la section « Vérification » dans la section Notes pour <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 L’exemple de code suivant crée une méthode dynamique qui prend deux paramètres. L’exemple émet un corps de fonction simple qui imprime le premier paramètre de la console et l’exemple utilise le deuxième paramètre comme valeur de retour de la méthode. L’exemple exécute la méthode en créant un délégué, appelle le délégué avec des paramètres différents et enfin appelle la méthode dynamique à l’aide de la <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (méthode).  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">Taille du flux MSIL, en octets.</param>
        <summary>Retourne un générateur de langage MSIL (Microsoft Intermediate Language) pour la méthode avec la taille de flux MSIL spécifiée.</summary>
        <returns>Objet <see cref="T:System.Reflection.Emit.ILGenerator" /> pour la méthode avec la taille de flux MSIL spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fois une méthode dynamique terminée, en appelant le <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> ou <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (méthode), toute tentative supplémentaire ajouter le code MSIL est ignorée. Aucune exception n'est levée.  
  
> [!NOTE]
>  Il existe des restrictions sur du code non vérifiable dans les méthodes dynamiques, même dans certains scénarios de confiance totale. Consultez la section « Vérification » dans la section Notes pour <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre cette surcharge de méthode. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="dynamicMethod.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne les indicateurs d’implémentation pour la méthode.</summary>
        <returns>Combinaison d'opérations de bits de valeurs <see cref="T:System.Reflection.MethodImplAttributes" /> qui représentent les indicateurs d'implémentation de la méthode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuellement, les attributs d’implémentation de méthode pour les méthodes dynamiques sont toujours <xref:System.Reflection.MethodImplAttributes.IL> et <xref:System.Reflection.MethodImplAttributes.NoInlining>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="dynamicMethod.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne les paramètres de la méthode dynamique.</summary>
        <returns>Tableau d’objets <see cref="T:System.Reflection.ParameterInfo" /> qui représentent les paramètres de la méthode dynamique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.ParameterInfo> sont des objets retournés par cette méthode pour information uniquement. Utilisez le <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> méthode pour définir ou modifier les caractéristiques des paramètres.  
  
   
  
## Examples  
 L’exemple de code suivant affiche les paramètres d’une méthode dynamique. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si les variables locales de la méthode sont initialisées à zéro.</summary>
        <value>
          <see langword="true" /> si les variables locales dans la méthode sont initialisées à zéro ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette propriété est définie sur `true`, l’émis Microsoft intermediate language (MSIL) comprend l’initialisation de variables locales. Si elle est définie sur `false`, les variables locales ne sont pas initialisées et le code généré est non vérifiable.  
  
   
  
## Examples  
 Le code suivant exemple affiche le <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> propriété d’une méthode dynamique. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="dynamicMethod.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">Ce paramètre est ignoré pour les méthodes dynamiques, car elles sont statiques. Spécifiez <see langword="null" />.</param>
        <param name="invokeAttr">Combinaison d'opérations de bits de valeurs <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="binder">Objet <see cref="T:System.Reflection.Binder" /> qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see cref="T:System.Reflection.MemberInfo" /> par réflexion. Si <c>binder</c> a la valeur <see langword="null" />, le binder par défaut est utilisé. Pour plus d'informations, consultez <see cref="T:System.Reflection.Binder" />.</param>
        <param name="parameters">Liste d’arguments. Il s’agit d’un tableau d’arguments possédant les mêmes nombre, ordre et type que les paramètres de la méthode à appeler. En l'absence de paramètre, ce paramètre doit avoir la valeur <see langword="null" />.</param>
        <param name="culture">Instance de <see cref="T:System.Globalization.CultureInfo" /> utilisée pour régir la contrainte des types. Si la valeur est <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé. Par exemple, cette information est nécessaire pour convertir correctement un <see cref="T:System.String" /> représentant 1 000 en valeur <see cref="T:System.Double" />, car 1 000 est représenté de différentes manières, selon la culture.</param>
        <summary>Appelle la méthode dynamique à l’aide des paramètres spécifiés, sous les contraintes du binder spécifié, avec les informations de culture spécifiées.</summary>
        <returns>
          <see cref="T:System.Object" /> contenant la valeur de retour de la méthode appelée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Outre les exceptions répertoriées, le code appelant doit être préparé pour intercepter les exceptions levées par la méthode dynamique.  
  
 L’exécution d’une méthode dynamique avec un délégué créé par le <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> méthode est plus efficace que l’exécution avec le <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (méthode).  
  
 Appelant le <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> méthode ou le <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> méthode exécute la méthode dynamique. Tout davantage de tenter de modifier la méthode dynamique, telles que la modification des définitions de paramètres ou d’émission plus Microsoft intermediate language (MSIL), est ignorée ; aucune exception n’est levée.  
  
 Toutes les méthodes dynamiques sont statiques, donc le `obj` paramètre est toujours ignoré. Pour traiter une méthode dynamique comme s’il s’agissait d’une méthode d’instance, utilisez le <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> surcharge qui accepte une instance d’objet.  
  
 Si la méthode dynamique n’a aucun paramètre, la valeur de `parameters` doit être `null`. Sinon, le nombre, le type et l’ordre des éléments dans le tableau de paramètres doivent être identiques sur le nombre, le type et l’ordre des paramètres de la méthode dynamique.  
  
> [!NOTE]
>  Cette surcharge de méthode est appelée par le <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> surcharge de méthode est héritée de la <xref:System.Reflection.MethodBase> classe, les remarques précédentes s’appliquent pour les deux surcharges.  
  
 Cette méthode ne demande pas directement les autorisations, mais l’appel de la méthode dynamique peut entraîner des demandes de sécurité, en fonction de la méthode. Par exemple, aucune des demandes ne sont effectuées pour les méthodes dynamiques hébergées anonymement qui sont créés avec le `restrictedSkipVisibility` paramètre défini sur `false`. En revanche, si vous créez une méthode avec `restrictedSkipVisibility` définie sur `true` afin qu’il peut accéder à un membre masqué d’un assembly cible, la méthode provoquera une demande pour les autorisations de l’assembly cible plu <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> indicateur.  
  
> [!NOTE]
>  Avant la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode requise <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> indicateur.  
  
   
  
## Examples  
 L’exemple de code suivant appelle une méthode dynamique avec liaison exacte, à l’aide de la culture anglais des États-Unis. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La conversion d'appel <see cref="F:System.Reflection.CallingConventions.VarArgs" /> n'est pas prise en charge.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">Le nombre d'éléments dans <paramref name="parameters" /> ne correspond pas au nombre de paramètres contenus dans la méthode dynamique.</exception>
        <exception cref="T:System.ArgumentException">Le type d'un ou plusieurs éléments de <paramref name="parameters" /> ne correspond pas au type du paramètre correspondant de la méthode dynamique.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">La méthode dynamique est associée à un module, n'est pas hébergée anonymement et est construite avec le paramètre <paramref name="skipVisibility" /> défini sur <see langword="false" />, mais la méthode dynamique accède aux membres qui ne sont pas <see langword="public" /> ni <see langword="internal" /> (<see langword="Friend" /> en Visual Basic).  
  
- ou - 
La méthode dynamique est hébergée anonymement et a été construite avec le paramètre <paramref name="skipVisibility" /> défini sur <see langword="false" />, mais il accède aux membres qui ne sont pas <see langword="public" />.  
  
- ou - 
La méthode dynamique contient du code non vérifiable. Consultez la section « Vérification » dans la section Notes pour <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="dynamicMethod.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <see cref="T:System.Type" /> représentant le type d'attribut personnalisé à rechercher.</param>
        <param name="inherit">
          <see langword="true" /> pour rechercher la chaîne d'héritage de la méthode afin de détecter les attributs personnalisés ; <see langword="false" /> pour vérifier uniquement la méthode actuelle.</param>
        <summary>Indique si le type d’attribut personnalisé spécifié est défini.</summary>
        <returns>
          <see langword="true" /> si le type d'attribut personnalisé spécifié est défini ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les méthodes dynamiques, en spécifiant `true` pour `inherit` n’a aucun effet. Les méthodes dynamiques n’ont aucune chaîne d’héritage.  
  
> [!NOTE]
>  Attributs personnalisés ne sont pas actuellement pris en charge sur les méthodes dynamiques.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la méthode dynamique actuelle est critique de sécurité (security-critical) ou critique sécurisée (security-safe-critical), et peut donc effectuer des opérations critiques.</summary>
        <value>
          <see langword="true" /> si la méthode dynamique actuelle est critique de sécurité ou critique sécurisée ; <see langword="false" /> si elle est transparente de sécurité (security-transparent).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, et <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence de la méthode dynamique, tel que déterminé par le common language runtime (CLR). Les combinaisons de ces propriétés sont affichées dans le tableau suivant :  
  
|Niveau de sécurité|EstCritiqueDeSécurité|EstCritiqueSécurisé|EstTransparentDeSécurité|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critique|`true`|`false`|`false`|  
|Critique de sécurité|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.  
  
 La transparence d’une méthode dynamique dépend du module, qu'il est associé. Si la méthode dynamique est associée à un type plutôt qu’un module, sa transparence dépend du module qui contient le type. Méthodes dynamiques n’ont pas d’annotations de sécurité, afin qu’ils sont affectés à la transparence par défaut pour le module associé.  
  
-   Méthodes dynamiques hébergées anonymement sont toujours transparents, car le module fournie par le système qui les contient est transparent.  
  
-   La transparence d’une méthode dynamique qui est associée à un assembly de confiance (autrement dit, un assembly avec nom fort qui est installé dans le global assembly cache) est décrite dans le tableau suivant.  
  
    |Annotation d’assembly|Transparence de niveau 1|Transparence de niveau 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Entièrement transparent|Transparent|Transparent|  
    |Complètement critique|Critique|Critique|  
    |Transparence mixte|Transparent|Transparent|  
    |Indépendant de la sécurité|Critique sécurisé|Critique|  
  
     Par exemple, si vous associez une méthode dynamique à un type qui se trouve dans le fichier mscorlib.dll, qui a transparence de niveau 2 mixte, la méthode dynamique est transparente et ne peut pas exécuter de code critique. Pour plus d’informations sur les niveaux de transparence, consultez [Code Transparent de sécurité, niveau 1](~/docs/framework/misc/security-transparent-code-level-1.md) et [Code Transparent de sécurité, niveau 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Association d’une méthode dynamique à un module dans un assembly de niveau 1 approuvé qui est indépendant de la sécurité, tels que System.dll, n’autorise pas l’élévation d’approbation. Si le jeu d’autorisations du code qui appelle la méthode dynamique n’inclut pas le jeu d’autorisations de System.dll (autrement dit, une confiance totale), <xref:System.Security.SecurityException> est levée lorsque la méthode dynamique est appelée.  
  
-   La transparence d’une méthode dynamique qui est associée à un assembly partiellement approuvé dépend de la façon dont l’assembly est chargé. Si l’assembly est chargé avec une confiance partielle (par exemple, dans un domaine d’application sandbox), le runtime ignore les annotations de sécurité de l’assembly. L’assembly et tous ses types et membres, y compris les méthodes dynamiques, sont traités comme étant transparent. Le runtime tient compte des annotations de sécurité uniquement si l’assembly de confiance partielle est chargé avec une confiance totale (par exemple, dans le domaine d’application par défaut d’une application de bureau). Dans ce cas, le runtime affecte la transparence par défaut pour les méthodes en fonction des annotations de l’assembly à la méthode dynamique.  
  
 Pour plus d’informations sur la réflexion émettre et la transparence, consultez [problèmes de sécurité dans l’émission de réflexion](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La méthode dynamique n’a pas de corps de méthode.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la méthode dynamique actuelle est critique sécurisée au niveau de confiance actuel, autrement dit si elle peut exécuter des opérations critiques et être accessible par du code transparent.</summary>
        <value>
          <see langword="true" /> si la méthode dynamique actuelle est critique sécurisée au niveau de confiance actuel ; <see langword="false" /> si elle est critique de sécurité ou transparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, et <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence de la méthode dynamique, tel que déterminé par le common language runtime (CLR). Les combinaisons de ces propriétés sont affichées dans le tableau suivant :  
  
|Niveau de sécurité|EstCritiqueDeSécurité|EstCritiqueSécurisé|EstTransparentDeSécurité|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critique|`true`|`false`|`false`|  
|Critique de sécurité|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.  
  
 La transparence d’une méthode dynamique dépend du module, qu'il est associé. Si la méthode dynamique est associée à un type plutôt qu’un module, sa transparence dépend du module qui contient le type. Méthodes dynamiques n’ont pas d’annotations de sécurité, afin qu’ils sont affectés à la transparence par défaut pour le module associé.  
  
-   Méthodes dynamiques hébergées anonymement sont toujours transparents, car le module fournie par le système qui les contient est transparent.  
  
-   La transparence d’une méthode dynamique qui est associée à un assembly de confiance (autrement dit, un assembly avec nom fort qui est installé dans le global assembly cache) est décrite dans le tableau suivant.  
  
    |Annotation d’assembly|Transparence de niveau 1|Transparence de niveau 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Entièrement transparent|Transparent|Transparent|  
    |Complètement critique|Critique|Critique|  
    |Transparence mixte|Transparent|Transparent|  
    |Indépendant de la sécurité|Critique sécurisé|Critique|  
  
     Par exemple, si vous associez une méthode dynamique à un type qui se trouve dans le fichier mscorlib.dll, qui a transparence de niveau 2 mixte, la méthode dynamique est transparente et ne peut pas exécuter de code critique. Pour plus d’informations sur les niveaux de transparence, consultez [Code Transparent de sécurité, niveau 1](~/docs/framework/misc/security-transparent-code-level-1.md) et [Code Transparent de sécurité, niveau 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Association d’une méthode dynamique à un module dans un assembly de niveau 1 approuvé qui est indépendant de la sécurité, tels que System.dll, n’autorise pas l’élévation d’approbation. Si le jeu d’autorisations du code qui appelle la méthode dynamique n’inclut pas le jeu d’autorisations de System.dll (autrement dit, une confiance totale), <xref:System.Security.SecurityException> est levée lorsque la méthode dynamique est appelée.  
  
-   La transparence d’une méthode dynamique qui est associée à un assembly partiellement approuvé dépend de la façon dont l’assembly est chargé. Si l’assembly est chargé avec une confiance partielle (par exemple, dans un domaine d’application sandbox), le runtime ignore les annotations de sécurité de l’assembly. L’assembly et tous ses types et membres, y compris les méthodes dynamiques, sont traités comme étant transparent. Le runtime tient compte des annotations de sécurité uniquement si l’assembly de confiance partielle est chargé avec une confiance totale (par exemple, dans le domaine d’application par défaut d’une application de bureau). Dans ce cas, le runtime affecte la transparence par défaut pour les méthodes en fonction des annotations de l’assembly à la méthode dynamique.  
  
 Pour plus d’informations sur la réflexion émettre et la transparence, consultez [problèmes de sécurité dans l’émission de réflexion](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La méthode dynamique n’a pas de corps de méthode.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la méthode dynamique actuelle est transparente au niveau de confiance actuel et ne peut donc pas exécuter d’opérations critiques.</summary>
        <value>
          <see langword="true" /> si la méthode dynamique est transparente de sécurité au niveau de confiance actuel ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, et <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence de la méthode dynamique, tel que déterminé par le common language runtime (CLR). Les combinaisons de ces propriétés sont affichées dans le tableau suivant :  
  
|Niveau de sécurité|EstCritiqueDeSécurité|EstCritiqueSécurisé|EstTransparentDeSécurité|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critique|`true`|`false`|`false`|  
|Critique de sécurité|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.  
  
 La transparence d’une méthode dynamique dépend du module, qu'il est associé. Si la méthode dynamique est associée à un type plutôt qu’un module, sa transparence dépend du module qui contient le type. Méthodes dynamiques n’ont pas d’annotations de sécurité, afin qu’ils sont affectés à la transparence par défaut pour le module associé.  
  
-   Méthodes dynamiques hébergées anonymement sont toujours transparents, car le module fournie par le système qui les contient est transparent.  
  
-   La transparence d’une méthode dynamique qui est associée à un assembly de confiance (autrement dit, un assembly avec nom fort qui est installé dans le global assembly cache) est décrite dans le tableau suivant.  
  
    |Annotation d’assembly|Transparence de niveau 1|Transparence de niveau 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Entièrement transparent|Transparent|Transparent|  
    |Complètement critique|Critique|Critique|  
    |Transparence mixte|Transparent|Transparent|  
    |Indépendant de la sécurité|Critique sécurisé|Critique|  
  
     Par exemple, si vous associez une méthode dynamique à un type qui se trouve dans le fichier mscorlib.dll, qui a transparence de niveau 2 mixte, la méthode dynamique est transparente et ne peut pas exécuter de code critique. Pour plus d’informations sur les niveaux de transparence, consultez [Code Transparent de sécurité, niveau 1](~/docs/framework/misc/security-transparent-code-level-1.md) et [Code Transparent de sécurité, niveau 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Association d’une méthode dynamique à un module dans un assembly de niveau 1 approuvé qui est indépendant de la sécurité, tels que System.dll, n’autorise pas l’élévation d’approbation. Si le jeu d’autorisations du code qui appelle la méthode dynamique n’inclut pas le jeu d’autorisations de System.dll (autrement dit, une confiance totale), <xref:System.Security.SecurityException> est levée lorsque la méthode dynamique est appelée.  
  
-   La transparence d’une méthode dynamique qui est associée à un assembly partiellement approuvé dépend de la façon dont l’assembly est chargé. Si l’assembly est chargé avec une confiance partielle (par exemple, dans un domaine d’application sandbox), le runtime ignore les annotations de sécurité de l’assembly. L’assembly et tous ses types et membres, y compris les méthodes dynamiques, sont traités comme étant transparent. Le runtime tient compte des annotations de sécurité uniquement si l’assembly de confiance partielle est chargé avec une confiance totale (par exemple, dans le domaine d’application par défaut d’une application de bureau). Dans ce cas, le runtime affecte la transparence par défaut pour les méthodes en fonction des annotations de l’assembly à la méthode dynamique.  
  
 Pour plus d’informations sur la réflexion émettre et la transparence, consultez [problèmes de sécurité dans l’émission de réflexion](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La méthode dynamique n’a pas de corps de méthode.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Non pris en charge pour les méthodes dynamiques.</summary>
        <value>Non pris en charge pour les méthodes dynamiques.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Non autorisé pour les méthodes dynamiques.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.DynamicMethod.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le module auquel la méthode dynamique est logiquement associée.</summary>
        <value>
          <see cref="T:System.Reflection.Module" /> auquel la méthode dynamique actuelle est associée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un module a été spécifié lors de la méthode dynamique a été créée, cette propriété retourne ce module. Si un type a été spécifié comme propriétaire lors de la méthode dynamique a été créée, cette propriété retourne le module qui contient ce type.  
  
   
  
## Examples  
 Le code suivant exemple affiche le <xref:System.Reflection.Emit.DynamicMethod.Module%2A> propriété d’une méthode dynamique. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.DynamicMethod.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de la méthode dynamique.</summary>
        <value>Nom simple de la méthode.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Il n’est pas nécessaire de nommer les méthodes dynamiques.  
  
   
  
## Examples  
 L’exemple de code suivant affiche le nom d’une méthode dynamique. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la classe qui a été utilisée dans la réflexion pour obtenir la méthode.</summary>
        <value>Toujours <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne toujours `null` pour les méthodes dynamiques.  
  
   
  
## Examples  
 L’exemple de code suivant affiche le type réfléchi d’une méthode dynamique. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le paramètre de retour de la méthode dynamique.</summary>
        <value>Toujours <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne toujours `null` pour les méthodes dynamiques.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type de la valeur de retour de la méthode dynamique.</summary>
        <value>
          <see cref="T:System.Type" /> représentant le type de la valeur de retour de la méthode actuelle ; <see cref="T:System.Void" /> si la méthode n’a aucun type de retour.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `null` a été spécifié pour le type de retour lorsque la méthode dynamique a été créée, cette propriété retourne <xref:System.Void?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple de code suivant affiche le type de retour d’une méthode dynamique. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les attributs personnalisés du type de retour pour la méthode dynamique.</summary>
        <value>
          <see cref="T:System.Reflection.ICustomAttributeProvider" /> représentant les attributs personnalisés du type de retour de la méthode dynamique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attributs personnalisés ne sont pas pris en charge sur le type de retour d’une méthode dynamique, donc le tableau d’attributs personnalisés retourné par la <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A> méthode est toujours vide.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment afficher les attributs personnalisés du type de retour d’une méthode dynamique. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dynamicMethod.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la signature de la méthode, représentée sous forme de chaîne.</summary>
        <returns>Chaîne représentant la signature de la méthode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La signature inclut uniquement les types et le nom de la méthode, le cas échéant. Noms de paramètres ne sont pas inclus.  
  
   
  
## Examples  
 Le code suivant exemple affiche la <xref:System.Reflection.Emit.DynamicMethod.ToString%2A> méthode d’une méthode dynamique. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>