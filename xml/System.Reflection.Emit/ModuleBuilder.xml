<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ModuleBuilder.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cd62ca0fc3883c3b58b0d81ab5d8f47e85cb31d6.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cd62ca0fc3883c3b58b0d81ab5d8f47e85cb31d6</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines and represents a module in a dynamic assembly.</source>
          <target state="translated">Définit et représente un module dans un assembly dynamique.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>To get an instance of <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour obtenir une instance de <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>, utilisez le <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>The following code sample demonstrates the use of <ph id="ph1">`ModuleBuilder`</ph> to create a dynamic module.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de <ph id="ph1">`ModuleBuilder`</ph> pour créer un module dynamique.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Note that the ModuleBuilder is created by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph> in <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>, rather than through a constructor.</source>
          <target state="translated">Notez que ModuleBuilder est créé en appelant <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph> dans <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>, plutôt que via un constructeur.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.Assembly">
          <source>Gets the dynamic assembly that defined this instance of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>.</source>
          <target state="translated">Obtient l'assembly dynamique qui a défini cette instance de <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.Assembly">
          <source>The dynamic assembly that defined the current dynamic module.</source>
          <target state="translated">Assembly dynamique qui a défini le module dynamique actuel.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object that is returned is the <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> that defined this instance of <ph id="ph3">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> objet retourné est le <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> qui défini par cette instance de <ph id="ph3">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>Completes the global function definitions and global data definitions for this dynamic module.</source>
          <target state="translated">Complète les définitions de fonction globale et les définitions de données globales pour ce module dynamique.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>This method should be called when the user is done with defining all the global functions within this dynamic module.</source>
          <target state="translated">Cette méthode doit être appelée lorsque l’utilisateur a terminé de définir toutes les fonctions globales dans ce module dynamique.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>After calling this function, no more new global functions or new global data are allowed.</source>
          <target state="translated">Après avoir appelé cette fonction, aucune autre fonction ou les nouvelles données globales ne sont autorisées.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>The following sample illustrates the use of <ph id="ph1">`CreateGlobalFunctions`</ph> to create a static global method from a <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> implemented with <ph id="ph3">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph>.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de <ph id="ph1">`CreateGlobalFunctions`</ph> pour créer une méthode globale statique à partir d’un <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> implémenté avec <ph id="ph3">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>This method was called previously.</source>
          <target state="translated">Cette méthode a été appelée au préalable.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The URL for the document.</source>
          <target state="translated">URL du document.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The GUID that identifies the document language.</source>
          <target state="translated">GUID qui identifie le langage du document.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>This can be <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph>.</source>
          <target state="translated">Il peut s’agir de <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The GUID that identifies the document language vendor.</source>
          <target state="translated">GUID qui identifie le fournisseur du langage du document.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>This can be <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph>.</source>
          <target state="translated">Il peut s’agir de <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The GUID that identifies the document type.</source>
          <target state="translated">GUID qui identifie le type du document.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>This can be <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph>.</source>
          <target state="translated">Il peut s’agir de <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>Defines a document for source.</source>
          <target state="translated">Définit un document comme source.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The defined document.</source>
          <target state="translated">Document défini.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>Earlier versions of the .NET Framework throw <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> instead of <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph> when <ph id="ph3">`url`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Les versions antérieures du .NET Framework lèvent <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> au lieu de <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph> lorsque <ph id="ph3">`url`</ph> est <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The following code sample illustrates the use of <ph id="ph1">`DefineDocument`</ph> to attach an external symbol document (in this case, a raw IL file) to a dynamic module.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de <ph id="ph1">`DefineDocument`</ph> pour attacher un document de symbole externe (dans ce cas, un fichier IL brut) à un module dynamique.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source><ph id="ph1">&lt;paramref name="url" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="url" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>This is a change from earlier versions of the .NET Framework.</source>
          <target state="translated">Il s'agit d'une modification des versions antérieures du .NET Framework.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>This method is called on a dynamic module that is not a debug module.</source>
          <target state="translated">Cette méthode est appelée sur un module dynamique qui n'est pas un module de débogage.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The full path of the enumeration type.</source>
          <target state="translated">Chemin d'accès complet du type d'énumération.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de valeurs null incorporées.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The type attributes for the enumeration.</source>
          <target state="translated">Attributs de type pour l'énumération.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The attributes are any bits defined by <ph id="ph1">&lt;see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /&gt;</ph>.</source>
          <target state="translated">Un attribut correspond à n'importe quel octet défini par <ph id="ph1">&lt;see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The underlying type for the enumeration.</source>
          <target state="translated">Type sous-jacent pour l'énumération.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This must be a built-in integer type.</source>
          <target state="translated">Ce doit être un type entier intégré.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Defines an enumeration type that is a value type with a single non-static field called <ph id="ph1">&lt;paramref name="value__" /&gt;</ph> of the specified type.</source>
          <target state="translated">Définit un type d'énumération qui est un type valeur avec un champ non statique unique appelé <ph id="ph1">&lt;paramref name="value__" /&gt;</ph> du type spécifié.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The defined enumeration.</source>
          <target state="translated">Énumération définie.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The defined enum is a derived class of <ph id="ph1">&lt;xref:System.Enum&gt;</ph>.</source>
          <target state="translated">L’enum défini est une classe dérivée de <ph id="ph1">&lt;xref:System.Enum&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The <ph id="ph1">`value__`</ph> field has <ph id="ph2">&lt;xref:System.Reflection.FieldAttributes.Private&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.FieldAttributes.SpecialName&gt;</ph> attributes set.</source>
          <target state="translated">Le <ph id="ph1">`value__`</ph> champ a <ph id="ph2">&lt;xref:System.Reflection.FieldAttributes.Private&gt;</ph> et <ph id="ph3">&lt;xref:System.Reflection.FieldAttributes.SpecialName&gt;</ph> jeu d’attributs.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>For more information about the built-in integer types that can be specified as the underlying types of enumerations, see <bpt id="p1">[</bpt>Class Library Overview<ept id="p1">](~/docs/standard/class-library-overview.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les types entiers intégrés qui peuvent être spécifiées en tant que types sous-jacents d’énumérations, consultez <bpt id="p1">[</bpt>Class Library Overview<ept id="p1">](~/docs/standard/class-library-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>In the .NET Framework versions 1.0 and 1.1, it is necessary to define enumerations using <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> because <ph id="ph2">&lt;xref:System.Reflection.Emit.EnumBuilder&gt;</ph> emits enumerations whose elements are of type <ph id="ph3">&lt;xref:System.Int32&gt;</ph> instead of the enumeration type.</source>
          <target state="translated">Dans les versions 1.0 et 1.1 du .NET Framework, il est nécessaire de définir des énumérations à l’aide de <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> car <ph id="ph2">&lt;xref:System.Reflection.Emit.EnumBuilder&gt;</ph> émet des énumérations dont les éléments sont de type <ph id="ph3">&lt;xref:System.Int32&gt;</ph> au lieu du type énumération.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>In the .NET Framework version 2.0, <ph id="ph1">&lt;xref:System.Reflection.Emit.EnumBuilder&gt;</ph> emits enumerations whose elements have the correct type.</source>
          <target state="translated">Dans le .NET Framework version 2.0, <ph id="ph1">&lt;xref:System.Reflection.Emit.EnumBuilder&gt;</ph> émet des énumérations dont les éléments ont le type approprié.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The following example illustrates the use of <ph id="ph1">`DefineEnum`</ph> to implement an enumeration class in a dynamic module.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de <ph id="ph1">`DefineEnum`</ph> pour implémenter une classe d’énumération dans un module dynamique.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The example defines an enumeration named <ph id="ph1">`Elevation`</ph> that has an underlying type of <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, and creates two elements: <ph id="ph3">`Low`</ph>, with a value of 0, and <ph id="ph4">`High`</ph>, with a value of 1.</source>
          <target state="translated">L’exemple définit une énumération nommée <ph id="ph1">`Elevation`</ph> qui a un type sous-jacent de <ph id="ph2">&lt;xref:System.Int32&gt;</ph>et crée deux éléments : <ph id="ph3">`Low`</ph>, avec la valeur 0, et <ph id="ph4">`High`</ph>, avec la valeur 1.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>After the type has been created, the assembly is saved with the name <ph id="ph1">`TempAssembly.dll`</ph>.</source>
          <target state="translated">Une fois que le type a été créé, l’assembly est enregistré avec le nom <ph id="ph1">`TempAssembly.dll`</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the contents of this assembly.</source>
          <target state="translated">Vous pouvez utiliser la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> pour examiner le contenu de cet assembly.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Prior to the .NET Framework version 2.0, this code example does not produce a correct enumeration.</source>
          <target state="translated">Avant la version 2.0 du .NET Framework, cet exemple de code ne produit pas une énumération correcte.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Attributes other than visibility attributes are provided.</source>
          <target state="translated">Des attributs autres que des attributs de visibilité sont fournis.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>An enumeration with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Une énumération portant le nom donné existe dans l'assembly parent de ce module.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The visibility attributes do not match the scope of the enumeration.</source>
          <target state="translated">Les attributs de visibilité ne correspondent pas à la portée de l'énumération.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>For example, <ph id="ph1">&lt;see cref="F:System.Reflection.TypeAttributes.NestedPublic" /&gt;</ph> is specified for <ph id="ph2">&lt;paramref name="visibility" /&gt;</ph>, but the enumeration is not a nested type.</source>
          <target state="translated">Par exemple, si <ph id="ph1">&lt;see cref="F:System.Reflection.TypeAttributes.NestedPublic" /&gt;</ph> est spécifié pour <ph id="ph2">&lt;paramref name="visibility" /&gt;</ph> alors que l'énumération n'est pas de type imbriqué.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines a global method.</source>
          <target state="translated">Définit une méthode globale.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The name of the method.</source>
          <target state="translated">Nom de la méthode.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de valeurs null incorporées.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The attributes of the method.</source>
          <target state="translated">Attributs de la méthode.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>attributes<ept id="p1">&lt;/c&gt;</ept> must include <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>attributes<ept id="p1">&lt;/c&gt;</ept> doit inclure <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">Type de retour de la méthode.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The types of the method's parameters.</source>
          <target state="translated">Types des paramètres de la méthode.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>Defines a global method with the specified name, attributes, return type, and parameter types.</source>
          <target state="translated">Définit une méthode globale à l'aide du nom, des attributs, du type de retour et des types de paramètres spécifiés.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The defined global method.</source>
          <target state="translated">Méthode globale définie.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The global method that this method defines is not usable until you call <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode définit la méthode globale n’est pas utilisable jusqu'à ce que vous appeliez <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The following example illustrates the use of <ph id="ph1">`DefineGlobalMethod`</ph> to create a type-independent method tied to the current <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de <ph id="ph1">`DefineGlobalMethod`</ph> pour créer une méthode indépendante du type liée à actuel <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>After building the global method, <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> must be called in order to complete it.</source>
          <target state="translated">Après la génération de la méthode globale, <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> doit être appelé pour terminer.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The method is not static.</source>
          <target state="translated">La méthode n’est pas statique.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>That is, <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> does not include <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated">C'est-à-dire que <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> n'inclut pas <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> est égale à zéro.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>An element in the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un élément du tableau <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> has been previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> a été appelé précédemment.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The name of the method.</source>
          <target state="translated">Nom de la méthode.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de valeurs null incorporées.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The attributes of the method.</source>
          <target state="translated">Attributs de la méthode.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>attributes<ept id="p1">&lt;/c&gt;</ept> must include <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>attributes<ept id="p1">&lt;/c&gt;</ept> doit inclure <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The calling convention for the method.</source>
          <target state="translated">Convention d’appel de la méthode.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">Type de retour de la méthode.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the method's parameters.</source>
          <target state="translated">Types des paramètres de la méthode.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Defines a global method with the specified name, attributes, calling convention, return type, and parameter types.</source>
          <target state="translated">Définit une méthode globale à l'aide du nom, des attributs, de la convention d'appel, du type de retour et des types de paramètres spécifiés.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The defined global method.</source>
          <target state="translated">Méthode globale définie.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>You cannot use the global method that this method defines until you call <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</source>
          <target state="translated">Vous ne pouvez pas utiliser la méthode globale, cette méthode définit jusqu'à ce que vous appelez <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The following code sample illustrates the use of <ph id="ph1">`DefineGlobalMethod`</ph> to create a type-independent method tied to the current <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de <ph id="ph1">`DefineGlobalMethod`</ph> pour créer une méthode indépendante du type liée à actuel <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>After building the global method, <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> must be called in order to complete it.</source>
          <target state="translated">Après la génération de la méthode globale, <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> doit être appelé pour terminer.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The method is not static.</source>
          <target state="translated">La méthode n’est pas statique.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>That is, <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> does not include <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated">C'est-à-dire que <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> n'inclut pas <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>An element in the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un élément du tableau <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> has been previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> a été appelé précédemment.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the method.</source>
          <target state="translated">Nom de la méthode.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded null characters.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de caractères Null incorporés.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the method.</source>
          <target state="translated">Attributs de la méthode.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>attributes<ept id="p1">&lt;/c&gt;</ept> must include <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>attributes<ept id="p1">&lt;/c&gt;</ept> doit inclure <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention for the method.</source>
          <target state="translated">Convention d’appel de la méthode.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the method.</source>
          <target state="translated">Type de retour de la méthode.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers for the return type, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Runtime.CompilerServices.IsBoxed" /&gt;</ph>.</source>
          <target state="translated">Tableau des types représentant les modificateurs personnalisés requis pour le type de retour, tels que <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> ou <ph id="ph2">&lt;see cref="T:System.Runtime.CompilerServices.IsBoxed" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si le type de retour ne possède pas de modificateur personnalisé requis, spécifiez <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers for the return type, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Runtime.CompilerServices.IsBoxed" /&gt;</ph>.</source>
          <target state="translated">Tableau des types représentant les modificateurs personnalisés facultatifs pour le type de retour, tels que <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> ou <ph id="ph2">&lt;see cref="T:System.Runtime.CompilerServices.IsBoxed" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si le type de retour ne possède pas de modificateur personnalisé facultatif, spécifiez <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the method's parameters.</source>
          <target state="translated">Types des paramètres de la méthode.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Tableau de tableaux de types.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter of the global method.</source>
          <target state="translated">Chaque tableau de types représente les modificateurs personnalisés requis pour le paramètre correspondant de la méthode globale.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular argument has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Si un argument particulier ne possède pas de modificateur personnalisé requis, spécifiez <ph id="ph1">&lt;see langword="null" /&gt;</ph> plutôt qu'un tableau de types.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the global method has no arguments, or if none of the arguments have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Si la méthode globale ne possède pas d'argument, ou si aucun des arguments ne possède de modificateur personnalisé requis, spécifiez <ph id="ph1">&lt;see langword="null" /&gt;</ph> plutôt qu'un tableau de tableaux.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Tableau de tableaux de types.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter.</source>
          <target state="translated">Chaque tableau de types représente les modificateurs personnalisés facultatifs pour le paramètre correspondant.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular argument has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Si un argument particulier ne possède pas de modificateur personnalisé facultatif, spécifiez <ph id="ph1">&lt;see langword="null" /&gt;</ph> plutôt qu'un tableau de types.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the global method has no arguments, or if none of the arguments have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Si la méthode globale ne possède pas d'argument, ou si aucun des arguments ne possède de modificateur personnalisé facultatif, spécifiez <ph id="ph1">&lt;see langword="null" /&gt;</ph> plutôt qu'un tableau de tableaux.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Defines a global method with the specified name, attributes, calling convention, return type, custom modifiers for the return type, parameter types, and custom modifiers for the parameter types.</source>
          <target state="translated">Définit une méthode globale à l'aide du nom, des attributs, de la convention d'appel, du type de retour, des modificateurs personnalisés pour le type de retour, des types de paramètres et des modificateurs personnalisés pour les types de paramètres spécifiés.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The defined global method.</source>
          <target state="translated">Méthode globale définie.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Cette surcharge est fournie pour les concepteurs de compilateurs managés.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>You cannot use the global method that this method defines until you call <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</source>
          <target state="translated">Vous ne pouvez pas utiliser la méthode globale, cette méthode définit jusqu'à ce que vous appelez <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The method is not static.</source>
          <target state="translated">La méthode n’est pas statique.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>That is, <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> does not include <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated">C'est-à-dire que <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> n'inclut pas <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An element in the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un élément du tableau <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> method has been previously called.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> a été appelée au préalable.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The name used to refer to the data.</source>
          <target state="translated">Nom utilisé pour faire référence aux données.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de valeurs null incorporées.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The binary large object (BLOB) of data.</source>
          <target state="translated">Objet BLOB de données.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The attributes for the field.</source>
          <target state="translated">Attributs du champ.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The default is <ph id="ph1">&lt;see langword="Static" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>Defines an initialized data field in the .sdata section of the portable executable (PE) file.</source>
          <target state="translated">Définit un champ de données initialisé dans la section .sdata du fichier exécutable portable.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>A field to reference the data.</source>
          <target state="translated">Champ pour référencer les données.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.Static&gt;</ph> is automatically included in <ph id="ph2">`attributes`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.Static&gt;</ph> est automatiquement incluse dans <ph id="ph2">`attributes`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The data defined by this method is not created until the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method is called.</source>
          <target state="translated">Les données définies par cette méthode ne sont pas créées tant que le <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> method to define an initialized data field in the <ph id="ph2">`.sdata`</ph> section of the portable executable (PE) file.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> méthode pour définir un champ de données initialisé dans la <ph id="ph2">`.sdata`</ph> section du fichier exécutable portable (PE).</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> est égale à zéro.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The size of <ph id="ph1">&lt;paramref name="data" /&gt;</ph> is less than or equal to zero or greater than or equal to 0x3f0000.</source>
          <target state="translated">La taille de <ph id="ph1">&lt;paramref name="data" /&gt;</ph> est inférieure ou égale à zéro, ou supérieure ou égale à 0x3f0000.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="data" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="data" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> has been previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> a été appelé précédemment.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The case-sensitive name for the resource.</source>
          <target state="translated">Nom qui respecte la casse de la ressource.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>A stream that contains the bytes for the resource.</source>
          <target state="translated">Flux contenant les octets de la ressource.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>An enumeration value that specifies whether the resource is public or private.</source>
          <target state="translated">Valeur d'énumération qui spécifie si la ressource est publique ou privée.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>Defines a binary large object (BLOB) that represents a manifest resource to be embedded in the dynamic assembly.</source>
          <target state="translated">Définit un objet BLOB qui représente une ressource de manifeste à incorporer dans l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>Resources that are recorded in the assembly manifest can be managed resources or manifest resource BLOBs, and each of these can be included in the assembly either by linking or by embedding.</source>
          <target state="translated">Les ressources qui sont enregistrés dans le manifeste d’assembly peuvent être des ressources managées ou BLOBs de ressources de manifeste, et chacune de ces peut être inclus dans l’assembly en la liant ou en incorporant.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>All four scenarios are supported for dynamic assemblies.</source>
          <target state="translated">Les quatre scénarios sont pris en charge pour les assemblys dynamiques.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>This method allows you to embed a manifest resource BLOB into a dynamic assembly.</source>
          <target state="translated">Cette méthode vous permet d’incorporer un BLOB de ressources de manifeste dans un assembly dynamique.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>To embed a managed resource into the manifest module of a dynamic assembly or into a satellite module, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineResource%2A?displayProperty=nameWithType&gt;</ph> method to get a resource writer, and use the <ph id="ph2">&lt;xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType&gt;</ph> method to add the resource.</source>
          <target state="translated">Pour incorporer une ressource managée dans le module du manifeste d’un assembly dynamique ou dans un module satellite, utilisez la <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineResource%2A?displayProperty=nameWithType&gt;</ph> méthode pour obtenir un writer de ressource et le <ph id="ph2">&lt;xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType&gt;</ph> méthode pour ajouter la ressource.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>To link a managed resource into a dynamic assembly, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A?displayProperty=nameWithType&gt;</ph> method to get a resource writer, and use the <ph id="ph2">&lt;xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType&gt;</ph> method to add the linked resource.</source>
          <target state="translated">Pour lier une ressource managée dans un assembly dynamique, utilisez la <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A?displayProperty=nameWithType&gt;</ph> méthode pour obtenir un writer de ressource et le <ph id="ph2">&lt;xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType&gt;</ph> méthode pour ajouter la ressource liée.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>To link a manifest resource BLOB into a dynamic assembly, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A?displayProperty=nameWithType&gt;</ph> method to add the linked resource.</source>
          <target state="translated">Pour lier une objet BLOB de ressource de manifeste dans un assembly dynamique, utilisez la <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A?displayProperty=nameWithType&gt;</ph> méthode pour ajouter la ressource liée.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>In addition, a single Win32 resource can be attached to an assembly by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType&gt;</ph> method or the <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">En outre, une seule ressource Win32 peut être attachée à un assembly à l’aide de la <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType&gt;</ph> méthode ou la <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>This resource does not appear in the assembly manifest.</source>
          <target state="translated">Cette ressource n’apparaît pas dans le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The following example generates and saves a dynamic assembly named <ph id="ph1">`EmittedManifestResourceAssembly.exe`</ph>, which contains an embedded unmanaged resource.</source>
          <target state="translated">L’exemple suivant génère et enregistre un assembly dynamique nommé <ph id="ph1">`EmittedManifestResourceAssembly.exe`</ph>, qui contient un élément incorporé, la ressource non managée.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The example creates the assembly, which consists of one module, and opens a memory stream to contain the unmanaged resource.</source>
          <target state="translated">L’exemple crée l’assembly, qui se compose d’un module et ouvre un flux de mémoire qui contiendra la ressource non managée.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The code then calls the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> method to define the resource.</source>
          <target state="translated">Le code appelle ensuite la <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> méthode pour définir la ressource.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>You can use any kind of stream for your resource; for example, you can read the unmanaged binary data from a file.</source>
          <target state="translated">Vous pouvez utiliser n’importe quel type de flux pour votre ressource ; par exemple, vous pouvez lire les données binaires non managées à partir d’un fichier.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The example defines a type in the dynamic module with a <ph id="ph1">`Main`</ph> method, and generates MSIL for the method body.</source>
          <target state="translated">L’exemple définit un type dans le module dynamique avec un <ph id="ph1">`Main`</ph> (méthode) et génère le code MSIL pour le corps de méthode.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>After the body for the <ph id="ph1">`Main`</ph> method has been generated and the type has been created, the code example writes five bytes to the stream associated with the manifest resource.</source>
          <target state="translated">Lorsque le corps de la <ph id="ph1">`Main`</ph> méthode a été générée et le type a été créé, l’exemple de code écrit cinq octets dans le flux associé à la ressource de manifeste.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>When the assembly is saved, the resource is appended to it.</source>
          <target state="translated">Lorsque l’assembly est enregistré, la ressource est ajoutée.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>After running the example, you can run the emitted assembly.</source>
          <target state="translated">Après avoir exécuté l’exemple, vous pouvez exécuter l’assembly émis.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The code in the emitted assembly's <ph id="ph1">`Main`</ph> method reads the embedded manifest resource and prints the byte values to the console.</source>
          <target state="translated">Le code dans l’assembly émis <ph id="ph1">`Main`</ph> méthode lit la ressource de manifeste incorporée et imprime les valeurs d’octets dans la console.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to view the information in the assembly manifest.</source>
          <target state="translated">Vous pouvez utiliser la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> pour afficher les informations dans le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est une chaîne de longueur nulle.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The dynamic assembly that contains the current module is transient; that is, no file name was specified when <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)" /&gt;</ph> was called.</source>
          <target state="translated">L'assembly dynamique qui contient le module actuel est transitoire, ce qui signifie qu'aucun nom de fichier n'a été spécifié lorsque <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)" /&gt;</ph> a été appelé.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Définit une méthode <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Nom de la méthode <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de valeurs null incorporées.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">Nom de la DLL dans laquelle la méthode <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> est définie.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Attributs de la méthode.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">Convention d’appel de la méthode.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">Type de retour de la méthode.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Types des paramètres de la méthode.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">Convention d’appel native.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">Jeu de caractères natif de la méthode.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method with the specified name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags.</source>
          <target state="translated">Définit une méthode <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> à l'aide du nom, du nom de la DLL dans laquelle la méthode a été définie, des attributs de la méthode, de la convention d'appel, du type de retour, des types de paramètres et des indicateurs <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> spécifiés.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The defined <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Méthode <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> définie.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of System.Runtime.InteropServices.DllImportAttribute) cannot be specified as arguments to this method.</source>
          <target state="translated">Certains attributs d’importation DLL (consultez la description de System.Runtime.InteropServices.DllImportAttribute) ne peut pas être spécifiés en tant qu’arguments à cette méthode.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Such attributes should be set by emitting a custom attribute for the method.</source>
          <target state="translated">Ces attributs doivent être définis en émettant un attribut personnalisé pour la méthode.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">`PreserveSig`</ph> is set by emitting a custom attribute.</source>
          <target state="translated">Par exemple, la DLL Importer attribut <ph id="ph1">`PreserveSig`</ph> est défini en émettant un attribut personnalisé.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following example illustrates the use of the <ph id="ph1">`DefinePInvokeMethod`</ph> method to create a <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> for an external unmanaged method, <ph id="ph3">`MessageBoxA`</ph>, in the Win32 API.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de la <ph id="ph1">`DefinePInvokeMethod`</ph> méthode pour créer un <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> pour une méthode non managée externe, <ph id="ph3">`MessageBoxA`</ph>, dans l’API Win32.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example displays a message box with <bpt id="p1">**</bpt>Retry<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Cancel<ept id="p2">**</ept> buttons, and displays the return value from the message box.</source>
          <target state="translated">L’exemple affiche une boîte de message avec <bpt id="p1">**</bpt>réessayer<ept id="p1">**</ept> et <bpt id="p2">**</bpt>Annuler<ept id="p2">**</ept> boutons et affiche la valeur de retour à partir de la boîte de message.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> to the method implementation flags after you create the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Pour obtenir une valeur de retour différente de zéro, vous devez ajouter <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> aux indicateurs d’implémentation de méthode après avoir créé le <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, à l’aide de la <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static or if the containing type is an interface.</source>
          <target state="translated">La méthode n'est pas statique ou le type conteneur est une interface.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">La méthode est de type abstract.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">La méthode a déjà été définie.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph></source>
          <target state="translated">Le type conteneur a été créé au préalable à l'aide de la méthode <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Nom de la méthode <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de valeurs null incorporées.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">Nom de la DLL dans laquelle la méthode <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> est définie.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the entry point in the DLL.</source>
          <target state="translated">Nom du point d’entrée dans la DLL.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Attributs de la méthode.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">Convention d’appel de la méthode.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">Type de retour de la méthode.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Types des paramètres de la méthode.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">Convention d’appel native.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">Jeu de caractères natif de la méthode.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method with the specified name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags.</source>
          <target state="translated">Définit une méthode <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> à l'aide du nom, du nom de la DLL dans laquelle la méthode a été définie, des attributs de la méthode, de la convention d'appel, du type de retour, des types de paramètres et des indicateurs <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> spécifiés.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The defined <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Méthode <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> définie.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">Attributs d’importation de certaines DLL (consultez la description de <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) ne peut pas être spécifié en tant qu’arguments à cette méthode.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Such attributes should be set by emitting a custom attribute for the method.</source>
          <target state="translated">Ces attributs doivent être définis en émettant un attribut personnalisé pour la méthode.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">`PreserveSig`</ph> is set by emitting a custom attribute.</source>
          <target state="translated">Par exemple, la DLL Importer attribut <ph id="ph1">`PreserveSig`</ph> est défini en émettant un attribut personnalisé.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following example illustrates the use of the <ph id="ph1">`DefinePInvokeMethod`</ph> method to create a <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> for an external unmanaged method, <ph id="ph3">`MessageBoxA`</ph>, in the Win32 API.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de la <ph id="ph1">`DefinePInvokeMethod`</ph> méthode pour créer un <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> pour une méthode non managée externe, <ph id="ph3">`MessageBoxA`</ph>, dans l’API Win32.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example displays a message box with <bpt id="p1">**</bpt>Retry<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Cancel<ept id="p2">**</ept> buttons, and displays the return value from the message box.</source>
          <target state="translated">L’exemple affiche une boîte de message avec <bpt id="p1">**</bpt>réessayer<ept id="p1">**</ept> et <bpt id="p2">**</bpt>Annuler<ept id="p2">**</ept> boutons et affiche la valeur de retour à partir de la boîte de message.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> to the method implementation flags after you create the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Pour obtenir une valeur de retour différente de zéro, vous devez ajouter <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> aux indicateurs d’implémentation de méthode après avoir créé le <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, à l’aide de la <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>This example uses a different overload of the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A&gt;</ph> method, but the technique is the same.</source>
          <target state="translated">Cet exemple utilise une autre surcharge de la <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A&gt;</ph> (méthode), mais la technique est la même.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static or if the containing type is an interface or if the method is abstract of if the method was previously defined.</source>
          <target state="translated">La méthode n'est pas statique, le type conteneur est une interface, la méthode est abstraite ou elle a été définie au préalable.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph></source>
          <target state="translated">Le type conteneur a été créé au préalable à l'aide de la méthode <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines a managed embedded resource to be stored in this module.</source>
          <target state="translated">Définit une ressource incorporée managée à stocker dans ce module.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>The name of the resource.</source>
          <target state="translated">Nom de la ressource.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de valeurs null incorporées.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>The description of the resource.</source>
          <target state="translated">Description de la ressource.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>Defines the named managed embedded resource to be stored in this module.</source>
          <target state="translated">Définit la ressource incorporée managée nommée à stocker dans ce module.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>A resource writer for the defined resource.</source>
          <target state="translated">Writer de ressource pour la ressource définie.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>The caller must not call the <ph id="ph1">`ResourceWriter.Generate()`</ph> and <ph id="ph2">`ResourceWriter.Close()`</ph> methods, because these methods are called by <ph id="ph3">`ModuleBuilder.Save`</ph> when the dynamic assembly is written to disk.</source>
          <target state="translated">L’appelant ne doit pas appeler la <ph id="ph1">`ResourceWriter.Generate()`</ph> et <ph id="ph2">`ResourceWriter.Close()`</ph> méthodes, car ces méthodes sont appelées par <ph id="ph3">`ModuleBuilder.Save`</ph> lorsque l’assembly dynamique est écrite sur le disque.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>Use this method to embed a managed resource.</source>
          <target state="translated">Utilisez cette méthode pour incorporer une ressource managée.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>To embed a manifest resource blob, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> method.</source>
          <target state="translated">Pour incorporer un objet blob de ressource de manifeste, utilisez la <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>For a summary of embedding and linking managed resources and manifest resource blobs, see the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> method.</source>
          <target state="translated">Pour obtenir un résumé de l’incorporation et de liaison de ressources managées et les objets BLOB de ressource de manifeste, consultez la <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>The following example illustrates the use of <ph id="ph1">`DefineResource`</ph> to add an external resource to the current <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de <ph id="ph1">`DefineResource`</ph> pour ajouter une ressource externe actuel <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> est égale à zéro.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>This module is transient.</source>
          <target state="translated">Ce module est transitoire.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>The containing assembly is not persistable.</source>
          <target state="translated">L'assembly contenant n'est pas persistable.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The name of the resource.</source>
          <target state="translated">Nom de la ressource.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de valeurs null incorporées.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The description of the resource.</source>
          <target state="translated">Description de la ressource.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The resource attributes.</source>
          <target state="translated">Attributs de la ressource.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Defines the named managed embedded resource with the given attributes that is to be stored in this module.</source>
          <target state="translated">Définit la ressource incorporée managée nommée, avec les attributs donnés, à stocker dans ce module.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>A resource writer for the defined resource.</source>
          <target state="translated">Writer de ressource pour la ressource définie.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The caller must not call the <ph id="ph1">`ResourceWriter.Generate()`</ph> and <ph id="ph2">`ResourceWriter.Close()`</ph> methods, because these methods are called by <ph id="ph3">`ModuleBuilder.Save`</ph> when the dynamic assembly is written to disk.</source>
          <target state="translated">L’appelant ne doit pas appeler la <ph id="ph1">`ResourceWriter.Generate()`</ph> et <ph id="ph2">`ResourceWriter.Close()`</ph> méthodes, car ces méthodes sont appelées par <ph id="ph3">`ModuleBuilder.Save`</ph> lorsque l’assembly dynamique est écrite sur le disque.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Use this method to embed a managed resource.</source>
          <target state="translated">Utilisez cette méthode pour incorporer une ressource managée.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>To embed a manifest resource blob, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> method.</source>
          <target state="translated">Pour incorporer un objet blob de ressource de manifeste, utilisez la <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>For a summary of embedding and linking managed resources and manifest resource blobs, see the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> method.</source>
          <target state="translated">Pour obtenir un résumé de l’incorporation et de liaison de ressources managées et les objets BLOB de ressource de manifeste, consultez la <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The following example illustrates the use of DefineResource to add an external resource to the current <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de DefineResource pour ajouter une ressource externe actuel <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> est égale à zéro.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>This module is transient.</source>
          <target state="translated">Ce module est transitoire.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The containing assembly is not persistable.</source>
          <target state="translated">L'assembly contenant n'est pas persistable.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Construit un objet <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>To define a value type, define a type that derives from <ph id="ph1">&lt;see cref="T:System.ValueType" /&gt;</ph>.</source>
          <target state="translated">Pour définir un type valeur, définissez un type dérivé de <ph id="ph1">&lt;see cref="T:System.ValueType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>The full path of the type, including the namespace.</source>
          <target state="translated">Chemin d'accès complet du type, espace de noms compris.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de valeurs null incorporées.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> for a private type with the specified name in this module.</source>
          <target state="translated">Construit un <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> pour un type privé portant le nom spécifié dans ce module.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>A private type with the specified name.</source>
          <target state="translated">Type privé portant le nom spécifié.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Les noms de type doivent être uniques dans un assembly.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Vous ne pouvez avoir deux types portant le même nom dans deux modules différents d’un assembly.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> dans le module dynamique actuel à l’aide <ph id="ph2">`CreateType`</ph>, génère et termine le type et enregistre l’assembly.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Un type portant le nom donné existe dans l'assembly parent de ce module.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Des attributs de type imbriqué sont définis sur un type non imbriqué.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>The full path of the type.</source>
          <target state="translated">Chemin d'accès complet du type.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de valeurs null incorporées.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>The attributes of the defined type.</source>
          <target state="translated">Attributs du type défini.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given the type name and the type attributes.</source>
          <target state="translated">Construit un <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> en fonction du nom et des attributs du type.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> created with all of the requested attributes.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> créé avec tous les attributs demandés.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Les noms de type doivent être uniques dans un assembly.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Vous ne pouvez avoir deux types portant le même nom dans deux modules différents d’un assembly.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> dans le module dynamique actuel à l’aide <ph id="ph2">`CreateType`</ph>, génère et termine le type et enregistre l’assembly.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Un type portant le nom donné existe dans l'assembly parent de ce module.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Des attributs de type imbriqué sont définis sur un type non imbriqué.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The full path of the type.</source>
          <target state="translated">Chemin d'accès complet du type.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de valeurs null incorporées.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The attribute to be associated with the type.</source>
          <target state="translated">Attribut à associer au type.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The type that the defined type extends.</source>
          <target state="translated">Type étendu par le type défini.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given type name, its attributes, and the type that the defined type extends.</source>
          <target state="translated">Construit un <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> en fonction du nom et des attributs du type, ainsi que du type que le type défini étend.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> created with all of the requested attributes.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> créé avec tous les attributs demandés.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Les noms de type doivent être uniques dans un assembly.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Vous ne pouvez avoir deux types portant le même nom dans deux modules différents d’un assembly.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> dans le module dynamique actuel à l’aide <ph id="ph2">`CreateType`</ph>, génère et termine le type et enregistre l’assembly.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Un type portant le nom donné existe dans l'assembly parent de ce module.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Des attributs de type imbriqué sont définis sur un type non imbriqué.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The full path of the type.</source>
          <target state="translated">Chemin d'accès complet du type.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de valeurs null incorporées.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The attributes of the defined type.</source>
          <target state="translated">Attributs du type défini.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The type that the defined type extends.</source>
          <target state="translated">Type étendu par le type défini.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The total size of the type.</source>
          <target state="translated">Taille totale du type.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given the type name, the attributes, the type that the defined type extends, and the total size of the type.</source>
          <target state="translated">Construit un <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> en fonction du nom et des attributs du type, du type étendu par le type défini et de la taille totale du type.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Les noms de type doivent être uniques dans un assembly.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>It is forbidden to have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Il est interdit d’avoir deux types portant le même nom dans deux modules différents d’un assembly.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> dans le module dynamique actuel à l’aide <ph id="ph2">`CreateType`</ph>, génère et termine le type et enregistre l’assembly.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Un type portant le nom donné existe dans l'assembly parent de ce module.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Des attributs de type imbriqué sont définis sur un type non imbriqué.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The full path of the type.</source>
          <target state="translated">Chemin d'accès complet du type.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de valeurs null incorporées.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The attributes of the defined type.</source>
          <target state="translated">Attributs du type défini.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The type that the defined type extends.</source>
          <target state="translated">Type étendu par le type défini.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The packing size of the type.</source>
          <target state="translated">Taille de compression du type.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given the type name, the attributes, the type that the defined type extends, and the packing size of the type.</source>
          <target state="translated">Construit un <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> en fonction du nom et des attributs du type, du type étendu par le type défini et de la taille de compactage du type.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Les noms de type doivent être uniques dans un assembly.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Vous ne pouvez avoir deux types portant le même nom dans deux modules différents d’un assembly.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> dans le module dynamique actuel à l’aide <ph id="ph2">`CreateType`</ph>, génère et termine le type et enregistre l’assembly.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Un type portant le nom donné existe dans l'assembly parent de ce module.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Des attributs de type imbriqué sont définis sur un type non imbriqué.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The full path of the type.</source>
          <target state="translated">Chemin d'accès complet du type.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de valeurs null incorporées.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The attributes to be associated with the type.</source>
          <target state="translated">Attributs à associer au type.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The type that the defined type extends.</source>
          <target state="translated">Type étendu par le type défini.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The list of interfaces that the type implements.</source>
          <target state="translated">Liste des interfaces implémentées par le type.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given the type name, attributes, the type that the defined type extends, and the interfaces that the defined type implements.</source>
          <target state="translated">Construit un <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> en fonction du nom et des attributs du type, du type étendu par le type défini et de l'interface implémentée par le type défini.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> created with all of the requested attributes.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> créé avec tous les attributs demandés.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Les noms de type doivent être uniques dans un assembly.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Vous ne pouvez avoir deux types portant le même nom dans deux modules différents d’un assembly.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> dans le module dynamique actuel à l’aide <ph id="ph2">`CreateType`</ph>, génère et termine le type et enregistre l’assembly.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Un type portant le nom donné existe dans l'assembly parent de ce module.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Des attributs de type imbriqué sont définis sur un type non imbriqué.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The full path of the type.</source>
          <target state="translated">Chemin d'accès complet du type.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de valeurs null incorporées.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The attributes of the defined type.</source>
          <target state="translated">Attributs du type défini.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The type that the defined type extends.</source>
          <target state="translated">Type étendu par le type défini.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The packing size of the type.</source>
          <target state="translated">Taille de compression du type.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The total size of the type.</source>
          <target state="translated">Taille totale du type.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given the type name, attributes, the type that the defined type extends, the packing size of the defined type, and the total size of the defined type.</source>
          <target state="translated">Construit un <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> en fonction du nom et des attributs du type, du type étendu par le type défini, de la taille de compactage et de la taille totale du type défini.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> created with all of the requested attributes.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> créé avec tous les attributs demandés.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Les noms de type doivent être uniques dans un assembly.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Vous ne pouvez avoir deux types portant le même nom dans deux modules différents d’un assembly.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> dans le module dynamique actuel à l’aide <ph id="ph2">`CreateType`</ph>, génère et termine le type et enregistre l’assembly.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Un type portant le nom donné existe dans l'assembly parent de ce module.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Des attributs de type imbriqué sont définis sur un type non imbriqué.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The name used to refer to the data.</source>
          <target state="translated">Nom utilisé pour faire référence aux données.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> ne peut pas contenir de valeurs null incorporées.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The size of the data field.</source>
          <target state="translated">Taille du champ de données.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The attributes for the field.</source>
          <target state="translated">Attributs du champ.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>Defines an uninitialized data field in the .sdata section of the portable executable (PE) file.</source>
          <target state="translated">Définit un champ de données non initialisé dans la section .sdata du fichier exécutable portable (PE, Portable Executable).</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>A field to reference the data.</source>
          <target state="translated">Champ pour référencer les données.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.Static&gt;</ph> is automatically included in <ph id="ph2">`attributes`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.Static&gt;</ph> est automatiquement incluse dans <ph id="ph2">`attributes`</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The data defined by this method is not created until the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method is called.</source>
          <target state="translated">Les données définies par cette méthode ne sont pas créées tant que le <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> est égale à zéro.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than or equal to zero, or greater than or equal to 0x003f0000.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> est inférieur ou égal à zéro, ou supérieur ou égal à 0x003f0000.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> has been previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> a été appelé précédemment.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines an unmanaged resource in this module.</source>
          <target state="translated">Définit une ressource non managée dans ce module.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>The binary large object (BLOB) must have the right format for a Win32 resource.</source>
          <target state="translated">L'objet BLOB doit avoir le format approprié pour une ressource Win32.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>An opaque BLOB that represents an unmanaged resource</source>
          <target state="translated">Objet BLOB opaque qui représente une ressource non managée.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>Defines an unmanaged embedded resource given an opaque binary large object (BLOB) of bytes.</source>
          <target state="translated">Définit une ressource incorporée non managée en fonction d'un objet BLOB d'octets opaque.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>An assembly can be associated with only one unmanaged resource.</source>
          <target state="translated">Un assembly peut être associé à une seule ressource non managée.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>This means that calling <ph id="ph1">`DefineVersionInfoResource`</ph> or <ph id="ph2">`DefineUnmanagedResource`</ph> after either one of the methods was called previously throws <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Cela signifie que l’appel <ph id="ph1">`DefineVersionInfoResource`</ph> ou <ph id="ph2">`DefineUnmanagedResource`</ph> après l’une des méthodes a été appelée précédemment lève <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>Multiple unmanaged resources need to be merged with a tool such as the Microsoft ResMerge utility (not supplied with the common language runtime).</source>
          <target state="translated">Plusieurs ressources non managées doivent être fusionnées avec un outil tel que l’utilitaire Microsoft ResMerge (non fourni avec le common language runtime).</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>An unmanaged resource has already been defined in the module's assembly.</source>
          <target state="translated">Une ressource non managée a déjà été définie dans l'assembly du module.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="resource" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resource" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>The name of the unmanaged resource file.</source>
          <target state="translated">Nom du fichier de ressources non managé.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>Defines an unmanaged resource given the name of Win32 resource file.</source>
          <target state="translated">Définit une ressource non managée en fonction du nom d'un fichier de ressources Win32.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>An assembly can be associated with only one unmanaged resource.</source>
          <target state="translated">Un assembly peut être associé à une seule ressource non managée.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>This means that calling <ph id="ph1">`DefineVersionInfoResource`</ph> or <ph id="ph2">`DefineUnmanagedResource`</ph> after either one of the methods was called previously throws <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Cela signifie que l’appel <ph id="ph1">`DefineVersionInfoResource`</ph> ou <ph id="ph2">`DefineUnmanagedResource`</ph> après l’une des méthodes a été appelée précédemment lève <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>Multiple unmanaged resources need to be merged with a tool such as the Microsoft ResMerge utility (not supplied with the common language runtime).</source>
          <target state="translated">Plusieurs ressources non managées doivent être fusionnées avec un outil tel que l’utilitaire Microsoft ResMerge (non fourni avec le common language runtime).</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>An unmanaged resource has already been defined in the module's assembly.</source>
          <target state="translated">Une ressource non managée a déjà été définie dans l'assembly du module.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> est la chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is a directory.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> est un répertoire.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
          <source>An object to compare with this instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objet à comparer à cette instance ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
          <source>Returns a value that indicates whether this instance is equal to the specified object.</source>
          <target state="translated">Retourne une valeur qui indique si cette instance équivaut à l’objet spécifié.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> equals the type and value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> est égal au type et à la valeur de cette instance ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>Gets a <ph id="ph1">&lt;see langword="String" /&gt;</ph> representing the fully qualified name and path to this module.</source>
          <target state="translated">Obtient un <ph id="ph1">&lt;see langword="String" /&gt;</ph> représentant le nom et le chemin d'accès complets de ce module.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>The fully qualified module name.</source>
          <target state="translated">Nom qualifié complet du module.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>To get the name without the path, use <ph id="ph1">`Name`</ph>.</source>
          <target state="translated">Pour obtenir le nom sans le chemin d’accès, utilisez <ph id="ph1">`Name`</ph>.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>The case of a module name is platform dependent.</source>
          <target state="translated">Le cas d’un nom de module est dépendant de la plate-forme.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>Accesses information in the path.</source>
          <target state="translated">Accéder à des informations dans le chemin d’accès.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>An array class.</source>
          <target state="translated">Classe Array.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The name of a method on the array class.</source>
          <target state="translated">Nom d'une méthode sur la classe Array.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The method's calling convention.</source>
          <target state="translated">Convention d’appel de la méthode.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">Type de retour de la méthode.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the method's parameters.</source>
          <target state="translated">Types des paramètres de la méthode.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Returns the named method on an array class.</source>
          <target state="translated">Retourne la méthode nommée sur une classe Array.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The named method on an array class.</source>
          <target state="translated">Méthode nommée sur une classe Array.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">`GetArrayMethod`</ph> is useful when you have an array of a type whose definition has not been completed and you want to access methods defined on <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`GetArrayMethod`</ph> est utile lorsque vous avez un tableau d’un type dont la définition n’a pas été effectuée et que vous souhaitez accéder aux méthodes définies sur <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>For example, you might define a type and want to define a method that takes an array of the type as a parameter.</source>
          <target state="translated">Par exemple, vous pouvez définir un type et à définir une méthode qui prend un tableau du type en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>In order to access the elements of the array, you will need to call methods of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">Pour accéder aux éléments du tableau, vous devez appeler les méthodes de la <ph id="ph1">&lt;xref:System.Array&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The following example demonstrates how to use <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph> to obtain the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> corresponding to a method that returns an array value.</source>
          <target state="translated">L’exemple suivant montre comment utiliser <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph> pour obtenir le <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> correspondant à une méthode qui retourne une valeur de tableau.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> is not an array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> n'est pas un tableau.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> or <ph id="ph2">&lt;paramref name="methodName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="methodName" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The object for the array.</source>
          <target state="translated">Objet du tableau.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>A string that contains the name of the method.</source>
          <target state="translated">Chaîne qui contient le nom de la méthode.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The calling convention for the method.</source>
          <target state="translated">Convention d’appel de la méthode.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">Type de retour de la méthode.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Types des paramètres de la méthode.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Returns the token for the named method on an array class.</source>
          <target state="translated">Retourne le jeton de la méthode nommée sur une classe Array.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The token for the named method on an array class.</source>
          <target state="translated">Jeton de la méthode nommée sur une classe Array.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>This method is similar to <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph>, except that it returns the token of the array method instead of the method itself.</source>
          <target state="translated">Cette méthode est similaire à <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph>, sauf qu’il retourne le jeton de la méthode du tableau au lieu de la méthode proprement dite.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The following example demonstrates how to use <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph> to obtain the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodToken&gt;</ph> corresponding to a method that returns an array value.</source>
          <target state="translated">L’exemple suivant montre comment utiliser <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph> pour obtenir le <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodToken&gt;</ph> correspondant à une méthode qui retourne une valeur de tableau.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> is not an array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> n'est pas un tableau.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="methodName" /&gt;</ph> is zero.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="methodName" /&gt;</ph> est égale à zéro.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> or <ph id="ph2">&lt;paramref name="methodName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="methodName" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Returns the token used to identify the specified constructor within this module.</source>
          <target state="translated">Retourne le jeton servant à identifier le constructeur spécifié dans ce module.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)">
          <source>The constructor to get a token for.</source>
          <target state="translated">Constructeur pour lequel un jeton doit être obtenu.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)">
          <source>Returns the token used to identify the specified constructor within this module.</source>
          <target state="translated">Retourne le jeton servant à identifier le constructeur spécifié dans ce module.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)">
          <source>The token used to identify the specified constructor within this module.</source>
          <target state="translated">Jeton servant à identifier le constructeur spécifié dans ce module.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>The constructor to get a token for.</source>
          <target state="translated">Constructeur pour lequel un jeton doit être obtenu.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>A collection of the types of the optional parameters to the constructor.</source>
          <target state="translated">Collection de types des paramètres facultatifs au constructeur.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>Returns the token used to identify the constructor that has the specified attributes and parameter types within this module.</source>
          <target state="translated">Retourne le jeton utilisé pour identifier le constructeur qui possède les attributs spécifiés et les types de paramètres dans ce module.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>The token used to identify the specified constructor within this module.</source>
          <target state="translated">Jeton servant à identifier le constructeur spécifié dans ce module.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source><ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Returns the custom attributes that are applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>.</source>
          <target state="translated">Retourne les attributs personnalisés appliqués au <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Cet argument est ignoré pour les objets de ce type.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes that have been applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>.</source>
          <target state="translated">Retourne tous les attributs personnalisés appliqués au <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
          <source>An array that contains the custom attributes; the array is empty if there are no attributes.</source>
          <target state="translated">Un tableau qui contient les attributs personnalisés ; le tableau est vide s’il n’existe pas d’attributs.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The base type from which attributes derive.</source>
          <target state="translated">Type de base duquel dérivent des attributs.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Cet argument est ignoré pour les objets de ce type.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns all the custom attributes that have been applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>, and that derive from a specified attribute type.</source>
          <target state="translated">Retourne tous les attributs personnalisés appliqués au <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> actuel et qui dérivent du type d'attribut spécifié.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array that contains the custom attributes that are derived, at any level, from <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>; the array is empty if there are no such attributes.</source>
          <target state="translated">Tableau qui contient les attributs personnalisés dérivés (à tous les niveaux) de <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> ; le tableau est vide si de tels attributs n'existent pas.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object supplied by the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> n'est pas un objet <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> fourni par le runtime.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>For example, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> est un objet <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>Returns information about the attributes that have been applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>, expressed as <ph id="ph2">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects.</source>
          <target state="translated">Retourne des informations sur les attributs appliqués au <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> actuel, en tant qu'objets <ph id="ph2">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>A generic list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects representing data about the attributes that have been applied to the current module.</source>
          <target state="translated">Liste générique d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> représentant des données relatives aux attributs qui ont été appliqués au module actif.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</source>
          <target state="translated">Utilisez cette méthode pour examiner les attributs personnalisés du code dans le contexte de réflexion uniquement, dans les cas où les attributs personnalisés eux-mêmes sont définis dans le code qui est chargé dans le contexte de réflexion uniquement.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>Methods like <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> cannot be used in such cases, because they create instances of the attributes.</source>
          <target state="translated">Méthodes, telles que <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> ne peut pas être utilisé dans ce cas, parce qu’elles créent des instances des attributs.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>Code in the reflection-only context cannot be executed.</source>
          <target state="translated">Impossible d’exécuter le code dans le contexte de réflexion uniquement.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>For more information and for example code, see the <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> class.</source>
          <target state="translated">Pour plus d’informations et un par exemple de code, consultez la <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The field name.</source>
          <target state="translated">Nom du champ.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A combination of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Combinaison des bits indicateurs <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> utilisés pour contrôler la recherche.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns a module-level field, defined in the .sdata region of the portable executable (PE) file, that has the specified name and binding attributes.</source>
          <target state="translated">Retourne un champ au niveau du module, défini dans la région .sdata du fichier exécutable portable (PE, Portable Executable) ayant le nom et les attributs de liaison spécifiés.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A field that has the specified name and binding attributes, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the field does not exist.</source>
          <target state="translated">Champ ayant le nom et les attributs de liaison spécifiés, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si le champ n'existe pas.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>When you emit dynamic assemblies, fields in the .sdata region of the portable executable (PE) file are defined by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A&gt;</ph> methods.</source>
          <target state="translated">Lorsque vous émettez des assemblys dynamiques, les champs de la région .sdata du fichier exécutable portable (PE) sont définis à l’aide de la <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Module-level fields cannot be retrieved until after the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method has been called for the module.</source>
          <target state="translated">Impossible de récupérer les champs au niveau du module jusqu'à une fois la <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> méthode a été appelée pour le module.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>A combination of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Combinaison des bits indicateurs <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> utilisés pour contrôler la recherche.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Returns all fields defined in the .sdata region of the portable executable (PE) file that match the specified binding flags.</source>
          <target state="translated">Retourne tous les champs définis dans la région .sdata du fichier exécutable portable (PE) qui correspondent aux indicateurs de liaisons spécifiés.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>An array of fields that match the specified flags; the array is empty if no such fields exist.</source>
          <target state="translated">Tableau des champs qui correspondent aux indicateurs spécifiés ; le tableau est vide si de tels champs n'existent pas.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>When you emit dynamic assemblies, fields in the .sdata region of the portable executable (PE) file are defined by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A&gt;</ph> methods.</source>
          <target state="translated">Lorsque vous émettez des assemblys dynamiques, les champs de la région .sdata du fichier exécutable portable (PE) sont définis à l’aide de la <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Module-level fields cannot be retrieved until after the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method has been called for the module.</source>
          <target state="translated">Impossible de récupérer les champs au niveau du module jusqu'à une fois la <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> méthode a été appelée pour le module.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)">
          <source>The field to get a token for.</source>
          <target state="translated">Champ pour lequel un jeton doit être obtenu.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)">
          <source>Returns the token used to identify the specified field within this module.</source>
          <target state="translated">Retourne le jeton servant à identifier le champ spécifié dans ce module.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)">
          <source>The token used to identify the specified field within this module.</source>
          <target state="translated">Jeton utilisé pour identifier le champ spécifié dans ce module.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)">
          <source><ph id="ph1">&lt;paramref name="field" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="field" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Retourne le code de hachage de cette instance.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Code de hachage d'un entier signé 32 bits.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The method name.</source>
          <target state="translated">Nom de la méthode.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A combination of <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Combinaison des bits indicateurs <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> utilisés pour contrôler la recherche.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that implements <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, containing properties related to this method.</source>
          <target state="translated">Objet qui implémente <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, contenant les propriétés associées à cette méthode.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling convention for the method.</source>
          <target state="translated">Convention d’appel de la méthode.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The parameter types of the method.</source>
          <target state="translated">Types des paramètres de la méthode.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</source>
          <target state="translated">Tableau de modificateurs de paramètres utilisé pour que la liaison fonctionne avec des signatures de paramètres dans lesquelles les types ont été modifiés.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Returns the module-level method that matches the specified criteria.</source>
          <target state="translated">Retourne la méthode au niveau du module qui correspond aux critères spécifiés.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method that is defined at the module level, and matches the specified criteria; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if such a method does not exist.</source>
          <target state="translated">Méthode définie au niveau du module et qui correspond aux critères spécifiés, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si une telle méthode n'existe pas.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This method provides the implementation for all overloads of the inherited <ph id="ph1">&lt;xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Cette méthode fournit l’implémentation pour toutes les surcharges de hérité <ph id="ph1">&lt;xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Use the inherited <ph id="ph1">&lt;xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType&gt;</ph> method to get methods that have been declared at the module level.</source>
          <target state="translated">Utilisez la <ph id="ph1">&lt;xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType&gt;</ph> méthode pour obtenir les méthodes qui ont été déclarés au niveau du module.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Module-level methods are defined in emitted code by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph> method.</source>
          <target state="translated">Les méthodes au niveau du module sont définies dans le code émis en utilisant le <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Module-level methods cannot be retrieved until after the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method has been called for the module.</source>
          <target state="translated">Les méthodes au niveau du module ne peut pas être récupérées jusqu'à ce qu’après le <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> méthode a été appelée pour le module.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>, or an element of <ph id="ph5">&lt;paramref name="types" /&gt;</ph> is <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> est <ph id="ph4">&lt;see langword="null" /&gt;</ph> ou un élément du paramètre <ph id="ph5">&lt;paramref name="types" /&gt;</ph> est <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>A combination of <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Combinaison des bits indicateurs <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> utilisés pour contrôler la recherche.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns all the methods that have been defined at the module level for the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>, and that match the specified binding flags.</source>
          <target state="translated">Retourne toutes les méthodes définies au niveau du module pour le <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> actuel et qui correspondent aux indicateurs de liaisons spécifiés.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>An array that contains all the module-level methods that match <ph id="ph1">&lt;paramref name="bindingFlags" /&gt;</ph>.</source>
          <target state="translated">Tableau qui contient toutes les méthodes au niveau du module correspondant à <ph id="ph1">&lt;paramref name="bindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Module-level methods are defined in emitted code by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph> method.</source>
          <target state="translated">Les méthodes au niveau du module sont définies dans le code émis en utilisant le <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Module-level methods cannot be retrieved until after the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method has been called for the module.</source>
          <target state="translated">Les méthodes au niveau du module ne peut pas être récupérées jusqu'à ce qu’après le <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> méthode a été appelée pour le module.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Returns the token used to identify the specified method within this module.</source>
          <target state="translated">Retourne le jeton ayant servi à identifier la méthode spécifiée dans ce module.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)">
          <source>The method to get a token for.</source>
          <target state="translated">Méthode pour laquelle un jeton doit être obtenu.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)">
          <source>Returns the token used to identify the specified method within this module.</source>
          <target state="translated">Retourne le jeton ayant servi à identifier la méthode spécifiée dans ce module.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)">
          <source>The token used to identify the specified method within this module.</source>
          <target state="translated">Jeton utilisé pour identifier la méthode spécifiée dans ce module.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)">
          <source>The declaring type for the method is not in this module.</source>
          <target state="translated">Le type déclarant de la méthode ne figure pas dans ce module.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>The method to get a token for.</source>
          <target state="translated">Méthode pour laquelle un jeton doit être obtenu.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>A collection of the types of the optional parameters to the method.</source>
          <target state="translated">Collection de types des paramètres facultatifs à la méthode.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>Returns the token used to identify the method that has the specified attributes and parameter types within this module.</source>
          <target state="translated">Retourne le jeton utilisé pour identifier la méthode qui possède les attributs spécifiés et les types de paramètres dans ce module.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>The token used to identify the specified method within this module.</source>
          <target state="translated">Jeton utilisé pour identifier la méthode spécifiée dans ce module.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>The declaring type for the method is not in this module.</source>
          <target state="translated">Le type déclarant de la méthode ne figure pas dans ce module.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>When this method returns, a combination of the <ph id="ph1">&lt;see cref="T:System.Reflection.PortableExecutableKinds" /&gt;</ph> values indicating the nature of the code in the module.</source>
          <target state="translated">Cette méthode retourne une combinaison des valeurs <ph id="ph1">&lt;see cref="T:System.Reflection.PortableExecutableKinds" /&gt;</ph> indiquant la nature du code dans le module.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>When this method returns, one of the <ph id="ph1">&lt;see cref="T:System.Reflection.ImageFileMachine" /&gt;</ph> values indicating the platform targeted by the module.</source>
          <target state="translated">Cette méthode retourne une des valeurs <ph id="ph1">&lt;see cref="T:System.Reflection.ImageFileMachine" /&gt;</ph> indiquant la plateforme ciblée par le module.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.</source>
          <target state="translated">Obtient une paire de valeurs indiquant la nature du code dans un module et la plateforme ciblée par le module.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>For dynamic modules, <ph id="ph1">`peKind`</ph> is always <ph id="ph2">&lt;xref:System.Reflection.PortableExecutableKinds.NotAPortableExecutableImage?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`machine`</ph> is always 0 (zero).</source>
          <target state="translated">Pour les modules dynamiques, <ph id="ph1">`peKind`</ph> est toujours <ph id="ph2">&lt;xref:System.Reflection.PortableExecutableKinds.NotAPortableExecutableImage?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">`machine`</ph> est toujours 0 (zéro).</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines a signature token.</source>
          <target state="translated">Définit un jeton de signature.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)">
          <source>The signature.</source>
          <target state="translated">Signature.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)">
          <source>Defines a token for the signature that is defined by the specified <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.SignatureHelper" /&gt;</ph>.</source>
          <target state="translated">Définit un jeton pour la signature définie par le <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.SignatureHelper" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)">
          <source>A token for the defined signature.</source>
          <target state="translated">Jeton pour la signature définie.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)">
          <source>This method defines a metadata token for the signature described by <ph id="ph1">`sigHelper`</ph>.</source>
          <target state="translated">Cette méthode définit un jeton de métadonnées pour la signature décrite par <ph id="ph1">`sigHelper`</ph>.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)">
          <source><ph id="ph1">&lt;paramref name="sigHelper" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sigHelper" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)">
          <source>The signature binary large object (BLOB).</source>
          <target state="translated">Objet BLOB de signature.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)">
          <source>The length of the signature BLOB.</source>
          <target state="translated">Longueur de l'objet BLOB de signature.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)">
          <source>Defines a token for the signature that has the specified character array and signature length.</source>
          <target state="translated">Définit un jeton pour la signature possédant le tableau de caractères et la longueur de signature spécifiés.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)">
          <source>A token for the specified signature.</source>
          <target state="translated">Jeton pour la signature spécifiée.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sigBytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sigBytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignerCertificate">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /&gt;</ph> object corresponding to the certificate included in the Authenticode signature of the assembly which this module belongs to.</source>
          <target state="translated">Retourne un objet <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /&gt;</ph> correspondant au certificat inclus dans la signature Authenticode de l'assembly auquel appartient ce module.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignerCertificate">
          <source>If the assembly has not been Authenticode signed, <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">Si l'assembly n'est pas signé avec Authenticode, <ph id="ph1">&lt;see langword="null" /&gt;</ph> est retournée.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignerCertificate">
          <source>A certificate, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the assembly to which this module belongs has not been Authenticode signed.</source>
          <target state="translated">Certificat, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si l'assembly auquel appartient ce module n'est pas signé avec Authenticode.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)">
          <source>The string to add to the module's constant pool.</source>
          <target state="translated">Chaîne à ajouter au pool de constantes du module.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)">
          <source>Returns the token of the given string in the module’s constant pool.</source>
          <target state="translated">Retourne le jeton de la chaîne donnée dans le pool de constantes du module.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)">
          <source>The token of the string in the constant pool.</source>
          <target state="translated">Jeton de la chaîne dans le pool de constantes.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)">
          <source>If <ph id="ph1">`str`</ph> has already been defined, the existing token will be returned.</source>
          <target state="translated">Si <ph id="ph1">`str`</ph> a déjà été défini, le jeton existant est retourné.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter">
          <source>Returns the symbol writer associated with this dynamic module.</source>
          <target state="translated">Retourne le writer de symbole associé à ce module dynamique.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter">
          <source>The symbol writer associated with this dynamic module.</source>
          <target state="translated">Writer de symbole associé à ce module dynamique.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Gets the named type defined in the module.</source>
          <target state="translated">Obtient le type nommé défini dans le module.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">Nom du <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>Gets the named type defined in the module.</source>
          <target state="translated">Obtient le type nommé défini dans le module.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>The requested type, if the type is defined in this module; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Type demandé, si le type est défini dans ce module ; sinon, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>Do not use this method to generate array types, pointer types, or byref types.</source>
          <target state="translated">N’utilisez pas cette méthode pour générer des types tableau, types pointeur ou des types byref.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> methods instead.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, et <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> méthodes à la place.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>Length of <ph id="ph1">&lt;paramref name="className" /&gt;</ph> is zero or is greater than 1023.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="className" /&gt;</ph> est égale à zéro ou supérieure à 1 023.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>The requested <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is non-public and the caller does not have <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> to reflect non-public objects outside the current assembly.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> demandé est non public et l'appelant n'a pas <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> pour réfléchir les objets non publics en dehors de l'assembly en cours.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Un initialiseur de classe est appelé et lève une exception.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>An error is encountered while loading the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Une erreur s'est produite pendant le chargement de <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">Nom du <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, the search is case-insensitive.</source>
          <target state="translated">Si <ph id="ph1">&lt;see langword="true" /&gt;</ph>, la recherche ne respecte pas la casse.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the search is case-sensitive.</source>
          <target state="translated">Si <ph id="ph1">&lt;see langword="false" /&gt;</ph>, la recherche respecte la casse.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>Gets the named type defined in the module, optionally ignoring the case of the type name.</source>
          <target state="translated">Obtient le type nommé défini dans le module en ignorant éventuellement la casse du nom de type.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>The requested type, if the type is defined in this module; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Type demandé, si le type est défini dans ce module ; sinon, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>Do not use this method to generate array types, pointer types, or byref types.</source>
          <target state="translated">N’utilisez pas cette méthode pour générer des types tableau, types pointeur ou des types byref.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> methods instead.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, et <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> méthodes à la place.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>Length of <ph id="ph1">&lt;paramref name="className" /&gt;</ph> is zero or is greater than 1023.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="className" /&gt;</ph> est égale à zéro ou supérieure à 1 023.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>The requested <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is non-public and the caller does not have <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> to reflect non-public objects outside the current assembly.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> demandé est non public et l'appelant n'a pas <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> pour réfléchir les objets non publics en dehors de l'assembly en cours.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Un initialiseur de classe est appelé et lève une exception.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">Nom du <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour lever une exception si le type est introuvable ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour retourner <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, the search is case-insensitive.</source>
          <target state="translated">Si <ph id="ph1">&lt;see langword="true" /&gt;</ph>, la recherche ne respecte pas la casse.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the search is case-sensitive.</source>
          <target state="translated">Si <ph id="ph1">&lt;see langword="false" /&gt;</ph>, la recherche respecte la casse.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the named type defined in the module, optionally ignoring the case of the type name.</source>
          <target state="translated">Obtient le type nommé défini dans le module en ignorant éventuellement la casse du nom de type.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Optionally throws an exception if the type is not found.</source>
          <target state="translated">Peut lever une exception, si le type est introuvable.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The specified type, if the type is declared in this module; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Type spécifié, si le type est déclaré dans ce module ; sinon, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter only affects what happens when the type is not found.</source>
          <target state="translated">Le <ph id="ph1">`throwOnError`</ph> paramètre affecte uniquement ce qui se passe lorsque le type est introuvable.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>It does not affect any other exceptions that might be thrown.</source>
          <target state="translated">Il n’affecte pas toutes les exceptions qui peuvent être levées.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In particular, if the type is found but cannot be loaded, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> can be thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">En particulier, si le type est trouvé mais ne peut pas être chargé, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> peut être levée même si <ph id="ph2">`throwOnError`</ph> est <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Do not use this method to generate array types, pointer types, or byref types.</source>
          <target state="translated">N’utilisez pas cette méthode pour générer des types tableau, types pointeur ou des types byref.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> methods instead.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, et <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> méthodes à la place.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Length of <ph id="ph1">&lt;paramref name="className" /&gt;</ph> is zero or is greater than 1023.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="className" /&gt;</ph> est égale à zéro ou supérieure à 1 023.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The requested <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is non-public and the caller does not have <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> to reflect non-public objects outside the current assembly.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> demandé est non public et l'appelant n'a pas <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> pour réfléchir les objets non publics en dehors de l'assembly en cours.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Un initialiseur de classe est appelé et lève une exception.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the specified type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="true" /&gt;</ph> et le type spécifié est introuvable.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>Returns all the classes defined within this module.</source>
          <target state="translated">Retourne toutes les classes définies dans ce module.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>An array that contains the types defined within the module that is reflected by this instance.</source>
          <target state="translated">Tableau qui contient les types définis dans le module réfléchi par cette instance.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source><ph id="ph1">`ReflectionTypeLoadException`</ph> is a special class load exception.</source>
          <target state="translated"><ph id="ph1">`ReflectionTypeLoadException`</ph> est une exception de chargement de classe spéciale.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> property contains the array of classes that were defined in the module and loaded.</source>
          <target state="translated">Le <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> propriété contient le tableau des classes qui ont été définies dans le module et chargées.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>This array can contain some null values.</source>
          <target state="translated">Ce tableau peut contenir des valeurs null.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> property is an array of exceptions that represent the exceptions that were thrown by the class loader.</source>
          <target state="translated">Le <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> propriété est un tableau d’exceptions qui représentent les exceptions levées par le chargeur de classes.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>The holes in the class array line up with the exceptions.</source>
          <target state="translated">Les trous dans le tableau de classe s’aligner avec les exceptions.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>For example, if the class initializers of one of the classes throws an exception while it is being loaded, a <ph id="ph1">`TargetInvocationException`</ph> is stored in the corresponding element of the <ph id="ph2">`LoaderExceptions`</ph> array.</source>
          <target state="translated">Par exemple, si les initialiseurs de classe d’une des classes lève une exception pendant elle est chargée, un <ph id="ph1">`TargetInvocationException`</ph> est stocké dans l’élément correspondant de le <ph id="ph2">`LoaderExceptions`</ph> tableau.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>One or more classes in a module could not be loaded.</source>
          <target state="translated">Au moins une des classes d’un module n’a pas pu être chargée.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Returns a type token.</source>
          <target state="translated">Retourne un jeton de type.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>The name of the class, including the namespace.</source>
          <target state="translated">Nom de la classe, espace de noms compris.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>Returns the token used to identify the type with the specified name.</source>
          <target state="translated">Retourne le jeton utilisé pour identifier le type portant le nom spécifié.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>The token used to identify the type with the specified name within this module.</source>
          <target state="translated">Jeton utilisé pour identifier le type portant le nom spécifié dans ce module.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>This method is useful for clients of the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodRental&gt;</ph> class who want to directly modify the body of a method.</source>
          <target state="translated">Cette méthode est utile pour les clients de la <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodRental&gt;</ph> classe qui veulent modifier directement le corps d’une méthode.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est la chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> represents a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> représente un type <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>The type specified by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> could not be found.</source>
          <target state="translated">Le type spécifié par <ph id="ph1">&lt;paramref name="name" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>This is a non-transient module that references a transient module.</source>
          <target state="translated">Il s'agit d'un module non transitoire qui référence un module transitoire.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>The type object that represents the class type.</source>
          <target state="translated">Objet de type représentant le type classe.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>Returns the token used to identify the specified type within this module.</source>
          <target state="translated">Retourne le jeton servant à identifier le type spécifié dans ce module.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>The token used to identify the given type within this module.</source>
          <target state="translated">Jeton utilisé pour identifier le type donné dans ce module.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>Tokens are used in Microsoft intermediate language (MSIL) instructions to identify objects.</source>
          <target state="translated">Pour identifier les objets, les jetons sont utilisés dans les instructions Microsoft intermediate language (MSIL).</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>Tokens are relative to the module in which they are contained.</source>
          <target state="translated">Les jetons sont fonction du module dans lequel elles sont contenues.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>For example, the token value for <ph id="ph1">`String`</ph> is likely to be different from module to module.</source>
          <target state="translated">Par exemple, la valeur du jeton pour <ph id="ph1">`String`</ph> est susceptible d’être différente pour chaque module.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>When <ph id="ph1">`GetTypeToken`</ph> is invoked, a reference is added to the module.</source>
          <target state="translated">Lorsque <ph id="ph1">`GetTypeToken`</ph> est appelé, une référence est ajoutée au module.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>The reference becomes a permanent part of the module; multiple calls with the same argument have no additional effect.</source>
          <target state="translated">La référence devient partie intégrante du module ; plusieurs appels avec le même argument n’auront aucun effet supplémentaire.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> est un type <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>This is a non-transient module that references a transient module.</source>
          <target state="translated">Il s'agit d'un module non transitoire qui référence un module transitoire.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source>The type of custom attribute to test for.</source>
          <target state="translated">Type de l'attribut personnalisé à tester.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Cet argument est ignoré pour les objets de ce type.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Returns a value that indicates whether the specified attribute type has been applied to this module.</source>
          <target state="translated">Retourne une valeur qui indique si le type d'attribut spécifié a été appliqué à ce module.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if one or more instances of <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> have been applied to this module; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si une ou plusieurs instances de <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> ont été appliquées à ce module ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object supplied by the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> n'est pas un objet <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> fourni par le runtime.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source>For example, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> est un objet <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsResource">
          <source>Gets a value indicating whether the object is a resource.</source>
          <target state="translated">Obtient une valeur indiquant si l'objet est une ressource.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsResource">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the object is a resource; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'objet est une ressource ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsTransient">
          <source>Returns a value that indicates whether this dynamic module is transient.</source>
          <target state="translated">Retourne une valeur qui indique si ce module dynamique est transitoire.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsTransient">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this dynamic module is transient; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si ce module dynamique est transitoire ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
          <source>Gets the metadata stream version.</source>
          <target state="translated">Obtient la version de flux des métadonnées.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
          <source>A 32-bit integer representing the metadata stream version.</source>
          <target state="translated">Entier 32 bits représentant la version de flux des métadonnées.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
          <source>The high-order two bytes represent the major version number, and the low-order two bytes represent the minor version number.</source>
          <target state="translated">Les deux octets de poids fort représentent le numéro de la version principale, et les deux octets de poids faible représentent le numéro de la version secondaire.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
          <source>For more information on the metadata header, see "Partition II: Metadata Definition and Semantics" in the Common Language Infrastructure (CLI) documentation.</source>
          <target state="translated">Pour plus d’informations sur l’en-tête de métadonnées, consultez « Partition II : Metadata Definition et Semantics » dans la documentation du Common Language Infrastructure (CLI).</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentation est disponible en ligne. consultez <bpt id="p1">[</bpt>Common Language Infrastructure Standards et c# ECMA<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> sur MSDN et <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> sur le site Web ECMA.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>Gets a token that identifies the current dynamic module in metadata.</source>
          <target state="translated">Obtient un jeton qui identifie le module dynamique actuel dans les métadonnées.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>An integer token that identifies the current module in metadata.</source>
          <target state="translated">Jeton d'entier qui identifie le module actuel dans les métadonnées.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>The tokens obtained using this property can be passed to the unmanaged Reflection API.</source>
          <target state="translated">Les jetons obtenus à l’aide de cette propriété peuvent être passés à l’API de réflexion non managée.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>For more information, see <bpt id="p1">[</bpt>Unmanaged Reflection API<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>API de réflexion non managée<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Vous trouverez plus d’informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentation est disponible en ligne. consultez <bpt id="p1">[</bpt>Common Language Infrastructure Standards et c# ECMA<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> sur MSDN et <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> sur le site Web ECMA.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
          <source>Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</source>
          <target state="translated">Obtient un identificateur unique universel (UUID) qui peut être utilisé pour faire la distinction entre deux versions d’un module.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
          <source>A <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> that can be used to distinguish between two versions of a module.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> qui peut être utilisé pour faire la distinction entre deux versions d’un module.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
          <source>In unmanaged metadata, the GUID returned by the <ph id="ph1">&lt;xref:System.Reflection.Module.ModuleVersionId%2A&gt;</ph> property is referred to as the <ph id="ph2">`mvid`</ph>, and is stored in the GUID heap.</source>
          <target state="translated">Dans les métadonnées non managées, le GUID retourné par le <ph id="ph1">&lt;xref:System.Reflection.Module.ModuleVersionId%2A&gt;</ph> propriété constitue le <ph id="ph2">`mvid`</ph>et est stocké dans le tas GUID.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
          <source>More information about metadata can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Vous trouverez plus d’informations sur les métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentation est disponible en ligne. consultez <bpt id="p1">[</bpt>Common Language Infrastructure Standards et c# ECMA<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> sur MSDN et <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> sur le site Web ECMA.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.Name">
          <source>A string that indicates that this is an in-memory module.</source>
          <target state="translated">Chaîne qui indique qu'il s'agit d'un module en mémoire.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.Name">
          <source>Text that indicates that this is an in-memory module.</source>
          <target state="translated">Texte qui indique qu'il s'agit d'un module en mémoire.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.Name">
          <source>The name of a dynamic module cannot be obtained until the module has been saved and reloaded from disk.</source>
          <target state="translated">Le nom d’un module dynamique ne peut pas être obtenu jusqu'à ce que le module a été enregistré et rechargé à partir du disque.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a field in the module.</source>
          <target state="translated">Jeton de métadonnées qui identifie un champ dans le module.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Tableau d'objets <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> représentant les arguments de type générique du type pour lequel le jeton est dans la portée, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si ce type n'est pas générique.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Tableau d'objets <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> représentant les arguments de type générique de la méthode pour laquelle le jeton est dans la portée, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si cette méthode n'est pas générique.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Retourne le champ identifié par le jeton de métadonnées spécifié dans le contexte défini par les paramètres de type générique spécifiés.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field that is identified by the specified metadata token.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> qui représente le champ identifié par le jeton de métadonnées spécifié.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> méthode sur le type où <ph id="ph2">`metadataToken`</ph> est dans la portée pour obtenir un tableau d’arguments de type générique pour <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> méthode sur la méthode où <ph id="ph2">`metadataToken`</ph> est dans la portée pour obtenir un tableau d’arguments de type générique pour <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Il est recommandé de fournir ces arguments, même lorsqu’ils ne sont pas nécessaires.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Vous trouverez plus d’informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentation est disponible en ligne. consultez <bpt id="p1">[</bpt>Common Language Infrastructure Standards et c# ECMA<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> sur MSDN et <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> sur le site Web ECMA.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour le code qui illustre la résolution du jeton à l’aide du contexte générique (autrement dit, les paramètres de type générique de type générique ou de la méthode générique à laquelle le jeton est incorporé) consultez les <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a field in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> n'est pas un jeton de champ dans la portée du module actuel.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a field whose parent <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> has a signature containing element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifie un champ dont le <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> parent a une signature contenant le type d'élément <ph id="ph3">&lt;see langword="var" /&gt;</ph> (un paramètre de type d'un type générique) ou <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (un paramètre de type d'une méthode générique), et les arguments de type générique nécessaires n'ont pas été fournis pour <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> ou <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph> (ou pour les deux).</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> n'est pas un jeton valide dans la portée du module actuel.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a type or member in the module.</source>
          <target state="translated">Jeton de métadonnées qui identifie un type ou un membre dans le module.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Tableau d'objets <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> représentant les arguments de type générique du type pour lequel le jeton est dans la portée, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si ce type n'est pas générique.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Tableau d'objets <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> représentant les arguments de type générique de la méthode pour laquelle le jeton est dans la portée, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si cette méthode n'est pas générique.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Retourne le type ou le membre identifié par le jeton de métadonnées spécifié dans le contexte défini par les paramètres de type générique spécifiés.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> object representing the type or member that is identified by the specified metadata token.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> représentant le type ou le membre identifié par le jeton de métadonnées spécifié.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> méthode sur le type où <ph id="ph2">`metadataToken`</ph> est dans la portée pour obtenir un tableau d’arguments de type générique pour <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> méthode sur la méthode où <ph id="ph2">`metadataToken`</ph> est dans la portée pour obtenir un tableau d’arguments de type générique pour <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Il est recommandé de fournir ces arguments, même lorsqu’ils ne sont pas nécessaires.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Vous trouverez plus d’informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentation est disponible en ligne. consultez <bpt id="p1">[</bpt>Common Language Infrastructure Standards et c# ECMA<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> sur MSDN et <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> sur le site Web ECMA.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour le code qui illustre la résolution du jeton à l’aide du contexte générique (autrement dit, les paramètres de type générique de type générique ou de la méthode générique à laquelle le jeton est incorporé) consultez les <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type or member in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> n'est pas un jeton pour un type ou un membre dans la portée du module actuel.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> or <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph4">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph6">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph7">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> est un <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> ou <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> dont la signature contient un type d'élément <ph id="ph4">&lt;see langword="var" /&gt;</ph> (un paramètre de type d'un type générique) ou <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (un paramètre de type d'une méthode générique), et les arguments de type générique nécessaires n'ont pas été fournis pour <ph id="ph6">&lt;paramref name="genericTypeArguments" /&gt;</ph> ou <ph id="ph7">&lt;paramref name="genericMethodArguments" /&gt;</ph> (ou pour les deux).</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a property or event.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifie une propriété ou un événement.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> n'est pas un jeton valide dans la portée du module actuel.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a method or constructor in the module.</source>
          <target state="translated">Jeton de métadonnées qui identifie une méthode ou un constructeur dans le module.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Tableau d'objets <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> représentant les arguments de type générique du type pour lequel le jeton est dans la portée, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si ce type n'est pas générique.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Tableau d'objets <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> représentant les arguments de type générique de la méthode pour laquelle le jeton est dans la portée, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si cette méthode n'est pas générique.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Retourne la méthode ou le constructeur identifié par le jeton de métadonnées spécifié dans le contexte défini par les paramètres de type générique spécifiés.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object representing the method that is identified by the specified metadata token.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> qui représente la méthode identifiée par le jeton de métadonnées spécifié.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> méthode sur le type où <ph id="ph2">`metadataToken`</ph> est dans la portée pour obtenir un tableau d’arguments de type générique pour <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericMethodArguments`</ph>.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> méthode sur la méthode où <ph id="ph2">`metadataToken`</ph> est dans la portée pour obtenir un tableau d’arguments de type générique pour <ph id="ph3">`genericMethodArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Il est recommandé de fournir ces arguments, même lorsqu’ils ne sont pas nécessaires.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Vous trouverez plus d’informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentation est disponible en ligne. consultez <bpt id="p1">[</bpt>Common Language Infrastructure Standards et c# ECMA<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> sur MSDN et <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> sur le site Web ECMA.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour le code qui illustre la résolution du jeton à l’aide du contexte générique (autrement dit, les paramètres de type générique de type générique ou de la méthode générique à laquelle le jeton est incorporé) consultez les <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a method or constructor in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> n'est pas un jeton pour une méthode ou un constructeur dans la portée du module en cours.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> est un <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> dont la signature contient un type d'élément <ph id="ph3">&lt;see langword="var" /&gt;</ph> (un paramètre de type d'un type générique) ou <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (un paramètre de type d'une méthode générique), et les arguments de type générique nécessaires n'ont pas été fournis pour <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> ou <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph> (ou pour les deux).</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> n'est pas un jeton valide dans la portée du module actuel.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source>A metadata token that identifies a signature in the module.</source>
          <target state="translated">Jeton de métadonnées qui identifie une signature dans le module.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source>Returns the signature blob identified by a metadata token.</source>
          <target state="translated">Retourne le blob de signature identifié par un jeton de métadonnées.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source>An array of bytes representing the signature blob.</source>
          <target state="translated">Tableau d'octets représentant le blob de signature.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source>Information about metadata tokens and signatures can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Vous trouverez des informations sur les jetons de métadonnées et les signatures dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentation est disponible en ligne. consultez <bpt id="p1">[</bpt>Common Language Infrastructure Standards et c# ECMA<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> sur MSDN et <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> sur le site Web ECMA.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid <ph id="ph2">&lt;see langword="MemberRef" /&gt;</ph>, <ph id="ph3">&lt;see langword="MethodDef" /&gt;</ph>, <ph id="ph4">&lt;see langword="TypeSpec" /&gt;</ph>, signature, or <ph id="ph5">&lt;see langword="FieldDef" /&gt;</ph> token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph>n'est pas un <ph id="ph2">&lt;see langword="MemberRef" /&gt;</ph>, un <ph id="ph3">&lt;see langword="MethodDef" /&gt;</ph>, un <ph id="ph4">&lt;see langword="TypeSpec" /&gt;</ph>, une signature ou un jeton <ph id="ph5">&lt;see langword="FieldDef" /&gt;</ph> valide dans la portée du module en cours.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> n'est pas un jeton valide dans la portée du module actuel.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source>A metadata token that identifies a string in the string heap of the module.</source>
          <target state="translated">Jeton de métadonnées qui identifie une chaîne dans le tas de chaînes du module.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source>Returns the string identified by the specified metadata token.</source>
          <target state="translated">Retourne la chaîne identifiée par le jeton de métadonnées spécifié.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing a string value from the metadata string heap.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> contenant une valeur de chaîne du tas de chaînes des métadonnées.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Vous trouverez plus d’informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentation est disponible en ligne. consultez <bpt id="p1">[</bpt>Common Language Infrastructure Standards et c# ECMA<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> sur MSDN et <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> sur le site Web ECMA.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a string in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> n'est pas un jeton pour une chaîne dans la portée du module actuel.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> n'est pas un jeton valide dans la portée du module actuel.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a type in the module.</source>
          <target state="translated">Jeton de métadonnées qui identifie un type dans le module.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Tableau d'objets <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> représentant les arguments de type générique du type pour lequel le jeton est dans la portée, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si ce type n'est pas générique.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Tableau d'objets <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> représentant les arguments de type générique de la méthode pour laquelle le jeton est dans la portée, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si cette méthode n'est pas générique.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Retourne le type identifié par le jeton de métadonnées spécifié dans le contexte défini par les paramètres de type générique spécifiés.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the type that is identified by the specified metadata token.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> qui représente le type identifié par le jeton de métadonnées spécifié.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> méthode sur le type où <ph id="ph2">`metadataToken`</ph> est dans la portée pour obtenir un tableau d’arguments de type générique pour <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> méthode sur la méthode où <ph id="ph2">`metadataToken`</ph> est dans la portée pour obtenir un tableau d’arguments de type générique pour <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Il est recommandé de fournir ces arguments, même lorsqu’ils ne sont pas nécessaires.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Vous trouverez plus d’informations sur les jetons de métadonnées dans la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">La documentation est disponible en ligne. consultez <bpt id="p1">[</bpt>Common Language Infrastructure Standards et c# ECMA<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> sur MSDN et <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> sur le site Web ECMA.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour le code qui illustre la résolution du jeton à l’aide du contexte générique (autrement dit, les paramètres de type générique de type générique ou de la méthode générique à laquelle le jeton est incorporé) consultez les <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> n'est pas le jeton d'un type dans la portée du module en cours.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> est un <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> dont la signature contient un type d'élément <ph id="ph3">&lt;see langword="var" /&gt;</ph> (un paramètre de type d'un type générique) ou <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (un paramètre de type d'une méthode générique), et les arguments de type générique nécessaires n'ont pas été fournis pour <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> ou <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph> (ou pour les deux).</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> n'est pas un jeton valide dans la portée du module actuel.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.ScopeName">
          <source>Gets a string that represents the name of the dynamic module.</source>
          <target state="translated">Obtient une chaîne qui représente le nom du module dynamique.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.ScopeName">
          <source>The name of the dynamic module.</source>
          <target state="translated">Nom du module dynamique.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Applies a custom attribute to this module.</source>
          <target state="translated">Applique un attribut personnalisé à ce module.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>An instance of a helper class that specifies the custom attribute to apply.</source>
          <target state="translated">Instance de classe d'assistance qui spécifie l'attribut personnalisé à appliquer.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Applies a custom attribute to this module by using a custom attribute builder.</source>
          <target state="translated">Applique un attribut personnalisé à ce module à l'aide d'un générateur d'attributs personnalisés.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The constructor for the custom attribute.</source>
          <target state="translated">Le constructeur de l’attribut personnalisé.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>A byte BLOB representing the attribute.</source>
          <target state="translated">Objet BLOB d'octets représentant l'attribut.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Applies a custom attribute to this module by using a specified binary large object (BLOB) that represents the attribute.</source>
          <target state="translated">Applique un attribut personnalisé à ce module à l'aide d'un objet BLOB spécifié qui représente l'attribut.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For more information about how to format <ph id="ph1">`binaryAttribute`</ph>, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Pour plus d’informations sur la mise en forme <ph id="ph1">`binaryAttribute`</ph>, consultez la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ».</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentation est disponible en ligne. Consultez <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> sur MSDN et <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> sur le site web d’Ecma International.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> or <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The name of the custom attribute</source>
          <target state="translated">Nom de l'attribut personnalisé.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>An opaque binary large object (BLOB) of bytes that represents the value of the custom attribute.</source>
          <target state="translated">Objet BLOB d'octets opaque qui représente la valeur de l'attribut personnalisé.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>This method does nothing.</source>
          <target state="translated">Cette méthode ne réalise aucune action.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>This method does nothing.</source>
          <target state="translated">Cette méthode ne réalise aucune action.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="url" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="url" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>The user entry point.</source>
          <target state="translated">Point d'entrée utilisateur.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>Sets the user entry point.</source>
          <target state="translated">Définit le point d'entrée utilisateur.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>The compiler might generate a startup stub before calling user main.</source>
          <target state="translated">Le compilateur peut générer un stub de démarrage avant d’appeler l’utilisateur principal.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>The startup stub will be the entry point.</source>
          <target state="translated">Le stub de démarrage sera le point d’entrée.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>While the user main will be the user entry point so that debugger will not step into the compiler entry point.</source>
          <target state="translated">Pendant que l’utilisateur principal sera le point d’entrée utilisateur afin que le débogueur pas à pas détaillé du point d’entrée du compilateur.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, ce membre n’a plus besoin <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>émettre des problèmes de sécurité dans la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="entryPoint" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="entryPoint" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>This method is called on a dynamic module that is not a debug module.</source>
          <target state="translated">Cette méthode est appelée sur un module dynamique qui n'est pas un module de débogage.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="entryPoint" /&gt;</ph> is not contained in this dynamic module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="entryPoint" /&gt;</ph> n'est pas contenu dans ce module dynamique.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Réservé à un usage ultérieur.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Doit être IID_NULL.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Tableau passé des noms à mapper.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Compte des noms à mapper.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Contexte des paramètres régionaux dans lequel interpréter les noms.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Tableau alloué par l'appelant et recevant les ID qui correspondent aux noms.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, consultez MSDN Library.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">La méthode est appelée à liaison tardive à l’aide de l’interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Informations de type à retourner.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Identificateur des paramètres régionaux pour les informations de type.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>A pointer to the requested type information object.</source>
          <target state="translated">Pointeur vers l'objet d'informations de type demandé.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, consultez MSDN Library.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">La méthode est appelée à liaison tardive à l’aide de l’interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>The location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Emplacement qui reçoit le nombre d'interfaces d'informations de type fourni par l'objet.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(System.UInt32@)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(System.UInt32@)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, consultez MSDN Library.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">La méthode est appelée à liaison tardive à l’aide de l’interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The member ID.</source>
          <target state="translated">ID de membre.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Réservé à un usage ultérieur.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Doit être IID_NULL.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Contexte des paramètres régionaux dans lequel interpréter les arguments.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Indicateurs décrivant le contexte de l'appel.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Pointeur vers une structure qui contient un tableau d’arguments, un tableau d’arguments DISPID pour les arguments nommés et le nombre d’éléments de chaque tableau.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Pointeur vers l'emplacement où le résultat doit être stocké.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Pointeur vers une structure qui contient les informations sur les exceptions.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Index du premier argument comportant une erreur.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur <ph id="ph1">`IDispatch::Invoke`</ph>, consultez MSDN Library.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">La méthode est appelée à liaison tardive à l’aide de l’interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>