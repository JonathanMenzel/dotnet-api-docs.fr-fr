<Type Name="DynamicILInfo" FullName="System.Reflection.Emit.DynamicILInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3fb2475d512306a7b04576fcbde93ad19af06c77" /><Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/17/2018" /><Meta Name="ms.locfileid" Value="51890032" /></Metadata><TypeSignature Language="C#" Value="public class DynamicILInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DynamicILInfo extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicILInfo" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicILInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicILInfo" />
  <TypeSignature Language="F#" Value="type DynamicILInfo = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit la prise en charge d'autres façons de générer le code MSIL (Microsoft Intermediate Language) et les métadonnées d'une méthode dynamique, y compris les méthodes pour créer des jetons et pour insérer le code, la gestion des exceptions et les blobs de signature de variables locales.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Emit.DynamicILInfo> classe permet aux développeurs d’écrire leurs propres générateurs MSIL au lieu d’utiliser <xref:System.Reflection.Emit.ILGenerator>.  
  
 Pour créer des instances d’autres types, appeler des méthodes et ainsi de suite, le MSIL que vous générez doit inclure des jetons pour ces entités. Le <xref:System.Reflection.Emit.DynamicILInfo> classe fournit plusieurs surcharges de la <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A> (méthode), qui retournent des jetons valides dans la portée de l’actuel <xref:System.Reflection.Emit.DynamicILInfo>. Par exemple, si vous devez appeler une surcharge de la <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> (méthode), vous pouvez obtenir un <xref:System.RuntimeMethodHandle> pour cette surcharge et transmettez-le à la <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A> méthode pour obtenir un jeton à incorporer dans votre code MSIL.  
  
 Une fois que vous avez créé <xref:System.Byte> tableaux pour votre signature de variable locale, les exceptions et les corps de code, vous pouvez utiliser la <xref:System.Reflection.Emit.DynamicILInfo.SetCode%2A>, <xref:System.Reflection.Emit.DynamicILInfo.SetExceptions%2A>, et <xref:System.Reflection.Emit.DynamicILInfo.SetLocalSignature%2A> méthodes pour les insérer dans le <xref:System.Reflection.Emit.DynamicMethod> associé à votre <xref:System.Reflection.Emit.DynamicILInfo> objet.  
  
 Génération de vos propres métadonnées et MSIL nécessaire de connaître la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition and Semantics » et « Partition III : CIL Instruction Set ». La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
> [!NOTE]
>  N’utilisez pas <xref:System.Reflection.Emit.DynamicILInfo> pour générer le code qui crée un délégué à une autre méthode dynamique en appelant le constructeur délégué directement. Au lieu de cela, utilisez la <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> méthode pour créer le délégué. Un délégué est créé avec le constructeur délégué n’a pas une référence à la méthode dynamique cible. La méthode dynamique peut être récupérée par le garbage collection pendant que le délégué est en cours d’utilisation.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="DynamicMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicMethod DynamicMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Emit.DynamicMethod DynamicMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicILInfo.DynamicMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicMethod As DynamicMethod" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::DynamicMethod ^ DynamicMethod { System::Reflection::Emit::DynamicMethod ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicMethod : System.Reflection.Emit.DynamicMethod" Usage="System.Reflection.Emit.DynamicILInfo.DynamicMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicMethod</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la méthode dynamique dont le corps est généré par l'instance actuelle.</summary>
        <value>Objet <see cref="T:System.Reflection.Emit.DynamicMethod" /> qui représente la méthode dynamique pour laquelle l'objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel génère le code.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Reflection.Emit.DynamicILInfo> objet est toujours associé à une méthode dynamique. L’objectif de la <xref:System.Reflection.Emit.DynamicILInfo> classe consiste à fournir une autre façon d’insérer le flux MSIL, la gestion des exceptions et la signature de variable locale dans une méthode dynamique, pour les développeurs qui souhaitent génèrent du code MSIL sans utiliser le <xref:System.Reflection.Emit.ILGenerator> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTokenFor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, représentant une chaîne, un champ, une méthode, un type ou une signature dans le flux MSIL de la méthode dynamique associée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (byte[] signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(unsigned int8[] signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (signature As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(cli::array &lt;System::Byte&gt; ^ signature);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : byte[] -&gt; int" Usage="dynamicILInfo.GetTokenFor signature" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="signature">Tableau qui contient la signature.</param>
        <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, représentant la signature de la méthode dynamique associée.</summary>
        <returns>Jeton qui peut être incorporé dans les métadonnées et le flux MSIL de la méthode dynamique associée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur les objets BLOB de signature, consultez la documentation de Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ». La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (System.Reflection.Emit.DynamicMethod method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(class System.Reflection.Emit.DynamicMethod method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Reflection.Emit.DynamicMethod)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (method As DynamicMethod) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(System::Reflection::Emit::DynamicMethod ^ method);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : System.Reflection.Emit.DynamicMethod -&gt; int" Usage="dynamicILInfo.GetTokenFor method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.Emit.DynamicMethod" />
      </Parameters>
      <Docs>
        <param name="method">Méthode dynamique à appeler.</param>
        <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, représentant une méthode dynamique à appeler par la méthode associée.</summary>
        <returns>Jeton qui peut être incorporé dans le flux MSIL de la méthode dynamique associée, comme cible d'une instruction MSIL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le jeton retourné par cette surcharge de méthode vous permet d’appeler une méthode dynamique à partir de la méthode dynamique associée à l’actuel <xref:System.Reflection.Emit.DynamicILInfo> objet. Pour appeler la méthode dynamique associée de manière récursive, passez la valeur de la <xref:System.Reflection.Emit.DynamicILInfo.DynamicMethod%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeFieldHandle field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeFieldHandle field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (field As RuntimeFieldHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeFieldHandle field);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeFieldHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor field" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.RuntimeFieldHandle" />
      </Parameters>
      <Docs>
        <param name="field">Champ auquel accéder.</param>
        <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, représentant un champ accessible à partir de la méthode dynamique associée.</summary>
        <returns>Jeton qui peut être utilisé comme opérande d'une instruction MSIL qui accède à des champs, dans la portée de l'objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez obtenir un jeton pour tout champ qui sera accessible par la méthode dynamique associée à l’actuel <xref:System.Reflection.Emit.DynamicILInfo> objet. Utiliser le <xref:System.Type.GetField%2A?displayProperty=nameWithType> méthode pour obtenir un <xref:System.Reflection.FieldInfo> pour le champ que vous souhaitez accéder, puis utilisez le <xref:System.Reflection.FieldInfo.FieldHandle%2A> propriété à obtenir le <xref:System.RuntimeFieldHandle>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeMethodHandle method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeMethodHandle method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (method As RuntimeMethodHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeMethodHandle method);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeMethodHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="method">Méthode à laquelle accéder.</param>
        <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, représentant une méthode à laquelle accéder à partir de la méthode dynamique associée.</summary>
        <returns>Jeton qui peut être utilisé comme opérande d'une instruction MSIL qui accède à des méthodes, telles que <see cref="F:System.Reflection.Emit.OpCodes.Call" /> ou <see cref="F:System.Reflection.Emit.OpCodes.Ldtoken" />, dans la portée de l'objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez obtenir un jeton pour toute méthode qui sera accessible par la méthode dynamique associée à l’actuel <xref:System.Reflection.Emit.DynamicILInfo> objet. Utiliser le <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> méthode pour obtenir un <xref:System.Reflection.MethodInfo> pour la méthode que vous souhaitez accéder et utiliser ensuite le <xref:System.Reflection.MethodBase.MethodHandle%2A> propriété à obtenir le <xref:System.RuntimeMethodHandle>.  
  
> [!NOTE]
>  Pour une méthode qui appartient à un type générique, utilisez le <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%29> surcharge de méthode et spécifiez un <xref:System.RuntimeTypeHandle> pour le type générique.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeTypeHandle type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeTypeHandle type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (type As RuntimeTypeHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeTypeHandle type);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeTypeHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="type">Type à utiliser.</param>
        <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, représentant un type à utiliser dans la méthode dynamique associée.</summary>
        <returns>Jeton qui peut être utilisé comme opérande d'une instruction MSIL qui nécessite un type, dans la portée de l'objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le jeton retourné par cette surcharge de méthode vous permet de définir un type de variable locale et émettre du code MSIL pour créer une instance d’un type dans la méthode dynamique associée à l’actuel <xref:System.Reflection.Emit.DynamicILInfo> objet.  
  
 Pour obtenir un <xref:System.RuntimeTypeHandle> représentant un type, utilisez le <xref:System.Type.TypeHandle%2A?displayProperty=nameWithType> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (string literal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(string literal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (literal As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(System::String ^ literal);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : string -&gt; int" Usage="dynamicILInfo.GetTokenFor literal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="literal" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="literal">Chaîne à utiliser.</param>
        <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, représentant un littéral de chaîne à utiliser dans la méthode dynamique associée.</summary>
        <returns>Jeton qui peut être utilisé comme opérande d'une instruction MSIL qui nécessite une chaîne, dans la portée de l'objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeFieldHandle field, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeFieldHandle field, valuetype System.RuntimeTypeHandle contextType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (field As RuntimeFieldHandle, contextType As RuntimeTypeHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeFieldHandle * RuntimeTypeHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor (field, contextType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.RuntimeFieldHandle" />
        <Parameter Name="contextType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="field">Champ auquel accéder.</param>
        <param name="contextType">Type générique auquel le champ appartient.</param>
        <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, représentant un champ accessible à partir de la méthode dynamique associée ; le champ est du type générique spécifié.</summary>
        <returns>Jeton qui peut être utilisé comme opérande d'une instruction MSIL qui accède à des champs dans la portée de l'objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actif.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez obtenir un jeton pour tout champ qui sera accessible par la méthode dynamique associée à l’actuel <xref:System.Reflection.Emit.DynamicILInfo> objet. Utiliser le <xref:System.Type.GetField%2A?displayProperty=nameWithType> méthode pour obtenir un <xref:System.Reflection.FieldInfo> pour le champ que vous souhaitez accéder et utiliser ensuite le <xref:System.Reflection.FieldInfo.FieldHandle%2A> propriété à obtenir le <xref:System.RuntimeFieldHandle>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeMethodHandle method, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeMethodHandle method, valuetype System.RuntimeTypeHandle contextType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (method As RuntimeMethodHandle, contextType As RuntimeTypeHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeMethodHandle * RuntimeTypeHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor (method, contextType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
        <Parameter Name="contextType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="method">Méthode.</param>
        <param name="contextType">Type générique auquel la méthode appartient.</param>
        <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, qui représente une méthode sur un type générique.</summary>
        <returns>Jeton qui peut être utilisé comme opérande d'une instruction MSIL qui accède à des méthodes, telles que <see cref="F:System.Reflection.Emit.OpCodes.Call" /> ou <see cref="F:System.Reflection.Emit.OpCodes.Ldtoken" />, dans la portée de l'objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez obtenir un jeton pour toute méthode qui sera appelée par la méthode dynamique associée à l’actuel <xref:System.Reflection.Emit.DynamicILInfo> objet. Utiliser le <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> méthode pour obtenir un <xref:System.Reflection.MethodInfo> pour la méthode que vous souhaitez appeler, puis utiliser le <xref:System.Reflection.MethodBase.MethodHandle%2A> propriété à obtenir le <xref:System.RuntimeMethodHandle>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCode">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit le corps du code de la méthode dynamique associée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCode">
      <MemberSignature Language="C#" Value="public void SetCode (byte[] code, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCode(unsigned int8[] code, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCode (code As Byte(), maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCode(cli::array &lt;System::Byte&gt; ^ code, int maxStackSize);" />
      <MemberSignature Language="F#" Value="member this.SetCode : byte[] * int -&gt; unit" Usage="dynamicILInfo.SetCode (code, maxStackSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Byte[]" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="code">Tableau qui contient le flux MSIL.</param>
        <param name="maxStackSize">Nombre maximal d'éléments sur le tas d'opérandes lorsque la méthode s'exécute.</param>
        <summary>Définit le corps du code de la méthode dynamique associée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucune vérification de validité est effectuée sur le flux MSIL.  
  
 Un second appel à cette méthode remplace le premier flux MSIL par la seconde.  
  
 Génération de vos propres métadonnées et MSIL nécessaire de connaître la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition and Semantics » et « Partition III : CIL Instruction Set ». La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCode">
      <MemberSignature Language="C#" Value="public void SetCode (byte* code, int codeSize, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCode(unsigned int8* code, int32 codeSize, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCode(System::Byte* code, int codeSize, int maxStackSize);" />
      <MemberSignature Language="F#" Value="member this.SetCode : nativeptr&lt;byte&gt; * int * int -&gt; unit" Usage="dynamicILInfo.SetCode (code, codeSize, maxStackSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Byte*" />
        <Parameter Name="codeSize" Type="System.Int32" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="code">Pointeur vers un tableau d'octets qui contient le flux MSIL.</param>
        <param name="codeSize">Nombre d'octets dans le flux MSIL.</param>
        <param name="maxStackSize">Nombre maximal d'éléments sur le tas d'opérandes lorsque la méthode s'exécute.</param>
        <summary>Définit le corps du code de la méthode dynamique associée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucune vérification de validité est effectuée sur le flux MSIL.  
  
 Un second appel à cette méthode remplace le premier flux MSIL par la seconde.  
  
 Génération de vos propres métadonnées et MSIL nécessaire de connaître la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics » et « Partition III : CIL Instruction Set. » La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="code" /> est <see langword="null" /> et  <paramref name="codeSize" /> est supérieur à 0.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codeSize" /> est inférieur à 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetExceptions">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit les métadonnées d'exception de la méthode dynamique associée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetExceptions">
      <MemberSignature Language="C#" Value="public void SetExceptions (byte[] exceptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetExceptions(unsigned int8[] exceptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetExceptions (exceptions As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetExceptions(cli::array &lt;System::Byte&gt; ^ exceptions);" />
      <MemberSignature Language="F#" Value="member this.SetExceptions : byte[] -&gt; unit" Usage="dynamicILInfo.SetExceptions exceptions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptions" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="exceptions">Tableau qui contient les métadonnées d'exception.</param>
        <summary>Définit les métadonnées d'exception de la méthode dynamique associée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les métadonnées d’exception pour une méthode définissent l’emplacement et la taille de tous les `try`, `catch`, `finally`, filtre et les blocs fault. Pour plus d’informations sur la disposition de ces métadonnées, consultez la documentation de Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ». La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetExceptions">
      <MemberSignature Language="C#" Value="public void SetExceptions (byte* exceptions, int exceptionsSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetExceptions(unsigned int8* exceptions, int32 exceptionsSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetExceptions(System::Byte* exceptions, int exceptionsSize);" />
      <MemberSignature Language="F#" Value="member this.SetExceptions : nativeptr&lt;byte&gt; * int -&gt; unit" Usage="dynamicILInfo.SetExceptions (exceptions, exceptionsSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptions" Type="System.Byte*" />
        <Parameter Name="exceptionsSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exceptions">Pointeur vers un tableau d'octets qui contient les métadonnées d'exception.</param>
        <param name="exceptionsSize">Nombre d'octets de métadonnées d'exception.</param>
        <summary>Définit les métadonnées d'exception de la méthode dynamique associée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les métadonnées d’exception pour une méthode définissent l’emplacement et la taille de tous les `try`, `catch`, `finally`, filtre et les blocs fault. Pour plus d’informations sur la disposition de ces métadonnées, consultez la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition and Semantics » et « Partition III : CIL Instruction Set ». La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="exceptions" /> est <see langword="null" /> et  <paramref name="exceptionSize" /> est supérieur à 0.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exceptionSize" /> est inférieur à 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetLocalSignature">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit la signature des variables locales qui décrit la mise en forme des variables locales de la méthode dynamique associée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetLocalSignature">
      <MemberSignature Language="C#" Value="public void SetLocalSignature (byte[] localSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLocalSignature(unsigned int8[] localSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetLocalSignature (localSignature As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLocalSignature(cli::array &lt;System::Byte&gt; ^ localSignature);" />
      <MemberSignature Language="F#" Value="member this.SetLocalSignature : byte[] -&gt; unit" Usage="dynamicILInfo.SetLocalSignature localSignature" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localSignature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="localSignature">Tableau qui contient la structure des variables locales du <see cref="T:System.Reflection.Emit.DynamicMethod" /> associé.</param>
        <summary>Définit la signature des variables locales qui décrit la mise en forme des variables locales de la méthode dynamique associée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La signature de variable locale décrit la disposition des variables locales d’une méthode. Pour simplifier la construction de la signature de variable locale, utilisez la `static` (`Shared` en Visual Basic) <xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=nameWithType> méthode pour obtenir un <xref:System.Reflection.Emit.SignatureHelper> pour la signature locale.  
  
 Pour plus d’informations sur les signatures de variables locales, consultez la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ». La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLocalSignature">
      <MemberSignature Language="C#" Value="public void SetLocalSignature (byte* localSignature, int signatureSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLocalSignature(unsigned int8* localSignature, int32 signatureSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLocalSignature(System::Byte* localSignature, int signatureSize);" />
      <MemberSignature Language="F#" Value="member this.SetLocalSignature : nativeptr&lt;byte&gt; * int -&gt; unit" Usage="dynamicILInfo.SetLocalSignature (localSignature, signatureSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localSignature" Type="System.Byte*" />
        <Parameter Name="signatureSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="localSignature">Tableau qui contient la structure des variables locales du <see cref="T:System.Reflection.Emit.DynamicMethod" /> associé.</param>
        <param name="signatureSize">Nombre d'octets dans la signature.</param>
        <summary>Définit la signature des variables locales qui décrit la mise en forme des variables locales de la méthode dynamique associée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La signature de variable locale décrit la disposition des variables locales d’une méthode. Pour simplifier la construction de la signature de variable locale, utilisez la `static` (`Shared` en Visual Basic) <xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=nameWithType> méthode pour obtenir un <xref:System.Reflection.Emit.SignatureHelper> pour la signature locale.  
  
 Pour plus d’informations sur les signatures de variables locales, consultez la documentation du Common Language Infrastructure (CLI), en particulier « Partition II : Metadata Definition et Semantics ». La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="localSignature" /> est <see langword="null" /> et  <paramref name="signatureSize" /> est supérieur à 0.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="signatureSize" /> est inférieur à 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
  </Members>
</Type>