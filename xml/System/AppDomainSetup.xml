<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata><Meta Name="ms.openlocfilehash" Value="36dc523e0fd487a7e0d6f938812caccdef1a2e57" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55333900" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <TypeSignature Language="F#" Value="type AppDomainSetup = class&#xA;    interface IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente des informations de liaison d’assembly qui peuvent être ajoutées à une instance de <see cref="T:System.AppDomain" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modification des propriétés d’un <xref:System.AppDomainSetup> instance n’affecte pas les existantes <xref:System.AppDomain>. Cela peut affecter uniquement la création d’un nouveau <xref:System.AppDomain>, lorsque le <xref:System.AppDomain.CreateDomain%2A> méthode est appelée avec le <xref:System.AppDomainSetup> instance en tant que paramètre.  
  
 Cette classe implémente l'interface <xref:System.IAppDomainSetup> .  
  
> [!CAUTION]
>  La valeur par défaut pour le <xref:System.AppDomainSetup.DisallowCodeDownload%2A> propriété a la valeur false. Ce paramètre n’est pas sûre pour les services. Pour aider à empêcher les services de téléchargement de code de confiance partielle, définissez cette propriété sur true  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">Procédure : configurer un domaine d’application</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.AppDomainSetup" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.AppDomainSetup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : ActivationContext -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">Contexte d'activation à utiliser pour un domaine d'application.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.AppDomainSetup" /> avec le contexte d’activation spécifié requis pour l’activation basée sur un manifeste d’un domaine d’application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ActivationContext> objet spécifié pour `activationContext` est utilisé pour générer un <xref:System.Runtime.Hosting.ActivationArguments> objet contenant les informations requises pour activer un nouveau domaine d’application. Cela <xref:System.Runtime.Hosting.ActivationArguments> objet est accessible à l’aide de la <xref:System.AppDomainSetup.ActivationArguments%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationContext" /> est <see langword="null" />.</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : System.Runtime.Hosting.ActivationArguments -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationArguments" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" />
      </Parameters>
      <Docs>
        <param name="activationArguments">Objet qui spécifie les informations requises pour l'activation basée sur un manifeste d'un nouveau domaine d'application.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.AppDomainSetup" /> avec les arguments d’activation spécifiés nécessaires pour l’activation basée sur un manifeste d’un domaine d’application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’objet spécifié pour `activationArguments` sont accessibles à l’aide de la <xref:System.AppDomainSetup.ActivationArguments%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationArguments" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActivationArguments : System.Runtime.Hosting.ActivationArguments with get, set" Usage="System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les données relatives à l'activation d'un domaine d'application.</summary>
        <value>Objet qui contient les données relatives à l'activation d'un domaine d'application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucune exception n’est levée si cette propriété est définie sur `null`.  
  
 Les informations fournies par le <xref:System.Runtime.Hosting.ActivationArguments> objet prend en charge l’activation basée sur un manifeste.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété a la valeur d’un objet <see cref="T:System.Runtime.Hosting.ActivationArguments" /> dont l’identité d’application ne correspond pas à l’identité d’application de l’objet <see cref="T:System.Security.Policy.ApplicationTrust" /> retourné par la propriété <see cref="P:System.AppDomainSetup.ApplicationTrust" />. Aucune exception n’est levée si la propriété <see cref="P:System.AppDomainSetup.ApplicationTrust" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializer : AppDomainInitializer with get, set" Usage="System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le délégué <see cref="T:System.AppDomainInitializer" />, qui représente une méthode de rappel appelée quand le domaine d’application est initialisé.</summary>
        <value>Délégué qui représente une méthode de rappel appelée lorsque le domaine d'application est initialisé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour transmettre des informations à la méthode de rappel, assignez un tableau de chaînes à le <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> propriété. Le tableau est passé à la méthode de rappel chaque fois qu’un <xref:System.AppDomain> est initialisé.  
  
 La méthode de rappel est exécutée dans le contexte du domaine d’application nouvellement créé.  
  
   
  
## Examples  
 L’exemple suivant crée un domaine d’application enfant nommé `ChildDomain`, en utilisant un <xref:System.AppDomainSetup> objet et la preuve du domaine d’application par défaut. Le <xref:System.AppDomainSetup.AppDomainInitializer%2A> propriété est définie sur la méthode de rappel `AppDomainInit`, qui est appelé lorsque le domaine enfant est initialisé. Les arguments de la méthode de rappel sont placés dans un tableau de chaînes, qui est assignée à la <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> propriété. Lorsque le domaine enfant est créé, la méthode de rappel imprime simplement les chaînes.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializerArguments : string[] with get, set" Usage="System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les arguments passés à la méthode de rappel représentée par le délégué <see cref="T:System.AppDomainInitializer" />. La méthode de rappel est appelée lors de l'initialisation du domaine d'application.</summary>
        <value>Tableau de chaînes passé à la méthode de rappel représentée par le délégué <see cref="T:System.AppDomainInitializer" />, quand la méthode de rappel est appelée pendant l’initialisation de <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.AppDomainSetup.AppDomainInitializer%2A> propriété pour spécifier une méthode de rappel qui est appelée lors du <xref:System.AppDomain> l’initialisation. Si le <xref:System.AppDomainSetup.AppDomainInitializer%2A> propriété n’est pas définie, le tableau assigné à cette propriété n’est pas utilisé.  
  
 La méthode de rappel est exécutée dans le contexte du domaine d’application nouvellement créé.  
  
   
  
## Examples  
 L’exemple de code suivant crée un domaine d’application enfant nommé `ChildDomain`, en utilisant un <xref:System.AppDomainSetup> objet et la preuve du domaine d’application par défaut. Le <xref:System.AppDomainSetup.AppDomainInitializer%2A> propriété est définie sur la méthode de rappel `AppDomainInit`, qui est appelé lorsque le domaine enfant est initialisé. Les arguments de la méthode de rappel sont placés dans un tableau de chaînes, qui est assignée à la <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> propriété. Lorsque le domaine enfant est créé, la méthode de rappel imprime simplement les chaînes.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerAssembly : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom d’affichage de l’assembly qui fournit le type du gestionnaire de domaine d’application pour les domaines d’application créés en utilisant cet objet <see cref="T:System.AppDomainSetup" />.</summary>
        <value>Nom d’affichage de l’assembly qui fournit le <see cref="T:System.Type" /> du gestionnaire de domaine d’application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour spécifier le type du Gestionnaire de domaine, définissez cette propriété et la <xref:System.AppDomainSetup.AppDomainManagerType%2A> propriété. Si une de ces propriétés n’est pas définie, l’autre est ignorée.  
  
 Si aucun type n’est fourni, le Gestionnaire de domaine d’application est créé à partir du même type que le domaine d’application parent (autrement dit, le domaine d’application à partir de laquelle le <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> méthode est appelée).  
  
 Lorsque le domaine d’application est chargé, <xref:System.TypeLoadException> est levée si l’assembly n’existe pas, ou si l’assembly ne contient pas le type spécifié par le <xref:System.AppDomainSetup.AppDomainManagerType%2A> propriété. <xref:System.IO.FileLoadException> est levée si l’assembly est trouvé, mais les informations de version ne correspondent pas.  
  
 Pour définir le Gestionnaire de domaine d’application pour le domaine d’application par défaut, utilisez le [ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) et [ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) éléments dans le [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) section du fichier de configuration d’application, ou utilise les variables d’environnement décrit dans <xref:System.AppDomainManager>.  
  
 Cette fonctionnalité nécessite l’application ait une confiance totale. (Par exemple, une application en cours d’exécution sur le bureau a une confiance totale.) Si l’application n’a pas une confiance totale, un <xref:System.TypeLoadException> est levée.  
  
 Le format du nom complet d’assembly est donné par le <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerType : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom complet du type qui fournit le gestionnaire de domaine d’application pour les domaines d’application créés à l’aide de cet objet <see cref="T:System.AppDomainSetup" />.</summary>
        <value>Nom complet du type, y compris l'espace de noms.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour spécifier le type du Gestionnaire de domaine, définissez cette propriété et la <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> propriété. Si une de ces propriétés n’est pas définie, l’autre est ignorée.  
  
 Si aucun type n’est fourni, le Gestionnaire de domaine d’application est créé à partir du même type que le domaine d’application parent (autrement dit, le domaine d’application à partir de laquelle le <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> méthode est appelée).  
  
 Lorsque le domaine d’application est chargé, <xref:System.TypeLoadException> est levée si l’assembly spécifié par le <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> propriété ne contient pas le type spécifié par cette propriété.  
  
 Pour définir le Gestionnaire de domaine d’application pour le domaine d’application par défaut, utilisez le [ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) et [ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) éléments dans le [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) section du fichier de configuration d’application, ou utilise les variables d’environnement décrit dans <xref:System.AppDomainManager>.  
  
 Cette fonctionnalité nécessite l’application ait une confiance totale. (Par exemple, une application en cours d’exécution sur le bureau a une confiance totale.) Si l’application n’a pas une confiance totale, un <xref:System.TypeLoadException> est levée.  
  
 Le format du nom complet d’un type est donné par le <xref:System.Type.FullName%2A?displayProperty=nameWithType> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string with get, set" Usage="System.AppDomainSetup.ApplicationBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom du répertoire contenant l'application.</summary>
        <value>Nom du répertoire de base de l'application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le répertoire de base d’application est où le Gestionnaire des assemblys commence à détecter les assemblys.  
  
 Le <xref:System.AppDomainSetup.ApplicationBase%2A> propriété peut influencer les autorisations accordées à un domaine d’application. Par exemple, un domaine d’application normalement d’origine à partir de l’ordinateur local reçoit une confiance totale en fonction de son emplacement d’origine. Toutefois, si le <xref:System.AppDomainSetup.ApplicationBase%2A> propriété cela <xref:System.AppDomain> est défini sur le nom complet d’un annuaire intranet, le <xref:System.AppDomainSetup.ApplicationBase%2A> paramètre limite les autorisations accordées au domaine d’application à LocalIntranet même si le domaine d’application provient en fait de l’ordinateur local.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.AppDomainSetup.ApplicationBase%2A> propriété pour définir l’emplacement où le chargeur d’assembly commence la détection des assemblys à charger dans un nouveau domaine d’application.  
  
> [!NOTE]
>  Vous devez vous assurer que le dossier spécifié existe.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations du chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de l'application.</summary>
        <value>Nom de l'application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment définir le <xref:System.AppDomainSetup.ApplicationName%2A> propriété lorsque vous créez un nouveau domaine d’application.  
  
 L’exemple crée un nouveau domaine d’application et appelle ensuite la <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> méthode pour charger l’assembly de l’exemple dans le nouveau domaine d’application et de créer une instance de la `Worker` classe. Le `Worker` hérite de la classe <xref:System.MarshalByRefObject>, de sorte que l’exemple peut utiliser le proxy retourné par <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> pour appeler le `TestLoad` (méthode).  
  
 Le `TestLoad` méthode charge un assembly que vous spécifiez. Vous devez spécifier un nom d’assembly qualifié complet valide ou commentez le <xref:System.Reflection.Assembly.Load%28System.String%29> (méthode). Le `TestLoad` méthode répertorie les assemblys sont chargés dans le nouveau domaine d’application, indiquant que votre assembly spécifié et l’exemple d’assembly sont chargées.  
  
 L’exemple utilise le <xref:System.LoaderOptimizationAttribute> attribut pour indiquer le chargeur d’assembly comment l’application partagera le code dans des domaines d’application.  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust with get, set" Usage="System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un objet contenant les informations de sécurité et d'approbation.</summary>
        <value>Objet qui contient les informations de sécurité et d’approbation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est `null` lorsque le <xref:System.AppDomainSetup> est créé. Une fois modifiées, elle ne peut pas être réinitialisée à une référence null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété a la valeur d’un objet <see cref="T:System.Security.Policy.ApplicationTrust" /> dont l’identité d’application ne correspond pas à l’identité d’application de l’objet <see cref="T:System.Runtime.Hosting.ActivationArguments" /> retourné par la propriété <see cref="P:System.AppDomainSetup.ActivationArguments" />. Aucune exception n’est levée si la propriété <see cref="P:System.AppDomainSetup.ActivationArguments" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">La propriété est définie sur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePath : string with get, set" Usage="System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom d’une zone propre à l’application où se trouvent les clichés instantanés des fichiers.</summary>
        <value>Nom qualifié complet du chemin d'accès au répertoire et du nom de fichier contenant les clichés instantanés des fichiers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour que cette propriété ait un effet, le <xref:System.AppDomainSetup.ApplicationName%2A> propriété doit également être définie. Si le <xref:System.AppDomainSetup.ApplicationName%2A> propriété n’est pas définie, le <xref:System.AppDomainSetup.CachePath%2A> propriété est ignorée et l’emplacement du cache des clichés instantanés par défaut est le cache de téléchargement.  
  
 Pour plus d’informations sur les clichés instantanés, consultez [clichés instantanés d’assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations du chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Clichés instantanés d'assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationFile : string with get, set" Usage="System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom du fichier de configuration pour un domaine d'application.</summary>
        <value>Nom du fichier de configuration.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le fichier de configuration décrit les règles de recherche et les données de configuration pour le domaine d’application. L’hôte qui crée le domaine d’application est chargé de fournir ces données, car les valeurs significatives varient d’une situation à l’autre.  
  
 Par exemple, les données de configuration pour les applications ASP.NET sont stockées pour chaque application, le site et l’ordinateur, tandis que les données de configuration pour un fichier exécutable sont stockées pour chaque application, un utilisateur et un ordinateur. Seul l’hôte connaît les caractéristiques des données de configuration pour une circonstance particulière.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations du chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">Schéma des paramètres d'exécution</related>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowApplicationBaseProbing : bool with get, set" Usage="System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie si le chemin d'accès de base de l'application et le chemin d'accès binaire privé sont interrogés lors de la recherche des assemblys à charger.</summary>
        <value><see langword="true" /> si la détection n’est pas autorisée ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> propriété est `true`, la valeur de la <xref:System.AppDomainSetup.ApplicationBase%2A> propriété est ignorée. Autrement dit, aucun assembly n’est détectés pour dans les répertoires spécifiés par la <xref:System.AppDomainSetup.ApplicationBase%2A> propriété. En outre, les valeurs de la <xref:System.AppDomainSetup.PrivateBinPath%2A> propriété et le <xref:System.AppDomainSetup.PrivateBinPathProbe%2A> propriété sont ignorées. Aucun assembly n’est détectés pour dans les répertoires spécifiés par la <xref:System.AppDomainSetup.PrivateBinPath%2A> propriété.  
  
 Le <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> propriété fournit une couche supplémentaire de contrôle sur le processus de chargement. Dans la séquence de chargement des assemblys normal, la base de l’application est explorée avant le <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> événement est déclenché. Toutefois, certaines applications peuvent avoir à charger des assemblys à partir d’un fichier composé OLE dans un document ou à partir d’un emplacement connu unique qui n’est ni dans le global assembly cache, ni dans les répertoires spécifiés par la <xref:System.AppDomainSetup.ApplicationBase%2A> et <xref:System.AppDomainSetup.PrivateBinPath%2A> propriétés. Ces applications peuvent utiliser le <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> propriété afin d’éviter le délai provoqué par la détection normale et pour éviter de charger des copies de l’assembly nécessaire qui peuvent se trouver dans les chemins de détection normaux.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowBindingRedirects : bool with get, set" Usage="System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si un domaine d’application autorise la redirection des liaisons d’assembly.</summary>
        <value><see langword="true" /> si la redirection des assemblys n’est pas autorisée ; <see langword="false" /> si elle est autorisée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomainSetup.DisallowBindingRedirects%2A> propriété est conçue pour être utilisée par les services et applications de serveur où la redirection de liaison d’assembly n’est pas partie du scénario d’application.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowCodeDownload : bool with get, set" Usage="System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le téléchargement HTTP d'assemblys est autorisé pour un domaine d'application.</summary>
        <value><see langword="true" /> si le téléchargement HTTP d’assemblys n’est pas autorisé ; <see langword="false" /> s’il est autorisé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomainSetup.DisallowCodeDownload%2A> propriété est conçue pour être utilisée par les services et applications de serveur où le téléchargement de code à partir d’un intranet ou Internet n’est pas partie du scénario d’application.  
  
> [!CAUTION]
>  La valeur par défaut pour le <xref:System.AppDomainSetup.DisallowCodeDownload%2A> propriété est `false`. Ce paramètre n’est pas sûre pour les services. Pour aider à empêcher les services de téléchargement de code de confiance partielle, définissez cette propriété sur `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowPublisherPolicy : bool with get, set" Usage="System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la section [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) contenue dans le fichier de configuration est appliquée à un domaine d’application.</summary>
        <value><see langword="true" /> si la section <see langword="&lt;publisherPolicy&gt;" /> du fichier de configuration pour un domaine d’application est ignorée ; <see langword="false" /> si la stratégie de l’éditeur ayant été déclarée est respectée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A> propriété s’applique spécifiquement à une application Web chargée localement. Utilisez cette propriété pour empêcher une tentative malveillante d’exécuter une application Web non en mode sans échec.  
  
 Pour plus d’informations sur le contournement de stratégie d’éditeur, consultez le [redirection des Versions d’Assembly](~/docs/framework/configure-apps/redirect-assembly-versions.md) rubrique. Pour plus d’informations sur le mode sans échec, consultez la section « Examinant les fichiers de Configuration » de la [méthode de localisation des assemblys par le Runtime](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md) rubrique.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicBase : string with get, set" Usage="System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le répertoire de base où se trouve le répertoire des fichiers générés dynamiquement.</summary>
        <value>Répertoire où se trouve <see cref="P:System.AppDomain.DynamicDirectory" />.  

 <block subset="none" type="note"><para>  
 La valeur de retour de cette propriété est différente de la valeur assignée.
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 Utilisez cette propriété pour définir le répertoire de base où se trouvera le répertoire dynamique du nouveau domaine d’application. Lorsque le code dans le nouveau domaine d’application charge un assembly, la résolution d’assembly recherche d’abord dans les chemins de détection normaux. S’il ne trouve pas l’assembly, il recherche dans le répertoire dynamique, ce qui est retourné par la <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> propriété. Assemblys dynamiques qui seront chargés et exécutés par le nouveau domaine d’application peuvent être placés là.  
  
 Lorsque vous affectez un chemin d’accès à la <xref:System.AppDomainSetup.DynamicBase%2A> propriété, un sous-répertoire supplémentaire est ajouté ; le nom de ce sous-répertoire est le code de hachage de la valeur affectée à la <xref:System.AppDomainSetup.ApplicationName%2A> propriété. Par conséquent, le répertoire de base retourné par la suite par cette propriété est toujours différent de la valeur assignée.  
  
> [!IMPORTANT]
>  Affectez une valeur à cette propriété ne crée pas les répertoires. Les répertoires doivent être créées ou vérifiés par le code qui les utilise.  
  
 Le répertoire dynamique est un sous-répertoire de <xref:System.AppDomainSetup.DynamicBase%2A>. Son nom simple est la valeur retournée par la <xref:System.AppDomainSetup.ApplicationName%2A> propriété, donc son format est *chemin d’accès d’origine*\\*le code de hachage*\\*nom de l’application*.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.AppDomainSetup.DynamicBase%2A> sondes de propriété pour définir le chemin d’accès à un domaine d’application lors du chargement des assemblys dynamiques.  
  
 L’exemple crée un <xref:System.AppDomainSetup> objet et définit son <xref:System.AppDomainSetup.ApplicationName%2A> propriété à « Exemple » et ses <xref:System.AppDomainSetup.DynamicBase%2A> propriété à « C:\DynamicAssemblyDir ». L’exemple affiche ensuite le <xref:System.AppDomainSetup.DynamicBase%2A> propriété, pour montrer que le code de hachage du nom de l’application a été ajouté en tant que sous-répertoire du chemin qui a été affecté à l’origine.  
  
> [!NOTE]
>  Le répertoire de base dans cet exemple est destiné à être à l’extérieur du chemin de recherche pour l’exemple d’application. Veillez à compiler l’exemple dans un autre emplacement. Supprimer le répertoire de base et tous ses sous-répertoires chaque fois que vous exécutez l’exemple.  
  
 L’exemple crée une nouvelle application domaine à l’aide de la <xref:System.AppDomainSetup> objet. L’exemple crée ensuite le répertoire dynamique si elle n’existe pas déjà. Bien que l’exemple utilise le domaine d’application <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> propriété pour obtenir le nom du répertoire dynamique, il pourrait tout aussi facilement créer au préalable le répertoire en concaténant le chemin d’accès d’origine, le code de hachage du nom de l’application et le nom de l’application.  
  
 L’exemple a un `GenerateDynamicAssembly` méthode qui émet un assembly nommé `DynamicHelloWorld.dll` et le stocke dans le répertoire dynamique du nouveau domaine d’application. L’assembly dynamique contient un seul type, `HelloWorld`, qui a une méthode statique (`Shared` méthode en Visual Basic) nommée `HelloFromAD`. Appel de cette méthode affiche le nom du domaine d’application.  
  
 Le `Example` dérive de la classe <xref:System.MarshalByRefObject>, de sorte que l’exemple peut créer une instance de la classe dans le nouveau domaine d’application et appelez ses `Test` (méthode). Le `Test` méthode charge l’assembly dynamique par son nom d’affichage et appelle la méthode statique `HelloFromAD` (méthode).  
  
 Vous pouvez afficher que le répertoire dynamique est recherché après les chemins de détection normaux en écrivant du code pour un assembly nommé `DynamicHelloWorld.dll` et en le compilant dans le même répertoire que cet exemple. L’assembly doit avoir une classe nommée `HelloWorld` avec une méthode statique nommée `HelloFromAD`. Cette méthode n’a pas d’avoir les mêmes fonctionnalités que celui de l’exemple ; Il peut simplement afficher une chaîne dans la console. L’assembly doit également avoir un <xref:System.Reflection.AssemblyVersionAttribute> attribut qui définit sa version à 1.0.0.0. Lorsque vous exécutez l’exemple, l’assembly que vous avez compilé dans le répertoire actif est trouvé avant que le répertoire dynamique est recherché.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Impossible de définir cette propriété, car le nom de l’application sur le domaine d’application est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations du chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberSignature Language="F#" Value="member this.GetConfigurationBytes : unit -&gt; byte[]" Usage="appDomainSetup.GetConfigurationBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne les informations de configuration XML définies par la méthode <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />, qui substitue les informations de configuration XML de l’application.</summary>
        <returns>Tableau qui contient les informations de configuration XML définies par la méthode <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />, ou <see langword="null" /> si la méthode <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> n’a pas été appelée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomainSetup.SetConfigurationBytes%2A> méthode fournit un moyen pour remplacer les informations de configuration d’une application qui crée un nouveau domaine d’application. Les informations du fichier de configuration dans `value` substitue les informations de fichier de configuration de l’application. Par exemple, quand l’application Example.exe crée un nouveau domaine d’application, il peut remplacer les informations de configuration initialement obtenues à partir du fichier Example.exe.config.  
  
> [!IMPORTANT]
>  Certains consommateurs d’informations de fichier de configuration n’utilisent pas les informations stockées par le <xref:System.AppDomainSetup.SetConfigurationBytes%2A> (méthode). Le runtime n’applique pas cela. Pour vous assurer que toutes les informations de fichier de configuration sont substituées dans un nouveau domaine d’application, utilisez le <xref:System.AppDomainSetup.ConfigurationFile%2A> propriété pour spécifier un fichier de configuration. Le <xref:System.AppDomainSetup.SetConfigurationBytes%2A> méthode n’affecte pas de liaison d’assembly.  
  
 Le code XML dans `value` est le même que le code XML dans un fichier de configuration normale, à ceci près qu’il est stocké comme un <xref:System.Byte> tableau.  
  
 Pour accéder aux octets de configuration d’un domaine d’application, utilisez le <xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType> propriété à obtenir le <xref:System.AppDomainSetup> de l’objet pour le domaine d’application, puis utiliser le <xref:System.AppDomainSetup.GetConfigurationBytes%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LicenseFile : string with get, set" Usage="System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'emplacement du fichier de licence associé à ce domaine.</summary>
        <value>Emplacement et nom du fichier de licence.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations du chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberSignature Language="F#" Value="member this.LoaderOptimization : LoaderOptimization with get, set" Usage="System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie la stratégie d'optimisation utilisée pour charger un exécutable.</summary>
        <value>Constante énumérée utilisée avec <see cref="T:System.LoaderOptimizationAttribute" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un assembly dynamique et l’enregistre sur disque, puis utilise le <xref:System.AppDomainSetup.LoaderOptimization%2A> propriété à définir la stratégie d’optimisation utilisée pour charger l’assembly dans un domaine d’application.  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PartialTrustVisibleAssemblies : string[] with get, set" Usage="System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une liste d’assemblys marqués avec l’indicateur <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> et rendus visibles pour le code de confiance partielle s’exécutant dans un domaine d’application en mode bac à sable (sandbox).</summary>
        <value>Tableau de noms d'assemblys partiels, où chaque nom partiel se compose du nom d'assembly simple et de la clé publique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le <xref:System.Security.AllowPartiallyTrustedCallersAttribute> attribut (APTCA) peut être rendu conditionnel en définissant son <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> propriété <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>. Un assembly APTCA marqué avec <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> ne peut pas être utilisé par du code partiellement fiable, sauf si l’application hôte lui permet.  
  
 L’hôte d’un domaine d’application sandbox permet au code dans le domaine d’application à utiliser des assemblys avec les attributs APTCA conditionnels en créant un tableau qui contient le nom simple et la clé publique de chaque assembly et en attribuant à cette propriété. Par exemple, un élément du tableau peut se présenter comme suit : « MyAssembly, PublicKey = 0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad 0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9 ».  
  
> [!IMPORTANT]
>  Si vous utilisez une sous-classe de <xref:System.AppDomainManager>et l’assembly qui le définit dépend des assemblys marqués avec l’attribut APTCA conditionnel, vous devez inclure ces assemblys dans la liste que vous passez à la <xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A> propriété de la <xref:System.AppDomainSetup>vous permet de créer des domaines d’application. Sinon, les assemblys marqués avec l’attribut APTCA conditionnel seront désactivées.  
  
> [!NOTE]
>  Lorsque vous déboguez une application qui s’exécute dans un domaine d’application sandbox, certains <xref:System.Security.SecurityException> messages peuvent être trompeurs. Par exemple, un message peut indiquer qu’un de vos assemblys de confiance totale dispose uniquement d’autorisations limitées, lorsque la véritable cause du problème est qu’une demande de sécurité qui dépasse le jeu d’autorisations du domaine d’application sandbox a dépassé la limite de la domaine d’application sandbox et ayant échoué.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPath : string with get, set" Usage="System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la liste des répertoires sous le répertoire de base de l'application utilisés pour détecter les assemblys privés.</summary>
        <value>Liste de noms de répertoires séparés par des points-virgules.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Assemblys privés sont déployés dans la même structure de répertoire que l’application. Si les répertoires spécifiés pour <xref:System.AppDomainSetup.PrivateBinPath%2A> ne sont pas sous <xref:System.AppDomainSetup.ApplicationBase%2A>, ils sont ignorés.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPathProbe : string with get, set" Usage="System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur de chaîne qui inclut ou exclut <see cref="P:System.AppDomainSetup.ApplicationBase" /> du chemin de recherche de l’application, puis recherche uniquement dans <see cref="P:System.AppDomainSetup.PrivateBinPath" />.</summary>
        <value>Référence Null (<see langword="Nothing" /> en Visual Basic) pour inclure le chemin de base de l’application pendant la recherche d’assemblys ; toute valeur de chaîne autre que Null pour exclure le chemin. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définissez cette propriété sur n’importe quelle valeur de chaîne non null, y compris <xref:System.String.Empty?displayProperty=nameWithType> (« »), pour exclure le chemin du répertoire application - autrement dit, <xref:System.AppDomainSetup.ApplicationBase%2A> : dans le chemin de recherche pour l’application et recherchez les assemblys uniquement dans <xref:System.AppDomainSetup.PrivateBinPath%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SandboxInterop : bool with get, set" Usage="System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la mise en cache de l’interface est désactivée pour les appels Interop dans le domaine d’application, de manière à effectuer un <c>QueryInterface</c> lors de chaque appel.</summary>
        <value><see langword="true" /> si la mise en cache de l’interface est désactivée pour les appels Interop dans les domaines d’application créés avec l’objet <see cref="T:System.AppDomainSetup" /> actuel ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La désactivation de la mise en cache de l’interface a un impact significatif sur les performances des appels interop.  
  
 Ce membre est introduit dans le [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberSignature Language="F#" Value="member this.SetCompatibilitySwitches : seq&lt;string&gt; -&gt; unit" Usage="appDomainSetup.SetCompatibilitySwitches switches" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="switches">Ensemble énumérable de valeurs de chaîne qui spécifient des commutateurs de compatibilité, ou <see langword="null" /> pour effacer les commutateurs de compatibilité existants.</param>
        <summary>Définit les commutateurs spécifiés et rend le domaine d'application compatible avec les versions antérieures de .NET Framework pour les problèmes spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les versions principales du .NET Framework parfois introduisent de nouvelles modifications de la version précédente. Par exemple, le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] présente un petit nombre de modifications avec rupture à partir de la [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]. Utilisez le <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A> méthode pour spécifier qu’un ou plusieurs de ces modifications avec rupture doit être restaurée pour le domaine d’application, afin de rendre le comportement compatible avec la version précédente du .NET Framework.  
  
 Chaque fois que vous appelez cette méthode, il remplace les paramètres de commutateur existants. Pour effacer les paramètres, spécifiez `null` pour le `switches` paramètre.  
  
 L’ensemble de valeurs de chaîne que vous fournissez pour `switches` peut être un tableau de chaînes simples, car les tableaux implémentent la <xref:System.Collections.IEnumerable> interface.  
  
 Le tableau suivant fournit des exemples de commutateurs de compatibilité qui peuvent être définies pour restaurer le comportement des versions antérieures du .NET Framework.  
  
|Basculer|Signification|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Sécurité accès du code (CAS) pour le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] est activé dans ce domaine d’application. Consultez [ &lt;NetFx40_LegacySecurityPolicy&gt; élément](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Chaîne de tri des valeurs par défaut pour le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] sont activées dans ce domaine d’application. Restauration réussie du comportement de tri hérité requiert également la bibliothèque de liens dynamiques sort00001000.dll soit disponible sur le système local. Consultez [ &lt;CompatSortNLSVersion&gt; élément](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|« NetFx40_Legacy40SortingBehavior »|Chaîne de tri des valeurs par défaut pour le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] et Unicode 5.0 sont activées dans ce domaine d’application. Restauration réussie du comportement de tri hérité requiert également la bibliothèque de liens dynamiques sort00060101.dll soit disponible sur le système local.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> mise en forme de comportement pour le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] est activé dans ce domaine d’application. Consultez [ &lt;TimeSpan_LegacyFormatMode&gt; élément](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) et la section « Restauration hérité TimeSpan mise en forme » de la <xref:System.TimeSpan> rubrique.|  
|"UseRandomizedStringHashAlgorithm"|Le runtime calcule les codes de hachage pour les chaînes sur un par domaine d’application au lieu d’utiliser un algorithme de hachage unique qui produit un code de hachage cohérent entre domaines d’application. Consultez [ &lt;UseRandomizedStringHashAlgorithm&gt; élément](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/07132b9c-4a72-4710-99d7-e702405e02d4">&lt;NetFx40_LegacySecurityPolicy&gt; élément</related>
        <related type="Article" href="https://msdn.microsoft.com/library/782cc82e-83f7-404a-80b7-6d3061a8b6e3">&lt;CompatSortNLSVersion&gt; élément</related>
        <related type="Article" href="https://msdn.microsoft.com/library/865e7207-d050-4442-b574-57ea29d5e2d6">&lt;TimeSpan_LegacyFormatMode&gt; Element</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; élément</related>
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetConfigurationBytes : byte[] -&gt; unit" Usage="appDomainSetup.SetConfigurationBytes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Tableau qui contient les informations de configuration XML à utiliser pour le domaine d'application.</param>
        <summary>Fournit des informations de configuration XML pour le domaine d'application, en remplaçant les informations de configuration XML de l'application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomainSetup.SetConfigurationBytes%2A> méthode fournit un moyen pour remplacer les informations de configuration d’une application qui crée un nouveau domaine d’application. Les informations du fichier de configuration dans `value` remplace les informations du fichier de configuration de l’application. Par exemple, quand l’application Example.exe crée un nouveau domaine d’application, il peut remplacer les informations de configuration obtenues à partir du fichier Example.exe.config.  
  
> [!IMPORTANT]
>  Certains consommateurs d’informations de fichier de configuration n’utilisent pas les informations stockées par le <xref:System.AppDomainSetup.SetConfigurationBytes%2A> (méthode). Le runtime n’applique pas cela. Pour vous assurer que toutes les informations de fichier de configuration sont remplacées dans un nouveau domaine d’application, utilisez le <xref:System.AppDomainSetup.ConfigurationFile%2A> propriété pour spécifier un fichier de configuration. Le <xref:System.AppDomainSetup.SetConfigurationBytes%2A> méthode n’affecte pas de liaison d’assembly.  
  
 Le code XML dans `value` est le même que le code XML dans un fichier de configuration normale, à ceci près qu’il est stocké comme un <xref:System.Byte> tableau.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">Schéma des paramètres d'exécution</related>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="F#" Value="member this.SetNativeFunction : string * int * nativeint -&gt; unit" Usage="appDomainSetup.SetNativeFunction (functionName, functionVersion, functionPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="functionVersion" Type="System.Int32" />
        <Parameter Name="functionPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="functionName">Nom de la fonction de comparaison de chaînes à substituer.</param>
        <param name="functionVersion">Version de la fonction. Pour [!INCLUDE[net_v45](~/includes/net-v45-md.md)], la valeur doit être supérieure ou égale à 1.</param>
        <param name="functionPointer">Pointeur vers la fonction qui substitue <paramref name="functionName" />.</param>
        <summary>Fournit au Common Language Runtime une autre implémentation d’une fonction de comparaison de chaînes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La comparaison des chaînes suivantes et les méthodes de tri peuvent être remplacées par la <xref:System.AppDomainSetup.SetNativeFunction%2A> méthode :  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 Pour plus d’informations sur ces fonctions, consultez [fonctions de prise en charge la langue nationale](https://go.microsoft.com/fwlink/?LinkId=228134).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="functionName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="functionVersion" /> n’est supérieur ou égal à 1.  
  
ou 
 <paramref name="functionPointer" /> est <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyDirectories : string with get, set" Usage="System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les noms des répertoires contenant les assemblys pour lesquels des clichés instantanés doivent être créés.</summary>
        <value>Liste de noms de répertoires séparés par des points-virgules.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors de la copie de clichés instantanés est activée, la valeur par défaut est de cliché instantané de tous les assemblys trouvés par le biais de détection ; Autrement dit, dans les répertoires spécifiés par la <xref:System.AppDomainSetup.PrivateBinPath%2A> et <xref:System.AppDomainSetup.ApplicationBase%2A> propriétés. Le <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> propriété restreint le cliché instantané aux assemblys dans les répertoires spécifiés par <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>.  
  
 Si vous n’affectez pas une chaîne à la <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> propriété, ou si vous définissez cette propriété sur `null`, tous les assemblys dans les répertoires spécifiés par la <xref:System.AppDomainSetup.ApplicationBase%2A> et <xref:System.AppDomainSetup.PrivateBinPath%2A> propriétés sont des clichés instantanés.  
  
> [!IMPORTANT]
>  Les chemins d'accès des répertoires ne doivent pas contenir de points-virgules, car le point-virgule est le caractère délimiteur. Il n'existe pas de caractère d'échappement pour les points-virgules.  
  
 Lorsque les clichés instantanés est en vigueur, les fichiers d’assembly sont copiés vers un autre emplacement avant que les assemblys sont chargés. Le fichier d’assembly d’origine n’est pas verrouillé, vous pouvez mettre à jour. Pour plus d’informations sur les clichés instantanés, consultez [clichés instantanés d’assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations du chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Clichés instantanés d'assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : string with get, set" Usage="System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une chaîne indiquant si les clichés instantanés sont activés ou désactivés.</summary>
        <value>Valeur de chaîne « true » pour indiquer que les clichés instantanés sont activés ou « false » pour indiquer que les clichés instantanés sont désactivés.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur les clichés instantanés, consultez [clichés instantanés d’assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Clichés instantanés d'assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string with get, set" Usage="System.AppDomainSetup.TargetFrameworkName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une chaîne qui spécifie la version et le profil cibles du .NET Framework pour le domaine d’application, dans un format qui peut être analysé par le constructeur <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" />.</summary>
        <value>Version et profil cibles du .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définissez cette propriété pour indiquer la version en cours d’exécution du .NET Framework que le domaine d’application sera être utilisé pour charger et exécuter des assemblys qui ont été compilés pour la version et profil cibles. Si la version en cours d’exécution du .NET Framework a des comportements facultatifs qui affectent la compatibilité du code qui a été compilé avec la version cible, il peut activer ou désactiver ces comportements, si nécessaire, pour améliorer la compatibilité. Cela peut être utile lorsqu’une application prend en charge des compléments compilés avec plusieurs versions du .NET Framework en les exécutant dans les domaines d’application distincts.  
  
 Pour les applications clientes, la valeur de la <xref:System.AppDomainSetup.TargetFrameworkName%2A> propriété est déduite à partir de la <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribut. Dans [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] et versions ultérieures, cet attribut est ajouté à l’assembly automatiquement en fonction du paramètre du projet **Framework cible** propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>