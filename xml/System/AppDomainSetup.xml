<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b01f805ef110c375925a5ca5ffbb351875c265af" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36433358" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <TypeSignature Language="F#" Value="type AppDomainSetup = class&#xA;    interface IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents assembly binding information that can be added to an instance of <see cref="T:System.AppDomain" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modification des propriétés d’un <xref:System.AppDomainSetup> instance n’affecte pas existants <xref:System.AppDomain>. Il peut affecter uniquement la création d’un nouveau <xref:System.AppDomain>, lorsque le <xref:System.AppDomain.CreateDomain%2A> méthode est appelée avec le <xref:System.AppDomainSetup> instance en tant que paramètre.  
  
 Cette classe implémente l'interface <xref:System.IAppDomainSetup>.  
  
> [!CAUTION]
>  La valeur par défaut pour le <xref:System.AppDomainSetup.DisallowCodeDownload%2A> propriété a la valeur false. Ce paramètre est déconseillé pour les services. Pour aider à empêcher les services de téléchargement du code partiellement fiable, définissez cette propriété sur true  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.AppDomainSetup" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.AppDomainSetup" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : ActivationContext -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">The activation context to be used for an application domain.</param>
        <summary>Initializes a new instance of the <see cref="T:System.AppDomainSetup" /> class with the specified activation context to use for manifest-based activation of an application domain.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ActivationContext> objet spécifié pour `activationContext` est utilisé pour générer un <xref:System.Runtime.Hosting.ActivationArguments> objet contenant les informations requises pour activer un nouveau domaine d’application. Cela <xref:System.Runtime.Hosting.ActivationArguments> objet sont accessibles à l’aide de la <xref:System.AppDomainSetup.ActivationArguments%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationContext" /> is <see langword="null" />.</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : System.Runtime.Hosting.ActivationArguments -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationArguments" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" />
      </Parameters>
      <Docs>
        <param name="activationArguments">An object that specifies information required for the manifest-based activation of a new application domain.</param>
        <summary>Initializes a new instance of the <see cref="T:System.AppDomainSetup" /> class with the specified activation arguments required for manifest-based activation of an application domain.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’objet spécifié pour `activationArguments` sont accessibles à l’aide de la <xref:System.AppDomainSetup.ActivationArguments%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationArguments" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActivationArguments : System.Runtime.Hosting.ActivationArguments with get, set" Usage="System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets data about the activation of an application domain.</summary>
        <value>Objet qui contient les données relatives à l'activation d'un domaine d'application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucune exception n’est levée si cette propriété est définie sur `null`.  
  
 Les informations fournies par le <xref:System.Runtime.Hosting.ActivationArguments> objet prend en charge l’activation basée sur un manifeste.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The property is set to an <see cref="T:System.Runtime.Hosting.ActivationArguments" /> object whose application identity does not match the application identity of the <see cref="T:System.Security.Policy.ApplicationTrust" /> object returned by the <see cref="P:System.AppDomainSetup.ApplicationTrust" /> property. No exception is thrown if the <see cref="P:System.AppDomainSetup.ApplicationTrust" /> property is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializer : AppDomainInitializer with get, set" Usage="System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.AppDomainInitializer" /> delegate, which represents a callback method that is invoked when the application domain is initialized.</summary>
        <value>Délégué qui représente une méthode de rappel appelée lorsque le domaine d'application est initialisé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour passer des informations à la méthode de rappel, assigner un tableau de chaînes à la <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> propriété. Le tableau est passé à la méthode de rappel chaque fois qu’un <xref:System.AppDomain> est initialisé.  
  
 La méthode de rappel est exécutée dans le contexte du domaine d’application nouvellement créé.  
  
   
  
## Examples  
 L’exemple suivant crée un domaine d’application enfant nommé `ChildDomain`, en utilisant un <xref:System.AppDomainSetup> objet et la preuve du domaine d’application par défaut. Le <xref:System.AppDomainSetup.AppDomainInitializer%2A> est définie sur la méthode de rappel `AppDomainInit`, qui est appelé lorsque le domaine enfant est initialisé. Les arguments de la méthode de rappel sont placés dans un tableau de chaînes, qui est assignée à la <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> propriété. Lorsque le domaine enfant est créé, la méthode de rappel imprime simplement les chaînes.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializerArguments : string[] with get, set" Usage="System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the arguments passed to the callback method represented by the <see cref="T:System.AppDomainInitializer" /> delegate. The callback method is invoked when the application domain is initialized.</summary>
        <value>Tableau de chaînes passé à la méthode de rappel représentée par le délégué <see cref="T:System.AppDomainInitializer" />, quand la méthode de rappel est appelée pendant l’initialisation de <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.AppDomainSetup.AppDomainInitializer%2A> propriété pour spécifier une méthode de rappel qui est appelée lors de <xref:System.AppDomain> l’initialisation. Si le <xref:System.AppDomainSetup.AppDomainInitializer%2A> propriété n’est pas définie, le tableau assigné à cette propriété n’est pas utilisé.  
  
 La méthode de rappel est exécutée dans le contexte du domaine d’application nouvellement créé.  
  
   
  
## Examples  
 L’exemple de code suivant crée un domaine d’application enfant nommé `ChildDomain`, en utilisant un <xref:System.AppDomainSetup> objet et la preuve du domaine d’application par défaut. Le <xref:System.AppDomainSetup.AppDomainInitializer%2A> est définie sur la méthode de rappel `AppDomainInit`, qui est appelé lorsque le domaine enfant est initialisé. Les arguments de la méthode de rappel sont placés dans un tableau de chaînes, qui est assignée à la <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> propriété. Lorsque le domaine enfant est créé, la méthode de rappel imprime simplement les chaînes.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerAssembly : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the display name of the assembly that provides the type of the application domain manager for application domains created using this <see cref="T:System.AppDomainSetup" /> object.</summary>
        <value>Nom d’affichage de l’assembly qui fournit le <see cref="T:System.Type" /> du gestionnaire de domaine d’application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour spécifier le type du Gestionnaire de domaine d’application, définissez cette propriété et la <xref:System.AppDomainSetup.AppDomainManagerType%2A> propriété. Si une de ces propriétés n’est pas définie, l’autre est ignorée.  
  
 Si aucun type n’est fourni, le Gestionnaire de domaine d’application est créé à partir du même type que le domaine d’application parent (autrement dit, le domaine d’application à partir de laquelle la <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> méthode est appelée).  
  
 Lorsque le domaine d’application est chargé, <xref:System.TypeLoadException> est levée si l’assembly n’existe pas, ou si l’assembly ne contient pas le type spécifié par le <xref:System.AppDomainSetup.AppDomainManagerType%2A> propriété. <xref:System.IO.FileLoadException> est levée si l’assembly est trouvé, mais les informations de version ne correspondent pas.  
  
 Pour définir le Gestionnaire de domaine d’application pour le domaine d’application par défaut, utilisez le [ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) et [ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) éléments dans le [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) section du fichier de configuration d’application, ou utilisez les variables d’environnement décrites dans <xref:System.AppDomainManager>.  
  
 Cette fonctionnalité nécessite l’application dispose d’une confiance totale. (Par exemple, une application en cours d’exécution sur le bureau a une confiance totale.) Si l’application n’a pas d’une confiance totale, un <xref:System.TypeLoadException> est levée.  
  
 Le format du nom complet d’assembly est donné par le <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerType : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the full name of the type that provides the application domain manager for application domains created using this <see cref="T:System.AppDomainSetup" /> object.</summary>
        <value>Nom complet du type, y compris l'espace de noms.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour spécifier le type du Gestionnaire de domaine d’application, définissez cette propriété et la <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> propriété. Si une de ces propriétés n’est pas définie, l’autre est ignorée.  
  
 Si aucun type n’est fourni, le Gestionnaire de domaine d’application est créé à partir du même type que le domaine d’application parent (autrement dit, le domaine d’application à partir de laquelle la <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> méthode est appelée).  
  
 Lorsque le domaine d’application est chargé, <xref:System.TypeLoadException> est levée si l’assembly spécifié par le <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> propriété ne contient pas le type spécifié par cette propriété.  
  
 Pour définir le Gestionnaire de domaine d’application pour le domaine d’application par défaut, utilisez le [ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) et [ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) éléments dans le [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) section du fichier de configuration d’application, ou utilisez les variables d’environnement décrites dans <xref:System.AppDomainManager>.  
  
 Cette fonctionnalité nécessite l’application dispose d’une confiance totale. (Par exemple, une application en cours d’exécution sur le bureau a une confiance totale.) Si l’application n’a pas d’une confiance totale, un <xref:System.TypeLoadException> est levée.  
  
 Le format du nom complet d’un type est donné par le <xref:System.Type.FullName%2A?displayProperty=nameWithType> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string with get, set" Usage="System.AppDomainSetup.ApplicationBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the directory containing the application.</summary>
        <value>Nom du répertoire de base de l'application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le répertoire de base d’application est où le Gestionnaire des assemblys commence à détecter les assemblys.  
  
 Le <xref:System.AppDomainSetup.ApplicationBase%2A> propriété peut influencer les autorisations accordées à un domaine d’application. Par exemple, un domaine d’application normalement d’origine à partir de l’ordinateur local reçoit une confiance totale, en fonction de son emplacement d’origine. Toutefois, si le <xref:System.AppDomainSetup.ApplicationBase%2A> propriété de qui <xref:System.AppDomain> est défini sur le nom complet d’un répertoire intranet, le <xref:System.AppDomainSetup.ApplicationBase%2A> paramètre limite les autorisations accordées au domaine d’application à LocalIntranet même si le domaine d’application provient effectivement de l’ordinateur local.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.AppDomainSetup.ApplicationBase%2A> propriété pour définir l’emplacement où le chargeur d’assembly commence la détection des assemblys à charger dans un domaine d’application.  
  
> [!NOTE]
>  Vous devez vous assurer que le dossier spécifié existe.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations de chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the application.</summary>
        <value>Nom de l'application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment définir le <xref:System.AppDomainSetup.ApplicationName%2A> propriété lorsque vous créez un nouveau domaine d’application.  
  
 L’exemple crée un nouveau domaine d’application, puis appelle la <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> méthode pour charger l’assembly de l’exemple dans le domaine d’application et créer une instance de la `Worker` classe. Le `Worker` hérite de la classe <xref:System.MarshalByRefObject>l’exemple peut donc utiliser le proxy retourné par <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> pour appeler le `TestLoad` (méthode).  
  
 Le `TestLoad` méthode charge un assembly que vous spécifiez. Vous devez spécifier un nom d’assembly qualifié complet valide ou mettez en commentaire la <xref:System.Reflection.Assembly.Load%28System.String%29> (méthode). Le `TestLoad` méthode répertorie les assemblys sont chargés dans le nouveau domaine d’application, indiquant que votre assembly spécifié et l’exemple d’assembly sont chargés.  
  
 L’exemple utilise le <xref:System.LoaderOptimizationAttribute> attribut pour indiquer le chargeur d’assembly comment l’application partagera le code dans des domaines d’application.  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust with get, set" Usage="System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an object containing security and trust information.</summary>
        <value>Objet qui contient les informations de sécurité et d’approbation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est `null` lorsque le <xref:System.AppDomainSetup> est créé. Une fois modifiées, elle ne peut pas être réinitialisée à une référence null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The property is set to an <see cref="T:System.Security.Policy.ApplicationTrust" /> object whose application identity does not match the application identity of the <see cref="T:System.Runtime.Hosting.ActivationArguments" /> object returned by the <see cref="P:System.AppDomainSetup.ActivationArguments" /> property. No exception is thrown if the <see cref="P:System.AppDomainSetup.ActivationArguments" /> property is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">The property is set to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePath : string with get, set" Usage="System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of an area specific to the application where files are shadow copied.</summary>
        <value>Nom qualifié complet du chemin d'accès au répertoire et du nom de fichier contenant les clichés instantanés des fichiers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans l’ordre de cette propriété pour avoir un effet, le <xref:System.AppDomainSetup.ApplicationName%2A> propriété doit également être définie. Si le <xref:System.AppDomainSetup.ApplicationName%2A> propriété n’est pas définie, le <xref:System.AppDomainSetup.CachePath%2A> propriété est ignorée et la valeur par défaut est l’emplacement du cache des clichés instantanés pour le cache de téléchargement.  
  
 Pour plus d’informations sur les clichés instantanés, consultez [clichés instantanés d’assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations de chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationFile : string with get, set" Usage="System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the configuration file for an application domain.</summary>
        <value>Nom du fichier de configuration.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le fichier de configuration décrit les règles de recherche et les données de configuration pour le domaine d’application. L’hôte qui crée le domaine d’application est chargé de fournir ces données, car les valeurs significatives varient d’une situation à l’autre.  
  
 Par exemple, les données de configuration pour les applications ASP.NET sont stockées pour chaque application, le site et l’ordinateur, tandis que les données de configuration pour un fichier exécutable sont stockées pour chaque application, utilisateur et ordinateur. Seul l’hôte connaît les caractéristiques des données de configuration pour un cas particulier.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations de chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowApplicationBaseProbing : bool with get, set" Usage="System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the application base path and private binary path are probed when searching for assemblies to load.</summary>
        <value>
          <see langword="true" /> si la détection n’est pas autorisée ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> propriété `true`, la valeur de la <xref:System.AppDomainSetup.ApplicationBase%2A> propriété est ignorée. Autrement dit, aucun assembly n’est interrogés pour dans les répertoires spécifiés par la <xref:System.AppDomainSetup.ApplicationBase%2A> propriété. En outre, les valeurs de la <xref:System.AppDomainSetup.PrivateBinPath%2A> propriété et le <xref:System.AppDomainSetup.PrivateBinPathProbe%2A> sont ignorées. Aucun assembly n’est interrogés pour dans les répertoires spécifiés par la <xref:System.AppDomainSetup.PrivateBinPath%2A> propriété.  
  
 Le <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> propriété fournit une couche supplémentaire de contrôle sur le processus de chargement. Dans la séquence de chargement des assemblys normal, la base de l’application est explorée avant le <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> événement est déclenché. Toutefois, certaines applications deviez charger des assemblys à partir d’un fichier composé OLE dans un document ou d’un emplacement connu unique qui n’est ni dans le global assembly cache, ni dans les répertoires spécifiés par la <xref:System.AppDomainSetup.ApplicationBase%2A> et <xref:System.AppDomainSetup.PrivateBinPath%2A> propriétés. Ces applications peuvent utiliser le <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> propriété afin d’éviter le délai causé par la détection normale et pour éviter de charger des copies de l’assembly nécessaire qui peuvent se trouver dans les chemins d’accès de détection normales.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowBindingRedirects : bool with get, set" Usage="System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether an application domain allows assembly binding redirection.</summary>
        <value>
          <see langword="true" /> si la redirection des assemblys n’est pas autorisée ; <see langword="false" /> si elle est autorisée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomainSetup.DisallowBindingRedirects%2A> propriété est conçue pour être utilisée par les applications et services serveur où la redirection de liaison d’assembly n’est pas partie du scénario d’application.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowCodeDownload : bool with get, set" Usage="System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether HTTP download of assemblies is allowed for an application domain.</summary>
        <value>
          <see langword="true" /> si le téléchargement HTTP d’assemblys n’est pas autorisé ; <see langword="false" /> s’il est autorisé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomainSetup.DisallowCodeDownload%2A> propriété est conçue pour être utilisée par les applications et services serveur où le téléchargement de code à partir d’un intranet ou Internet n’est pas partie du scénario d’application.  
  
> [!CAUTION]
>  La valeur par défaut pour le <xref:System.AppDomainSetup.DisallowCodeDownload%2A> propriété est `false`. Ce paramètre est déconseillé pour les services. Pour aider à empêcher les services de téléchargement du code partiellement fiable, définissez cette propriété sur `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowPublisherPolicy : bool with get, set" Usage="System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) section of the configuration file is applied to an application domain.</summary>
        <value>
          <see langword="true" /> si la section <see langword="&lt;publisherPolicy&gt;" /> du fichier de configuration pour un domaine d’application est ignorée ; <see langword="false" /> si la stratégie de l’éditeur ayant été déclarée est respectée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A> propriété s’applique spécifiquement à une application Web chargée localement. Utilisez cette propriété pour empêcher une tentative malveillante pour exécuter une application Web non en mode sans échec.  
  
 Pour plus d’informations sur le contournement de stratégie d’éditeur, consultez la [redirection des Versions d’Assembly](~/docs/framework/configure-apps/redirect-assembly-versions.md) rubrique. Pour plus d’informations sur le mode sans échec, consultez la section « Examinant les fichiers de Configuration » de la [méthode de localisation des assemblys par le Runtime](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md) rubrique.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicBase : string with get, set" Usage="System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the base directory where the directory for dynamically generated files is located.</summary>
        <value>Répertoire où se trouve <see cref="P:System.AppDomain.DynamicDirectory" />.  
 <block subset="none" type="note"><para> La valeur de retour de cette propriété est différente de la valeur assignée. </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 Utilisez cette propriété pour définir le répertoire de base où se trouvera le répertoire dynamique du nouveau domaine d’application. Lorsque le code dans le nouveau domaine d’application charge un assembly, la résolution d’assembly recherche d’abord dans les chemins d’accès de détection normales. S’il ne trouve pas l’assembly, il recherche dans le répertoire dynamique, ce qui est retourné par la <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> propriété. Assemblys dynamiques qui seront chargés et exécutés par le nouveau domaine d’application peuvent être placés là.  
  
 Lorsque vous affectez un chemin d’accès à la <xref:System.AppDomainSetup.DynamicBase%2A> propriété, un sous-répertoire supplémentaire est ajouté ; le nom de ce sous-répertoire est le code de hachage de la valeur affectée à la <xref:System.AppDomainSetup.ApplicationName%2A> propriété. Par conséquent, le répertoire de base par la suite retourné par cette propriété est toujours différent de la valeur assignée.  
  
> [!IMPORTANT]
>  Affectation d’une valeur à cette propriété ne crée pas les répertoires. Les répertoires doivent être créés ou vérifiés par le code qui les utilise.  
  
 Le répertoire dynamique est un sous-répertoire de <xref:System.AppDomainSetup.DynamicBase%2A>. Son nom simple est la valeur retournée par la <xref:System.AppDomainSetup.ApplicationName%2A> propriété, donc son format est *chemin d’accès d’origine*\\*le code de hachage*\\*nom de l’application*.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.AppDomainSetup.DynamicBase%2A> propriété à définir le chemin d’accès à un domaine d’application teste lors du chargement des assemblys dynamiques.  
  
 L’exemple crée un <xref:System.AppDomainSetup> objet et définit son <xref:System.AppDomainSetup.ApplicationName%2A> propriété « Exemple » et ses <xref:System.AppDomainSetup.DynamicBase%2A> propriété « C:\DynamicAssemblyDir ». L’exemple affiche ensuite le <xref:System.AppDomainSetup.DynamicBase%2A> propriété, pour montrer que le code de hachage du nom de l’application a été ajouté comme un sous-répertoire du chemin d’accès qui a été affectée à l’origine.  
  
> [!NOTE]
>  Le répertoire de base dans cet exemple est destiné à être à l’extérieur du chemin d’accès de détection pour l’exemple d’application. Veillez à compiler l’exemple dans un autre emplacement. Supprimer le répertoire de base et tous ses sous-répertoires chaque fois que vous exécutez l’exemple.  
  
 L’exemple crée une nouvelle application domaine à l’aide de la <xref:System.AppDomainSetup> objet. L’exemple crée ensuite le répertoire dynamique s’il n’existe pas. Bien que l’exemple utilise le domaine d’application <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> propriété à obtenir le nom du répertoire dynamique, il pourrait tout aussi facilement créer au préalable le répertoire en concaténant le chemin d’accès d’origine, le code de hachage du nom de l’application et le nom de l’application.  
  
 L’exemple a un `GenerateDynamicAssembly` (méthode) qui émet un assembly nommé `DynamicHelloWorld.dll` et le stocke dans le répertoire dynamique de nouveau domaine d’application. L’assembly dynamique contient un seul type, `HelloWorld`, qui a une méthode statique (`Shared` méthode dans Visual Basic) nommée `HelloFromAD`. Appel de cette méthode affiche le nom du domaine d’application.  
  
 Le `Example` dérive de la classe <xref:System.MarshalByRefObject>, de sorte que l’exemple peut créer une instance de la classe dans le nouveau domaine d’application et appelez sa `Test` (méthode). Le `Test` méthode charge l’assembly dynamique par son nom d’affichage et appelle la méthode statique `HelloFromAD` (méthode).  
  
 Vous pouvez afficher recherché dans le répertoire dynamique après les chemins d’accès de détection normaux en écrivant du code pour un assembly nommé `DynamicHelloWorld.dll` puis en le compilant dans le même répertoire que cet exemple. L’assembly doit avoir une classe nommée `HelloWorld` avec une méthode statique nommée `HelloFromAD`. Cette méthode n’a pas d’avoir les mêmes fonctionnalités que celui de l’exemple ; Il peut simplement afficher une chaîne dans la console. L’assembly doit également avoir un <xref:System.Reflection.AssemblyVersionAttribute> attribut qui définit sa version 1.0.0.0. Lorsque vous exécutez l’exemple, l’assembly que vous avez compilé dans le répertoire actif se trouve avant le répertoire dynamique est recherché.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">This property cannot be set because the application name on the application domain is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations de chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberSignature Language="F#" Value="member this.GetConfigurationBytes : unit -&gt; byte[]" Usage="appDomainSetup.GetConfigurationBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the XML configuration information set by the <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> method, which overrides the application's XML configuration information.</summary>
        <returns>An array that contains the XML configuration information that was set by the <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> method, or <see langword="null" /> if the <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> method has not been called.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomainSetup.SetConfigurationBytes%2A> méthode offre un moyen pour remplacer les informations de configuration d’une application qui crée un nouveau domaine d’application. Les informations du fichier de configuration de `value` substitue les informations de fichier de configuration de l’application. Par exemple, quand l’application Example.exe crée un nouveau domaine d’application, il peut remplacer les informations de configuration obtenues à partir du fichier Example.exe.config.  
  
> [!IMPORTANT]
>  Certains consommateurs d’informations de fichier de configuration n’utilisent pas les informations stockées par le <xref:System.AppDomainSetup.SetConfigurationBytes%2A> (méthode). Le runtime n’applique pas cela. Pour vous assurer que toutes les informations de fichier de configuration sont remplacées dans un domaine d’application, utilisez le <xref:System.AppDomainSetup.ConfigurationFile%2A> propriété pour spécifier un fichier de configuration. Le <xref:System.AppDomainSetup.SetConfigurationBytes%2A> méthode n’affecte pas de liaison d’assembly.  
  
 Le code XML dans `value` est le même que le code XML dans un fichier de configuration normal, à ceci près qu’il est stocké en tant qu’un <xref:System.Byte> tableau.  
  
 Pour accéder aux octets de configuration d’un domaine d’application, utilisez le <xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType> propriété à obtenir le <xref:System.AppDomainSetup> de l’objet pour le domaine d’application, puis utilisez le <xref:System.AppDomainSetup.GetConfigurationBytes%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LicenseFile : string with get, set" Usage="System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the location of the license file associated with this domain.</summary>
        <value>Emplacement et nom du fichier de licence.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations de chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberSignature Language="F#" Value="member this.LoaderOptimization : LoaderOptimization with get, set" Usage="System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies the optimization policy used to load an executable.</summary>
        <value>Constante énumérée qui est utilisée avec le <see cref="T:System.LoaderOptimizationAttribute" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un assembly dynamique et l’enregistre sur disque, puis utilise le <xref:System.AppDomainSetup.LoaderOptimization%2A> propriété à définir la stratégie d’optimisation utilisée pour charger l’assembly dans un domaine d’application.  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PartialTrustVisibleAssemblies : string[] with get, set" Usage="System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a list of assemblies marked with the <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> flag that are made visible to partial-trust code running in a sandboxed application domain.</summary>
        <value>Tableau de noms d'assemblys partiels, où chaque nom partiel se compose du nom d'assembly simple et de la clé publique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le <xref:System.Security.AllowPartiallyTrustedCallersAttribute> l’attribut (APTCA) peut être rendu conditionnel en définissant son <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> propriété <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>. Un assembly APTCA marqué avec <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> ne peut pas être utilisé par du code partiellement fiable, sauf si l’application hôte lui permet de.  
  
 L’hôte d’un domaine d’application sandbox permet au code dans le domaine d’application pour utiliser des assemblys avec les attributs APTCA conditionnels en créant un tableau qui contient le nom simple et la clé publique de chaque assembly et en attribuant à cette propriété. Par exemple, un élément du tableau peut se présenter comme suit : « MyAssembly, PublicKey = 0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad 0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9 ».  
  
> [!IMPORTANT]
>  Si vous utilisez une sous-classe de <xref:System.AppDomainManager>et l’assembly qui le définit dépend des assemblys marqués avec l’attribut APTCA conditionnel, vous devez inclure ces assemblys dans la liste que vous passez à la <xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A> propriété de la <xref:System.AppDomainSetup>vous permet de créer des domaines d’application. Sinon, les assemblys marqués avec l’attribut APTCA conditionnel seront désactivées.  
  
> [!NOTE]
>  Lorsque vous déboguez une application qui s’exécute dans un domaine d’application bac à sable, certains <xref:System.Security.SecurityException> messages peuvent être trompeuses. Par exemple, un message peut indiquer qu’un de vos assemblys de confiance totale dispose uniquement d’autorisations limitées, lorsque la véritable cause du problème est qu’une demande de sécurité qui dépasse le jeu d’autorisations du domaine d’application bac à sable a dépassé la limite de la domaine d’application sandbox et a échoué.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPath : string with get, set" Usage="System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the list of directories under the application base directory that are probed for private assemblies.</summary>
        <value>Liste de noms de répertoires séparés par des points-virgules.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les assemblys privés sont déployés dans la même structure de répertoire que l’application. Si les répertoires spécifiés pour <xref:System.AppDomainSetup.PrivateBinPath%2A> ne sont pas sous <xref:System.AppDomainSetup.ApplicationBase%2A>, ils sont ignorés.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPathProbe : string with get, set" Usage="System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a string value that includes or excludes <see cref="P:System.AppDomainSetup.ApplicationBase" /> from the search path for the application, and searches only <see cref="P:System.AppDomainSetup.PrivateBinPath" />.</summary>
        <value>Une référence null (<see langword="Nothing" /> en Visual Basic) pour inclure le chemin de base application lors de la recherche d’assemblys ; toute valeur de chaîne non null pour exclure le chemin d’accès. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définissez cette propriété sur une valeur de chaîne non null, y compris <xref:System.String.Empty?displayProperty=nameWithType> (« »), pour exclure le chemin de répertoire d’application : autrement dit, <xref:System.AppDomainSetup.ApplicationBase%2A> : du chemin de recherche pour l’application et pour rechercher des assemblys uniquement dans <xref:System.AppDomainSetup.PrivateBinPath%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SandboxInterop : bool with get, set" Usage="System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether interface caching is disabled for interop calls in the application domain, so that a <c>QueryInterface</c> is performed on each call.</summary>
        <value>
          <see langword="true" /> Si la mise en cache de l’interface est désactivée pour les appels interop dans les domaines d’application créés avec actuel <see cref="T:System.AppDomainSetup" /> de l’objet ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La désactivation de la mise en cache de l’interface d’a un impact significatif sur les performances des appels interop.  
  
 Ce membre est introduit dans le [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberSignature Language="F#" Value="member this.SetCompatibilitySwitches : seq&lt;string&gt; -&gt; unit" Usage="appDomainSetup.SetCompatibilitySwitches switches" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="switches">An enumerable set of string values that specify compatibility switches, or <see langword="null" /> to erase the existing compatibility switches.</param>
        <summary>Sets the specified switches, making the application domain compatible with previous versions of the .NET Framework for the specified issues.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les versions principales du .NET Framework parfois introduisent de modifications avec rupture de la version précédente. Par exemple, le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] présente un petit nombre de modifications avec rupture de la [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]. Utilisez le <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A> pour spécifier qu’une ou plusieurs de ces modifications avec rupture (méthode) doit être annulée pour le domaine d’application, pour rendre le comportement compatible avec la version précédente du .NET Framework.  
  
 Chaque fois que vous appelez cette méthode, il remplace les paramètres de commutateur existants. Pour effacer les paramètres, spécifiez `null` pour la `switches` paramètre.  
  
 L’ensemble de valeurs de chaîne que vous fournissez pour `switches` peut être un simple tableau de chaînes, car les tableaux implémentent la <xref:System.Collections.IEnumerable> interface.  
  
 Le tableau suivant fournit des exemples de commutateurs de compatibilité qui peuvent être définies pour restaurer le comportement des versions antérieures du .NET Framework.  
  
|Basculer|Signification|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Sécurité accès du code (CAS) pour le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] est activé dans ce domaine d’application. Consultez [ &lt;NetFx40_LegacySecurityPolicy&gt; élément](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|« NetFx40_Legacy20SortingBehavior »|Chaîne de tri des valeurs par défaut pour le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] sont activées dans ce domaine d’application. Restauration réussie du comportement de tri hérité requiert également la bibliothèque de liens dynamiques sort00001000.dll soit disponible sur le système local. Consultez [ &lt;CompatSortNLSVersion&gt; élément](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|« NetFx40_Legacy40SortingBehavior »|Chaîne de tri des valeurs par défaut pour le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] et Unicode 5.0 sont activés dans ce domaine d’application. Restauration réussie du comportement de tri hérité requiert également la bibliothèque de liens dynamiques sort00060101.dll soient disponibles sur le système local.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> mise en forme de comportement pour le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] est activé dans ce domaine d’application. Consultez [ &lt;TimeSpan_LegacyFormatMode&gt; élément](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) et la section « Restauration hérité TimeSpan mise en forme » de la <xref:System.TimeSpan> rubrique.|  
|« UseRandomizedStringHashAlgorithm »|Le runtime calcule les codes de hachage de chaînes sur un par domaine d’application au lieu d’utiliser un seul algorithme de hachage qui génère un code de hachage cohérent entre domaines d’application. Consultez [ &lt;UseRandomizedStringHashAlgorithm&gt; élément](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetConfigurationBytes : byte[] -&gt; unit" Usage="appDomainSetup.SetConfigurationBytes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">An array that contains the XML configuration information to be used for the application domain.</param>
        <summary>Provides XML configuration information for the application domain, replacing the application's XML configuration information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomainSetup.SetConfigurationBytes%2A> méthode offre un moyen pour remplacer les informations de configuration d’une application qui crée un nouveau domaine d’application. Les informations du fichier de configuration de `value` remplace les informations du fichier de configuration de l’application. Par exemple, quand l’application Example.exe crée un nouveau domaine d’application, il peut remplacer les informations de configuration obtenues à partir du fichier Example.exe.config.  
  
> [!IMPORTANT]
>  Certains consommateurs d’informations de fichier de configuration n’utilisent pas les informations stockées par le <xref:System.AppDomainSetup.SetConfigurationBytes%2A> (méthode). Le runtime n’applique pas cela. Pour vous assurer que toutes les informations de fichier de configuration sont remplacées dans un domaine d’application, utilisez le <xref:System.AppDomainSetup.ConfigurationFile%2A> propriété pour spécifier un fichier de configuration. Le <xref:System.AppDomainSetup.SetConfigurationBytes%2A> méthode n’affecte pas de liaison d’assembly.  
  
 Le code XML dans `value` est le même que le code XML dans un fichier de configuration normal, à ceci près qu’il est stocké en tant qu’un <xref:System.Byte> tableau.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="F#" Value="member this.SetNativeFunction : string * int * nativeint -&gt; unit" Usage="appDomainSetup.SetNativeFunction (functionName, functionVersion, functionPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="functionVersion" Type="System.Int32" />
        <Parameter Name="functionPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="functionName">The name of the string comparison function to override.</param>
        <param name="functionVersion">The function version. For [!INCLUDE[net_v45](~/includes/net-v45-md.md)], its value must be 1 or greater.</param>
        <param name="functionPointer">A pointer to the function that overrides <c>functionName</c>.</param>
        <summary>Provides the common language runtime with an alternate implementation of a string comparison function.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La comparaison des chaînes suivantes et les méthodes de tri peuvent être remplacées par la <xref:System.AppDomainSetup.SetNativeFunction%2A> méthode :  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 Pour plus d’informations sur ces fonctions, consultez [fonctions de prise en charge la langue nationale](http://go.microsoft.com/fwlink/?LinkId=228134).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionVersion" /> is not 1 or greater.  -or-  <paramref name="functionPointer" /> is <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyDirectories : string with get, set" Usage="System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the names of the directories containing assemblies to be shadow copied.</summary>
        <value>Liste de noms de répertoires séparés par des points-virgules.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors de la copie de l’ombre est activée, la valeur par défaut est de cliché instantané de tous les assemblys trouvés par détection ; Autrement dit, dans les répertoires spécifiés par la <xref:System.AppDomainSetup.PrivateBinPath%2A> et <xref:System.AppDomainSetup.ApplicationBase%2A> propriétés. Le <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> propriété restreint le cliché instantané aux assemblys dans les répertoires spécifiés par <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>.  
  
 Si vous n'affectez pas une chaîne à la propriété <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> ou si vous définissez cette propriété à `null`, tous les assemblys dans les répertoires spécifiés par les propriétés <xref:System.AppDomainSetup.ApplicationBase%2A> et <xref:System.AppDomainSetup.PrivateBinPath%2A> font l'objet d'un cliché instantané.  
  
> [!IMPORTANT]
>  Les chemins d'accès des répertoires ne doivent pas contenir de points-virgules, car le point-virgule est le caractère délimiteur. Il n'existe pas de caractère d'échappement pour les points-virgules.  
  
 Lors de la copie des clichés instantanés, les fichiers d’assembly sont copiés vers un autre emplacement avant que les assemblys sont chargés. Le fichier d’assembly d’origine n’est pas verrouillé, il peut être mis à jour. Pour plus d’informations sur les clichés instantanés, consultez [clichés instantanés d’assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations de chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : string with get, set" Usage="System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a string that indicates whether shadow copying is turned on or off.</summary>
        <value>Valeur de chaîne « true » pour indiquer que les clichés instantanés sont activés ou « false » pour indiquer que les clichés instantanés sont désactivés.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur les clichés instantanés, consultez [clichés instantanés d’assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string with get, set" Usage="System.AppDomainSetup.TargetFrameworkName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a string that specifies the target version and profile of the .NET Framework for the application domain, in a format that can be parsed by the <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" /> constructor.</summary>
        <value>Version et profil cibles du .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définissez cette propriété pour indiquer la version en cours d’exécution de .NET Framework que le domaine d’application servira à charger et exécuter des assemblys qui ont été compilés pour la version cible et le profil. Si la version en cours d’exécution du .NET Framework possède des comportements facultatifs qui affectent la compatibilité du code qui a été compilé avec la version cible, il peut activer ou désactiver ces comportements, si nécessaire, pour améliorer la compatibilité. Cela peut être utile lorsqu’une application prend en charge des compléments compilés avec plusieurs versions du .NET Framework en les exécutant dans les domaines d’application distincts.  
  
 Pour les applications clientes, la valeur de la <xref:System.AppDomainSetup.TargetFrameworkName%2A> propriété est déduite à partir de la <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribut. Dans [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] et version ultérieure, cet attribut est ajouté à l’assembly automatiquement en fonction du paramètre du projet **Framework cible** propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>