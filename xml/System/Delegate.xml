<Type Name="Delegate" FullName="System.Delegate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5da8a5d903502aaa8f36abfbc0a12b2e72e9ec73" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58749861" /></Metadata><TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un délégué qui est une structure de données référençant une méthode statique ou une instance de classe et une méthode d'instance de cette classe.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Delegate> classe est la classe de base pour les types délégués. Toutefois, seul le système et les compilateurs peuvent dériver explicitement de la <xref:System.Delegate> classe ou à partir de la <xref:System.MulticastDelegate> classe. Il est également possible de dériver un nouveau type à partir d’un type délégué. Le <xref:System.Delegate> classe n’est pas considéré comme un type délégué ; c’est une classe utilisée pour dériver des types délégués.  
  
 Implémenter la plupart des langages un `delegate` mot clé et les compilateurs pour ces langages sont en mesure de dériver à partir de la <xref:System.MulticastDelegate> classe ; par conséquent, les utilisateurs doivent utiliser le `delegate` mot clé fourni par le langage.  
  
> [!NOTE]
>  Le common language runtime fournit un `Invoke` méthode pour chaque type de délégué, avec la même signature que le délégué. Il est inutile d’appeler cette méthode explicitement à partir de c#, Visual Basic ou Visual C++, car les compilateurs appellent automatiquement. Le `Invoke` méthode est utile dans [réflexion](~/docs/framework/reflection-and-codedom/reflection.md) lorsque vous souhaitez trouver la signature du type délégué.  
  
 Le common language runtime fournit chaque type délégué avec `BeginInvoke` et `EndInvoke` méthodes, pour permettre l’invocation asynchrone du délégué. Pour plus d’informations sur ces méthodes, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 La déclaration d’un type délégué établit un contrat qui spécifie la signature d’une ou plusieurs méthodes. Un délégué est une instance d’un type délégué qui comporte des références à :  
  
-   Une méthode d’instance d’un type et un objet cible peut être assigné à ce type.  
  
-   Une méthode d’instance d’un type, avec le texte masqué `this` paramètre exposée dans la liste de paramètres formels. Le délégué est dit être un délégué d’ouvrir une instance.  
  
-   Une méthode statique.  
  
-   Une méthode statique et un objet cible peut être assigné au premier paramètre de la méthode. Le délégué est dit être fermé sur son premier argument.  
  
 Pour plus d’informations sur la liaison de délégués, consultez le <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> surcharge de méthode.  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, un délégué peut représenter une méthode uniquement si la signature de la méthode correspond exactement à la signature spécifiée par le type délégué. Par conséquent, uniquement les première et troisième puces dans la liste précédente sont prises en charge, et la première puce requiert une correspondance de type exact.  
  
 Lorsqu’un délégué représente une méthode d’instance fermée sur son premier argument (le cas le plus courant), le délégué stocke une référence au point d’entrée de la méthode et une référence à un objet, appelé cible, qui est d’un type assignable au type défini par le méthode. Lorsqu’un délégué représente une méthode d’instance ouverte, il stocke une référence au point d’entrée de la méthode. La signature du délégué doit inclure le texte masqué `this` paramètre dans sa liste de paramètres formels ; dans ce cas, le délégué n’a pas une référence à un objet cible, et un objet cible doit être fourni lorsque le délégué est appelé.  
  
 Lorsqu’un délégué représente une méthode statique, le délégué stocke une référence au point d’entrée de la méthode. Lorsqu’un délégué représente une méthode statique fermée sur son premier argument, le délégué stocke une référence au point d’entrée de la méthode et une référence à un objet cible peut être assigné au type du premier argument de la méthode. Lorsque le délégué est appelé, le premier argument de la méthode statique reçoit l’objet cible.  
  
 La liste d’appel d’un délégué est un ensemble ordonné de délégués dont chaque élément de la liste appelle exactement une des méthodes représentées par le délégué. Une liste d’appel peut contenir des méthodes en double. Lors d’un appel, les méthodes sont appelées dans l’ordre dans lequel ils apparaissent dans la liste d’appel. Un délégué tente d’appeler chaque méthode dans sa liste d’appel ; les doublons sont appelés une fois pour chaque fois qu’ils apparaissent dans la liste d’appel. Les délégués sont immuables ; une fois créé, la liste d’appel d’un délégué ne change pas.  
  
 Les délégués sont désignées comme multidiffusion ou la classe combinable, car un délégué peut appeler une ou plusieurs méthodes et peut être utilisé dans la combinaison d’opérations.  
  
 Opérations d’association, tel que <xref:System.Delegate.Combine%2A> et <xref:System.Delegate.Remove%2A>, ne modifient pas les délégués existants. Au lieu de cela, une telle opération retourne un nouveau délégué qui contient les résultats de l’opération, un délégué inchangé ou `null`. Une opération d’association retourne `null` lorsque le résultat de l’opération est un délégué qui ne fait pas référence au moins une méthode. Retourne un délégué inchangé lorsque l’opération demandée n’a aucun effet.  
  
> [!NOTE]
>  Les langages managés utilisent le <xref:System.Delegate.Combine%2A> et <xref:System.Delegate.Remove%2A> méthodes pour implémenter des opérations de délégué. Exemples incluent la `AddHandler` et `RemoveHandler` instructions en Visual Basic et les opérateurs += et -= sur types délégués en c#.  
  
 En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], les types délégués génériques peuvent avoir des paramètres de type variant. Paramètres de type contravariant peuvent être utilisés comme types de paramètre du délégué et un paramètre de type covariant peut être utilisé comme type de retour. Cette fonctionnalité autorise types construits à partir de la même définition de type générique pour être compatibles-assignation si leurs arguments de type sont des types de référence avec une relation d’héritage, comme expliqué dans les délégués génériques [Covariance et La contravariance](~/docs/standard/generics/covariance-and-contravariance.md).  
  
> [!NOTE]
>  Les délégués génériques qui sont compatibles avec affectation en raison de la variance ne sont pas nécessairement combinables. Pour pouvoir être associés, les types doivent correspondre exactement. Par exemple, prenons une classe nommée `Derived` est dérivé d’une classe nommée `Base`. Un délégué du type `Action<Base>` (`Action(Of Base)` en Visual Basic) peut être assignée à une variable de type `Action<Derived>`, mais les deux délégués ne peuvent pas être combinés, car les types ne correspondent pas exactement.  
  
 Si une méthode appelée lève une exception, la méthode arrête l’exécution de l’exception est passée à l’appelant du délégué et les méthodes restantes dans la liste d’appel ne sont pas appelés. Intercepter l’exception dans l’appelant ne modifie pas ce comportement.  
  
 Lors de la signature des méthodes appelées par un délégué inclut une valeur de retour, le délégué retourne la valeur de retour du dernier élément dans la liste d’appel. Lors de la signature inclut un paramètre qui est passé par référence, la valeur finale du paramètre est le résultat de chaque méthode dans la liste d’appel l’exécution de manière séquentielle et la mise à jour la valeur du paramètre.  
  
 L’équivalent le plus proche d’un délégué en C est un pointeur de fonction. Un délégué peut représenter une méthode statique ou une méthode d’instance. Lorsque le délégué représente une méthode d’instance, le délégué stocke non seulement une référence au point d’entrée de la méthode, mais également une référence à l’instance de classe. Contrairement aux pointeurs de fonction, les délégués sont orientés objet et plus sûr.  
  
   
  
## Examples  
 L’exemple suivant montre comment définir un délégué nommé `myMethodDelegate`. Instances de ce délégué sont créées pour une méthode d’instance et une méthode statique de la commande imbriquée `mySampleClass` classe. Le délégué de la méthode d’instance requiert une instance de `mySampleClass`. Le `mySampleClass` instance est enregistrée dans une variable nommée `mySC`.  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="https://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb">Appel de méthodes synchrones de façon asynchrone</related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md">Délégués (Guide de programmation C#)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md">Délégués (Visual Basic)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8">Comment : définir et utiliser des délégués (C++/CLI)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f">Gestion et déclenchement d'événements</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise un nouveau délégué.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="target">Instance de classe sur laquelle le délégué appelle <paramref name="method" />.</param>
        <param name="method">Nom de la méthode d'instance représentée par le délégué.</param>
        <summary>Initialise un délégué qui appelle la méthode d'instance spécifiée sur l'instance de classe spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur ne peut pas être utilisé dans le code d’application. Pour créer un délégué en spécifiant le nom d’une méthode d’instance, utilisez une surcharge de la <xref:System.Delegate.CreateDelegate%2A> méthode qui spécifie un nom de méthode et un objet cible. Par exemple, le <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> surcharge de méthode crée un délégué pour une méthode d’instance avec un nom spécifié.  
  
 Ce constructeur crée des délégués par exemple uniquement des méthodes. Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Une erreur s'est produite lors de la liaison à la méthode cible.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Type" /> représentant la classe qui définit <paramref name="method" />.</param>
        <param name="method">Nom de la méthode statique représentée par le délégué.</param>
        <summary>Initialise un délégué qui appelle la méthode statique spécifiée à partir de la classe spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur ne peut pas être utilisé dans le code d’application. Pour créer un délégué en spécifiant le nom d’une méthode statique, utilisez une surcharge de la <xref:System.Delegate.CreateDelegate%2A> méthode qui spécifie un nom de méthode, mais ne spécifie pas un objet cible. Par exemple, le <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> surcharge de méthode crée un délégué statique pour une méthode avec un nom spécifié.  
  
 Ce constructeur crée des délégués pour les méthodes statiques uniquement. Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> n’est pas un <see langword="RuntimeType" />. Consultez [Types au moment de l’exécution dans la réflexion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
ou 
 <paramref name="target" /> représente un type générique ouvert.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une copie superficielle du délégué.</summary>
        <returns>Copie superficielle du délégué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le clone a les mêmes <xref:System.Type>, cible, méthode et liste d’appel que le délégué d’origine.  
  
 Une copie superficielle crée une nouvelle instance du même type que l’objet d’origine et copie ensuite les champs non statiques de l’objet d’origine. Si le champ est un type valeur, une copie bit par bit du champ est effectuée. Si le champ est un type référence, la référence est copiée, mais l’objet référencé n’est pas. Par conséquent, la référence dans l’objet d’origine et la référence dans le clone pointent vers le même objet. En revanche, une copie complète d’un objet duplique tous les éléments référencés directement ou indirectement par les champs dans l’objet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatène les listes d'appel des délégués multicast (pouvant être combinés) spécifiés.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">Tableau de délégués à combiner.</param>
        <summary>Concatène les listes d'appel d'un tableau de délégués.</summary>
        <returns>Nouveau délégué avec une liste d’invocation qui concatène les listes d’invocation des délégués dans le tableau <paramref name="delegates" />. Retourne <see langword="null" /> si <paramref name="delegates" /> est <see langword="null" />, si <paramref name="delegates" /> contient zéro élément ou si chaque entrée de <paramref name="delegates" /> est <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `delegates` tableau contient des entrées qui sont `null`, ces entrées sont ignorées.  
  
 La liste d’appel peut contenir des entrées en double ; Autrement dit, les entrées qui font référence à la même méthode sur le même objet.  
  
> [!NOTE]
>  Les délégués génériques qui sont compatibles avec affectation en raison de la variance ne sont pas nécessairement combinables. Pour pouvoir être associés, les types doivent correspondre exactement. Par exemple, prenons une classe nommée `Derived` est dérivé d’une classe nommée `Base`. Un délégué du type `Action<Base>` (`Action(Of Base)` en Visual Basic) peut être assignée à une variable de type `Action<Derived>`, comme expliqué dans [Covariance et Contravariance](~/docs/standard/generics/covariance-and-contravariance.md), mais les deux délégués ne peuvent pas être combinés, car les types pas correspondre exactement.  
  
 <xref:System.Delegate.Combine%2A> est utile pour créer des gestionnaires d’événements qui appellent que plusieurs méthodes chaque fois qu’un événement se produit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Les entrées non null dans <paramref name="delegates" /> ne sont pas toutes des instances du même type de délégué.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">Délégué dont la liste d’appel est la première.</param>
        <param name="b">Délégué dont la liste d’appel est la dernière.</param>
        <summary>Concatène les listes d'appel de deux délégués.</summary>
        <returns>Nouveau délégué avec une liste d’appel qui concatène les listes d’appel de <paramref name="a" /> et <paramref name="b" />, dans cet ordre. Retourne <paramref name="a" /> si <paramref name="b" /> est <see langword="null" />, retourne <paramref name="b" /> si <paramref name="a" /> est une référence null, et retourne une référence null si <paramref name="a" /> et <paramref name="b" /> sont des références null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La liste d’appel peut contenir des entrées en double ; Autrement dit, les entrées qui font référence à la même méthode sur le même objet.  
  
> [!NOTE]
>  Les délégués génériques qui sont compatibles avec affectation en raison de la variance ne sont pas nécessairement combinables. Pour pouvoir être associés, les types doivent correspondre exactement. Par exemple, prenons une classe nommée `Derived` est dérivé d’une classe nommée `Base`. Un délégué du type `Action<Base>` (`Action(Of Base)` en Visual Basic) peut être assignée à une variable de type `Action<Derived>`, comme expliqué dans [Covariance et Contravariance](~/docs/standard/generics/covariance-and-contravariance.md), mais les deux délégués ne peuvent pas être combinés, car les types pas correspondre exactement.  
  
 <xref:System.Delegate.Combine%2A> est utile pour créer des gestionnaires d’événements qui appellent que plusieurs méthodes chaque fois qu’un événement se produit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="a" /> et <paramref name="b" /> ne sont ni l’un ni l’autre <see langword="null" />, et <paramref name="a" /> et <paramref name="b" /> ne sont pas des instances du même type délégué.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">Délégué multicast (pouvant être combiné) dont la liste d'appel doit être ajoutée à la fin de la liste d'appel du délégué multicast (pouvant être combiné) en cours.</param>
        <summary>Concatène les listes d'appel du délégué multicast (pouvant être combiné) spécifié et du délégué multicast (pouvant être combiné) en cours.</summary>
        <returns>Nouveau délégué multicast (pouvant être combiné) avec une liste d'appel qui concatène les listes d'appel du délégué multicast (pouvant être combiné) en cours et de <paramref name="d" />, ou délégué multicast (pouvant être combiné) en cours si <paramref name="d" /> est <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode s’applique uniquement si le délégué actuel est multicast (pouvant être combiné).  
  
 L’implémentation actuelle lève simplement une <xref:System.MulticastNotSupportedException>.  
  
 La liste d’appel peut contenir des entrées en double ; Autrement dit, les entrées qui font référence à la même méthode sur le même objet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">Toujours levée.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un délégué du type spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de délégué à créer.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> décrivant la méthode statique ou d’instance que le délégué doit représenter. Seules les méthodes statiques sont prises en charge dans les versions 1.0 et 1.1 du .NET Framework.</param>
        <summary>Crée un délégué du type spécifié pour représenter la méthode statique spécifiée.</summary>
        <returns>Délégué du type spécifié pour représenter la méthode statique spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans la version 1.0 et 1.1 du .NET Framework, cette surcharge de méthode crée des délégués pour les méthodes statiques uniquement. Dans le .NET Framework version 2.0, cette surcharge de méthode peut également créer instance ouverte délégués de la méthode ; Autrement dit, les délégués qui fournissent explicitement le premier argument masqué des méthodes d’instance. Pour obtenir une explication détaillée, consultez le plus général <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> surcharge de méthode, qui vous permet de créer toutes les combinaisons de délégués ouverts ou fermés pour les méthodes d’instance ou statiques et éventuellement pour spécifier un premier argument.  
  
> [!NOTE]
>  Cette surcharge de méthode doit être utilisée lorsque le délégué n’est pas fermé sur son premier argument, car il est un peu plus rapide dans ce cas.  
  
 Cette surcharge de méthode revient à appeler le <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> surcharge de méthode et en spécifiant `true` pour `throwOnBindFailure`.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Types de paramètre compatibles et Type de retour  
 Dans le .NET Framework version 2.0, les types de paramètre et le type de retour d’un délégué créé à l’aide de cette surcharge de méthode doivent être compatibles avec les types de paramètre et le type de retour de la méthode que le délégué représente ; les types n’ont pas à correspondre exactement. Cela représente un réel atout car bien du comportement de liaison dans le .NET Framework version 1.0 et 1.1, où les types doivent correspondre exactement.  
  
 Le paramètre d'un délégué est compatible avec le paramètre correspondant d'une méthode si le type de paramètre du délégué est plus restrictif que le type de paramètre de la méthode. En effet, cela garantit qu'un argument transmis au délégué peut être transmis à la méthode en toute sécurité.  
  
 De même, le type de retour d’un délégué est compatible avec le type de retour d’une méthode si le type de retour de la méthode est plus restrictif que le type de retour du délégué, car cela garantit que le cast de la valeur de retour de la méthode peut être effectué sans risque au type de retour du délégué.  
  
 Par exemple, un délégué avec un paramètre de type <xref:System.Collections.Hashtable> et un type de retour <xref:System.Object> peut représenter une méthode avec un paramètre de type <xref:System.Object> et une valeur de retour de type <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Cette section contient deux exemples de code. Le premier exemple montre les deux types délégués qui peuvent être créés avec cette surcharge de méthode : ouvrir sur une méthode d’instance et ouvert sur une méthode statique.  
  
 Le deuxième exemple de code illustre les types de paramètre compatibles et types de retour.  
  
 **Exemple 1**  
  
 L’exemple de code suivant montre deux façons un délégué peut être créé à l’aide de cette surcharge de la <xref:System.Delegate.CreateDelegate%2A> (méthode).  
  
> [!NOTE]
>  Il existe deux surcharges de la <xref:System.Delegate.CreateDelegate%2A> méthode qui spécifient un <xref:System.Reflection.MethodInfo> mais pas dans un premier argument ; leurs fonctionnalités sont identiques, sauf qu’une vous permet de spécifier s’il faut lever en cas d’échec pour lier et l’autre lève toujours. Cet exemple de code utilise les deux surcharges.  
  
 L’exemple déclare une classe `C` avec une méthode statique `M2` et une méthode d’instance `M1`, et deux types délégués : `D1` prend une instance de `C` et une chaîne, et `D2` prend une chaîne.  
  
 Une deuxième classe nommée `Example` contient le code qui crée les délégués.  
  
-   Un délégué du type `D1`, représentant une méthode d’instance ouverte, est créé pour la méthode d’instance `M1`. Une instance doit être passée lorsque le délégué est appelé.  
  
-   Un délégué du type `D2`, représentant une méthode statique ouverte, est créé pour la méthode statique `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Exemple 2**  
  
 L’exemple de code suivant illustre la compatibilité des types de paramètres et types de retour.  
  
 L’exemple de code définit une classe de base nommée `Base` et une classe nommée `Derived` qui dérive de `Base`. La classe dérivée a un `static` (`Shared` en Visual Basic) méthode nommée `MyMethod` avec un paramètre de type `Base` et un type de retour `Derived`. L’exemple de code définit également un délégué nommé `Example` qui a un paramètre de type `Derived` et un type de retour `Base`.  
  
 L’exemple de code montre que le délégué nommé `Example` peut être utilisé pour représenter la méthode `MyMethod`. La méthode peut être liée au délégué, car :  
  
-   Le type de paramètre du délégué (`Derived`) est plus restrictif que le type de paramètre de `MyMethod` (`Base`), afin qu’il soit toujours possible de passer l’argument du délégué à `MyMethod`.  
  
-   Le type de retour de `MyMethod` (`Derived`) est plus restrictif que le type de paramètre du délégué (`Base`), afin qu’il est toujours possible de convertir le type de retour de la méthode pour le type de retour du délégué.  
  
 L’exemple de code ne produit aucune sortie.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> n’hérite pas de <see cref="T:System.MulticastDelegate" />.  
  
ou 
 <paramref name="type" /> n’est pas un <see langword="RuntimeType" />. Consultez [Types au moment de l’exécution dans la réflexion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
ou 
 <paramref name="method" /> n’est pas une méthode statique, et la version du .NET Framework est 1.0 ou 1.1.  
  
ou 
 <paramref name="method" /> ne peut pas être liée.  
  
ou 
 <paramref name="method" /> n’est pas un <see langword="RuntimeMethodInfo" />. Consultez [Types au moment de l’exécution dans la réflexion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">La méthode <see langword="Invoke" /> de <paramref name="type" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de délégué à créer.</param>
        <param name="firstArgument">Objet auquel le délégué est lié, ou <see langword="null" /> si <paramref name="method" /> est traitée comme <see langword="static" /> (<see langword="Shared" /> en Visual Basic).</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> décrivant la méthode statique ou d’instance que le délégué doit représenter.</param>
        <summary>Crée un délégué du type spécifié qui représente la méthode statique ou méthode d'instance spécifiée, avec le premier argument spécifié.</summary>
        <returns>Délégué du type spécifié qui représente la méthode statique ou méthode d’instance spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette surcharge de méthode revient à appeler le <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> surcharge de méthode et en spécifiant `true` pour `throwOnBindFailure`. Ces deux surcharges offrent le moyen le plus simple pour créer des délégués. Vous pouvez les utiliser pour créer des délégués pour statiques ou des méthodes d’instance et éventuellement pour spécifier le premier argument.  
  
> [!NOTE]
>  Si vous ne fournissez pas un premier argument, utilisez le <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> surcharge de méthode pour de meilleures performances.  
  
 Le type de délégué et la méthode doivent avoir des types de retournés compatibles. Autrement dit, le type de retour de `method` doit être assignable au type de retour de `type`.  
  
 Si `firstArgument` est fourni, il est passé à `method` chaque fois que le délégué est appelé ; `firstArgument` est considéré comme lié au délégué, et le délégué est dit être fermé sur son premier argument. Si `method` est `static` (`Shared` en Visual Basic), l’argument fourni lorsque vous appelez le délégué de liste inclut tous les paramètres sauf la première ; si `method` est une méthode d’instance, puis `firstArgument` est passée à l’instance masquée paramètre (représenté par `this` dans c#, ou par `Me` en Visual Basic).  
  
 Si `firstArgument` est fourni, le premier paramètre de `method` doit être un type référence, et `firstArgument` doit être compatible avec ce type.  
  
> [!IMPORTANT]
>  Si `method` est `static` (`Shared` en Visual Basic) et son premier paramètre est de type <xref:System.Object> ou <xref:System.ValueType>, puis `firstArgument` peut être un type valeur. Dans ce cas `firstArgument` est automatiquement converti (boxed). Boxing automatique ne se produit pas pour les autres arguments, comme il s’agissait dans une fonction c# ou Visual Basic.  
  
 Si `firstArgument` est une référence null et `method` est une méthode d’instance, le résultat dépend des signatures du type délégué `type` et de `method`:  
  
-   Si la signature de `type` n’inclut pas explicitement le premier paramètre masqué de `method`, le délégué est dit représenter une méthode d’instance ouverte. Lorsque le délégué est appelé, le premier argument de la liste d’arguments est passé au paramètre d’instance masqué `method`.  
  
-   Si les signatures de `method` et `type` correspond à (autrement dit, tous les types de paramètre sont compatibles), le délégué est dit être fermé sur une référence null. Appel du délégué est à l’appel d’une méthode d’instance sur une instance null, ce qui n’est pas une chose particulièrement utile à faire.  
  
 Si `firstArgument` est une référence null et `method` est statique, le résultat dépend des signatures du type délégué `type` et de `method`:  
  
-   Si la signature de `method` et `type` correspond à (autrement dit, tous les types de paramètre sont compatibles), le délégué est dit représenter une méthode statique ouverte. Il s’agit du cas le plus courant pour les méthodes statiques. Dans ce cas, vous pouvez obtenir des performances légèrement meilleures en utilisant la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> surcharge de méthode.  
  
-   Si la signature de `type` commence par le deuxième paramètre de `method` le reste des types de paramètres sont compatibles, puis le délégué est dit être fermé sur une référence null. Lorsque le délégué est appelé, une référence null est passée au premier paramètre de `method`.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Types de paramètre compatibles et Type de retour  
 Les types de paramètre et le type de retour d’un délégué doivent être compatibles avec les types de paramètre et le type de retour de la méthode que le délégué représente ; les types n’ont pas à correspondre exactement.  
  
> [!NOTE]
>  Dans la version 1.0 et 1.1 du .NET Framework, les types doivent correspondre exactement.  
  
 Le paramètre d'un délégué est compatible avec le paramètre correspondant d'une méthode si le type de paramètre du délégué est plus restrictif que le type de paramètre de la méthode. En effet, cela garantit qu'un argument transmis au délégué peut être transmis à la méthode en toute sécurité.  
  
 De même, le type de retour d’un délégué est compatible avec le type de retour d’une méthode si le type de retour de la méthode est plus restrictif que le type de retour du délégué, car cela garantit que le cast de la valeur de retour de la méthode peut être effectué sans risque au type de retour du délégué.  
  
 Par exemple, un délégué avec un paramètre de type <xref:System.Collections.Hashtable> et un type de retour <xref:System.Object> peut représenter une méthode avec un paramètre de type <xref:System.Object> et une valeur de retour de type <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Déterminer les méthodes d’un délégué peut représenter.  
 Une autre façon utile de penser à la souplesse de cette surcharge de <xref:System.Delegate.CreateDelegate%2A> est qu’un délégué donné peut représenter quatre combinaisons différentes de signature de méthode et le type de méthode (statique contre instance). Considérez un type délégué `D` avec un argument de type `C`. La section suivante décrit les méthodes `D` peuvent représenter, en ignorant le type de retour dans la mesure où il doit correspondre dans tous les cas :  
  
-   `D` peut représenter n’importe quelle méthode d’instance qui a exactement un argument de type `C`, quel que soit le type auquel appartient la méthode d’instance. Lorsque <xref:System.Delegate.CreateDelegate%2A> est appelée, `firstArgument` est une instance du type `method` appartient, et le délégué résultant est dit être fermé sur cette instance. (Plus simplement, `D` peut aussi être fermé sur une référence null si `firstArgument` est une référence null.)  
  
-   `D` peut représenter une méthode d’instance de `C` qui n’a aucun argument. Lorsque <xref:System.Delegate.CreateDelegate%2A> est appelée, `firstArgument` est une référence null. Le délégué résultant représente une méthode d’instance ouverte et une instance de `C` doit être fourni à chaque fois qu’elle est appelée.  
  
-   `D` peut représenter une méthode statique qui prend un argument de type `C`, et cette méthode peut appartenir à n’importe quel type. Lorsque <xref:System.Delegate.CreateDelegate%2A> est appelée, `firstArgument` est une référence null. Le délégué résultant représente une méthode statique ouverte et une instance de `C` doit être fourni à chaque fois qu’elle est appelée.  
  
-   `D` peut représenter une méthode statique appartenant au type `F` et a deux arguments de type `F` et type `C`. Lorsque <xref:System.Delegate.CreateDelegate%2A> est appelée, `firstArgument` est une instance de `F`. Le délégué résultant représente une méthode statique qui est fermée sur cette instance de `F`. Notez que dans le cas où `F` et `C` sont du même type, la méthode statique a deux arguments de ce type. (Dans ce cas, `D` est fermé sur une référence null si `firstArgument` est une référence null.)  
  
   
  
## Examples  
 Cette section contient trois exemples de code. Le premier exemple illustre les quatre types de délégués qui peuvent être créés : fermé sur une méthode d’instance, ouverte sur une méthode d’instance, ouverte sur une méthode statique et fermé sur une méthode statique.  
  
 Le deuxième exemple de code illustre les types de paramètre compatibles et types de retour.  
  
 Le troisième exemple de code définit un type délégué simple et affiche toutes les méthodes que le type délégué peuvent représenter.  
  
 **Exemple 1**  
  
 L’exemple de code suivant montre les quatre façons un délégué peut être créé à l’aide de cette surcharge de la <xref:System.Delegate.CreateDelegate%2A> (méthode).  
  
> [!NOTE]
>  Il existe deux surcharges de la <xref:System.Delegate.CreateDelegate%2A> méthode spécifier `firstArgument` et un <xref:System.Reflection.MethodInfo>; leurs fonctionnalités sont identiques, sauf qu’une vous permet de spécifier s’il faut lever en cas d’échec pour lier et l’autre lève toujours. Cet exemple de code utilise les deux surcharges.  
  
 L’exemple déclare une classe `C` avec une méthode statique `M2` et une méthode d’instance `M1`, et trois types délégués : `D1` prend une instance de `C` et une chaîne, `D2` prend une chaîne et `D3`n’a aucun argument.  
  
 Une deuxième classe nommée `Example` contient le code qui crée les délégués.  
  
-   Un délégué du type `D2`, fermé sur une instance de `C`, est créé pour la méthode d’instance `M1`. Il est appelé avec différentes chaînes, pour indiquer que l’instance liée de `C` est toujours utilisé.  
  
-   Un délégué du type `D1`, représentant une méthode d’instance ouverte, est créé pour la méthode d’instance `M1`. Une instance doit être passée lorsque le délégué est appelé.  
  
-   Un délégué du type `D2`, représentant une méthode statique ouverte, est créé pour la méthode statique `M2`.  
  
-   Enfin, un délégué du type `D3`, fermé sur une chaîne, est créé pour la méthode statique `M2`. La méthode est appelée pour montrer qu’il utilise la chaîne liée.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Exemple 2**  
  
 L’exemple de code suivant illustre la compatibilité des types de paramètres et types de retour.  
  
> [!NOTE]
>  Cet exemple de code utilise le <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> surcharge de méthode. L’utilisation d’autres surcharges qui prennent <xref:System.Reflection.MethodInfo> est similaire.  
  
 L’exemple de code définit une classe de base nommée `Base` et une classe nommée `Derived` qui dérive de `Base`. La classe dérivée a un `static` (`Shared` en Visual Basic) méthode nommée `MyMethod` avec un paramètre de type `Base` et un type de retour `Derived`. L’exemple de code définit également un délégué nommé `Example` qui a un paramètre de type `Derived` et un type de retour `Base`.  
  
 L’exemple de code montre que le délégué nommé `Example` peut être utilisé pour représenter la méthode `MyMethod`. La méthode peut être liée au délégué, car :  
  
-   Le type de paramètre du délégué (`Derived`) est plus restrictif que le type de paramètre de `MyMethod` (`Base`), afin qu’il soit toujours possible de passer l’argument du délégué à `MyMethod`.  
  
-   Le type de retour de `MyMethod` (`Derived`) est plus restrictif que le type de paramètre du délégué (`Base`), afin qu’il est toujours possible de convertir le type de retour de la méthode pour le type de retour du délégué.  
  
 L’exemple de code ne produit aucune sortie.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Exemple 3**  
  
 L’exemple de code suivant montre toutes les méthodes d’un type délégué simple peut représenter, à l’aide de la <xref:System.Delegate.CreateDelegate%2A> méthode pour créer les délégués.  
  
> [!NOTE]
>  Il existe deux surcharges de la <xref:System.Delegate.CreateDelegate%2A> méthode spécifier `firstArgument` et un <xref:System.Reflection.MethodInfo>; leurs fonctionnalités sont identiques, sauf qu’une vous permet de spécifier s’il faut lever en cas d’échec pour lier et l’autre lève toujours. Cet exemple de code utilise les deux surcharges.  
  
 L’exemple de code définit deux classes, `C` et `F`et un type délégué `D` avec un argument de type `C`. Les classes ont la mise en correspondance statique et méthodes d’instance `M1`, `M3`, et `M4`et classe `C` a également une méthode d’instance `M2` qui n’a aucun argument.  
  
 Une troisième classe nommée `Example` contient le code qui crée les délégués.  
  
-   Les délégués sont créés pour instance méthode `M1` de type `C` et type `F`; chacun est fermé sur une instance du type respectif. Méthode `M1` de type `C` affiche le `ID` propriétés de l’instance liée et de l’argument.  
  
-   Un délégué est créé pour la méthode `M2` de type `C`. Il s’agit d’un délégué d’ouvrir une instance, dans laquelle l’argument du délégué représente le premier argument masqué sur la méthode d’instance. La méthode ne possède aucun autre argument. Elle est appelée comme s’il s’agissait d’une méthode statique.  
  
-   Les délégués sont créés pour la méthode statique `M3` de type `C` et type `F`; il s’agit des délégués statiques ouverts.  
  
-   Enfin, les délégués sont créés pour la méthode statique `M4` de type `C` et type `F`; chaque méthode a le type déclarant comme premier argument, et une instance du type est fournie, les délégués sont fermés sur leurs premiers arguments . Méthode `M4` de type `C` affiche le `ID` propriétés de l’instance liée et de l’argument.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> n’hérite pas de <see cref="T:System.MulticastDelegate" />.  
  
ou 
 <paramref name="type" /> n’est pas un <see langword="RuntimeType" />. Consultez [Types au moment de l’exécution dans la réflexion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
ou 
 <paramref name="method" /> ne peut pas être liée.  
  
ou 
 <paramref name="method" /> n’est pas un <see langword="RuntimeMethodInfo" />. Consultez [Types au moment de l’exécution dans la réflexion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">La méthode <see langword="Invoke" /> de <paramref name="type" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de délégué à créer.</param>
        <param name="target">Instance de classe sur laquelle la méthode <paramref name="method" /> est appelée.</param>
        <param name="method">Nom de la méthode d’instance que doit représenter le délégué.</param>
        <summary>Crée un délégué du type spécifié qui représente la méthode d'instance spécifiée à appeler sur l'instance de classe spécifiée.</summary>
        <returns>Délégué du type spécifié qui représente la méthode d'instance spécifiée à appeler sur l'instance de classe spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée des délégués par exemple uniquement des méthodes. Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.  
  
 Cette surcharge de méthode revient à appeler le <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode, en spécifiant `false` pour `ignoreCase` et `true` pour `throwOnBindFailure`.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="target" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> n’hérite pas de <see cref="T:System.MulticastDelegate" />.  
  
ou 
 <paramref name="type" /> n’est pas un <see langword="RuntimeType" />. Consultez [Types au moment de l’exécution dans la réflexion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
ou 
 <paramref name="method" /> n’est pas une méthode d’instance.  
  
ou 
 <paramref name="method" /> ne peut pas être lié, ce qui peut arriver s’il est introuvable.</exception>
        <exception cref="T:System.MissingMethodException">La méthode <see langword="Invoke" /> de <paramref name="type" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de délégué à créer.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> décrivant la méthode statique ou d’instance que le délégué doit représenter.</param>
        <param name="throwOnBindFailure"><see langword="true" /> pour lever une exception si <paramref name="method" /> ne peut pas être lié ; sinon, <see langword="false" />.</param>
        <summary>Crée un délégué du type spécifié pour représenter la méthode statique spécifiée, avec le comportement spécifié en cas d'échec de la liaison.</summary>
        <returns>Délégué du type spécifié pour représenter la méthode statique spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de méthode peut créer des délégués de méthode statique ouverte et méthode délégués d’instance ouverts - autrement dit, les délégués qui exposent le premier argument masqué des méthodes d’instance. Pour obtenir une explication détaillée, consultez le plus général <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> surcharge de méthode, qui vous permet de créer toutes les combinaisons de délégués ouverts ou fermés par l’instance ou les méthodes statiques.  
  
> [!NOTE]
>  Cette surcharge de méthode doit être utilisée lorsque le délégué n’est pas fermé sur son premier argument, car il est un peu plus rapide dans ce cas.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Types de paramètre compatibles et Type de retour  
 Les types de paramètre et le type de retour d’un délégué doivent être compatibles avec les types de paramètre et le type de retour de la méthode que le délégué représente ; les types n’ont pas à correspondre exactement.  
  
> [!NOTE]
>  Dans la version 1.0 et 1.1 du .NET Framework, les types doivent correspondre exactement.  
  
 Le paramètre d'un délégué est compatible avec le paramètre correspondant d'une méthode si le type de paramètre du délégué est plus restrictif que le type de paramètre de la méthode. En effet, cela garantit qu'un argument transmis au délégué peut être transmis à la méthode en toute sécurité.  
  
 De même, le type de retour d’un délégué est compatible avec le type de retour d’une méthode si le type de retour de la méthode est plus restrictif que le type de retour du délégué, car cela garantit que le cast de la valeur de retour de la méthode peut être effectué sans risque au type de retour du délégué.  
  
 Par exemple, un délégué avec un paramètre de type <xref:System.Collections.Hashtable> et un type de retour <xref:System.Object> peut représenter une méthode avec un paramètre de type <xref:System.Object> et une valeur de retour de type <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Cette section contient deux exemples de code. Le premier exemple montre les deux types délégués qui peuvent être créés avec cette surcharge de méthode : ouvrir sur une méthode d’instance et ouvert sur une méthode statique.  
  
 Le deuxième exemple de code illustre les types de paramètre compatibles et types de retour.  
  
 **Exemple 1**  
  
 L’exemple de code suivant montre deux façons un délégué peut être créé à l’aide de cette surcharge de la <xref:System.Delegate.CreateDelegate%2A> (méthode).  
  
> [!NOTE]
>  Il existe deux surcharges de la <xref:System.Delegate.CreateDelegate%2A> méthode qui spécifient un <xref:System.Reflection.MethodInfo> mais pas dans un premier argument ; leurs fonctionnalités sont identiques, sauf qu’une vous permet de spécifier s’il faut lever en cas d’échec pour lier et l’autre lève toujours. Cet exemple de code utilise les deux surcharges.  
  
 L’exemple déclare une classe `C` avec une méthode statique `M2` et une méthode d’instance `M1`, et deux types délégués : `D1` prend une instance de `C` et une chaîne, et `D2` prend une chaîne.  
  
 Une deuxième classe nommée `Example` contient le code qui crée les délégués.  
  
-   Un délégué du type `D1`, représentant une méthode d’instance ouverte, est créé pour la méthode d’instance `M1`. Une instance doit être passée lorsque le délégué est appelé.  
  
-   Un délégué du type `D2`, représentant une méthode statique ouverte, est créé pour la méthode statique `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Exemple 2**  
  
 L’exemple de code suivant illustre la compatibilité des types de paramètres et types de retour.  
  
> [!NOTE]
>  Cet exemple de code utilise le <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> surcharge de méthode. L’utilisation d’autres surcharges qui prennent <xref:System.Reflection.MethodInfo> est similaire.  
  
 L’exemple de code définit une classe de base nommée `Base` et une classe nommée `Derived` qui dérive de `Base`. La classe dérivée a un `static` (`Shared` en Visual Basic) méthode nommée `MyMethod` avec un paramètre de type `Base` et un type de retour `Derived`. L’exemple de code définit également un délégué nommé `Example` qui a un paramètre de type `Derived` et un type de retour `Base`.  
  
 L’exemple de code montre que le délégué nommé `Example` peut être utilisé pour représenter la méthode `MyMethod`. La méthode peut être liée au délégué, car :  
  
-   Le type de paramètre du délégué (`Derived`) est plus restrictif que le type de paramètre de `MyMethod` (`Base`), afin qu’il soit toujours possible de passer l’argument du délégué à `MyMethod`.  
  
-   Le type de retour de `MyMethod` (`Derived`) est plus restrictif que le type de paramètre du délégué (`Base`), afin qu’il est toujours possible de convertir le type de retour de la méthode pour le type de retour du délégué.  
  
 L’exemple de code ne produit aucune sortie.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> n’hérite pas de <see cref="T:System.MulticastDelegate" />.  
  
ou 
 <paramref name="type" /> n’est pas un <see langword="RuntimeType" />. Consultez [Types au moment de l’exécution dans la réflexion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
ou 
 <paramref name="method" /> ne peut pas être lié et <paramref name="throwOnBindFailure" /> a la valeur <see langword="true" />.  
  
ou 
 <paramref name="method" /> n’est pas un <see langword="RuntimeMethodInfo" />. Consultez [Types au moment de l’exécution dans la réflexion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">La méthode <see langword="Invoke" /> de <paramref name="type" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de délégué à créer.</param>
        <param name="target"><see cref="T:System.Type" /> représentant la classe qui implémente <paramref name="method" />.</param>
        <param name="method">Nom de la méthode statique que doit représenter le délégué.</param>
        <summary>Crée un délégué du type spécifié qui représente la méthode statique spécifiée de la classe spécifiée.</summary>
        <returns>Délégué du type spécifié qui représente la méthode statique spécifiée de la classe spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée des délégués pour les méthodes statiques uniquement. Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.  
  
 Cette surcharge de méthode revient à appeler le <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode, en spécifiant `false` pour `ignoreCase` et `true` pour `throwOnBindFailure`.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="target" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> n’hérite pas de <see cref="T:System.MulticastDelegate" />.  
  
ou 
 <paramref name="type" /> n’est pas un <see langword="RuntimeType" />. Consultez [Types au moment de l’exécution dans la réflexion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
ou 
 <paramref name="target" /> n'est pas un <see langword="RuntimeType" />.  
  
ou 
 <paramref name="target" /> est un type générique ouvert. Autrement dit, sa propriété <see cref="P:System.Type.ContainsGenericParameters" /> a la valeur <see langword="true" />.  
  
ou 
 <paramref name="method" /> n’est pas une méthode <see langword="static" /> (méthode <see langword="Shared" /> en Visual Basic).  
  
ou 
 <paramref name="method" /> ne peut pas être lié, par exemple car elle est introuvable, et <paramref name="throwOnBindFailure" /> a la valeur <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">La méthode <see langword="Invoke" /> de <paramref name="type" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> représentant le type de délégué à créer.</param>
        <param name="firstArgument"><see cref="T:System.Object" /> correspondant au premier argument de la méthode que le délégué représente. Pour les méthodes d'instance, il doit être compatible avec le type d'instance.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> décrivant la méthode statique ou d’instance que le délégué doit représenter.</param>
        <param name="throwOnBindFailure"><see langword="true" /> pour lever une exception si <paramref name="method" /> ne peut pas être lié ; sinon, <see langword="false" />.</param>
        <summary>Crée un délégué du type spécifié qui représente la méthode statique ou d'instance spécifiée, avec le premier argument spécifié et le comportement spécifié en cas d'échec de la liaison.</summary>
        <returns>Délégué du type spécifié qui représente la méthode statique ou d’instance spécifiée, ou <see langword="null" /> si <paramref name="throwOnBindFailure" /> a la valeur <see langword="false" /> et que le délégué ne peut pas être lié à <paramref name="method" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de méthode et la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> surcharge de méthode qui lève toujours une exception en cas d’échec à lier, le moyen le plus flexible pour créer des délégués. Vous pouvez les utiliser pour créer des délégués pour statiques ou des méthodes d’instance, avec ou sans un premier argument.  
  
> [!NOTE]
>  Si vous ne fournissez pas un premier argument, utilisez le <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> surcharge de méthode pour de meilleures performances.  
  
 Le type de délégué et la méthode doivent avoir des types de retournés compatibles. Autrement dit, le type de retour de `method` doit être assignable au type de retour de `type`.  
  
 Si `firstArgument` est fourni, il est passé à `method` chaque fois que le délégué est appelé ; `firstArgument` est considéré comme lié au délégué, et le délégué est dit être fermé sur son premier argument. Si `method` est `static` (`Shared` en Visual Basic), l’argument fourni lorsque vous appelez le délégué de liste inclut tous les paramètres sauf la première ; si `method` est une méthode d’instance, puis `firstArgument` est passée à l’instance masquée paramètre (représenté par `this` dans c#, ou par `Me` en Visual Basic).  
  
 Si `firstArgument` est fourni, le premier paramètre de `method` doit être un type référence, et `firstArgument` doit être compatible avec ce type.  
  
> [!IMPORTANT]
>  Si `method` est `static` (`Shared` en Visual Basic) et son premier paramètre est de type <xref:System.Object> ou <xref:System.ValueType>, puis `firstArgument` peut être un type valeur. Dans ce cas `firstArgument` est automatiquement converti (boxed). Boxing automatique ne se produit pas pour les autres arguments, comme il s’agissait dans une fonction c# ou Visual Basic.  
  
 Si `firstArgument` est une référence null et `method` est une méthode d’instance, le résultat dépend des signatures du type délégué `type` et de `method`:  
  
-   Si la signature de `type` n’inclut pas explicitement le premier paramètre masqué de `method`, le délégué est dit représenter une méthode d’instance ouverte. Lorsque le délégué est appelé, le premier argument de la liste d’arguments est passé au paramètre d’instance masqué `method`.  
  
-   Si les signatures de `method` et `type` correspond à (autrement dit, tous les types de paramètre sont compatibles), le délégué est dit être fermé sur une référence null. Appel du délégué est à l’appel d’une méthode d’instance sur une instance null, ce qui n’est pas une chose particulièrement utile à faire.  
  
 Si `firstArgument` est une référence null et `method` est statique, le résultat dépend des signatures du type délégué `type` et de `method`:  
  
-   Si la signature de `method` et `type` correspond à (autrement dit, tous les types de paramètre sont compatibles), le délégué est dit représenter une méthode statique ouverte. Il s’agit du cas le plus courant pour les méthodes statiques. Dans ce cas, vous pouvez obtenir des performances légèrement meilleures en utilisant la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> surcharge de méthode.  
  
-   Si la signature de `type` commence par le deuxième paramètre de `method` le reste des types de paramètres sont compatibles, puis le délégué est dit être fermé sur une référence null. Lorsque le délégué est appelé, une référence null est passée au premier paramètre de `method`.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Types de paramètre compatibles et Type de retour  
 Les types de paramètre et le type de retour d’un délégué doivent être compatibles avec les types de paramètre et le type de retour de la méthode que le délégué représente ; les types n’ont pas à correspondre exactement.  
  
> [!NOTE]
>  Dans le .NET Framework version 1.0 et 1.1, les types doivent correspondre exactement.  
  
 Le paramètre d'un délégué est compatible avec le paramètre correspondant d'une méthode si le type de paramètre du délégué est plus restrictif que le type de paramètre de la méthode. En effet, cela garantit qu'un argument transmis au délégué peut être transmis à la méthode en toute sécurité.  
  
 De même, le type de retour d’un délégué est compatible avec le type de retour d’une méthode si le type de retour de la méthode est plus restrictif que le type de retour du délégué, car cela garantit que le cast de la valeur de retour de la méthode peut être effectué sans risque au type de retour du délégué.  
  
 Par exemple, un délégué avec un paramètre de type <xref:System.Collections.Hashtable> et un type de retour <xref:System.Object> peut représenter une méthode avec un paramètre de type <xref:System.Object> et une valeur de retour de type <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Déterminer les méthodes d’un délégué peut représenter.  
 Une autre façon utile de penser à la souplesse de cette surcharge de <xref:System.Delegate.CreateDelegate%2A> est qu’un délégué donné peut représenter quatre combinaisons différentes de signature de méthode et le type de méthode (statique contre instance). Considérez un type délégué `D` avec un argument de type `C`. La section suivante décrit les méthodes `D` peuvent représenter, en ignorant le type de retour dans la mesure où il doit correspondre dans tous les cas :  
  
-   `D` peut représenter n’importe quelle méthode d’instance qui a exactement un argument de type `C`, quel que soit le type auquel appartient la méthode d’instance. Lorsque <xref:System.Delegate.CreateDelegate%2A> est appelée, `firstArgument` est une instance du type `method` appartient, et le délégué résultant est dit être fermé sur cette instance. (Plus simplement, `D` peut aussi être fermé sur une référence null si `firstArgument` est `null`.)  
  
-   `D` peut représenter une méthode d’instance de `C` qui n’a aucun argument. Lorsque <xref:System.Delegate.CreateDelegate%2A> est appelée, `firstArgument` est une référence null. Le délégué résultant représente une méthode d’instance ouverte et une instance de `C` doit être fourni à chaque fois qu’elle est appelée.  
  
-   `D` peut représenter une méthode statique qui prend un argument de type `C`, et cette méthode peut appartenir à n’importe quel type. Lorsque <xref:System.Delegate.CreateDelegate%2A> est appelée, `firstArgument` est une référence null. Le délégué résultant représente une méthode statique ouverte et une instance de `C` doit être fourni à chaque fois qu’elle est appelée.  
  
-   `D` peut représenter une méthode statique appartenant au type `F` et a deux arguments de type `F` et type `C`. Lorsque <xref:System.Delegate.CreateDelegate%2A> est appelée, `firstArgument` est une instance de `F`. Le délégué résultant représente une méthode statique qui est fermée sur cette instance de `F`. Notez que dans le cas où `F` et `C` sont du même type, la méthode statique a deux arguments de ce type. (Dans ce cas, `D` est fermé sur une référence null si `firstArgument` est `null`.)  
  
   
  
## Examples  
 Cette section contient trois exemples de code. Le premier exemple illustre les quatre types de délégués qui peuvent être créés : fermé sur une méthode d’instance, ouverte sur une méthode d’instance, ouverte sur une méthode statique et fermé sur une méthode statique.  
  
 Le deuxième exemple de code illustre les types de paramètre compatibles et types de retour.  
  
 Le troisième exemple de code définit un type délégué simple et affiche toutes les méthodes que le type délégué peuvent représenter.  
  
 **Exemple 1**  
  
 L’exemple de code suivant montre les quatre façons un délégué peut être créé à l’aide de cette surcharge de la <xref:System.Delegate.CreateDelegate%2A> (méthode).  
  
> [!NOTE]
>  Il existe deux surcharges de la <xref:System.Delegate.CreateDelegate%2A> méthode spécifier `firstArgument` et un <xref:System.Reflection.MethodInfo>; leurs fonctionnalités sont identiques, sauf qu’une vous permet de spécifier s’il faut lever en cas d’échec pour lier et l’autre lève toujours. Cet exemple de code utilise les deux surcharges.  
  
 L’exemple déclare une classe `C` avec une méthode statique `M2` et une méthode d’instance `M1`, et trois types délégués : `D1` prend une instance de `C` et une chaîne, `D2` prend une chaîne et `D3`n’a aucun argument.  
  
 Une deuxième classe nommée `Example` contient le code qui crée les délégués.  
  
-   Un délégué du type `D2`, fermé sur une instance de `C`, est créé pour la méthode d’instance `M1`. Il est appelé avec différentes chaînes, pour indiquer que l’instance liée de `C` est toujours utilisé.  
  
-   Un délégué du type `D1`, représentant une méthode d’instance ouverte, est créé pour la méthode d’instance `M1`. Une instance doit être passée lorsque le délégué est appelé.  
  
-   Un délégué du type `D2`, représentant une méthode statique ouverte, est créé pour la méthode statique `M2`.  
  
-   Enfin, un délégué du type `D3`, fermé sur une chaîne, est créé pour la méthode statique `M2`. La méthode est appelée pour montrer qu’il utilise la chaîne liée.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Exemple 2**  
  
 L’exemple de code suivant illustre la compatibilité des types de paramètres et types de retour.  
  
> [!NOTE]
>  Cet exemple de code utilise le <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> surcharge de méthode. L’utilisation d’autres surcharges qui prennent <xref:System.Reflection.MethodInfo> est similaire.  
  
 L’exemple de code définit une classe de base nommée `Base` et une classe nommée `Derived` qui dérive de `Base`. La classe dérivée a un `static` (`Shared` en Visual Basic) méthode nommée `MyMethod` avec un paramètre de type `Base` et un type de retour `Derived`. L’exemple de code définit également un délégué nommé `Example` qui a un paramètre de type `Derived` et un type de retour `Base`.  
  
 L’exemple de code montre que le délégué nommé `Example` peut être utilisé pour représenter la méthode `MyMethod`. La méthode peut être liée au délégué, car :  
  
-   Le type de paramètre du délégué (`Derived`) est plus restrictif que le type de paramètre de `MyMethod` (`Base`), afin qu’il soit toujours possible de passer l’argument du délégué à `MyMethod`.  
  
-   Le type de retour de `MyMethod` (`Derived`) est plus restrictif que le type de paramètre du délégué (`Base`), afin qu’il est toujours possible de convertir le type de retour de la méthode pour le type de retour du délégué.  
  
 L’exemple de code ne produit aucune sortie.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Exemple 3**  
  
 L’exemple de code suivant montre toutes les méthodes de qu'un type délégué simple peut représenter.  
  
> [!NOTE]
>  Il existe deux surcharges de la <xref:System.Delegate.CreateDelegate%2A> méthode spécifier `firstArgument` et un <xref:System.Reflection.MethodInfo>; leurs fonctionnalités sont identiques, sauf qu’une vous permet de spécifier s’il faut lever en cas d’échec pour lier et l’autre lève toujours. Cet exemple de code utilise les deux surcharges.  
  
 L’exemple de code définit deux classes, `C` et `F`et un type délégué `D` avec un argument de type `C`. Les classes ont la mise en correspondance statique et méthodes d’instance `M1`, `M3`, et `M4`et classe `C` a également une méthode d’instance `M2` qui n’a aucun argument.  
  
 Une troisième classe nommée `Example` contient le code qui crée les délégués.  
  
-   Les délégués sont créés pour instance méthode `M1` de type `C` et type `F`; chacun est fermé sur une instance du type respectif. Méthode `M1` de type `C` affiche le `ID` propriétés de l’instance liée et de l’argument.  
  
-   Un délégué est créé pour la méthode `M2` de type `C`. Il s’agit d’un délégué d’ouvrir une instance, dans laquelle l’argument du délégué représente le premier argument masqué sur la méthode d’instance. La méthode ne possède aucun autre argument.  
  
-   Les délégués sont créés pour la méthode statique `M3` de type `C` et type `F`; il s’agit des délégués statiques ouverts.  
  
-   Enfin, les délégués sont créés pour la méthode statique `M4` de type `C` et type `F`; chaque méthode a le type déclarant comme premier argument, et une instance du type est fournie, les délégués sont fermés sur leurs premiers arguments . Méthode `M4` de type `C` affiche le `ID` propriétés de l’instance liée et de l’argument.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> n’hérite pas de <see cref="T:System.MulticastDelegate" />.  
  
ou 
 <paramref name="type" /> n’est pas un <see langword="RuntimeType" />. Consultez [Types au moment de l’exécution dans la réflexion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
ou 
 <paramref name="method" /> ne peut pas être lié et <paramref name="throwOnBindFailure" /> a la valeur <see langword="true" />.  
  
ou 
 <paramref name="method" /> n’est pas un <see langword="RuntimeMethodInfo" />. Consultez [Types au moment de l’exécution dans la réflexion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">La méthode <see langword="Invoke" /> de <paramref name="type" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de délégué à créer.</param>
        <param name="target">Instance de classe sur laquelle la méthode <paramref name="method" /> est appelée.</param>
        <param name="method">Nom de la méthode d’instance que doit représenter le délégué.</param>
        <param name="ignoreCase">Valeur booléenne indiquant si la casse doit être ignorée pendant la comparaison du nom de la méthode.</param>
        <summary>Crée un délégué du type spécifié qui représente la méthode d'instance spécifiée à appeler sur l'instance de classe spécifiée, avec le respect de la casse spécifié.</summary>
        <returns>Délégué du type spécifié qui représente la méthode d'instance spécifiée à appeler sur l'instance de classe spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée des délégués par exemple uniquement des méthodes. Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.  
  
 Cette surcharge de méthode revient à appeler le <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode, en spécifiant `true` pour `throwOnBindFailure`.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="target" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> n’hérite pas de <see cref="T:System.MulticastDelegate" />.  
  
ou 
 <paramref name="type" /> n’est pas un <see langword="RuntimeType" />. Consultez [Types au moment de l’exécution dans la réflexion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
ou 
 <paramref name="method" /> n’est pas une méthode d’instance.  
  
ou 
 <paramref name="method" /> ne peut pas être lié, ce qui peut arriver s’il est introuvable.</exception>
        <exception cref="T:System.MissingMethodException">La méthode <see langword="Invoke" /> de <paramref name="type" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de délégué à créer.</param>
        <param name="target"><see cref="T:System.Type" /> représentant la classe qui implémente <paramref name="method" />.</param>
        <param name="method">Nom de la méthode statique que doit représenter le délégué.</param>
        <param name="ignoreCase">Valeur booléenne indiquant si la casse doit être ignorée pendant la comparaison du nom de la méthode.</param>
        <summary>Crée un délégué du type spécifié qui représente la méthode statique spécifiée de la classe spécifiée, avec le respect de la casse spécifié.</summary>
        <returns>Délégué du type spécifié qui représente la méthode statique spécifiée de la classe spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée des délégués pour les méthodes statiques uniquement. Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.  
  
 Cette surcharge de méthode revient à appeler le <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode, en spécifiant `true` pour `throwOnBindFailure`.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="target" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> n’hérite pas de <see cref="T:System.MulticastDelegate" />.  
  
ou 
 <paramref name="type" /> n’est pas un <see langword="RuntimeType" />. Consultez [Types au moment de l’exécution dans la réflexion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
ou 
 <paramref name="target" /> n'est pas un <see langword="RuntimeType" />.  
  
ou 
 <paramref name="target" /> est un type générique ouvert. Autrement dit, sa propriété <see cref="P:System.Type.ContainsGenericParameters" /> a la valeur <see langword="true" />.  
  
ou 
 <paramref name="method" /> n’est pas une méthode <see langword="static" /> (méthode <see langword="Shared" /> en Visual Basic).  
  
ou 
 <paramref name="method" /> ne peut pas être lié, ce qui peut arriver s’il est introuvable.</exception>
        <exception cref="T:System.MissingMethodException">La méthode <see langword="Invoke" /> de <paramref name="type" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de délégué à créer.</param>
        <param name="target">Instance de classe sur laquelle la méthode <paramref name="method" /> est appelée.</param>
        <param name="method">Nom de la méthode d’instance que doit représenter le délégué.</param>
        <param name="ignoreCase">Valeur booléenne indiquant si la casse doit être ignorée pendant la comparaison du nom de la méthode.</param>
        <param name="throwOnBindFailure"><see langword="true" /> pour lever une exception si <paramref name="method" /> ne peut pas être lié ; sinon, <see langword="false" />.</param>
        <summary>Crée un délégué du type spécifié qui représente la méthode d'instance spécifiée à appeler sur l'instance de classe spécifiée, avec le respect de la casse spécifié et le comportement spécifié en cas d'échec de la liaison.</summary>
        <returns>Délégué du type spécifié qui représente la méthode d'instance spécifiée à appeler sur l'instance de classe spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée des délégués par exemple uniquement des méthodes. Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="target" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> n’hérite pas de <see cref="T:System.MulticastDelegate" />.  
  
ou 
 <paramref name="type" /> n’est pas un <see langword="RuntimeType" />. Consultez [Types au moment de l’exécution dans la réflexion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
ou 
 <paramref name="method" /> n’est pas une méthode d’instance.  
  
ou 
 <paramref name="method" /> ne peut pas être lié, par exemple car elle est introuvable, et <paramref name="throwOnBindFailure" /> a la valeur <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">La méthode <see langword="Invoke" /> de <paramref name="type" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de délégué à créer.</param>
        <param name="target"><see cref="T:System.Type" /> représentant la classe qui implémente <paramref name="method" />.</param>
        <param name="method">Nom de la méthode statique que doit représenter le délégué.</param>
        <param name="ignoreCase">Valeur booléenne indiquant si la casse doit être ignorée pendant la comparaison du nom de la méthode.</param>
        <param name="throwOnBindFailure"><see langword="true" /> pour lever une exception si <paramref name="method" /> ne peut pas être lié ; sinon, <see langword="false" />.</param>
        <summary>Crée un délégué du type spécifié qui représente la méthode statique spécifiée de la classe spécifiée, avec le respect de la casse spécifié et le comportement spécifié en cas d'échec de la liaison.</summary>
        <returns>Délégué du type spécifié qui représente la méthode statique spécifiée de la classe spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée des délégués pour les méthodes statiques uniquement. Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="target" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> n’hérite pas de <see cref="T:System.MulticastDelegate" />.  
  
ou 
 <paramref name="type" /> n’est pas un <see langword="RuntimeType" />. Consultez [Types au moment de l’exécution dans la réflexion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
ou 
 <paramref name="target" /> n'est pas un <see langword="RuntimeType" />.  
  
ou 
 <paramref name="target" /> est un type générique ouvert. Autrement dit, sa propriété <see cref="P:System.Type.ContainsGenericParameters" /> a la valeur <see langword="true" />.  
  
ou 
 <paramref name="method" /> n’est pas une méthode <see langword="static" /> (méthode <see langword="Shared" /> en Visual Basic).  
  
ou 
 <paramref name="method" /> ne peut pas être lié, par exemple car elle est introuvable, et <paramref name="throwOnBindFailure" /> a la valeur <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">La méthode <see langword="Invoke" /> de <paramref name="type" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Tableau d'objets correspondant aux arguments à passer à la méthode représentée par le délégué en cours.  
  
ou 
 <see langword="null" />, si la méthode représentée par le délégué en cours ne requiert pas d'arguments.</param>
        <summary>Appelle de manière dynamique (à liaison tardive) la méthode représentée par le délégué en cours.</summary>
        <returns>Objet retourné par la méthode représentée par le délégué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle la méthode <xref:System.Delegate.DynamicInvokeImpl%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">L’appelant n’a pas accès à la méthode représentée par le délégué (par exemple, si la méthode est privée).  
  
ou 
Le nombre, l'ordre ou le type des paramètres répertoriés dans <paramref name="args" /> n'est pas valide.</exception>
        <exception cref="T:System.ArgumentException">La méthode représentée par le délégué est appelée sur un objet ou une classe qui ne la prend pas en charge.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">La méthode représentée par ce délégué est une méthode d'instance et l'objet cible est <see langword="null" />.  
  
ou 
L'une des méthodes encapsulées lève une exception.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="args">Tableau d'objets correspondant aux arguments à passer à la méthode représentée par le délégué en cours.  
  
ou 
 <see langword="null" />, si la méthode représentée par le délégué en cours ne requiert pas d'arguments.</param>
        <summary>Appelle de manière dynamique (à liaison tardive) la méthode représentée par le délégué en cours.</summary>
        <returns>Objet retourné par la méthode représentée par le délégué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode implémente la méthode <xref:System.Delegate.DynamicInvoke%2A> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">L’appelant n’a pas accès à la méthode représentée par le délégué (par exemple, si la méthode est privée).  
  
ou 
Le nombre, l'ordre ou le type des paramètres répertoriés dans <paramref name="args" /> n'est pas valide.</exception>
        <exception cref="T:System.ArgumentException">La méthode représentée par le délégué est appelée sur un objet ou une classe qui ne la prend pas en charge.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">La méthode représentée par ce délégué est une méthode d'instance et l'objet cible est <see langword="null" />.  
  
ou 
L'une des méthodes encapsulées lève une exception.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">L’objet à comparer avec le délégué actuel.</param>
        <summary>Détermine si l'objet spécifié et le délégué actuel sont du même type et partagent les mêmes cibles, méthodes et liste d'appel.</summary>
        <returns><see langword="true" /> si <paramref name="obj" /> et le délégué actuel ont les mêmes cibles, méthodes et liste d’appel ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les deux délégués ne sont pas du même type, ils ne sont pas considérés égaux.  
  
> [!IMPORTANT]
>  Dans la version 1.0 et 1.1 du .NET Framework, deux délégués ont été considérés comme égaux si leurs cibles, méthodes et liste d’appel sont égales, même si les délégués sont de types différents.  
  
 Les méthodes et les cibles sont comparées pour l’égalité, comme suit :  
  
-   Si les deux méthodes comparées toutes deux sont statiques et la même méthode sur la même classe, les méthodes sont considérées comme égales et les cibles sont également considérées comme égales.  
  
-   Si les deux méthodes comparés sont des méthodes d’instance et la même méthode sur le même objet, les méthodes sont considérées comme égales et les cibles sont également considérées comme égales.  
  
-   Sinon, les méthodes ne sont pas considérés comme égal et les cibles sont également pas considérées comme égales.  
  
 Deux listes d’appel sont considérés comme identiques uniquement si elles ont le même ordre et les éléments correspondants dans les deux listes représentent la même méthode et la cible.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">L’appelant n’a pas accès à la méthode représentée par le délégué (par exemple, si la méthode est privée).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un code de hachage pour le délégué.</summary>
        <returns>Code de hachage du délégué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de retour de cette méthode ne doit pas être persistante pour deux raisons. Tout d’abord, la fonction de hachage d’une classe peut être modifiée pour générer une meilleure distribution, toutes les valeurs à partir de l’ancienne fonction de hachage de rendu inutilisable. Deuxièmement, l’implémentation par défaut de cette classe ne garantit pas que la même valeur sera retournée par différentes instances.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la liste d'appel du délégué.</summary>
        <returns>Tableau de délégués représentant la liste d'appel du délégué actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque délégué dans le tableau représente exactement une méthode.  
  
 L’ordre des délégués dans le tableau est le même ordre que celui dans lequel le délégué actuel appelle les méthodes qui représentent ces délégués.  
  
   
  
## Examples  
 L’exemple suivant affecte les trois méthodes à un délégué. Il appelle ensuite la <xref:System.Delegate.GetInvocationList%2A> méthode pour obtenir le nombre total des méthodes assignée au délégué, d’exécuter les délégués dans l’ordre inverse et pour exécuter les méthodes dont le nom n’incluent pas la sous-chaîne « Fichier ».  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient la méthode statique représentée par le délégué en cours.</summary>
        <returns><see cref="T:System.Reflection.MethodInfo" /> décrivant la méthode statique représentée par le délégué en cours.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode s’applique uniquement si le délégué actuel représente une méthode statique.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">L’appelant n’a pas accès à la méthode représentée par le délégué (par exemple, si la méthode est privée).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Non pris en charge.</param>
        <param name="context">Non pris en charge.</param>
        <summary>Non pris en charge.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Cette méthode n'est pas prise en charge.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la méthode représentée par le délégué.</summary>
        <value><see cref="T:System.Reflection.MethodInfo" /> décrivant la méthode représentée par le délégué.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">L’appelant n’a pas accès à la méthode représentée par le délégué (par exemple, si la méthode est privée).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Premier délégué à comparer.</param>
        <param name="d2">Second délégué à comparer.</param>
        <summary>Détermine si les délégués spécifiés sont égaux.</summary>
        <returns><see langword="true" /> si <paramref name="d1" /> est égal à <paramref name="d2" /> ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deux délégués du même type avec les mêmes cibles, les méthodes et les listes d’appel sont considérées comme égales.  
  
 Si les deux délégués ne sont pas du même type, ils ne sont pas considérés égaux.  
  
> [!IMPORTANT]
>  Dans la version 1.0 et 1.1 du .NET Framework, deux délégués ont été considérés comme égaux si leurs cibles, méthodes et liste d’appel sont égales, même si les délégués sont de types différents.  
  
 Les méthodes et les cibles sont comparées pour l’égalité, comme suit :  
  
-   Si les deux méthodes comparées toutes deux sont statiques et la même méthode sur la même classe, les méthodes sont considérées comme égales et les cibles sont également considérées comme égales.  
  
-   Si les deux méthodes comparés sont des méthodes d’instance et la même méthode sur le même objet, les méthodes sont considérées comme égales et les cibles sont également considérées comme égales.  
  
-   Sinon, les méthodes ne sont pas considérés comme égal et les cibles sont également pas considérées comme égales.  
  
 Deux listes d’appel sont considérés comme identiques si elles ont le même ordre et les éléments correspondants dans les deux listes représentent la même méthode et la cible.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Premier délégué à comparer.</param>
        <param name="d2">Second délégué à comparer.</param>
        <summary>Détermine si les délégués spécifiés ne sont pas égaux.</summary>
        <returns><see langword="true" /> si <paramref name="d1" /> n'est pas égal à <paramref name="d2" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deux délégués ne sont pas considérés égaux s’ils sont de types différents, ou ont différentes méthodes, les différentes cibles ou les listes d’appel.  
  
 Si les deux délégués ne sont pas du même type, ils ne sont pas considérés égaux.  
  
> [!IMPORTANT]
>  Dans la version 1.0 et 1.1 du .NET Framework, deux délégués sont considérés comme égaux si leurs cibles, méthodes et liste d’appel sont égales, même si les délégués sont de types différents.  
  
 Les méthodes et les cibles sont comparées pour l’égalité, comme suit :  
  
-   Si les deux méthodes comparées toutes deux sont statiques et la même méthode sur la même classe, les méthodes sont considérées comme égales et les cibles sont également considérées comme égales.  
  
-   Si les deux méthodes comparés sont des méthodes d’instance et la même méthode sur le même objet, les méthodes sont considérées comme égales et les cibles sont également considérées comme égales.  
  
-   Sinon, les méthodes ne sont pas considérés comme égal et les cibles sont également pas considérées comme égales.  
  
 Deux listes d’appel ne sont pas égaux s’ils ont différentes tailles, si elles sont organisées différemment, ou si au moins un élément d’une liste représente une méthode ou une cible qui est différente de celle représentée par l’élément correspondant dans la liste des autres.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Délégué dans lequel supprimer la liste d'appel de <paramref name="value" />.</param>
        <param name="value">Délégué qui fournit la liste d'appel à supprimer de la liste d'appel de <paramref name="source" />.</param>
        <summary>Supprime la dernière occurrence de la liste d'appel d'un délégué de la liste d'appel d'un autre délégué.</summary>
        <returns>Nouveau délégué avec une liste d'appel générée à partir de la liste d'appel de <paramref name="source" /> de laquelle est supprimée la dernière occurrence de la liste d'appel de <paramref name="value" />, si la liste d'appel de <paramref name="value" /> figure dans la liste d'appel de <paramref name="source" />. Retourne <paramref name="source" />, si <paramref name="value" /> est <see langword="null" />, ou si la liste d'appel de <paramref name="value" /> ne figure pas dans la liste d'appel de <paramref name="source" />. Retourne une référence null si la liste d'appel de <paramref name="value" /> est égale à la liste d'appel de <paramref name="source" />, ou si <paramref name="source" /> est une référence null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la liste d’appel `value` correspond à un ensemble contigu d’éléments dans la liste d’appel `source`, puis la liste d’appel `value` apparaît dans la liste d’appel de `source`. Si la liste d’appel `value` apparaît plusieurs fois dans la liste d’appel `source`, la dernière occurrence est supprimée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">L’appelant n’a pas accès à la méthode représentée par le délégué (par exemple, si la méthode est privée).</exception>
        <exception cref="T:System.ArgumentException">Les types délégués ne correspondent pas.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Délégué dans lequel supprimer la liste d'appel de <paramref name="value" />.</param>
        <param name="value">Délégué qui fournit la liste d'appel à supprimer de la liste d'appel de <paramref name="source" />.</param>
        <summary>Supprime toutes les occurrences de la liste d'appel d'un délégué de la liste d'appel d'un autre délégué.</summary>
        <returns>Nouveau délégué avec une liste d'appel générée à partir de la liste d'appel de <paramref name="source" /> de laquelle est supprimée toutes les occurrences de la liste d'appel de <paramref name="value" />, si la liste d'appel de <paramref name="value" /> figure dans la liste d'appel de <paramref name="source" />. Retourne <paramref name="source" />, si <paramref name="value" /> est <see langword="null" />, ou si la liste d'appel de <paramref name="value" /> ne figure pas dans la liste d'appel de <paramref name="source" />. Retourne une référence null si la liste d'appel de <paramref name="value" /> est égale à la liste d'appel de <paramref name="source" />, si <paramref name="source" /> contient uniquement une série de listes d'appel égales à la liste d'appel de <paramref name="value" />, ou si <paramref name="source" /> est une référence null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la liste d’appel `value` correspond à un ensemble contigu d’éléments dans la liste d’appel `source`, puis la liste d’appel `value` apparaît dans la liste d’appel de `source`. Si la liste d’appel `value` apparaît plusieurs fois dans la liste d’appel `source`, toutes les occurrences sont supprimées.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">L’appelant n’a pas accès à la méthode représentée par le délégué (par exemple, si la méthode est privée).</exception>
        <exception cref="T:System.ArgumentException">Les types délégués ne correspondent pas.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">Délégué fournissant la liste d'appel à supprimer de la liste d'appel du délégué en cours.</param>
        <summary>Supprime la liste d'appel d'un délégué de la liste d'appel d'un autre délégué.</summary>
        <returns>Nouveau délégué dont la liste d'appel est générée à partir de la liste d'appel du délégué en cours, de laquelle est supprimée la liste d'appel de <paramref name="value" />, si la liste d'appel de <paramref name="value" /> figure dans la liste d'appel du délégué en cours. Retourne le délégué en cours, si <paramref name="value" /> est <see langword="null" />, ou si la liste d'appel de <paramref name="value" /> ne figure pas dans la liste d'appel du délégué en cours. Retourne <see langword="null" /> si la liste d'appel de <paramref name="value" /> est égale à la liste d'appel du délégué en cours.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la liste d’appel `value` correspond à un ensemble contigu d’éléments dans la liste d’appel du délégué en cours, puis la liste d’appel `value` est considéré comme se produisent dans la liste d’appel du délégué en cours. Si la liste d’appel `value` se produit plusieurs fois dans la liste d’appel du délégué en cours, la dernière occurrence est supprimée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">L’appelant n’a pas accès à la méthode représentée par le délégué (par exemple, si la méthode est privée).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'instance de classe sur laquelle le délégué en cours appelle la méthode d'instance.</summary>
        <value>Objet sur lequel le délégué en cours appelle la méthode d'instance, si le délégué représente une méthode d'instance ; <see langword="null" /> si le délégué représente une méthode statique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.  
  
 Si le délégué appelle une ou plusieurs méthodes d’instance, cette propriété retourne la cible de la dernière méthode d’instance dans la liste d’appel.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>