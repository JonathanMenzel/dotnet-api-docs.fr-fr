<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Delegate.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac53f0536eac77f3171e3a7eeb74486cfcf863ec3d8.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3f0536eac77f3171e3a7eeb74486cfcf863ec3d8</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Delegate">
          <source>Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</source>
          <target state="translated">Représente un délégué, qui est une structure de données faisant référence à une méthode statique ou une instance de classe et à une méthode d'instance de cette classe.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class is the base class for delegate types.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> est la classe de base pour les types délégués.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>However, only the system and compilers can derive explicitly from the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class or from the <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph> class.</source>
          <target state="translated">Toutefois, seul le système et les compilateurs peuvent dériver explicitement de la <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> classe ou à partir de la <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>It is also not permissible to derive a new type from a delegate type.</source>
          <target state="translated">Il est également possible de dériver un nouveau type à partir d’un type délégué.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class is not considered a delegate type; it is a class used to derive delegate types.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> classe n’est pas considéré comme un type délégué ; il s’agit d’une classe utilisée pour dériver des types délégués.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Most languages implement a <ph id="ph1">`delegate`</ph> keyword, and compilers for those languages are able to derive from the <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph> class; therefore, users should use the <ph id="ph3">`delegate`</ph> keyword provided by the language.</source>
          <target state="translated">La plupart des langages implémentent un <ph id="ph1">`delegate`</ph> mots clés et les compilateurs pour ces langues sont en mesure de dériver à partir de la <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph> classe ; par conséquent, les utilisateurs doivent utiliser le <ph id="ph3">`delegate`</ph> mot clé fourni par le langage.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The common language runtime provides an <ph id="ph1">`Invoke`</ph> method for each delegate type, with the same signature as the delegate.</source>
          <target state="translated">Le common language runtime fournit un <ph id="ph1">`Invoke`</ph> méthode pour chaque type de délégué, avec la même signature que le délégué.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>You do not have to call this method explicitly from C#, Visual Basic, or Visual C++, because the compilers call it automatically.</source>
          <target state="translated">Il est inutile d’appeler cette méthode explicitement à partir de c#, Visual Basic ou Visual C++, car les compilateurs appellent automatiquement.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The <ph id="ph1">`Invoke`</ph> method is useful in <bpt id="p1">[</bpt>reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/reflection.md)</ept> when you want to find the signature of the delegate type.</source>
          <target state="translated">Le <ph id="ph1">`Invoke`</ph> méthode est utile dans les <bpt id="p1">[</bpt>réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/reflection.md)</ept> lorsque vous souhaitez trouver la signature du type délégué.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The common language runtime provides each delegate type with <ph id="ph1">`BeginInvoke`</ph> and <ph id="ph2">`EndInvoke`</ph> methods, to enable asynchronous invocation of the delegate.</source>
          <target state="translated">Le common language runtime fournit chaque type délégué avec <ph id="ph1">`BeginInvoke`</ph> et <ph id="ph2">`EndInvoke`</ph> méthodes, pour permettre un appel asynchrone du délégué.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>For more information about these methods, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur ces méthodes, consultez <bpt id="p1">[</bpt>appel asynchrone des méthodes synchrones<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The declaration of a delegate type establishes a contract that specifies the signature of one or more methods.</source>
          <target state="translated">La déclaration d’un type délégué établit un contrat qui spécifie la signature d’une ou plusieurs méthodes.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A delegate is an instance of a delegate type that has references to:</source>
          <target state="translated">Un délégué est une instance d’un type délégué qui comporte des références à :</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>An instance method of a type and a target object assignable to that type.</source>
          <target state="translated">Une méthode d’instance d’un type et un objet cible pouvant être assigné à ce type.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>An instance method of a type, with the hidden <ph id="ph1">`this`</ph> parameter exposed in the formal parameter list.</source>
          <target state="translated">Une méthode d’instance d’un type, avec le texte masqué <ph id="ph1">`this`</ph> paramètre exposée dans la liste de paramètres formels.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The delegate is said to be an open instance delegate.</source>
          <target state="translated">Le délégué est dit d’un délégué d’instance ouverte.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A static method.</source>
          <target state="translated">Une méthode statique.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A static method and a target object assignable to the first parameter of the method.</source>
          <target state="translated">Une méthode statique et un objet cible pouvant être assigné au premier paramètre de la méthode.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The delegate is said to be closed over its first argument.</source>
          <target state="translated">Le délégué est dit fermé sur son premier argument.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>For more information on delegate binding, see the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations sur la liaison de délégués, consultez la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>In the .NET Framework versions 1.0 and 1.1, a delegate can represent a method only if the signature of the method exactly matches the signature specified by the delegate type.</source>
          <target state="translated">Dans les versions 1.0 et 1.1 du .NET Framework, un délégué peut représenter une méthode uniquement si la signature de la méthode correspond exactement à la signature spécifiée par le type délégué.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Thus, only the first and third bullets in the preceding list are supported, and the first bullet requires an exact type match.</source>
          <target state="translated">Par conséquent, uniquement les première et troisième puces dans la liste précédente sont prises en charge, et la première puce requiert une correspondance de type exact.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When a delegate represents an instance method closed over its first argument (the most common case), the delegate stores a reference to the method's entry point and a reference to an object, called the target, which is of a type assignable to the type that defined the method.</source>
          <target state="translated">Lorsqu’un délégué représente une méthode d’instance fermée sur son premier argument (le cas le plus courant), le délégué stocke une référence à un point d’entrée de la méthode et une référence à un objet, appelée la cible, qui est d’un type assignable au type défini par le méthode.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When a delegate represents an open instance method, it stores a reference to the method's entry point.</source>
          <target state="translated">Lorsqu’un délégué représente une méthode d’instance ouverte, il stocke une référence à un point d’entrée de la méthode.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The delegate signature must include the hidden <ph id="ph1">`this`</ph> parameter in its formal parameter list; in this case, the delegate does not have a reference to a target object, and a target object must be supplied when the delegate is invoked.</source>
          <target state="translated">La signature du délégué doit inclure le texte masqué <ph id="ph1">`this`</ph> paramètre dans sa liste de paramètres formels ; dans ce cas, le délégué n’a pas une référence à un objet cible, et un objet cible doit être fourni lorsque le délégué est appelé.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When a delegate represents a static method, the delegate stores a reference to the method's entry point.</source>
          <target state="translated">Lorsqu’un délégué représente une méthode statique, le délégué stocke une référence à un point d’entrée de la méthode.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When a delegate represents a static method closed over its first argument, the delegate stores a reference to the method's entry point and a reference to a target object assignable to the type of the method's first argument.</source>
          <target state="translated">Lorsqu’un délégué représente une méthode statique fermée sur son premier argument, le délégué stocke une référence à un point d’entrée de la méthode et une référence à un objet cible peut être assigné au type du premier argument de la méthode.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When the delegate is invoked, the first argument of the static method receives the target object.</source>
          <target state="translated">Lorsque le délégué est appelé, le premier argument de la méthode statique reçoit l’objet cible.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The invocation list of a delegate is an ordered set of delegates in which each element of the list invokes exactly one of the methods represented by the delegate.</source>
          <target state="translated">La liste d’appel d’un délégué est un ensemble ordonné de délégués dont chaque élément de la liste appelle exactement une des méthodes représentées par le délégué.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>An invocation list can contain duplicate methods.</source>
          <target state="translated">Une liste d’appel peut contenir des méthodes dupliquées.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>During an invocation, methods are invoked in the order in which they appear in the invocation list.</source>
          <target state="translated">Lors d’un appel, les méthodes sont appelées dans l’ordre dans lequel elles apparaissent dans la liste d’appel.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A delegate attempts to invoke every method in its invocation list; duplicates are invoked once for each time they appear in the invocation list.</source>
          <target state="translated">Un délégué tente d’appeler chaque méthode dans sa liste d’appel ; les doublons sont appelées une fois pour chaque fois qu’ils apparaissent dans la liste d’appel.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Delegates are immutable; once created, the invocation list of a delegate does not change.</source>
          <target state="translated">Les délégués sont immuables ; une fois créé, la liste d’appel d’un délégué ne modifie pas.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Delegates are referred to as multicast, or combinable, because a delegate can invoke one or more methods and can be used in combining operations.</source>
          <target state="translated">Les délégués sont désignées comme multidiffusion ou combinable, car un délégué peut appeler une ou plusieurs méthodes et peut être utilisé dans la combinaison d’opérations.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Combining operations, such as <ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph>, do not alter existing delegates.</source>
          <target state="translated">Opérations d’association, tel que <ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph>, ne modifiez pas les délégués existants.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Instead, such an operation returns a new delegate that contains the results of the operation, an unchanged delegate, or <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Au lieu de cela, une telle opération retourne un nouveau délégué qui contient les résultats de l’opération, un délégué inchangé ou <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A combining operation returns <ph id="ph1">`null`</ph> when the result of the operation is a delegate that does not reference at least one method.</source>
          <target state="translated">Une opération d’association retourne <ph id="ph1">`null`</ph> lorsque le résultat de l’opération est un délégué qui ne référence pas au moins une méthode.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A combining operation returns an unchanged delegate when the requested operation has no effect.</source>
          <target state="translated">Une opération d’association retourne un délégué inchangé lorsque l’opération demandée n’a aucun effet.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Managed languages use the <ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph> methods to implement delegate operations.</source>
          <target state="translated">Les langages managés utilisent le <ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph> méthodes à implémenter des opérations de délégué.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Examples include the <ph id="ph1">`AddHandler`</ph> and <ph id="ph2">`RemoveHandler`</ph> statements in Visual Basic and the += and -= operators on delegate types in C#.</source>
          <target state="translated">Exemples incluent la <ph id="ph1">`AddHandler`</ph> et <ph id="ph2">`RemoveHandler`</ph> instructions dans Visual Basic et les opérateurs += et -= sur les types délégués en c#.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, generic delegate types can have variant type parameters.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, les types délégués génériques peuvent avoir des paramètres de type variant.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Contravariant type parameters can be used as parameter types of the delegate, and a covariant type parameter can be used as the return type.</source>
          <target state="translated">Paramètres de type contravariant peuvent être utilisés en tant que types de paramètre du délégué et un paramètre de type covariant peut être utilisé comme type de retour.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>This feature allows generic delegate types that are constructed from the same generic type definition to be assignment-compatible if their type arguments are reference types with an inheritance relationship, as explained in <bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>.</source>
          <target state="translated">Cette fonctionnalité autorise les types qui sont construits à partir de la même définition de type générique pour être compatibles-assignation si leurs arguments de type sont des types référence avec une relation d’héritage, comme expliqué dans délégués génériques <bpt id="p1">[</bpt>Covariance et La contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</source>
          <target state="translated">Délégués génériques qui sont compatibles-assignation en raison de la variance ne sont pas nécessairement combinable.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>To be combinable, the types must match exactly.</source>
          <target state="translated">Pour pouvoir être associés, les types doivent correspondre exactement.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>For example, suppose that a class named <ph id="ph1">`Derived`</ph> is derived from a class named <ph id="ph2">`Base`</ph>.</source>
          <target state="translated">Par exemple, prenons une classe nommée <ph id="ph1">`Derived`</ph> est dérivée d’une classe nommée <ph id="ph2">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A delegate of type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) can be assigned to a variable of type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, but the two delegates cannot be combined because the types do not match exactly.</source>
          <target state="translated">Un délégué du type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> en Visual Basic) peut être assigné à une variable de type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, mais les deux délégués ne peuvent pas être combinés, car les types ne correspondent pas exactement.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>If an invoked method throws an exception, the method stops executing, the exception is passed back to the caller of the delegate, and remaining methods in the invocation list are not invoked.</source>
          <target state="translated">Si une méthode appelée lève une exception, la méthode arrête l’exécution de l’exception est passée à l’appelant du délégué et autres méthodes dans la liste d’appel ne sont pas appelés.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Catching the exception in the caller does not alter this behavior.</source>
          <target state="translated">Intercepter l’exception dans l’appelant ne modifie pas ce comportement.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When the signature of the methods invoked by a delegate includes a return value, the delegate returns the return value of the last element in the invocation list.</source>
          <target state="translated">Lorsque la signature des méthodes appelées par un délégué contient une valeur de retour, le délégué retourne la valeur de retour du dernier élément dans la liste d’appel.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When the signature includes a parameter that is passed by reference, the final value of the parameter is the result of every method in the invocation list executing sequentially and updating the parameter's value.</source>
          <target state="translated">Lorsque la signature inclut un paramètre qui est passé par référence, la valeur finale du paramètre est le résultat de chaque méthode dans la liste d’appel l’exécution de manière séquentielle et de mise à jour de la valeur du paramètre.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The closest equivalent of a delegate in C or C++ is a function pointer.</source>
          <target state="translated">L’équivalent le plus proche d’un délégué en C ou C++ est un pointeur de fonction.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A delegate can represent a static method or an instance method.</source>
          <target state="translated">Un délégué peut représenter une méthode statique ou une méthode d’instance.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When the delegate represents an instance method, the delegate stores not only a reference to the method's entry point, but also a reference to the class instance.</source>
          <target state="translated">Lorsque le délégué représente une méthode d’instance, le délégué stocke non seulement une référence au point d’entrée de la méthode, mais également une référence à l’instance de classe.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Unlike function pointers, delegates are object oriented and type safe.</source>
          <target state="translated">Contrairement aux pointeurs de fonction, les délégués sont orientés objet et de type sécurisés.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The following example shows how to define a delegate named <ph id="ph1">`myMethodDelegate`</ph>.</source>
          <target state="translated">L’exemple suivant montre comment définir un délégué nommé <ph id="ph1">`myMethodDelegate`</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Instances of this delegate are created for an instance method and a static method of the nested <ph id="ph1">`mySampleClass`</ph> class.</source>
          <target state="translated">Instances de ce délégué sont créées pour une méthode d’instance et une méthode statique de l’imbriquée <ph id="ph1">`mySampleClass`</ph> classe.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The delegate for the instance method requires an instance of <ph id="ph1">`mySampleClass`</ph>.</source>
          <target state="translated">Le délégué de la méthode d’instance requiert une instance de <ph id="ph1">`mySampleClass`</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The <ph id="ph1">`mySampleClass`</ph> instance is saved in a variable named <ph id="ph2">`mySC`</ph>.</source>
          <target state="translated">Le <ph id="ph1">`mySampleClass`</ph> instance est enregistrée dans une variable nommée <ph id="ph2">`mySC`</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="T:System.Delegate">
          <source>Initializes a new delegate.</source>
          <target state="translated">Initialise un nouveau délégué.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>The class instance on which the delegate invokes <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Instance de classe sur laquelle le délégué appelle <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>The name of the instance method that the delegate represents.</source>
          <target state="translated">Nom de la méthode d'instance représentée par le délégué.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>Initializes a delegate that invokes the specified instance method on the specified class instance.</source>
          <target state="translated">Initialise un délégué qui appelle la méthode d'instance spécifiée sur l'instance de classe spécifiée.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>This constructor cannot be used in application code.</source>
          <target state="translated">Ce constructeur ne peut pas être utilisé dans le code d’application.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>To create a delegate by specifying the name of an instance method, use an overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specifies a method name and a target object.</source>
          <target state="translated">Pour créer un délégué en spécifiant le nom d’une méthode d’instance, utilisez une surcharge de la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> méthode qui spécifie un nom de méthode et un objet cible.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29&gt;</ph> method overload creates a delegate for an instance method with a specified name.</source>
          <target state="translated">Par exemple, le <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29&gt;</ph> surcharge de méthode crée un délégué pour une méthode d’instance avec un nom spécifié.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>This constructor creates delegates for instance methods only.</source>
          <target state="translated">Ce constructeur crée des délégués pour l’instance des méthodes uniquement.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>There was an error binding to the target method.</source>
          <target state="translated">Une erreur s'est produite lors de la liaison à la méthode cible.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the class that defines <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> représentant la classe qui définit <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>The name of the static method that the delegate represents.</source>
          <target state="translated">Nom de la méthode statique représentée par le délégué.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>Initializes a delegate that invokes the specified static method from the specified class.</source>
          <target state="translated">Initialise un délégué qui appelle la méthode statique spécifiée à partir de la classe spécifiée.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>This constructor cannot be used in application code.</source>
          <target state="translated">Ce constructeur ne peut pas être utilisé dans le code d’application.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>To create a delegate by specifying the name of a static method, use an overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specifies a method name but does not specify a target object.</source>
          <target state="translated">Pour créer un délégué en spécifiant le nom d’une méthode statique, utilisez une surcharge de la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> méthode qui spécifie un nom de méthode, mais ne spécifie pas un objet cible.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29&gt;</ph> method overload creates a static delegate for a method with a specified name.</source>
          <target state="translated">Par exemple, le <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29&gt;</ph> surcharge de méthode crée un délégué statique pour une méthode avec un nom spécifié.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>This constructor creates delegates for static methods only.</source>
          <target state="translated">Ce constructeur crée des délégués pour les méthodes statiques uniquement.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Types au moment de l’exécution dans la réflexion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> represents an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> représente un type générique ouvert.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Delegate.Clone">
          <source>Creates a shallow copy of the delegate.</source>
          <target state="translated">Crée une copie superficielle du délégué.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Delegate.Clone">
          <source>A shallow copy of the delegate.</source>
          <target state="translated">Copie superficielle du délégué.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>The clone has the same <ph id="ph1">&lt;xref:System.Type&gt;</ph>, target, method, and invocation list as the original delegate.</source>
          <target state="translated">Le clone a les mêmes <ph id="ph1">&lt;xref:System.Type&gt;</ph>, cible, méthode et liste d’appel que le délégué d’origine.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>A shallow copy creates a new instance of the same type as the original object, and then copies the nonstatic fields of the original object.</source>
          <target state="translated">Une copie superficielle crée une nouvelle instance du même type que l’objet d’origine, puis copie les champs non statiques de l’objet d’origine.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>If the field is a value type, a bit-by-bit copy of the field is performed.</source>
          <target state="translated">Si le champ est un type valeur, une copie bit par bit du champ est effectuée.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>If the field is a reference type, the reference is copied but the referred object is not; therefore, the reference in the original object and the reference in the clone point to the same object.</source>
          <target state="translated">Si le champ est un type référence, la référence est copiée, mais l’objet référencé n’est pas. Par conséquent, la référence de l’objet d’origine et la référence dans le clone pointent vers le même objet.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>In contrast, a deep copy of an object duplicates everything directly or indirectly referenced by the fields in the object.</source>
          <target state="translated">En revanche, une copie complète d’un objet duplique tous les éléments référencés directement ou indirectement par les champs dans l’objet.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="T:System.Delegate">
          <source>Concatenates the invocation lists of the specified multicast (combinable) delegates.</source>
          <target state="translated">Concatène les listes d'appel des délégués multicast (pouvant être combinés) spécifiés.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>The array of delegates to combine.</source>
          <target state="translated">Tableau de délégués à combiner.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Concatenates the invocation lists of an array of delegates.</source>
          <target state="translated">Concatène les listes d'appel d'un tableau de délégués.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <ph id="ph1">&lt;paramref name="delegates" /&gt;</ph> array.</source>
          <target state="translated">Nouveau délégué avec une liste d’invocation qui concatène les listes d’invocation des délégués dans le tableau <ph id="ph1">&lt;paramref name="delegates" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Returns <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="delegates" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, if <ph id="ph4">&lt;paramref name="delegates" /&gt;</ph> contains zero elements, or if every entry in <ph id="ph5">&lt;paramref name="delegates" /&gt;</ph> is <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Retourne <ph id="ph1">&lt;see langword="null" /&gt;</ph> si <ph id="ph2">&lt;paramref name="delegates" /&gt;</ph> est <ph id="ph3">&lt;see langword="null" /&gt;</ph>, si <ph id="ph4">&lt;paramref name="delegates" /&gt;</ph> contient zéro élément ou si chaque entrée de <ph id="ph5">&lt;paramref name="delegates" /&gt;</ph> est <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>If the <ph id="ph1">`delegates`</ph> array contains entries that are <ph id="ph2">`null`</ph>, those entries are ignored.</source>
          <target state="translated">Si le <ph id="ph1">`delegates`</ph> tableau contient des entrées qui sont <ph id="ph2">`null`</ph>, ces entrées sont ignorées.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</source>
          <target state="translated">La liste d’appel peut contenir des entrées en double ; Autrement dit, les entrées qui font référence à la même méthode sur le même objet.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</source>
          <target state="translated">Délégués génériques qui sont compatibles-assignation en raison de la variance ne sont pas nécessairement combinable.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>To be combinable, the types must match exactly.</source>
          <target state="translated">Pour pouvoir être associés, les types doivent correspondre exactement.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>For example, suppose that a class named <ph id="ph1">`Derived`</ph> is derived from a class named <ph id="ph2">`Base`</ph>.</source>
          <target state="translated">Par exemple, prenons une classe nommée <ph id="ph1">`Derived`</ph> est dérivée d’une classe nommée <ph id="ph2">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>A delegate of type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) can be assigned to a variable of type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, as explained in <bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>, but the two delegates cannot be combined because the types do not match exactly.</source>
          <target state="translated">Un délégué du type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> en Visual Basic) peut être assigné à une variable de type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, comme expliqué dans <bpt id="p1">[</bpt>Covariance et Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>, mais les deux délégués ne peuvent pas être combinés, car les types ne sont pas correspondre exactement.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> is useful for creating event handlers that call multiple methods each time an event occurs.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> est utile pour créer des gestionnaires d’événements qui appellent que plusieurs méthodes chaque fois qu’un événement se produit.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Not all the non-null entries in <ph id="ph1">&lt;paramref name="delegates" /&gt;</ph> are instances of the same delegate type.</source>
          <target state="translated">Les entrées non null dans <ph id="ph1">&lt;paramref name="delegates" /&gt;</ph> ne sont pas toutes des instances du même type de délégué.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>The delegate whose invocation list comes first.</source>
          <target state="translated">Délégué dont la liste d’appel est la première.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>The delegate whose invocation list comes last.</source>
          <target state="translated">Délégué dont la liste d’appel est la dernière.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Concatenates the invocation lists of two delegates.</source>
          <target state="translated">Concatène les listes d'appel de deux délégués.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>A new delegate with an invocation list that concatenates the invocation lists of <ph id="ph1">&lt;paramref name="a" /&gt;</ph> and <ph id="ph2">&lt;paramref name="b" /&gt;</ph> in that order.</source>
          <target state="translated">Nouveau délégué avec une liste d’appel qui concatène les listes d’appel de <ph id="ph1">&lt;paramref name="a" /&gt;</ph> et <ph id="ph2">&lt;paramref name="b" /&gt;</ph>, dans cet ordre.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Returns <ph id="ph1">&lt;paramref name="a" /&gt;</ph> if <ph id="ph2">&lt;paramref name="b" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, returns <ph id="ph4">&lt;paramref name="b" /&gt;</ph> if <ph id="ph5">&lt;paramref name="a" /&gt;</ph> is a null reference, and returns a null reference if both <ph id="ph6">&lt;paramref name="a" /&gt;</ph> and <ph id="ph7">&lt;paramref name="b" /&gt;</ph> are null references.</source>
          <target state="translated">Retourne <ph id="ph1">&lt;paramref name="a" /&gt;</ph> si <ph id="ph2">&lt;paramref name="b" /&gt;</ph> est <ph id="ph3">&lt;see langword="null" /&gt;</ph>, retourne <ph id="ph4">&lt;paramref name="b" /&gt;</ph> si <ph id="ph5">&lt;paramref name="a" /&gt;</ph> est une référence null, et retourne une référence null si <ph id="ph6">&lt;paramref name="a" /&gt;</ph> et <ph id="ph7">&lt;paramref name="b" /&gt;</ph> sont des références null.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</source>
          <target state="translated">La liste d’appel peut contenir des entrées en double ; Autrement dit, les entrées qui font référence à la même méthode sur le même objet.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</source>
          <target state="translated">Délégués génériques qui sont compatibles-assignation en raison de la variance ne sont pas nécessairement combinable.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>To be combinable, the types must match exactly.</source>
          <target state="translated">Pour pouvoir être associés, les types doivent correspondre exactement.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>For example, suppose that a class named <ph id="ph1">`Derived`</ph> is derived from a class named <ph id="ph2">`Base`</ph>.</source>
          <target state="translated">Par exemple, prenons une classe nommée <ph id="ph1">`Derived`</ph> est dérivée d’une classe nommée <ph id="ph2">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>A delegate of type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) can be assigned to a variable of type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, as explained in <bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>, but the two delegates cannot be combined because the types do not match exactly.</source>
          <target state="translated">Un délégué du type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> en Visual Basic) peut être assigné à une variable de type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, comme expliqué dans <bpt id="p1">[</bpt>Covariance et Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>, mais les deux délégués ne peuvent pas être combinés, car les types ne sont pas correspondre exactement.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> is useful for creating event handlers that call multiple methods each time an event occurs.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> est utile pour créer des gestionnaires d’événements qui appellent que plusieurs méthodes chaque fois qu’un événement se produit.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Both <ph id="ph1">&lt;paramref name="a" /&gt;</ph> and <ph id="ph2">&lt;paramref name="b" /&gt;</ph> are not <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="a" /&gt;</ph> and <ph id="ph5">&lt;paramref name="b" /&gt;</ph> are not instances of the same delegate type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="a" /&gt;</ph> et <ph id="ph2">&lt;paramref name="b" /&gt;</ph> ne sont ni l’un ni l’autre <ph id="ph3">&lt;see langword="null" /&gt;</ph>, et <ph id="ph4">&lt;paramref name="a" /&gt;</ph> et <ph id="ph5">&lt;paramref name="b" /&gt;</ph> ne sont pas des instances du même type délégué.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>The multicast (combinable) delegate whose invocation list to append to the end of the invocation list of the current multicast (combinable) delegate.</source>
          <target state="translated">Délégué multicast (pouvant être combiné) dont la liste d'appel doit être ajoutée à la fin de la liste d'appel du délégué multicast (pouvant être combiné) en cours.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>Concatenates the invocation lists of the specified multicast (combinable) delegate and the current multicast (combinable) delegate.</source>
          <target state="translated">Concatène les listes d'appel du délégué multicast (pouvant être combiné) spécifié et du délégué multicast (pouvant être combiné) actuel.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>A new multicast (combinable) delegate with an invocation list that concatenates the invocation list of the current multicast (combinable) delegate and the invocation list of <ph id="ph1">&lt;paramref name="d" /&gt;</ph>, or the current multicast (combinable) delegate if <ph id="ph2">&lt;paramref name="d" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Nouveau délégué multicast (pouvant être combiné) avec une liste d'appel qui concatène les listes d'appel du délégué multicast (pouvant être combiné) en cours et de <ph id="ph1">&lt;paramref name="d" /&gt;</ph>, ou délégué multicast (pouvant être combiné) en cours si <ph id="ph2">&lt;paramref name="d" /&gt;</ph> est <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>This method applies only if the current delegate is multicast (combinable).</source>
          <target state="translated">Cette méthode s’applique uniquement si le délégué actuel est multicast (pouvant être combiné).</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>The current implementation simply throws a <ph id="ph1">&lt;xref:System.MulticastNotSupportedException&gt;</ph>.</source>
          <target state="translated">L’implémentation actuelle lève simplement une <ph id="ph1">&lt;xref:System.MulticastNotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</source>
          <target state="translated">La liste d’appel peut contenir des entrées en double ; Autrement dit, les entrées qui font référence à la même méthode sur le même objet.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>Always thrown.</source>
          <target state="translated">Toujours levée.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="T:System.Delegate">
          <source>Creates a delegate of the specified type.</source>
          <target state="translated">Crée un délégué du type spécifié.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de délégué à créer.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static or instance method the delegate is to represent.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> décrivant la méthode statique ou d’instance que le délégué doit représenter.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Only static methods are supported in the .NET Framework version 1.0 and 1.1.</source>
          <target state="translated">Seules les méthodes statiques sont prises en charge dans les versions 1.0 et 1.1 du .NET Framework.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Creates a delegate of the specified type to represent the specified static method.</source>
          <target state="translated">Crée un délégué du type spécifié pour représenter la méthode statique spécifiée.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A delegate of the specified type to represent the specified static method.</source>
          <target state="translated">Délégué du type spécifié pour représenter la méthode statique spécifiée.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>In the .NET Framework version 1.0 and 1.1, this method overload creates delegates for static methods only.</source>
          <target state="translated">Dans la version 1.0 et 1.1 du .NET Framework, cette surcharge de méthode crée des délégués pour les méthodes statiques uniquement.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>In the .NET Framework version 2.0, this method overload also can create open instance method delegates; that is, delegates that explicitly supply the hidden first argument of instance methods.</source>
          <target state="translated">Dans le .NET Framework version 2.0, cette surcharge de méthode peut également créer une instance ouverte délégués de la méthode ; Autrement dit, les délégués qui fournissent explicitement le premier argument masqué des méthodes d’instance.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>For a detailed explanation, see the more general <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods, and optionally to specify a first argument.</source>
          <target state="translated">Pour une explication détaillée, consultez la plus générale <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph> surcharge de méthode, ce qui vous permet de créer toutes les combinaisons de délégués ouverts ou fermés pour les méthodes d’instance ou statiques et éventuellement pour spécifier un premier argument.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</source>
          <target state="translated">Cette surcharge de méthode doit être utilisée lorsque le délégué n’est pas fermé sur son premier argument, car il est un peu plus rapide dans ce cas.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
          <target state="translated">Cette surcharge de méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> surcharge de méthode et en spécifiant <ph id="ph2">`true`</ph> pour <ph id="ph3">`throwOnBindFailure`</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>considérations de sécurité pour la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Compatible Parameter Types and Return Type</source>
          <target state="translated">Types de paramètre compatibles et Type de retour</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>In the .NET Framework version 2.0, the parameter types and return type of a delegate created using this method overload must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
          <target state="translated">Dans le .NET Framework version 2.0, les types de paramètre et le type de retour d’un délégué créé à l’aide de cette surcharge de méthode doivent être compatibles avec les types de paramètre et le type de retour de la méthode que le délégué représente ; les types n’ont pas à correspondre exactement.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This represents a relaxation of the binding behavior in the .NET Framework version 1.0 and 1.1, where the types must match exactly.</source>
          <target state="translated">Représente un assouplissement le comportement de liaison dans le .NET Framework version 1.0 et 1.1, où les types doivent correspondre exactement.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">Le paramètre d'un délégué est compatible avec le paramètre correspondant d'une méthode si le type de paramètre du délégué est plus restrictif que le type de paramètre de la méthode. En effet, cela garantit qu'un argument transmis au délégué peut être transmis à la méthode en toute sécurité.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">De même, le type de retour d'un délégué est compatible avec le type de retour d'une méthode si le type de retour de la méthode est plus restrictif que le type de retour du délégué, car cela garantit que le cast de la valeur de retour de la méthode peut être effectué sans risque au type de retour du délégué.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Par exemple, un délégué avec un paramètre de type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> et un type de retour <ph id="ph2">&lt;xref:System.Object&gt;</ph> peut représenter une méthode avec un paramètre de type <ph id="ph3">&lt;xref:System.Object&gt;</ph> et une valeur de retour de type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This section contains two code examples.</source>
          <target state="translated">Cette section contient deux exemples de code.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</source>
          <target state="translated">Le premier exemple montre les deux types de délégués qui peuvent être créés avec cette surcharge de méthode : ouvrir sur une méthode d’instance et ouvrir sur une méthode statique.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The second code example demonstrates compatible parameter types and return types.</source>
          <target state="translated">Le deuxième exemple de code illustre les types de paramètre compatibles et types de retour.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Exemple 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The following code example demonstrates the two ways a delegate can be created using this overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant montre deux façons de délégué peut être créé à l’aide de cette surcharge de la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">Il existe deux surcharges de la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> méthode qui spécifient un <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> mais pas un premier argument ; leur fonctionnalité est identique, sauf qu’un vous permet de spécifier s’il faut lever en cas d’échec pour lier et l’autre lève toujours une exception.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This code example uses both overloads.</source>
          <target state="translated">Cet exemple de code utilise les deux surcharges.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The example declares a class <ph id="ph1">`C`</ph> with a static method <ph id="ph2">`M2`</ph> and an instance method <ph id="ph3">`M1`</ph>, and two delegate types: <ph id="ph4">`D1`</ph> takes an instance of <ph id="ph5">`C`</ph> and a string, and <ph id="ph6">`D2`</ph> takes a string.</source>
          <target state="translated">L’exemple déclare une classe <ph id="ph1">`C`</ph> avec une méthode statique <ph id="ph2">`M2`</ph> et une méthode d’instance <ph id="ph3">`M1`</ph>, et deux types délégués : <ph id="ph4">`D1`</ph> prend une instance de <ph id="ph5">`C`</ph> et une chaîne, et <ph id="ph6">`D2`</ph> prend une chaîne.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A second class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">Une deuxième classe nommée <ph id="ph1">`Example`</ph> contient le code qui crée les délégués.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D1`</ph>, representing an open instance method, is created for the instance method <ph id="ph2">`M1`</ph>.</source>
          <target state="translated">Un délégué du type <ph id="ph1">`D1`</ph>, représentant une méthode d’instance ouverte, est créé pour la méthode d’instance <ph id="ph2">`M1`</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>An instance must be passed when the delegate is invoked.</source>
          <target state="translated">Une instance doit être passée lorsque le délégué est appelé.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, representing an open static method, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">Un délégué du type <ph id="ph1">`D2`</ph>, représentant une méthode statique ouverte, est créé pour la méthode statique <ph id="ph2">`M2`</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Exemple 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The following code example demonstrates compatibility of parameter types and return types.</source>
          <target state="translated">L’exemple de code suivant illustre la compatibilité des types de paramètres et types de retour.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The code example defines a base class named <ph id="ph1">`Base`</ph> and a class named <ph id="ph2">`Derived`</ph> that derives from <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">L’exemple de code définit une classe de base nommée <ph id="ph1">`Base`</ph> et une classe nommée <ph id="ph2">`Derived`</ph> qui dérive de <ph id="ph3">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The derived class has a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) method named <ph id="ph3">`MyMethod`</ph> with one parameter of type <ph id="ph4">`Base`</ph> and a return type of <ph id="ph5">`Derived`</ph>.</source>
          <target state="translated">La classe dérivée a un <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> en Visual Basic) méthode nommée <ph id="ph3">`MyMethod`</ph> avec un paramètre de type <ph id="ph4">`Base`</ph> et un type de retour de <ph id="ph5">`Derived`</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The code example also defines a delegate named <ph id="ph1">`Example`</ph> that has one parameter of type <ph id="ph2">`Derived`</ph> and a return type of <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">L’exemple de code définit également un délégué nommé <ph id="ph1">`Example`</ph> qui a un paramètre de type <ph id="ph2">`Derived`</ph> et un type de retour de <ph id="ph3">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The code example demonstrates that the delegate named <ph id="ph1">`Example`</ph> can be used to represent the method <ph id="ph2">`MyMethod`</ph>.</source>
          <target state="translated">L’exemple de code montre que le délégué nommé <ph id="ph1">`Example`</ph> peut être utilisé pour représenter la méthode <ph id="ph2">`MyMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The method can be bound to the delegate because:</source>
          <target state="translated">La méthode peut être liée au délégué, car :</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The parameter type of the delegate (<ph id="ph1">`Derived`</ph>) is more restrictive than the parameter type of <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), so that it is always safe to pass the argument of the delegate to <ph id="ph4">`MyMethod`</ph>.</source>
          <target state="translated">Le type de paramètre du délégué (<ph id="ph1">`Derived`</ph>) est plus restrictif que le type de paramètre de <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), afin qu’il soit toujours possible de passer l’argument du délégué à <ph id="ph4">`MyMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The return type of <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) is more restrictive than the parameter type of the delegate (<ph id="ph3">`Base`</ph>), so that it is always safe to cast the return type of the method to the return type of the delegate.</source>
          <target state="translated">Le type de retour de <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) est plus restrictif que le type de paramètre du délégué (<ph id="ph3">`Base`</ph>), afin qu’il soit toujours possible de convertir le type de retour de la méthode pour le type de retour du délégué.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The code example produces no output.</source>
          <target state="translated">L’exemple de code ne produit aucune sortie.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n’hérite pas de <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Types au moment de l’exécution dans la réflexion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a static method, and the .NET Framework version is 1.0 or 1.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> n’est pas une méthode statique, et la version du .NET Framework est 1.0 ou 1.1.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ne peut pas être liée.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Types au moment de l’exécution dans la réflexion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> de <ph id="ph2">&lt;paramref name="type" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de délégué à créer.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The object to which the delegate is bound, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> to treat <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> as <ph id="ph2">&lt;see langword="static" /&gt;</ph> (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Objet auquel le délégué est lié, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> pour traiter <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> comme <ph id="ph2">&lt;see langword="static" /&gt;</ph> (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static or instance method the delegate is to represent.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> décrivant la méthode statique ou d’instance que le délégué doit représenter.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument.</source>
          <target state="translated">Crée un délégué du type spécifié qui représente la méthode statique ou méthode d'instance spécifiée, avec le premier argument spécifié.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate of the specified type that represents the specified static or instance method.</source>
          <target state="translated">Délégué du type spécifié qui représente la méthode statique ou méthode d’instance spécifiée.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Calling this method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
          <target state="translated">Appel de cette surcharge de méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> surcharge de méthode et en spécifiant <ph id="ph2">`true`</ph> pour <ph id="ph3">`throwOnBindFailure`</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>These two overloads provide the most flexible way to create delegates.</source>
          <target state="translated">Ces deux surcharges offrent le moyen le plus souple pour créer des délégués.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>You can use them to create delegates for either static or instance methods, and optionally to specify the first argument.</source>
          <target state="translated">Vous pouvez les utiliser pour créer des délégués pour statiques ou des méthodes d’instance et éventuellement pour spécifier le premier argument.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If you do not supply a first argument, use the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload for better performance.</source>
          <target state="translated">Si vous ne fournissez pas un premier argument, utilisez le <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> la surcharge de méthode pour de meilleures performances.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The delegate type and the method must have compatible return types.</source>
          <target state="translated">Le type délégué et la méthode doivent avoir des types de retour compatibles.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>That is, the return type of <ph id="ph1">`method`</ph> must be assignable to the return type of <ph id="ph2">`type`</ph>.</source>
          <target state="translated">Autrement dit, le type de retour de <ph id="ph1">`method`</ph> doit pouvoir être assigné au type de retour de <ph id="ph2">`type`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, it is passed to <ph id="ph2">`method`</ph> every time the delegate is invoked; <ph id="ph3">`firstArgument`</ph> is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</source>
          <target state="translated">Si <ph id="ph1">`firstArgument`</ph> est fourni, il est passé à <ph id="ph2">`method`</ph> chaque fois que le délégué est appelé ; <ph id="ph3">`firstArgument`</ph> est considéré comme lié pour le délégué, et le délégué est dit fermé sur son premier argument.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if <ph id="ph4">`method`</ph> is an instance method, then <ph id="ph5">`firstArgument`</ph> is passed to the hidden instance parameter (represented by <ph id="ph6">`this`</ph> in C#, or by <ph id="ph7">`Me`</ph> in Visual Basic).</source>
          <target state="translated">Si <ph id="ph1">`method`</ph> est <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic), l’argument fourni lors de l’appel du délégué de liste inclut tous les paramètres sauf la première ; si <ph id="ph4">`method`</ph> est une méthode d’instance, puis <ph id="ph5">`firstArgument`</ph> est passée à l’instance masquée paramètre (représenté par <ph id="ph6">`this`</ph> en c#, ou par <ph id="ph7">`Me`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, the first parameter of <ph id="ph2">`method`</ph> must be a reference type, and <ph id="ph3">`firstArgument`</ph> must be compatible with that type.</source>
          <target state="translated">Si <ph id="ph1">`firstArgument`</ph> est fourni, le premier paramètre de <ph id="ph2">`method`</ph> doit être un type référence, et <ph id="ph3">`firstArgument`</ph> doit être compatible avec ce type.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) and its first parameter is of type <ph id="ph4">&lt;xref:System.Object&gt;</ph> or <ph id="ph5">&lt;xref:System.ValueType&gt;</ph>, then <ph id="ph6">`firstArgument`</ph> can be a value type.</source>
          <target state="translated">Si <ph id="ph1">`method`</ph> est <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic) et son premier paramètre est de type <ph id="ph4">&lt;xref:System.Object&gt;</ph> ou <ph id="ph5">&lt;xref:System.ValueType&gt;</ph>, puis <ph id="ph6">`firstArgument`</ph> peut être un type valeur.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>In this case <ph id="ph1">`firstArgument`</ph> is automatically boxed.</source>
          <target state="translated">Dans ce cas <ph id="ph1">`firstArgument`</ph> est automatiquement convertie (boxed).</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</source>
          <target state="translated">Conversion boxing automatique ne se produit pas pour les autres arguments, comme ce serait dans une fonction c# ou Visual Basic appel.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is an instance method, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
          <target state="translated">Si <ph id="ph1">`firstArgument`</ph> est une référence null et <ph id="ph2">`method`</ph> est une méthode d’instance, le résultat dépend des signatures du type délégué <ph id="ph3">`type`</ph> et de <ph id="ph4">`method`</ph>:</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If the signature of <ph id="ph1">`type`</ph> explicitly includes the hidden first parameter of <ph id="ph2">`method`</ph>, the delegate is said to represent an open instance method.</source>
          <target state="translated">Si la signature de <ph id="ph1">`type`</ph> n’inclut pas explicitement le premier paramètre masqué de <ph id="ph2">`method`</ph>, le délégué est dit représenter une méthode d’instance ouverte.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of <ph id="ph1">`method`</ph>.</source>
          <target state="translated">Lorsque le délégué est appelé, le premier argument de la liste d’arguments est passé au paramètre d’instance masqué <ph id="ph1">`method`</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If the signatures of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</source>
          <target state="translated">Si les signatures de <ph id="ph1">`method`</ph> et <ph id="ph2">`type`</ph> correspond à (autrement dit, tous les types de paramètre sont compatibles), le délégué est dit être fermé sur une référence null.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</source>
          <target state="translated">Appel du délégué ressemble à appeler une méthode d’instance sur une instance null, ce qui n’est pas une chose particulièrement utile à faire.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is static, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
          <target state="translated">Si <ph id="ph1">`firstArgument`</ph> est une référence null et <ph id="ph2">`method`</ph> est statique, le résultat dépend des signatures du type délégué <ph id="ph3">`type`</ph> et de <ph id="ph4">`method`</ph>:</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If the signature of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</source>
          <target state="translated">Si la signature de <ph id="ph1">`method`</ph> et <ph id="ph2">`type`</ph> correspond à (autrement dit, tous les types de paramètre sont compatibles), le délégué est dit représenter une méthode statique ouverte.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This is the most common case for static methods.</source>
          <target state="translated">Il s’agit du cas le plus courant pour les méthodes statiques.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>In this case, you can get slightly better performance by using the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
          <target state="translated">Dans ce cas, vous pouvez obtenir des performances sont légèrement meilleures en utilisant la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If the signature of <ph id="ph1">`type`</ph> begins with the second parameter of <ph id="ph2">`method`</ph> and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</source>
          <target state="translated">Si la signature de <ph id="ph1">`type`</ph> commence par le deuxième paramètre de <ph id="ph2">`method`</ph> le reste des types de paramètres sont compatibles, puis le délégué est dit être fermé sur une référence null.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When the delegate is invoked, a null reference is passed to the first parameter of <ph id="ph1">`method`</ph>.</source>
          <target state="translated">Lorsque le délégué est appelé, une référence null est passée au premier paramètre de <ph id="ph1">`method`</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>considérations de sécurité pour la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Compatible Parameter Types and Return Type</source>
          <target state="translated">Types de paramètre compatibles et Type de retour</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
          <target state="translated">Les types de paramètre et le type de retour d’un délégué doivent être compatibles avec les types de paramètre et le type de retour de la méthode que le délégué représente ; les types n’ont pas à correspondre exactement.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>In the .NET Framework version 1.0 and 1.1, the types must match exactly.</source>
          <target state="translated">Dans la version 1.0 et 1.1 du .NET Framework, les types doivent correspondre exactement.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">Le paramètre d'un délégué est compatible avec le paramètre correspondant d'une méthode si le type de paramètre du délégué est plus restrictif que le type de paramètre de la méthode. En effet, cela garantit qu'un argument transmis au délégué peut être transmis à la méthode en toute sécurité.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">De même, le type de retour d'un délégué est compatible avec le type de retour d'une méthode si le type de retour de la méthode est plus restrictif que le type de retour du délégué, car cela garantit que le cast de la valeur de retour de la méthode peut être effectué sans risque au type de retour du délégué.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Par exemple, un délégué avec un paramètre de type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> et un type de retour <ph id="ph2">&lt;xref:System.Object&gt;</ph> peut représenter une méthode avec un paramètre de type <ph id="ph3">&lt;xref:System.Object&gt;</ph> et une valeur de retour de type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Determining the Methods a Delegate Can Represent</source>
          <target state="translated">Déterminer les méthodes d’un délégué peut représenter.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Another useful way to think of the flexibility provided by this overload of <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</source>
          <target state="translated">Une autre façon utile de penser à la souplesse de cette surcharge de <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> est qu’un délégué donné peut représenter quatre combinaisons différentes de signature de méthode et le type de méthode (statique contre instance).</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Consider a delegate type <ph id="ph1">`D`</ph> with one argument of type <ph id="ph2">`C`</ph>.</source>
          <target state="translated">Considérez un type délégué <ph id="ph1">`D`</ph> avec un argument de type <ph id="ph2">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The following describes the methods <ph id="ph1">`D`</ph> can represent, ignoring the return type since it must match in all cases:</source>
          <target state="translated">La section suivante décrit les méthodes <ph id="ph1">`D`</ph> peuvent représenter, en ignorant le type de retour puisqu’il doit correspondre dans tous les cas :</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`D`</ph> can represent any instance method that has exactly one argument of type <ph id="ph2">`C`</ph>, regardless of what type the instance method belongs to.</source>
          <target state="translated"><ph id="ph1">`D`</ph> peut représenter n’importe quelle méthode d’instance qui possède un seul argument de type <ph id="ph2">`C`</ph>, quel que soit le type auquel appartient la méthode d’instance.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of the type <ph id="ph3">`method`</ph> belongs to, and the resulting delegate is said to be closed over that instance.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> est appelée, <ph id="ph2">`firstArgument`</ph> est une instance du type <ph id="ph3">`method`</ph> appartient, et le délégué obtenu est dit être fermé sur cette instance.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>(Trivially, <ph id="ph1">`D`</ph> can also be closed over a null reference if <ph id="ph2">`firstArgument`</ph> is a null reference.)</source>
          <target state="translated">(Plus simplement, <ph id="ph1">`D`</ph> peut aussi être fermé sur une référence null si <ph id="ph2">`firstArgument`</ph> est une référence null.)</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`D`</ph> can represent an instance method of <ph id="ph2">`C`</ph> that has no arguments.</source>
          <target state="translated"><ph id="ph1">`D`</ph> peut représenter une méthode d’instance de <ph id="ph2">`C`</ph> qui n’a aucun argument.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> est appelée, <ph id="ph2">`firstArgument`</ph> est une référence null.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The resulting delegate represents an open instance method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
          <target state="translated">Le délégué obtenu représente une méthode d’instance ouverte et une instance de <ph id="ph1">`C`</ph> doit être fourni à chaque fois qu’elle est appelée.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`D`</ph> can represent a static method that takes one argument of type <ph id="ph2">`C`</ph>, and that method can belong to any type.</source>
          <target state="translated"><ph id="ph1">`D`</ph> peut représenter une méthode statique qui prend un argument de type <ph id="ph2">`C`</ph>, et cette méthode peut appartenir à n’importe quel type.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> est appelée, <ph id="ph2">`firstArgument`</ph> est une référence null.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The resulting delegate represents an open static method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
          <target state="translated">Le délégué obtenu représente une méthode statique ouverte et une instance de <ph id="ph1">`C`</ph> doit être fourni à chaque fois qu’elle est appelée.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`D`</ph> can represent a static method that belongs to type <ph id="ph2">`F`</ph> and has two arguments, of type <ph id="ph3">`F`</ph> and type <ph id="ph4">`C`</ph>.</source>
          <target state="translated"><ph id="ph1">`D`</ph> peut représenter une méthode statique appartenant au type <ph id="ph2">`F`</ph> et a deux arguments de type <ph id="ph3">`F`</ph> et type <ph id="ph4">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of <ph id="ph3">`F`</ph>.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> est appelée, <ph id="ph2">`firstArgument`</ph> est une instance de <ph id="ph3">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The resulting delegate represents a static method that is closed over that instance of <ph id="ph1">`F`</ph>.</source>
          <target state="translated">Le délégué obtenu représente une méthode statique fermée sur cette instance de <ph id="ph1">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Note that in the case where <ph id="ph1">`F`</ph> and <ph id="ph2">`C`</ph> are the same type, the static method has two arguments of that type.</source>
          <target state="translated">Notez que dans le cas où <ph id="ph1">`F`</ph> et <ph id="ph2">`C`</ph> sont du même type, la méthode statique a deux arguments de ce type.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>(In this case, <ph id="ph1">`D`</ph> is closed over a null reference if <ph id="ph2">`firstArgument`</ph> is a null reference.)</source>
          <target state="translated">(Dans ce cas, <ph id="ph1">`D`</ph> est fermé sur une référence null si <ph id="ph2">`firstArgument`</ph> est une référence null.)</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This section contains three code examples.</source>
          <target state="translated">Cette section contient trois exemples de code.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</source>
          <target state="translated">Le premier exemple illustre les quatre types de délégués qui peuvent être créés : fermés sur une méthode d’instance, ouverte sur une méthode d’instance, ouverte sur une méthode statique ou fermés sur une méthode statique.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The second code example demonstrates compatible parameter types and return types.</source>
          <target state="translated">Le deuxième exemple de code illustre les types de paramètre compatibles et types de retour.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</source>
          <target state="translated">Le troisième exemple de code définit un type délégué simple et affiche toutes les méthodes que le type délégué peuvent représenter.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Exemple 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The following code example demonstrates the four ways a delegate can be created using this overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre les quatre façons un délégué peut être créé à l’aide de cette surcharge de la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify <ph id="ph2">`firstArgument`</ph> and a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">Il existe deux surcharges de la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> méthode spécifier <ph id="ph2">`firstArgument`</ph> et un <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; leur fonctionnalité est identique, sauf qu’un vous permet de spécifier s’il faut lever en cas d’échec pour lier et l’autre lève toujours une exception.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This code example uses both overloads.</source>
          <target state="translated">Cet exemple de code utilise les deux surcharges.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The example declares a class <ph id="ph1">`C`</ph> with a static method <ph id="ph2">`M2`</ph> and an instance method <ph id="ph3">`M1`</ph>, and three delegate types: <ph id="ph4">`D1`</ph> takes an instance of <ph id="ph5">`C`</ph> and a string, <ph id="ph6">`D2`</ph> takes a string, and <ph id="ph7">`D3`</ph> has no arguments.</source>
          <target state="translated">L’exemple déclare une classe <ph id="ph1">`C`</ph> avec une méthode statique <ph id="ph2">`M2`</ph> et une méthode d’instance <ph id="ph3">`M1`</ph>, et trois types délégués : <ph id="ph4">`D1`</ph> prend une instance de <ph id="ph5">`C`</ph> et une chaîne, <ph id="ph6">`D2`</ph> prend une chaîne et <ph id="ph7">`D3`</ph>n’a aucun argument.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A second class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">Une deuxième classe nommée <ph id="ph1">`Example`</ph> contient le code qui crée les délégués.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, closed over an instance of <ph id="ph2">`C`</ph>, is created for the instance method <ph id="ph3">`M1`</ph>.</source>
          <target state="translated">Un délégué du type <ph id="ph1">`D2`</ph>, fermé sur une instance de <ph id="ph2">`C`</ph>, est créé pour la méthode d’instance <ph id="ph3">`M1`</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>It is invoked with different strings, to show that the bound instance of <ph id="ph1">`C`</ph> is always used.</source>
          <target state="translated">Il est appelé avec différentes chaînes, pour indiquer que l’instance liée de <ph id="ph1">`C`</ph> est toujours utilisé.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D1`</ph>, representing an open instance method, is created for the instance method <ph id="ph2">`M1`</ph>.</source>
          <target state="translated">Un délégué du type <ph id="ph1">`D1`</ph>, représentant une méthode d’instance ouverte, est créé pour la méthode d’instance <ph id="ph2">`M1`</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>An instance must be passed when the delegate is invoked.</source>
          <target state="translated">Une instance doit être passée lorsque le délégué est appelé.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, representing an open static method, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">Un délégué du type <ph id="ph1">`D2`</ph>, représentant une méthode statique ouverte, est créé pour la méthode statique <ph id="ph2">`M2`</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Finally, a delegate of type <ph id="ph1">`D3`</ph>, closed over a string, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">Enfin, un délégué du type <ph id="ph1">`D3`</ph>, fermé sur une chaîne, est créé pour la méthode statique <ph id="ph2">`M2`</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The method is invoked to show that it uses the bound string.</source>
          <target state="translated">La méthode est appelée pour illustrer l’utilisation de la chaîne liée.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Exemple 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The following code example demonstrates compatibility of parameter types and return types.</source>
          <target state="translated">L’exemple de code suivant illustre la compatibilité des types de paramètres et types de retour.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This code example uses the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
          <target state="translated">Cet exemple de code utilise le <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The use of other overloads that take <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is similar.</source>
          <target state="translated">L’utilisation d’autres surcharges qui prennent <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> est similaire.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example defines a base class named <ph id="ph1">`Base`</ph> and a class named <ph id="ph2">`Derived`</ph> that derives from <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">L’exemple de code définit une classe de base nommée <ph id="ph1">`Base`</ph> et une classe nommée <ph id="ph2">`Derived`</ph> qui dérive de <ph id="ph3">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The derived class has a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) method named <ph id="ph3">`MyMethod`</ph> with one parameter of type <ph id="ph4">`Base`</ph> and a return type of <ph id="ph5">`Derived`</ph>.</source>
          <target state="translated">La classe dérivée a un <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> en Visual Basic) méthode nommée <ph id="ph3">`MyMethod`</ph> avec un paramètre de type <ph id="ph4">`Base`</ph> et un type de retour de <ph id="ph5">`Derived`</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example also defines a delegate named <ph id="ph1">`Example`</ph> that has one parameter of type <ph id="ph2">`Derived`</ph> and a return type of <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">L’exemple de code définit également un délégué nommé <ph id="ph1">`Example`</ph> qui a un paramètre de type <ph id="ph2">`Derived`</ph> et un type de retour de <ph id="ph3">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example demonstrates that the delegate named <ph id="ph1">`Example`</ph> can be used to represent the method <ph id="ph2">`MyMethod`</ph>.</source>
          <target state="translated">L’exemple de code montre que le délégué nommé <ph id="ph1">`Example`</ph> peut être utilisé pour représenter la méthode <ph id="ph2">`MyMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The method can be bound to the delegate because:</source>
          <target state="translated">La méthode peut être liée au délégué, car :</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The parameter type of the delegate (<ph id="ph1">`Derived`</ph>) is more restrictive than the parameter type of <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), so that it is always safe to pass the argument of the delegate to <ph id="ph4">`MyMethod`</ph>.</source>
          <target state="translated">Le type de paramètre du délégué (<ph id="ph1">`Derived`</ph>) est plus restrictif que le type de paramètre de <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), afin qu’il soit toujours possible de passer l’argument du délégué à <ph id="ph4">`MyMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The return type of <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) is more restrictive than the parameter type of the delegate (<ph id="ph3">`Base`</ph>), so that it is always safe to cast the return type of the method to the return type of the delegate.</source>
          <target state="translated">Le type de retour de <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) est plus restrictif que le type de paramètre du délégué (<ph id="ph3">`Base`</ph>), afin qu’il soit toujours possible de convertir le type de retour de la méthode pour le type de retour du délégué.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example produces no output.</source>
          <target state="translated">L’exemple de code ne produit aucune sortie.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 3<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Exemple 3<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The following code example shows all the methods a single delegate type can represent, using the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method to create the delegates.</source>
          <target state="translated">L’exemple de code suivant montre toutes les méthodes d’un type délégué simple peut représenter, à l’aide de la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> méthode pour créer les délégués.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify <ph id="ph2">`firstArgument`</ph> and a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">Il existe deux surcharges de la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> méthode spécifier <ph id="ph2">`firstArgument`</ph> et un <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; leur fonctionnalité est identique, sauf qu’un vous permet de spécifier s’il faut lever en cas d’échec pour lier et l’autre lève toujours une exception.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This code example uses both overloads.</source>
          <target state="translated">Cet exemple de code utilise les deux surcharges.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example defines two classes, <ph id="ph1">`C`</ph> and <ph id="ph2">`F`</ph>, and a delegate type <ph id="ph3">`D`</ph> with one argument of type <ph id="ph4">`C`</ph>.</source>
          <target state="translated">L’exemple de code définit deux classes, <ph id="ph1">`C`</ph> et <ph id="ph2">`F`</ph>et un type délégué <ph id="ph3">`D`</ph> avec un argument de type <ph id="ph4">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The classes have matching static and instance methods <ph id="ph1">`M1`</ph>, <ph id="ph2">`M3`</ph>, and <ph id="ph3">`M4`</ph>, and class <ph id="ph4">`C`</ph> also has an instance method <ph id="ph5">`M2`</ph> that has no arguments.</source>
          <target state="translated">Les classes concordent statiques et les méthodes d’instance <ph id="ph1">`M1`</ph>, <ph id="ph2">`M3`</ph>, et <ph id="ph3">`M4`</ph>et la classe <ph id="ph4">`C`</ph> a également une méthode d’instance <ph id="ph5">`M2`</ph> qui dispose d’aucun argument.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A third class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">Une troisième classe nommée <ph id="ph1">`Example`</ph> contient le code qui crée les délégués.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Delegates are created for instance method <ph id="ph1">`M1`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; each is closed over an instance of the respective type.</source>
          <target state="translated">Les délégués sont créés pour l’instance de méthode <ph id="ph1">`M1`</ph> de type <ph id="ph2">`C`</ph> et type <ph id="ph3">`F`</ph>; chacun est fermé sur une instance du type respectif.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Method <ph id="ph1">`M1`</ph> of type <ph id="ph2">`C`</ph> displays the <ph id="ph3">`ID`</ph> properties of the bound instance and of the argument.</source>
          <target state="translated">Méthode <ph id="ph1">`M1`</ph> de type <ph id="ph2">`C`</ph> affiche les <ph id="ph3">`ID`</ph> propriétés de l’instance liée et de l’argument.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate is created for method <ph id="ph1">`M2`</ph> of type <ph id="ph2">`C`</ph>.</source>
          <target state="translated">Un délégué est créé pour la méthode <ph id="ph1">`M2`</ph> de type <ph id="ph2">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</source>
          <target state="translated">Il s’agit d’un délégué d’instance ouverte, dans laquelle l’argument du délégué représente le premier argument masqué sur la méthode d’instance.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The method has no other arguments.</source>
          <target state="translated">La méthode n’a aucun autre argument.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>It is called as if it were a static method.</source>
          <target state="translated">Il est appelé comme s’il s’agissait d’une méthode statique.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Delegates are created for static method <ph id="ph1">`M3`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; these are open static delegates.</source>
          <target state="translated">Les délégués sont créés pour la méthode statique <ph id="ph1">`M3`</ph> de type <ph id="ph2">`C`</ph> et type <ph id="ph3">`F`</ph>; ce sont des délégués statiques ouverts.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Finally, delegates are created for static method <ph id="ph1">`M4`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</source>
          <target state="translated">Enfin, les délégués sont créés pour la méthode statique <ph id="ph1">`M4`</ph> de type <ph id="ph2">`C`</ph> et type <ph id="ph3">`F`</ph>; chaque méthode a le type déclarant comme premier argument, et une instance du type est fournie, les délégués sont fermés sur leurs premiers arguments .</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Method <ph id="ph1">`M4`</ph> of type <ph id="ph2">`C`</ph> displays the <ph id="ph3">`ID`</ph> properties of the bound instance and of the argument.</source>
          <target state="translated">Méthode <ph id="ph1">`M4`</ph> de type <ph id="ph2">`C`</ph> affiche les <ph id="ph3">`ID`</ph> propriétés de l’instance liée et de l’argument.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n’hérite pas de <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Types au moment de l’exécution dans la réflexion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ne peut pas être liée.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Types au moment de l’exécution dans la réflexion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> de <ph id="ph2">&lt;paramref name="type" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de délégué à créer.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The class instance on which <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> is invoked.</source>
          <target state="translated">Instance de classe sur laquelle <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> est appelé.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The name of the instance method that the delegate is to represent.</source>
          <target state="translated">Nom de la méthode d’instance que doit représenter le délégué.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
          <target state="translated">Crée un délégué du type spécifié qui représente la méthode d'instance spécifiée à appeler sur l'instance de classe spécifiée.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
          <target state="translated">Délégué du type spécifié qui représente la méthode d'instance spécifiée à appeler sur l'instance de classe spécifiée.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>This method creates delegates for instance methods only.</source>
          <target state="translated">Cette méthode crée des délégués pour l’instance des méthodes uniquement.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`false`</ph> for <ph id="ph3">`ignoreCase`</ph> and <ph id="ph4">`true`</ph> for <ph id="ph5">`throwOnBindFailure`</ph>.</source>
          <target state="translated">Cette surcharge de méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> surcharge de méthode, en spécifiant <ph id="ph2">`false`</ph> pour <ph id="ph3">`ignoreCase`</ph> et <ph id="ph4">`true`</ph> pour <ph id="ph5">`throwOnBindFailure`</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>considérations de sécurité pour la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n’hérite pas de <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Types au moment de l’exécution dans la réflexion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not an instance method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> n’est pas une méthode d’instance.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ne peut pas être lié, ce qui peut arriver s’il est introuvable.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> de <ph id="ph2">&lt;paramref name="type" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de délégué à créer.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static or instance method the delegate is to represent.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> décrivant la méthode statique ou d’instance que le délégué doit représenter.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> cannot be bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour lever une exception si <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> ne peut pas être lié ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Creates a delegate of the specified type to represent the specified static method, with the specified behavior on failure to bind.</source>
          <target state="translated">Crée un délégué du type spécifié pour représenter la méthode statique spécifiée, avec le comportement spécifié en cas d'échec de la liaison.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of the specified type to represent the specified static method.</source>
          <target state="translated">Délégué du type spécifié pour représenter la méthode statique spécifiée.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This method overload can create open static method delegates and open instance method delegates — that is, delegates that expose the hidden first argument of instance methods.</source>
          <target state="translated">Cette surcharge de méthode peut créer des délégués de méthode statique ouverte et ouvrir des délégués de méthode d’instance, autrement dit, les délégués qui exposent le premier argument masqué des méthodes d’instance.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>For a detailed explanation, see the more general <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods.</source>
          <target state="translated">Pour une explication détaillée, consultez la plus générale <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> surcharge de méthode, ce qui vous permet de créer toutes les combinaisons de délégués ouverts ou fermés par l’instance ou des méthodes statiques.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</source>
          <target state="translated">Cette surcharge de méthode doit être utilisée lorsque le délégué n’est pas fermé sur son premier argument, car il est un peu plus rapide dans ce cas.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>considérations de sécurité pour la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Compatible Parameter Types and Return Type</source>
          <target state="translated">Types de paramètre compatibles et Type de retour</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
          <target state="translated">Les types de paramètre et le type de retour d’un délégué doivent être compatibles avec les types de paramètre et le type de retour de la méthode que le délégué représente ; les types n’ont pas à correspondre exactement.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>In the .NET Framework version 1.0 and 1.1, the types must match exactly.</source>
          <target state="translated">Dans la version 1.0 et 1.1 du .NET Framework, les types doivent correspondre exactement.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">Le paramètre d'un délégué est compatible avec le paramètre correspondant d'une méthode si le type de paramètre du délégué est plus restrictif que le type de paramètre de la méthode. En effet, cela garantit qu'un argument transmis au délégué peut être transmis à la méthode en toute sécurité.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">De même, le type de retour d'un délégué est compatible avec le type de retour d'une méthode si le type de retour de la méthode est plus restrictif que le type de retour du délégué, car cela garantit que le cast de la valeur de retour de la méthode peut être effectué sans risque au type de retour du délégué.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Par exemple, un délégué avec un paramètre de type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> et un type de retour <ph id="ph2">&lt;xref:System.Object&gt;</ph> peut représenter une méthode avec un paramètre de type <ph id="ph3">&lt;xref:System.Object&gt;</ph> et une valeur de retour de type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This section contains two code examples.</source>
          <target state="translated">Cette section contient deux exemples de code.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</source>
          <target state="translated">Le premier exemple montre les deux types de délégués qui peuvent être créés avec cette surcharge de méthode : ouvrir sur une méthode d’instance et ouvrir sur une méthode statique.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The second code example demonstrates compatible parameter types and return types.</source>
          <target state="translated">Le deuxième exemple de code illustre les types de paramètre compatibles et types de retour.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Exemple 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example demonstrates the two ways a delegate can be created using this overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant montre deux façons de délégué peut être créé à l’aide de cette surcharge de la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">Il existe deux surcharges de la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> méthode qui spécifient un <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> mais pas un premier argument ; leur fonctionnalité est identique, sauf qu’un vous permet de spécifier s’il faut lever en cas d’échec pour lier et l’autre lève toujours une exception.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses both overloads.</source>
          <target state="translated">Cet exemple de code utilise les deux surcharges.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The example declares a class <ph id="ph1">`C`</ph> with a static method <ph id="ph2">`M2`</ph> and an instance method <ph id="ph3">`M1`</ph>, and two delegate types: <ph id="ph4">`D1`</ph> takes an instance of <ph id="ph5">`C`</ph> and a string, and <ph id="ph6">`D2`</ph> takes a string.</source>
          <target state="translated">L’exemple déclare une classe <ph id="ph1">`C`</ph> avec une méthode statique <ph id="ph2">`M2`</ph> et une méthode d’instance <ph id="ph3">`M1`</ph>, et deux types délégués : <ph id="ph4">`D1`</ph> prend une instance de <ph id="ph5">`C`</ph> et une chaîne, et <ph id="ph6">`D2`</ph> prend une chaîne.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A second class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">Une deuxième classe nommée <ph id="ph1">`Example`</ph> contient le code qui crée les délégués.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D1`</ph>, representing an open instance method, is created for the instance method <ph id="ph2">`M1`</ph>.</source>
          <target state="translated">Un délégué du type <ph id="ph1">`D1`</ph>, représentant une méthode d’instance ouverte, est créé pour la méthode d’instance <ph id="ph2">`M1`</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>An instance must be passed when the delegate is invoked.</source>
          <target state="translated">Une instance doit être passée lorsque le délégué est appelé.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, representing an open static method, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">Un délégué du type <ph id="ph1">`D2`</ph>, représentant une méthode statique ouverte, est créé pour la méthode statique <ph id="ph2">`M2`</ph>.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Exemple 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example demonstrates compatibility of parameter types and return types.</source>
          <target state="translated">L’exemple de code suivant illustre la compatibilité des types de paramètres et types de retour.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
          <target state="translated">Cet exemple de code utilise le <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The use of other overloads that take <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is similar.</source>
          <target state="translated">L’utilisation d’autres surcharges qui prennent <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> est similaire.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example defines a base class named <ph id="ph1">`Base`</ph> and a class named <ph id="ph2">`Derived`</ph> that derives from <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">L’exemple de code définit une classe de base nommée <ph id="ph1">`Base`</ph> et une classe nommée <ph id="ph2">`Derived`</ph> qui dérive de <ph id="ph3">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The derived class has a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) method named <ph id="ph3">`MyMethod`</ph> with one parameter of type <ph id="ph4">`Base`</ph> and a return type of <ph id="ph5">`Derived`</ph>.</source>
          <target state="translated">La classe dérivée a un <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> en Visual Basic) méthode nommée <ph id="ph3">`MyMethod`</ph> avec un paramètre de type <ph id="ph4">`Base`</ph> et un type de retour de <ph id="ph5">`Derived`</ph>.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example also defines a delegate named <ph id="ph1">`Example`</ph> that has one parameter of type <ph id="ph2">`Derived`</ph> and a return type of <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">L’exemple de code définit également un délégué nommé <ph id="ph1">`Example`</ph> qui a un paramètre de type <ph id="ph2">`Derived`</ph> et un type de retour de <ph id="ph3">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example demonstrates that the delegate named <ph id="ph1">`Example`</ph> can be used to represent the method <ph id="ph2">`MyMethod`</ph>.</source>
          <target state="translated">L’exemple de code montre que le délégué nommé <ph id="ph1">`Example`</ph> peut être utilisé pour représenter la méthode <ph id="ph2">`MyMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The method can be bound to the delegate because:</source>
          <target state="translated">La méthode peut être liée au délégué, car :</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The parameter type of the delegate (<ph id="ph1">`Derived`</ph>) is more restrictive than the parameter type of <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), so that it is always safe to pass the argument of the delegate to <ph id="ph4">`MyMethod`</ph>.</source>
          <target state="translated">Le type de paramètre du délégué (<ph id="ph1">`Derived`</ph>) est plus restrictif que le type de paramètre de <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), afin qu’il soit toujours possible de passer l’argument du délégué à <ph id="ph4">`MyMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The return type of <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) is more restrictive than the parameter type of the delegate (<ph id="ph3">`Base`</ph>), so that it is always safe to cast the return type of the method to the return type of the delegate.</source>
          <target state="translated">Le type de retour de <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) est plus restrictif que le type de paramètre du délégué (<ph id="ph3">`Base`</ph>), afin qu’il soit toujours possible de convertir le type de retour de la méthode pour le type de retour du délégué.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example produces no output.</source>
          <target state="translated">L’exemple de code ne produit aucune sortie.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n’hérite pas de <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Types au moment de l’exécution dans la réflexion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ne peut pas être lié et <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Types au moment de l’exécution dans la réflexion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> de <ph id="ph2">&lt;paramref name="type" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de délégué à créer.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the class that implements <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> représentant la classe qui implémente <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The name of the static method that the delegate is to represent.</source>
          <target state="translated">Nom de la méthode statique que doit représenter le délégué.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>Creates a delegate of the specified type that represents the specified static method of the specified class.</source>
          <target state="translated">Crée un délégué du type spécifié qui représente la méthode statique spécifiée de la classe spécifiée.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>A delegate of the specified type that represents the specified static method of the specified class.</source>
          <target state="translated">Délégué du type spécifié qui représente la méthode statique spécifiée de la classe spécifiée.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>This method creates delegates for static methods only.</source>
          <target state="translated">Cette méthode crée des délégués pour les méthodes statiques uniquement.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`false`</ph> for <ph id="ph3">`ignoreCase`</ph> and <ph id="ph4">`true`</ph> for <ph id="ph5">`throwOnBindFailure`</ph>.</source>
          <target state="translated">Cette surcharge de méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> surcharge de méthode, en spécifiant <ph id="ph2">`false`</ph> pour <ph id="ph3">`ignoreCase`</ph> et <ph id="ph4">`true`</ph> pour <ph id="ph5">`throwOnBindFailure`</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>considérations de sécurité pour la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n’hérite pas de <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Types au moment de l’exécution dans la réflexion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> est un type générique ouvert.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>That is, its <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Autrement dit, sa propriété <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="static" /&gt;</ph> method (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> method in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> n’est pas une méthode <ph id="ph2">&lt;see langword="static" /&gt;</ph> (méthode <ph id="ph3">&lt;see langword="Shared" /&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ne peut pas être lié, par exemple car elle est introuvable, et <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> de <ph id="ph2">&lt;paramref name="type" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the type of delegate to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> représentant le type de délégué à créer.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> that is the first argument of the method the delegate represents.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> correspondant au premier argument de la méthode que le délégué représente.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>For instance methods, it must be compatible with the instance type.</source>
          <target state="translated">Pour les méthodes d'instance, il doit être compatible avec le type d'instance.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static or instance method the delegate is to represent.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> décrivant la méthode statique ou d’instance que le délégué doit représenter.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> cannot be bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour lever une exception si <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> ne peut pas être lié ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument and the specified behavior on failure to bind.</source>
          <target state="translated">Crée un délégué du type spécifié qui représente la méthode statique ou d'instance spécifiée, avec le premier argument spécifié et le comportement spécifié en cas d'échec de la liaison.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of the specified type that represents the specified static or instance method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="false" /&gt;</ph> and the delegate cannot be bound to <ph id="ph4">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">Délégué du type spécifié qui représente la méthode statique ou d’instance spécifiée, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="false" /&gt;</ph> et que le délégué ne peut pas être lié à <ph id="ph4">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This method overload and the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload, which always throws on failure to bind, provide the most flexible way to create delegates.</source>
          <target state="translated">Cette surcharge de méthode et la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph> surcharge de méthode qui lève toujours une exception en cas d’échec pour lier, le moyen le plus souple pour créer des délégués.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>You can use them to create delegates for either static or instance methods, with or without a first argument.</source>
          <target state="translated">Vous pouvez les utiliser pour créer des délégués pour statiques ou des méthodes d’instance, avec ou sans un premier argument.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If you do not supply a first argument, use the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload for better performance.</source>
          <target state="translated">Si vous ne fournissez pas un premier argument, utilisez le <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> la surcharge de méthode pour de meilleures performances.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The delegate type and the method must have compatible return types.</source>
          <target state="translated">Le type délégué et la méthode doivent avoir des types de retour compatibles.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>That is, the return type of <ph id="ph1">`method`</ph> must be assignable to the return type of <ph id="ph2">`type`</ph>.</source>
          <target state="translated">Autrement dit, le type de retour de <ph id="ph1">`method`</ph> doit pouvoir être assigné au type de retour de <ph id="ph2">`type`</ph>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, it is passed to <ph id="ph2">`method`</ph> every time the delegate is invoked; <ph id="ph3">`firstArgument`</ph> is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</source>
          <target state="translated">Si <ph id="ph1">`firstArgument`</ph> est fourni, il est passé à <ph id="ph2">`method`</ph> chaque fois que le délégué est appelé ; <ph id="ph3">`firstArgument`</ph> est considéré comme lié pour le délégué, et le délégué est dit fermé sur son premier argument.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if <ph id="ph4">`method`</ph> is an instance method, then <ph id="ph5">`firstArgument`</ph> is passed to the hidden instance parameter (represented by <ph id="ph6">`this`</ph> in C#, or by <ph id="ph7">`Me`</ph> in Visual Basic).</source>
          <target state="translated">Si <ph id="ph1">`method`</ph> est <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic), l’argument fourni lors de l’appel du délégué de liste inclut tous les paramètres sauf la première ; si <ph id="ph4">`method`</ph> est une méthode d’instance, puis <ph id="ph5">`firstArgument`</ph> est passée à l’instance masquée paramètre (représenté par <ph id="ph6">`this`</ph> en c#, ou par <ph id="ph7">`Me`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, the first parameter of <ph id="ph2">`method`</ph> must be a reference type, and <ph id="ph3">`firstArgument`</ph> must be compatible with that type.</source>
          <target state="translated">Si <ph id="ph1">`firstArgument`</ph> est fourni, le premier paramètre de <ph id="ph2">`method`</ph> doit être un type référence, et <ph id="ph3">`firstArgument`</ph> doit être compatible avec ce type.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) and its first parameter is of type <ph id="ph4">&lt;xref:System.Object&gt;</ph> or <ph id="ph5">&lt;xref:System.ValueType&gt;</ph>, then <ph id="ph6">`firstArgument`</ph> can be a value type.</source>
          <target state="translated">Si <ph id="ph1">`method`</ph> est <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic) et son premier paramètre est de type <ph id="ph4">&lt;xref:System.Object&gt;</ph> ou <ph id="ph5">&lt;xref:System.ValueType&gt;</ph>, puis <ph id="ph6">`firstArgument`</ph> peut être un type valeur.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>In this case <ph id="ph1">`firstArgument`</ph> is automatically boxed.</source>
          <target state="translated">Dans ce cas <ph id="ph1">`firstArgument`</ph> est automatiquement convertie (boxed).</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</source>
          <target state="translated">Conversion boxing automatique ne se produit pas pour les autres arguments, comme ce serait dans une fonction c# ou Visual Basic appel.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is an instance method, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
          <target state="translated">Si <ph id="ph1">`firstArgument`</ph> est une référence null et <ph id="ph2">`method`</ph> est une méthode d’instance, le résultat dépend des signatures du type délégué <ph id="ph3">`type`</ph> et de <ph id="ph4">`method`</ph>:</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If the signature of <ph id="ph1">`type`</ph> explicitly includes the hidden first parameter of <ph id="ph2">`method`</ph>, the delegate is said to represent an open instance method.</source>
          <target state="translated">Si la signature de <ph id="ph1">`type`</ph> n’inclut pas explicitement le premier paramètre masqué de <ph id="ph2">`method`</ph>, le délégué est dit représenter une méthode d’instance ouverte.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of <ph id="ph1">`method`</ph>.</source>
          <target state="translated">Lorsque le délégué est appelé, le premier argument de la liste d’arguments est passé au paramètre d’instance masqué <ph id="ph1">`method`</ph>.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If the signatures of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</source>
          <target state="translated">Si les signatures de <ph id="ph1">`method`</ph> et <ph id="ph2">`type`</ph> correspond à (autrement dit, tous les types de paramètre sont compatibles), le délégué est dit être fermé sur une référence null.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</source>
          <target state="translated">Appel du délégué ressemble à appeler une méthode d’instance sur une instance null, ce qui n’est pas une chose particulièrement utile à faire.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is static, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
          <target state="translated">Si <ph id="ph1">`firstArgument`</ph> est une référence null et <ph id="ph2">`method`</ph> est statique, le résultat dépend des signatures du type délégué <ph id="ph3">`type`</ph> et de <ph id="ph4">`method`</ph>:</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If the signature of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</source>
          <target state="translated">Si la signature de <ph id="ph1">`method`</ph> et <ph id="ph2">`type`</ph> correspond à (autrement dit, tous les types de paramètre sont compatibles), le délégué est dit représenter une méthode statique ouverte.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This is the most common case for static methods.</source>
          <target state="translated">Il s’agit du cas le plus courant pour les méthodes statiques.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>In this case, you can get slightly better performance by using the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">Dans ce cas, vous pouvez obtenir des performances sont légèrement meilleures en utilisant la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If the signature of <ph id="ph1">`type`</ph> begins with the second parameter of <ph id="ph2">`method`</ph> and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</source>
          <target state="translated">Si la signature de <ph id="ph1">`type`</ph> commence par le deuxième paramètre de <ph id="ph2">`method`</ph> le reste des types de paramètres sont compatibles, puis le délégué est dit être fermé sur une référence null.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When the delegate is invoked, a null reference is passed to the first parameter of <ph id="ph1">`method`</ph>.</source>
          <target state="translated">Lorsque le délégué est appelé, une référence null est passée au premier paramètre de <ph id="ph1">`method`</ph>.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>considérations de sécurité pour la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Compatible Parameter Types and Return Type</source>
          <target state="translated">Types de paramètre compatibles et Type de retour</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
          <target state="translated">Les types de paramètre et le type de retour d’un délégué doivent être compatibles avec les types de paramètre et le type de retour de la méthode que le délégué représente ; les types n’ont pas à correspondre exactement.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>In the .NET Framework version 1.0 and 1.1 the types must match exactly.</source>
          <target state="translated">Dans la version 1.0 et 1.1 du .NET Framework, les types doivent correspondre exactement.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">Le paramètre d'un délégué est compatible avec le paramètre correspondant d'une méthode si le type de paramètre du délégué est plus restrictif que le type de paramètre de la méthode. En effet, cela garantit qu'un argument transmis au délégué peut être transmis à la méthode en toute sécurité.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">De même, le type de retour d'un délégué est compatible avec le type de retour d'une méthode si le type de retour de la méthode est plus restrictif que le type de retour du délégué, car cela garantit que le cast de la valeur de retour de la méthode peut être effectué sans risque au type de retour du délégué.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Par exemple, un délégué avec un paramètre de type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> et un type de retour <ph id="ph2">&lt;xref:System.Object&gt;</ph> peut représenter une méthode avec un paramètre de type <ph id="ph3">&lt;xref:System.Object&gt;</ph> et une valeur de retour de type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Determining the Methods a Delegate Can Represent</source>
          <target state="translated">Déterminer les méthodes d’un délégué peut représenter.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Another useful way to think of the flexibility provided by this overload of <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</source>
          <target state="translated">Une autre façon utile de penser à la souplesse de cette surcharge de <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> est qu’un délégué donné peut représenter quatre combinaisons différentes de signature de méthode et le type de méthode (statique contre instance).</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Consider a delegate type <ph id="ph1">`D`</ph> with one argument of type <ph id="ph2">`C`</ph>.</source>
          <target state="translated">Considérez un type délégué <ph id="ph1">`D`</ph> avec un argument de type <ph id="ph2">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following describes the methods <ph id="ph1">`D`</ph> can represent, ignoring the return type since it must match in all cases:</source>
          <target state="translated">La section suivante décrit les méthodes <ph id="ph1">`D`</ph> peuvent représenter, en ignorant le type de retour puisqu’il doit correspondre dans tous les cas :</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">`D`</ph> can represent any instance method that has exactly one argument of type <ph id="ph2">`C`</ph>, regardless of what type the instance method belongs to.</source>
          <target state="translated"><ph id="ph1">`D`</ph> peut représenter n’importe quelle méthode d’instance qui possède un seul argument de type <ph id="ph2">`C`</ph>, quel que soit le type auquel appartient la méthode d’instance.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of the type <ph id="ph3">`method`</ph> belongs to, and the resulting delegate is said to be closed over that instance.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> est appelée, <ph id="ph2">`firstArgument`</ph> est une instance du type <ph id="ph3">`method`</ph> appartient, et le délégué obtenu est dit être fermé sur cette instance.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>(Trivially, <ph id="ph1">`D`</ph> can also be closed over a null reference if <ph id="ph2">`firstArgument`</ph> is <ph id="ph3">`null`</ph>.)</source>
          <target state="translated">(Plus simplement, <ph id="ph1">`D`</ph> peut aussi être fermé sur une référence null si <ph id="ph2">`firstArgument`</ph> est <ph id="ph3">`null`</ph>.)</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">`D`</ph> can represent an instance method of <ph id="ph2">`C`</ph> that has no arguments.</source>
          <target state="translated"><ph id="ph1">`D`</ph> peut représenter une méthode d’instance de <ph id="ph2">`C`</ph> qui n’a aucun argument.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> est appelée, <ph id="ph2">`firstArgument`</ph> est une référence null.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The resulting delegate represents an open instance method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
          <target state="translated">Le délégué obtenu représente une méthode d’instance ouverte et une instance de <ph id="ph1">`C`</ph> doit être fourni à chaque fois qu’elle est appelée.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">`D`</ph> can represent a static method that takes one argument of type <ph id="ph2">`C`</ph>, and that method can belong to any type.</source>
          <target state="translated"><ph id="ph1">`D`</ph> peut représenter une méthode statique qui prend un argument de type <ph id="ph2">`C`</ph>, et cette méthode peut appartenir à n’importe quel type.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> est appelée, <ph id="ph2">`firstArgument`</ph> est une référence null.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The resulting delegate represents an open static method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
          <target state="translated">Le délégué obtenu représente une méthode statique ouverte et une instance de <ph id="ph1">`C`</ph> doit être fourni à chaque fois qu’elle est appelée.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">`D`</ph> can represent a static method that belongs to type <ph id="ph2">`F`</ph> and has two arguments, of type <ph id="ph3">`F`</ph> and type <ph id="ph4">`C`</ph>.</source>
          <target state="translated"><ph id="ph1">`D`</ph> peut représenter une méthode statique appartenant au type <ph id="ph2">`F`</ph> et a deux arguments de type <ph id="ph3">`F`</ph> et type <ph id="ph4">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of <ph id="ph3">`F`</ph>.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> est appelée, <ph id="ph2">`firstArgument`</ph> est une instance de <ph id="ph3">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The resulting delegate represents a static method that is closed over that instance of <ph id="ph1">`F`</ph>.</source>
          <target state="translated">Le délégué obtenu représente une méthode statique fermée sur cette instance de <ph id="ph1">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Note that in the case where <ph id="ph1">`F`</ph> and <ph id="ph2">`C`</ph> are the same type, the static method has two arguments of that type.</source>
          <target state="translated">Notez que dans le cas où <ph id="ph1">`F`</ph> et <ph id="ph2">`C`</ph> sont du même type, la méthode statique a deux arguments de ce type.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>(In this case, <ph id="ph1">`D`</ph> is closed over a null reference if <ph id="ph2">`firstArgument`</ph> is <ph id="ph3">`null`</ph>.)</source>
          <target state="translated">(Dans ce cas, <ph id="ph1">`D`</ph> est fermé sur une référence null si <ph id="ph2">`firstArgument`</ph> est <ph id="ph3">`null`</ph>.)</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This section contains three code examples.</source>
          <target state="translated">Cette section contient trois exemples de code.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</source>
          <target state="translated">Le premier exemple illustre les quatre types de délégués qui peuvent être créés : fermés sur une méthode d’instance, ouverte sur une méthode d’instance, ouverte sur une méthode statique ou fermés sur une méthode statique.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The second code example demonstrates compatible parameter types and return types.</source>
          <target state="translated">Le deuxième exemple de code illustre les types de paramètre compatibles et types de retour.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</source>
          <target state="translated">Le troisième exemple de code définit un type délégué simple et affiche toutes les méthodes que le type délégué peuvent représenter.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Exemple 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example demonstrates the four ways a delegate can be created using this overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre les quatre façons un délégué peut être créé à l’aide de cette surcharge de la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify <ph id="ph2">`firstArgument`</ph> and a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">Il existe deux surcharges de la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> méthode spécifier <ph id="ph2">`firstArgument`</ph> et un <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; leur fonctionnalité est identique, sauf qu’un vous permet de spécifier s’il faut lever en cas d’échec pour lier et l’autre lève toujours une exception.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses both overloads.</source>
          <target state="translated">Cet exemple de code utilise les deux surcharges.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The example declares a class <ph id="ph1">`C`</ph> with a static method <ph id="ph2">`M2`</ph> and an instance method <ph id="ph3">`M1`</ph>, and three delegate types: <ph id="ph4">`D1`</ph> takes an instance of <ph id="ph5">`C`</ph> and a string, <ph id="ph6">`D2`</ph> takes a string, and <ph id="ph7">`D3`</ph> has no arguments.</source>
          <target state="translated">L’exemple déclare une classe <ph id="ph1">`C`</ph> avec une méthode statique <ph id="ph2">`M2`</ph> et une méthode d’instance <ph id="ph3">`M1`</ph>, et trois types délégués : <ph id="ph4">`D1`</ph> prend une instance de <ph id="ph5">`C`</ph> et une chaîne, <ph id="ph6">`D2`</ph> prend une chaîne et <ph id="ph7">`D3`</ph>n’a aucun argument.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A second class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">Une deuxième classe nommée <ph id="ph1">`Example`</ph> contient le code qui crée les délégués.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, closed over an instance of <ph id="ph2">`C`</ph>, is created for the instance method <ph id="ph3">`M1`</ph>.</source>
          <target state="translated">Un délégué du type <ph id="ph1">`D2`</ph>, fermé sur une instance de <ph id="ph2">`C`</ph>, est créé pour la méthode d’instance <ph id="ph3">`M1`</ph>.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>It is invoked with different strings, to show that the bound instance of <ph id="ph1">`C`</ph> is always used.</source>
          <target state="translated">Il est appelé avec différentes chaînes, pour indiquer que l’instance liée de <ph id="ph1">`C`</ph> est toujours utilisé.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D1`</ph>, representing an open instance method, is created for the instance method <ph id="ph2">`M1`</ph>.</source>
          <target state="translated">Un délégué du type <ph id="ph1">`D1`</ph>, représentant une méthode d’instance ouverte, est créé pour la méthode d’instance <ph id="ph2">`M1`</ph>.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>An instance must be passed when the delegate is invoked.</source>
          <target state="translated">Une instance doit être passée lorsque le délégué est appelé.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, representing an open static method, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">Un délégué du type <ph id="ph1">`D2`</ph>, représentant une méthode statique ouverte, est créé pour la méthode statique <ph id="ph2">`M2`</ph>.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Finally, a delegate of type <ph id="ph1">`D3`</ph>, closed over a string, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">Enfin, un délégué du type <ph id="ph1">`D3`</ph>, fermé sur une chaîne, est créé pour la méthode statique <ph id="ph2">`M2`</ph>.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The method is invoked to show that it uses the bound string.</source>
          <target state="translated">La méthode est appelée pour illustrer l’utilisation de la chaîne liée.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Exemple 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example demonstrates compatibility of parameter types and return types.</source>
          <target state="translated">L’exemple de code suivant illustre la compatibilité des types de paramètres et types de retour.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
          <target state="translated">Cet exemple de code utilise le <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The use of other overloads that take <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is similar.</source>
          <target state="translated">L’utilisation d’autres surcharges qui prennent <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> est similaire.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example defines a base class named <ph id="ph1">`Base`</ph> and a class named <ph id="ph2">`Derived`</ph> that derives from <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">L’exemple de code définit une classe de base nommée <ph id="ph1">`Base`</ph> et une classe nommée <ph id="ph2">`Derived`</ph> qui dérive de <ph id="ph3">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The derived class has a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) method named <ph id="ph3">`MyMethod`</ph> with one parameter of type <ph id="ph4">`Base`</ph> and a return type of <ph id="ph5">`Derived`</ph>.</source>
          <target state="translated">La classe dérivée a un <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> en Visual Basic) méthode nommée <ph id="ph3">`MyMethod`</ph> avec un paramètre de type <ph id="ph4">`Base`</ph> et un type de retour de <ph id="ph5">`Derived`</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example also defines a delegate named <ph id="ph1">`Example`</ph> that has one parameter of type <ph id="ph2">`Derived`</ph> and a return type of <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">L’exemple de code définit également un délégué nommé <ph id="ph1">`Example`</ph> qui a un paramètre de type <ph id="ph2">`Derived`</ph> et un type de retour de <ph id="ph3">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example demonstrates that the delegate named <ph id="ph1">`Example`</ph> can be used to represent the method <ph id="ph2">`MyMethod`</ph>.</source>
          <target state="translated">L’exemple de code montre que le délégué nommé <ph id="ph1">`Example`</ph> peut être utilisé pour représenter la méthode <ph id="ph2">`MyMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The method can be bound to the delegate because:</source>
          <target state="translated">La méthode peut être liée au délégué, car :</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The parameter type of the delegate (<ph id="ph1">`Derived`</ph>) is more restrictive than the parameter type of <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), so that it is always safe to pass the argument of the delegate to <ph id="ph4">`MyMethod`</ph>.</source>
          <target state="translated">Le type de paramètre du délégué (<ph id="ph1">`Derived`</ph>) est plus restrictif que le type de paramètre de <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), afin qu’il soit toujours possible de passer l’argument du délégué à <ph id="ph4">`MyMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The return type of <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) is more restrictive than the parameter type of the delegate (<ph id="ph3">`Base`</ph>), so that it is always safe to cast the return type of the method to the return type of the delegate.</source>
          <target state="translated">Le type de retour de <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) est plus restrictif que le type de paramètre du délégué (<ph id="ph3">`Base`</ph>), afin qu’il soit toujours possible de convertir le type de retour de la méthode pour le type de retour du délégué.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example produces no output.</source>
          <target state="translated">L’exemple de code ne produit aucune sortie.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 3<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Exemple 3<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example shows all the methods a single delegate type can represent.</source>
          <target state="translated">L’exemple de code suivant montre toutes les méthodes de qu'un type délégué simple peut représenter.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify <ph id="ph2">`firstArgument`</ph> and a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">Il existe deux surcharges de la <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> méthode spécifier <ph id="ph2">`firstArgument`</ph> et un <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; leur fonctionnalité est identique, sauf qu’un vous permet de spécifier s’il faut lever en cas d’échec pour lier et l’autre lève toujours une exception.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses both overloads.</source>
          <target state="translated">Cet exemple de code utilise les deux surcharges.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example defines two classes, <ph id="ph1">`C`</ph> and <ph id="ph2">`F`</ph>, and a delegate type <ph id="ph3">`D`</ph> with one argument of type <ph id="ph4">`C`</ph>.</source>
          <target state="translated">L’exemple de code définit deux classes, <ph id="ph1">`C`</ph> et <ph id="ph2">`F`</ph>et un type délégué <ph id="ph3">`D`</ph> avec un argument de type <ph id="ph4">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The classes have matching static and instance methods <ph id="ph1">`M1`</ph>, <ph id="ph2">`M3`</ph>, and <ph id="ph3">`M4`</ph>, and class <ph id="ph4">`C`</ph> also has an instance method <ph id="ph5">`M2`</ph> that has no arguments.</source>
          <target state="translated">Les classes concordent statiques et les méthodes d’instance <ph id="ph1">`M1`</ph>, <ph id="ph2">`M3`</ph>, et <ph id="ph3">`M4`</ph>et la classe <ph id="ph4">`C`</ph> a également une méthode d’instance <ph id="ph5">`M2`</ph> qui dispose d’aucun argument.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A third class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">Une troisième classe nommée <ph id="ph1">`Example`</ph> contient le code qui crée les délégués.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Delegates are created for instance method <ph id="ph1">`M1`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; each is closed over an instance of the respective type.</source>
          <target state="translated">Les délégués sont créés pour l’instance de méthode <ph id="ph1">`M1`</ph> de type <ph id="ph2">`C`</ph> et type <ph id="ph3">`F`</ph>; chacun est fermé sur une instance du type respectif.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Method <ph id="ph1">`M1`</ph> of type <ph id="ph2">`C`</ph> displays the <ph id="ph3">`ID`</ph> properties of the bound instance and of the argument.</source>
          <target state="translated">Méthode <ph id="ph1">`M1`</ph> de type <ph id="ph2">`C`</ph> affiche les <ph id="ph3">`ID`</ph> propriétés de l’instance liée et de l’argument.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate is created for method <ph id="ph1">`M2`</ph> of type <ph id="ph2">`C`</ph>.</source>
          <target state="translated">Un délégué est créé pour la méthode <ph id="ph1">`M2`</ph> de type <ph id="ph2">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</source>
          <target state="translated">Il s’agit d’un délégué d’instance ouverte, dans laquelle l’argument du délégué représente le premier argument masqué sur la méthode d’instance.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The method has no other arguments.</source>
          <target state="translated">La méthode n’a aucun autre argument.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Delegates are created for static method <ph id="ph1">`M3`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; these are open static delegates.</source>
          <target state="translated">Les délégués sont créés pour la méthode statique <ph id="ph1">`M3`</ph> de type <ph id="ph2">`C`</ph> et type <ph id="ph3">`F`</ph>; ce sont des délégués statiques ouverts.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Finally, delegates are created for static method <ph id="ph1">`M4`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</source>
          <target state="translated">Enfin, les délégués sont créés pour la méthode statique <ph id="ph1">`M4`</ph> de type <ph id="ph2">`C`</ph> et type <ph id="ph3">`F`</ph>; chaque méthode a le type déclarant comme premier argument, et une instance du type est fournie, les délégués sont fermés sur leurs premiers arguments .</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Method <ph id="ph1">`M4`</ph> of type <ph id="ph2">`C`</ph> displays the <ph id="ph3">`ID`</ph> properties of the bound instance and of the argument.</source>
          <target state="translated">Méthode <ph id="ph1">`M4`</ph> de type <ph id="ph2">`C`</ph> affiche les <ph id="ph3">`ID`</ph> propriétés de l’instance liée et de l’argument.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n’hérite pas de <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Types au moment de l’exécution dans la réflexion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ne peut pas être lié et <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Types au moment de l’exécution dans la réflexion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> de <ph id="ph2">&lt;paramref name="type" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de délégué à créer.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The class instance on which <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> is invoked.</source>
          <target state="translated">Instance de classe sur laquelle <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> est appelé.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The name of the instance method that the delegate is to represent.</source>
          <target state="translated">Nom de la méthode d’instance que doit représenter le délégué.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
          <target state="translated">Valeur booléenne indiquant si la casse doit être ignorée pendant la comparaison du nom de la méthode.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance with the specified case-sensitivity.</source>
          <target state="translated">Crée un délégué du type spécifié qui représente la méthode d'instance spécifiée à appeler sur l'instance de classe spécifiée, avec le respect de la casse spécifié.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
          <target state="translated">Délégué du type spécifié qui représente la méthode d'instance spécifiée à appeler sur l'instance de classe spécifiée.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>This method creates delegates for instance methods only.</source>
          <target state="translated">Cette méthode crée des délégués pour l’instance des méthodes uniquement.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
          <target state="translated">Cette surcharge de méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> surcharge de méthode, en spécifiant <ph id="ph2">`true`</ph> pour <ph id="ph3">`throwOnBindFailure`</ph>.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>considérations de sécurité pour la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n’hérite pas de <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Types au moment de l’exécution dans la réflexion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not an instance method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> n’est pas une méthode d’instance.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ne peut pas être lié, ce qui peut arriver s’il est introuvable.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> de <ph id="ph2">&lt;paramref name="type" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de délégué à créer.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the class that implements <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> représentant la classe qui implémente <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The name of the static method that the delegate is to represent.</source>
          <target state="translated">Nom de la méthode statique que doit représenter le délégué.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
          <target state="translated">Valeur booléenne indiquant si la casse doit être ignorée pendant la comparaison du nom de la méthode.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity.</source>
          <target state="translated">Crée un délégué du type spécifié qui représente la méthode statique spécifiée de la classe spécifiée, avec le respect de la casse spécifié.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>A delegate of the specified type that represents the specified static method of the specified class.</source>
          <target state="translated">Délégué du type spécifié qui représente la méthode statique spécifiée de la classe spécifiée.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>This method creates delegates for static methods only.</source>
          <target state="translated">Cette méthode crée des délégués pour les méthodes statiques uniquement.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
          <target state="translated">Cette surcharge de méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> surcharge de méthode, en spécifiant <ph id="ph2">`true`</ph> pour <ph id="ph3">`throwOnBindFailure`</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>considérations de sécurité pour la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n’hérite pas de <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Types au moment de l’exécution dans la réflexion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> est un type générique ouvert.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>That is, its <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Autrement dit, sa propriété <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="static" /&gt;</ph> method (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> method in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> n’est pas une méthode <ph id="ph2">&lt;see langword="static" /&gt;</ph> (méthode <ph id="ph3">&lt;see langword="Shared" /&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ne peut pas être lié, ce qui peut arriver s’il est introuvable.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> de <ph id="ph2">&lt;paramref name="type" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de délégué à créer.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The class instance on which <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> is invoked.</source>
          <target state="translated">Instance de classe sur laquelle <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> est appelé.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The name of the instance method that the delegate is to represent.</source>
          <target state="translated">Nom de la méthode d’instance que doit représenter le délégué.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
          <target state="translated">Valeur booléenne indiquant si la casse doit être ignorée pendant la comparaison du nom de la méthode.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> cannot be bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour lever une exception si <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> ne peut pas être lié ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance, with the specified case-sensitivity and the specified behavior on failure to bind.</source>
          <target state="translated">Crée un délégué du type spécifié qui représente la méthode d'instance spécifiée à appeler sur l'instance de classe spécifiée, avec le respect de la casse spécifié et le comportement spécifié en cas d'échec de la liaison.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
          <target state="translated">Délégué du type spécifié qui représente la méthode d'instance spécifiée à appeler sur l'instance de classe spécifiée.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>This method creates delegates for instance methods only.</source>
          <target state="translated">Cette méthode crée des délégués pour l’instance des méthodes uniquement.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>considérations de sécurité pour la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n’hérite pas de <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Types au moment de l’exécution dans la réflexion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not an instance method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> n’est pas une méthode d’instance.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ne peut pas être lié, par exemple car elle est introuvable, et <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> de <ph id="ph2">&lt;paramref name="type" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de délégué à créer.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the class that implements <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> représentant la classe qui implémente <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The name of the static method that the delegate is to represent.</source>
          <target state="translated">Nom de la méthode statique que doit représenter le délégué.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
          <target state="translated">Valeur booléenne indiquant si la casse doit être ignorée pendant la comparaison du nom de la méthode.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> cannot be bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour lever une exception si <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> ne peut pas être lié ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity and the specified behavior on failure to bind.</source>
          <target state="translated">Crée un délégué du type spécifié qui représente la méthode statique spécifiée de la classe spécifiée, avec le respect de la casse spécifié et le comportement spécifié en cas d'échec de la liaison.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>A delegate of the specified type that represents the specified static method of the specified class.</source>
          <target state="translated">Délégué du type spécifié qui représente la méthode statique spécifiée de la classe spécifiée.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>This method creates delegates for static methods only.</source>
          <target state="translated">Cette méthode crée des délégués pour les méthodes statiques uniquement.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, cette méthode peut être utilisée pour accéder à des méthodes non publiques si l’appelant a été accordé <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> indicateur et si le jeu d’autorisations des méthodes non publiques est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consultez <bpt id="p1">[</bpt>considérations de sécurité pour la réflexion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Pour utiliser cette fonctionnalité, votre application doit cibler <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n’hérite pas de <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Types au moment de l’exécution dans la réflexion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> est un type générique ouvert.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>That is, its <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Autrement dit, sa propriété <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="static" /&gt;</ph> method (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> method in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> n’est pas une méthode <ph id="ph2">&lt;see langword="static" /&gt;</ph> (méthode <ph id="ph3">&lt;see langword="Shared" /&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ne peut pas être lié, par exemple car elle est introuvable, et <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> de <ph id="ph2">&lt;paramref name="type" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne dispose pas des autorisations nécessaires pour accéder à <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>An array of objects that are the arguments to pass to the method represented by the current delegate.</source>
          <target state="translated">Tableau d’objets correspondants aux arguments à passer à la méthode représentée par le délégué actuel.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph>, if the method represented by the current delegate does not require arguments.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, si la méthode représentée par le délégué en cours ne requiert pas d'arguments.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>Dynamically invokes (late-bound) the method represented by the current delegate.</source>
          <target state="translated">Appelle de manière dynamique (avec liaison tardive) la méthode représentée par le délégué actuel.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The object returned by the method represented by the delegate.</source>
          <target state="translated">Objet retourné par la méthode représentée par le délégué.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>This method calls the <ph id="ph1">&lt;xref:System.Delegate.DynamicInvokeImpl%2A&gt;</ph> method.</source>
          <target state="translated">Cette méthode appelle la méthode <ph id="ph1">&lt;xref:System.Delegate.DynamicInvokeImpl%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">L’appelant n’a pas accès à la méthode représentée par le délégué (par exemple, si la méthode est privée).</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The number, order, or type of parameters listed in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> is invalid.</source>
          <target state="translated">Le nombre, l'ordre ou le type des paramètres répertoriés dans <ph id="ph1">&lt;paramref name="args" /&gt;</ph> n'est pas valide.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The method represented by the delegate is invoked on an object or a class that does not support it.</source>
          <target state="translated">La méthode représentée par le délégué est appelée sur un objet ou une classe qui ne la prend pas en charge.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The method represented by the delegate is an instance method and the target object is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La méthode représentée par ce délégué est une méthode d'instance et l'objet cible est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>One of the encapsulated methods throws an exception.</source>
          <target state="translated">L'une des méthodes encapsulées lève une exception.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>An array of objects that are the arguments to pass to the method represented by the current delegate.</source>
          <target state="translated">Tableau d’objets correspondants aux arguments à passer à la méthode représentée par le délégué actuel.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph>, if the method represented by the current delegate does not require arguments.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, si la méthode représentée par le délégué en cours ne requiert pas d'arguments.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>Dynamically invokes (late-bound) the method represented by the current delegate.</source>
          <target state="translated">Appelle de manière dynamique (avec liaison tardive) la méthode représentée par le délégué actuel.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The object returned by the method represented by the delegate.</source>
          <target state="translated">Objet retourné par la méthode représentée par le délégué.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>This method implements the <ph id="ph1">&lt;xref:System.Delegate.DynamicInvoke%2A&gt;</ph> method.</source>
          <target state="translated">Cette méthode implémente la méthode <ph id="ph1">&lt;xref:System.Delegate.DynamicInvoke%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">L’appelant n’a pas accès à la méthode représentée par le délégué (par exemple, si la méthode est privée).</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The number, order, or type of parameters listed in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> is invalid.</source>
          <target state="translated">Le nombre, l'ordre ou le type des paramètres répertoriés dans <ph id="ph1">&lt;paramref name="args" /&gt;</ph> n'est pas valide.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The method represented by the delegate is invoked on an object or a class that does not support it.</source>
          <target state="translated">La méthode représentée par le délégué est appelée sur un objet ou une classe qui ne la prend pas en charge.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The method represented by the delegate is an instance method and the target object is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La méthode représentée par ce délégué est une méthode d'instance et l'objet cible est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>One of the encapsulated methods throws an exception.</source>
          <target state="translated">L'une des méthodes encapsulées lève une exception.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Delegate.Equals(System.Object)">
          <source>The object to compare with the current delegate.</source>
          <target state="translated">L’objet à comparer avec le délégué actuel.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Delegate.Equals(System.Object)">
          <source>Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</source>
          <target state="translated">Détermine si l'objet spécifié et le délégué actuel sont du même type et partagent les mêmes cibles, méthodes et liste d'appel.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Delegate.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> and the current delegate have the same targets, methods, and invocation list; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> et le délégué actuel ont les mêmes cibles, méthodes et liste d’appel ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>If the two delegates are not of the same type, they are not considered equal.</source>
          <target state="translated">Si les deux délégués ne sont pas du même type, elles ne sont pas considérées égales.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</source>
          <target state="translated">Dans la version 1.0 et 1.1 du .NET Framework, deux délégués ont été considérées comme égales si leurs cibles, méthodes et liste d’appel sont égales, même si les délégués sont de types différents.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>The methods and targets are compared for equality as follows:</source>
          <target state="translated">Les méthodes et les cibles sont comparées pour l’égalité, comme suit :</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">Si les deux méthodes comparées sont statiques et représentent la même méthode sur la même classe, les méthodes sont considérées comme égales et les cibles sont considérées comme égales.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">Si les deux méthodes comparées sont des méthodes d’instance et la même méthode sur le même objet, les méthodes sont considérées comme égales et les cibles sont considérées comme égales.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</source>
          <target state="translated">Sinon, les méthodes ne sont pas considérés comme égal et les cibles sont également pas considérées comme égales.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>Two invocation lists are considered identical only if they have the same order and the corresponding elements from the two lists represent the same method and target.</source>
          <target state="translated">Deux listes d’appel sont considérés comme identiques uniquement si elles ont le même ordre et les éléments correspondants dans les deux listes représentent la même méthode et la cible.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Delegate.Equals(System.Object)">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">L’appelant n’a pas accès à la méthode représentée par le délégué (par exemple, si la méthode est privée).</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetHashCode">
          <source>Returns a hash code for the delegate.</source>
          <target state="translated">Retourne un code de hachage pour le délégué.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetHashCode">
          <source>A hash code for the delegate.</source>
          <target state="translated">Code de hachage du délégué.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>The return value of this method must not be persisted for two reasons.</source>
          <target state="translated">La valeur de retour de cette méthode ne doit pas être persistante pour deux raisons.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>First, the hash function of a class might be altered to generate a better distribution, rendering any values from the old hash function useless.</source>
          <target state="translated">Tout d’abord, la fonction de hachage d’une classe peut être modifiée pour générer une meilleure distribution, toutes les valeurs de l’ancienne fonction de hachage de rendu inutile.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>Second, the default implementation of this class does not guarantee that the same value will be returned by different instances.</source>
          <target state="translated">En second lieu, l’implémentation par défaut de cette classe ne garantit pas que la même valeur s’affichera par instances différentes.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetInvocationList">
          <source>Returns the invocation list of the delegate.</source>
          <target state="translated">Retourne la liste d'appel du délégué.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetInvocationList">
          <source>An array of delegates representing the invocation list of the current delegate.</source>
          <target state="translated">Tableau de délégués représentant la liste d'appel du délégué actuel.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>Each delegate in the array represents exactly one method.</source>
          <target state="translated">Chaque délégué du tableau représente une seule méthode.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>The order of the delegates in the array is the same order in which the current delegate invokes the methods that those delegates represent.</source>
          <target state="translated">L’ordre des délégués dans le tableau est le même ordre que celui dans lequel le délégué actuel appelle les méthodes représentées par ces délégués.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>The following example assigns three methods to a delegate.</source>
          <target state="translated">L’exemple suivant affecte les trois méthodes à un délégué.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>It then calls the  <ph id="ph1">&lt;xref:System.Delegate.GetInvocationList%2A&gt;</ph> method to get a total count of the methods assigned to the delegate, to execute the delegates in reverse order, and to execute the methods whose name do not include the substring "File".</source>
          <target state="translated">Il appelle ensuite la <ph id="ph1">&lt;xref:System.Delegate.GetInvocationList%2A&gt;</ph> méthode pour obtenir le nombre total des méthodes assignée au délégué, à exécuter dans l’ordre inverse des délégués et pour exécuter les méthodes dont le nom n’incluent pas la sous-chaîne « Fichier ».</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetMethodImpl">
          <source>Gets the static method represented by the current delegate.</source>
          <target state="translated">Obtient la méthode statique représentée par le délégué actuel.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetMethodImpl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static method represented by the current delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> décrivant la méthode statique représentée par le délégué en cours.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetMethodImpl">
          <source>This method applies only if the current delegate represents a static method.</source>
          <target state="translated">Cette méthode s’applique uniquement si le délégué actuel représente une méthode statique.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetMethodImpl">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">L’appelant n’a pas accès à la méthode représentée par le délégué (par exemple, si la méthode est privée).</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetMethodImpl">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetMethodImpl">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Not supported.</source>
          <target state="translated">Non pris en charge.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Not supported.</source>
          <target state="translated">Non pris en charge.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Not supported.</source>
          <target state="translated">Non pris en charge.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This method is not supported.</source>
          <target state="translated">Cette méthode n'est pas prise en charge.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="P:System.Delegate.Method">
          <source>Gets the method represented by the delegate.</source>
          <target state="translated">Obtient la méthode représentée par le délégué.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Method">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the method represented by the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> décrivant la méthode représentée par le délégué.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="P:System.Delegate.Method">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">L’appelant n’a pas accès à la méthode représentée par le délégué (par exemple, si la méthode est privée).</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Method">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Method">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>The first delegate to compare.</source>
          <target state="translated">Premier délégué à comparer.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>The second delegate to compare.</source>
          <target state="translated">Second délégué à comparer.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Determines whether the specified delegates are equal.</source>
          <target state="translated">Détermine si les délégués spécifiés sont égaux.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="d1" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="d2" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="d1" /&gt;</ph> est égal à <ph id="ph3">&lt;paramref name="d2" /&gt;</ph> ; sinon <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Two delegates of the same type with the same targets, methods, and invocation lists are considered equal.</source>
          <target state="translated">Deux délégués du même type avec les mêmes cibles, méthodes et listes d’appel sont considérées comme égales.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>If the two delegates are not of the same type, they are not considered equal.</source>
          <target state="translated">Si les deux délégués ne sont pas du même type, elles ne sont pas considérées égales.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</source>
          <target state="translated">Dans la version 1.0 et 1.1 du .NET Framework, deux délégués ont été considérées comme égales si leurs cibles, méthodes et liste d’appel sont égales, même si les délégués sont de types différents.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>The methods and targets are compared for equality as follows:</source>
          <target state="translated">Les méthodes et les cibles sont comparées pour l’égalité, comme suit :</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">Si les deux méthodes comparées sont statiques et représentent la même méthode sur la même classe, les méthodes sont considérées comme égales et les cibles sont considérées comme égales.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">Si les deux méthodes comparées sont des méthodes d’instance et la même méthode sur le même objet, les méthodes sont considérées comme égales et les cibles sont considérées comme égales.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</source>
          <target state="translated">Sinon, les méthodes ne sont pas considérés comme égal et les cibles sont également pas considérées comme égales.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Two invocation lists are considered identical if they have the same order and the corresponding elements from the two lists represent the same method and target.</source>
          <target state="translated">Deux listes d’appel sont considérés comme identiques si elles ont le même ordre et les éléments correspondants dans les deux listes représentent la même méthode et la cible.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">La méthode équivalente pour cet opérateur est <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>The first delegate to compare.</source>
          <target state="translated">Premier délégué à comparer.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>The second delegate to compare.</source>
          <target state="translated">Second délégué à comparer.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Determines whether the specified delegates are not equal.</source>
          <target state="translated">Détermine si les délégués spécifiés ne sont pas égaux.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="d1" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="d2" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="d1" /&gt;</ph> n'est pas égal à <ph id="ph3">&lt;paramref name="d2" /&gt;</ph> ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Two delegates are considered not equal if they are of different types, or have different methods, different targets, or different invocation lists.</source>
          <target state="translated">Deux délégués sont considérés comme pas égaux s’ils sont de types différents, ou ont différentes méthodes, les différentes cibles ou les listes d’appel.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>If the two delegates are not of the same type, they are not considered equal.</source>
          <target state="translated">Si les deux délégués ne sont pas du même type, elles ne sont pas considérées égales.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>In the .NET Framework version 1.0 and 1.1, two delegates are considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</source>
          <target state="translated">Dans la version 1.0 et 1.1 du .NET Framework, deux délégués sont considérées comme égales si leurs cibles, méthodes et liste d’appel sont égales, même si les délégués sont de types différents.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>The methods and targets are compared for equality as follows:</source>
          <target state="translated">Les méthodes et les cibles sont comparées pour l’égalité, comme suit :</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">Si les deux méthodes comparées sont statiques et représentent la même méthode sur la même classe, les méthodes sont considérées comme égales et les cibles sont considérées comme égales.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">Si les deux méthodes comparées sont des méthodes d’instance et la même méthode sur le même objet, les méthodes sont considérées comme égales et les cibles sont considérées comme égales.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</source>
          <target state="translated">Sinon, les méthodes ne sont pas considérés comme égal et les cibles sont également pas considérées comme égales.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Two invocation lists are not equal if they have different sizes, if they are ordered differently, or if at least one element from one list represents a method or target that is different from that represented by its corresponding element in the other list.</source>
          <target state="translated">Deux listes d’appel ne sont pas égales si elles ont différentes tailles, si elles sont organisées différemment, ou si au moins un élément d’une liste représente une méthode ou une cible qui est différente de celle représentée par l’élément correspondant dans l’autre liste.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">La méthode équivalente pour cet opérateur est <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>The delegate from which to remove the invocation list of <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Délégué dans lequel supprimer la liste d’invocation de <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>The delegate that supplies the invocation list to remove from the invocation list of <bpt id="p1">&lt;c&gt;</bpt>source<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Délégué qui fournit la liste d’invocation à supprimer de la liste d’invocation de <bpt id="p1">&lt;c&gt;</bpt>source<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</source>
          <target state="translated">Supprime la dernière occurrence de la liste d'appel d'un délégué dans la liste d'appel d'un autre délégué.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>A new delegate with an invocation list formed by taking the invocation list of <ph id="ph1">&lt;paramref name="source" /&gt;</ph> and removing the last occurrence of the invocation list of <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, if the invocation list of <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found within the invocation list of <ph id="ph4">&lt;paramref name="source" /&gt;</ph>.</source>
          <target state="translated">Nouveau délégué avec une liste d'appel générée à partir de la liste d'appel de <ph id="ph1">&lt;paramref name="source" /&gt;</ph> de laquelle est supprimée la dernière occurrence de la liste d'appel de <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, si la liste d'appel de <ph id="ph3">&lt;paramref name="value" /&gt;</ph> figure dans la liste d'appel de <ph id="ph4">&lt;paramref name="source" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>Returns <ph id="ph1">&lt;paramref name="source" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or if the invocation list of <ph id="ph4">&lt;paramref name="value" /&gt;</ph> is not found within the invocation list of <ph id="ph5">&lt;paramref name="source" /&gt;</ph>.</source>
          <target state="translated">Retourne <ph id="ph1">&lt;paramref name="source" /&gt;</ph>, si <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est <ph id="ph3">&lt;see langword="null" /&gt;</ph>, ou si la liste d'appel de <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ne figure pas dans la liste d'appel de <ph id="ph5">&lt;paramref name="source" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>Returns a null reference if the invocation list of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is equal to the invocation list of <ph id="ph2">&lt;paramref name="source" /&gt;</ph> or if <ph id="ph3">&lt;paramref name="source" /&gt;</ph> is a null reference.</source>
          <target state="translated">Retourne une référence null si la liste d'appel de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est égale à la liste d'appel de <ph id="ph2">&lt;paramref name="source" /&gt;</ph>, ou si <ph id="ph3">&lt;paramref name="source" /&gt;</ph> est une référence null.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> matches a contiguous set of elements in the invocation list of <ph id="ph2">`source`</ph>, then the invocation list of <ph id="ph3">`value`</ph> is said to occur within the invocation list of <ph id="ph4">`source`</ph>.</source>
          <target state="translated">Si la liste d’appel de <ph id="ph1">`value`</ph> correspond à un ensemble contigu d’éléments dans la liste d’appel de <ph id="ph2">`source`</ph>, puis la liste d’appel de <ph id="ph3">`value`</ph> apparaît dans la liste d’appel de <ph id="ph4">`source`</ph>.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> occurs more than once in the invocation list of <ph id="ph2">`source`</ph>, the last occurrence is removed.</source>
          <target state="translated">Si la liste d’appel de <ph id="ph1">`value`</ph> apparaît plusieurs fois dans la liste d’appel de <ph id="ph2">`source`</ph>, la dernière occurrence est supprimée.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">L’appelant n’a pas accès à la méthode représentée par le délégué (par exemple, si la méthode est privée).</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>The delegate types do not match.</source>
          <target state="translated">Les types délégués ne correspondent pas.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>The delegate from which to remove the invocation list of <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Délégué dans lequel supprimer la liste d’invocation de <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>The delegate that supplies the invocation list to remove from the invocation list of <bpt id="p1">&lt;c&gt;</bpt>source<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Délégué qui fournit la liste d’invocation à supprimer de la liste d’invocation de <bpt id="p1">&lt;c&gt;</bpt>source<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</source>
          <target state="translated">Supprime toutes les occurrences de la liste d'appel d'un délégué dans la liste d'appel d'un autre délégué.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>A new delegate with an invocation list formed by taking the invocation list of <ph id="ph1">&lt;paramref name="source" /&gt;</ph> and removing all occurrences of the invocation list of <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, if the invocation list of <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found within the invocation list of <ph id="ph4">&lt;paramref name="source" /&gt;</ph>.</source>
          <target state="translated">Nouveau délégué avec une liste d'appel générée à partir de la liste d'appel de <ph id="ph1">&lt;paramref name="source" /&gt;</ph> de laquelle est supprimée toutes les occurrences de la liste d'appel de <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, si la liste d'appel de <ph id="ph3">&lt;paramref name="value" /&gt;</ph> figure dans la liste d'appel de <ph id="ph4">&lt;paramref name="source" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>Returns <ph id="ph1">&lt;paramref name="source" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or if the invocation list of <ph id="ph4">&lt;paramref name="value" /&gt;</ph> is not found within the invocation list of <ph id="ph5">&lt;paramref name="source" /&gt;</ph>.</source>
          <target state="translated">Retourne <ph id="ph1">&lt;paramref name="source" /&gt;</ph>, si <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est <ph id="ph3">&lt;see langword="null" /&gt;</ph>, ou si la liste d'appel de <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ne figure pas dans la liste d'appel de <ph id="ph5">&lt;paramref name="source" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>Returns a null reference if the invocation list of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is equal to the invocation list of <ph id="ph2">&lt;paramref name="source" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="source" /&gt;</ph> contains only a series of invocation lists that are equal to the invocation list of <ph id="ph4">&lt;paramref name="value" /&gt;</ph>, or if <ph id="ph5">&lt;paramref name="source" /&gt;</ph> is a null reference.</source>
          <target state="translated">Retourne une référence null si la liste d'appel de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est égale à la liste d'appel de <ph id="ph2">&lt;paramref name="source" /&gt;</ph>, si <ph id="ph3">&lt;paramref name="source" /&gt;</ph> contient uniquement une série de listes d'appel égales à la liste d'appel de <ph id="ph4">&lt;paramref name="value" /&gt;</ph>, ou si <ph id="ph5">&lt;paramref name="source" /&gt;</ph> est une référence null.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> matches a contiguous set of elements in the invocation list of <ph id="ph2">`source`</ph>, then the invocation list of <ph id="ph3">`value`</ph> is said to occur within the invocation list of <ph id="ph4">`source`</ph>.</source>
          <target state="translated">Si la liste d’appel de <ph id="ph1">`value`</ph> correspond à un ensemble contigu d’éléments dans la liste d’appel de <ph id="ph2">`source`</ph>, puis la liste d’appel de <ph id="ph3">`value`</ph> apparaît dans la liste d’appel de <ph id="ph4">`source`</ph>.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> occurs more than once in the invocation list of <ph id="ph2">`source`</ph>, all occurrences are removed.</source>
          <target state="translated">Si la liste d’appel de <ph id="ph1">`value`</ph> apparaît plusieurs fois dans la liste d’appel <ph id="ph2">`source`</ph>, toutes les occurrences sont supprimées.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">L’appelant n’a pas accès à la méthode représentée par le délégué (par exemple, si la méthode est privée).</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>The delegate types do not match.</source>
          <target state="translated">Les types délégués ne correspondent pas.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>The delegate that supplies the invocation list to remove from the invocation list of the current delegate.</source>
          <target state="translated">Délégué fournissant la liste d'appel à supprimer de la liste d'appel du délégué en cours.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>Removes the invocation list of a delegate from the invocation list of another delegate.</source>
          <target state="translated">Supprime la liste d'appel d'un délégué de la liste d'appel d'un autre délégué.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>A new delegate with an invocation list formed by taking the invocation list of the current delegate and removing the invocation list of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, if the invocation list of <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is found within the current delegate's invocation list.</source>
          <target state="translated">Nouveau délégué dont la liste d'appel est générée à partir de la liste d'appel du délégué en cours, de laquelle est supprimée la liste d'appel de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, si la liste d'appel de <ph id="ph2">&lt;paramref name="value" /&gt;</ph> figure dans la liste d'appel du délégué en cours.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>Returns the current delegate if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or if the invocation list of <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is not found within the current delegate's invocation list.</source>
          <target state="translated">Retourne le délégué en cours, si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>, ou si la liste d'appel de <ph id="ph3">&lt;paramref name="value" /&gt;</ph> ne figure pas dans la liste d'appel du délégué en cours.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>Returns <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the invocation list of <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is equal to the current delegate's invocation list.</source>
          <target state="translated">Retourne <ph id="ph1">&lt;see langword="null" /&gt;</ph> si la liste d'appel de <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est égale à la liste d'appel du délégué en cours.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> matches a contiguous set of elements in the current delegate's invocation list, then the invocation list of <ph id="ph2">`value`</ph> is said to occur within the current delegate's invocation list.</source>
          <target state="translated">Si la liste d’appel de <ph id="ph1">`value`</ph> correspond à un ensemble contigu d’éléments dans la liste d’appel du délégué en cours, puis la liste d’appel <ph id="ph2">`value`</ph> apparaît dans la liste d’appel du délégué actuel.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> occurs more than once in the current delegate's invocation list, the last occurrence is removed.</source>
          <target state="translated">Si la liste d’appel <ph id="ph1">`value`</ph> est présent plusieurs fois dans la liste d’appel du délégué en cours, la dernière occurrence est supprimée.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">L’appelant n’a pas accès à la méthode représentée par le délégué (par exemple, si la méthode est privée).</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="P:System.Delegate.Target">
          <source>Gets the class instance on which the current delegate invokes the instance method.</source>
          <target state="translated">Obtient l'instance de classe sur laquelle le délégué actuel appelle la méthode d'instance.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>The object on which the current delegate invokes the instance method, if the delegate represents an instance method; <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the delegate represents a static method.</source>
          <target state="translated">Objet sur lequel le délégué en cours appelle la méthode d'instance, si le délégué représente une méthode d'instance ; <ph id="ph1">&lt;see langword="null" /&gt;</ph> si le délégué représente une méthode statique.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Une méthode d’instance est une méthode qui est associée à une instance d’une classe ; une méthode statique est une méthode qui est associée à la classe elle-même.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>If the delegate invokes one or more instance methods, this property returns the target of the last instance method in the invocation list.</source>
          <target state="translated">Si le délégué appelle une ou plusieurs méthodes d’instance, cette propriété retourne la cible de la dernière méthode d’instance dans la liste d’appel.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>