<Type Name="Uri" FullName="System.Uri">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bc748165070ca7c2fc35cc5a3d821923907161f7" />
    <Meta Name="ms.sourcegitcommit" Value="41742a1055cefdeaf2f9d76364f4bad3c9f83126" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/16/2018" />
    <Meta Name="ms.locfileid" Value="48689797" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Uri : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Uri extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Uri" />
  <TypeSignature Language="VB.NET" Value="Public Class Uri&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Uri : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Uri = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit une représentation objet d'un URI (Uniform Resource Identifier) et un accès simplifié aux parties de l'identificateur.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un URI est une représentation compacte d’une ressource disponible pour votre application sur l’intranet ou Internet. Le <xref:System.Uri> classe définit les propriétés et méthodes pour la gestion des URI, y compris l’analyse, la comparaison et la combinaison. Le <xref:System.Uri> propriétés de la classe sont en lecture seule ; pour créer un objet modifiable, utilisez la <xref:System.UriBuilder> classe.  
  
 URI relatifs (par exemple, « / /New/index.htm ») doit être développée en ce qui concerne un URI de base afin qu’ils soient absolus. Le <xref:System.Uri.MakeRelative%2A> méthode est fournie pour convertir les URI absolus vers les URI relatifs lorsque cela est nécessaire.  
  
 Le <xref:System.Uri> constructeurs n’échappent pas les chaînes URI si la chaîne est un URI bien formé, y compris un identificateur de schéma.  
  
 Le <xref:System.Uri> propriétés retournent une représentation de données canonique dans le codage avec séquence d’échappement, avec tous les caractères avec les valeurs Unicode supérieures à 127 étant remplacés par leurs équivalents hexadécimaux. Pour mettre l’URI au format réglementaire, le <xref:System.Uri> constructeur effectue les étapes suivantes :  
  
-   Convertit le schéma d’URI en minuscules.  
  
-   Convertit le nom d’hôte en minuscules.  
  
-   Si le nom d’hôte est une adresse IPv6, l’adresse IPv6 canonique est utilisé. ScopeId et autres données IPv6 facultatives sont supprimées.  
  
-   Supprime la valeur par défaut et les numéros de port vide.

-   Caractères d’échappement (également appelé octets encodés en pourcentage) qui n’ont pas un objectif réservé sont décodés (également appelé en cours sans séquence d’échappement). Ces caractères non réservés sont en majuscules et minuscules (% 41-% 5 a et % 61-% 7 a), des traits d’union de chiffres décimaux (30-% 39), (% 2D), la période (% 2E), trait de soulignement (% 5F) et de tilde (7E %).

-   Canonicalise tels que le chemin d’accès pour les URI hiérarchique en séquences /. /, /... /, et / / (ou non la séquence est ignorée). Notez qu’il n’y a certains schémas pour lesquels ces séquences ne sont pas compactées.
  
-   Pour les URI hiérarchiques, si l’hôte n’est pas terminé par une barre oblique (/), une est ajoutée.  
  
-   Par défaut, tous les caractères réservés dans l’URI sont échappés conformément à la norme RFC 2396. Ce comportement change si International Resource Identifiers ou nom de domaine International l’analyse est activée dans les cas les caractères réservés dans l’URI est échappés conformément à RFC 3986 et RFC 3987.

 Dans le cadre de la canonisation dans le constructeur de certains schémas, les segments de points et les segments vides (/. /, /.. /, et / /) sont compactés (en d’autres termes, ils sont supprimés). Les schémas pour lesquels URI compactera ces séquences sont http, https, tcp, net.pipe et net.tcp. Pour certains autres modèles, ces séquences ne sont pas compactées. Voici à quoi ce compactage ressemble en pratique.
  
```  
var uri = new Uri("http://myUrl/../.."); // http scheme, unescaped
OR
var uri = new Uri("http://myUrl/%2E%2E/%2E%2E"); // http scheme, escaped
OR
var uri = new Uri("ftp://myUrl/../.."); // ftp scheme, unescaped
OR
var uri = new Uri("ftp://myUrl/%2E%2E/%2E%2E"); // ftp scheme, escaped

Console.WriteLine(uri.AbsoluteUri);  
Console.WriteLine(uri.PathAndQuery);  
```  
  
 Lorsque ce code est exécuté, il retourne la sortie suivante, avec les séquences d’échappement sans séquence d’échappement si nécessaire et puis compactés.

```  
http://myUrl/  
/  
```  
  
 Vous pouvez transformer le contenu de la <xref:System.Uri> classe à partir d’une référence d’URI d’échappement encodée en une référence URI lisible à l’aide de la <xref:System.Uri.ToString%2A> (méthode). Notez que certains caractères réservés peuvent encore être échappé dans la sortie de la <xref:System.Uri.ToString%2A> (méthode). Il s’agit pour prendre en charge la reconstitution non équivoque d’un URI à partir de la valeur retournée par <xref:System.Uri.ToString%2A>.  
  
 Certains URI comprennent un identificateur de fragment ou une requête ou les deux. Un identificateur de fragment est n’importe quel texte qui suit un signe dièse (#), sans le signe dièse ; le texte de fragment est stocké dans le <xref:System.Uri.Fragment%2A> propriété. Informations de requête sont n’importe quel texte qui suit un point d’interrogation ( ?) dans l’URI ; le texte de requête est stocké dans le <xref:System.Uri.Query%2A> propriété.  
  
 Dans le .NET Framework version 1.1, si la chaîne spécifiée à un constructeur contient un schéma inconnu et « c:\\», les insertions de classe Uri « / / » après le signe deux-points. Par exemple, l’URI `xyz:c:\abc` est convertie en `xyz://c:/abc`. Dans le .NET Framework version 2.0, ce comportement a été supprimé, et l’exemple de chaîne est convertie en `xyz:c:/abc`.  
  
> [!NOTE]
>  La classe URI prend en charge l’utilisation d’adresses IP dans les deux quad-notation du protocole IPv4 et deux points-hexadécimal du protocole IPv6. N’oubliez pas d’inclure l’adresse IPv6 entre crochets, comme dans http://[::1].  
  
## <a name="international-resource-identifier-support"></a>Prise en charge de ressource internationalisée identificateur  
 Adresses Web sont généralement exprimées à l’aide d’identificateurs de ressource uniforme qui se composent d’un jeu de caractères très limité :  
  
-   Lettres ASCII minuscules et majuscules de l’alphabet anglais.  
  
-   Chiffres de 0 à 9.  
  
-   Un petit nombre d’autres symboles ASCII.  
  
 Les spécifications pour les URI sont documentées dans la norme RFC 2396, RFC 2732, RFC 3986 et RFC 3987 publiée par Internet Engineering Task Force (IETF).  
  
 Avec l’essor d’Internet, l’identification de ressources utilisant d’autres langues que l’anglais devient de plus en plus nécessaire. Les identificateurs IRI (International Resource Identifier) sont des identificateurs qui permettent de répondre à ce besoin et d’utiliser des caractères non ASCII (ceux du jeu de caractères Unicode/ISO 10646). Les spécifications applicables aux IRI sont documentées dans la norme RFC 3987 publiée par l’IETF. L’utilisation d’IRI permet l’emploi de caractères Unicode dans les URL.  
  
 Existant <xref:System.Uri> classe a été étendue dans .NET Framework v3.5, 3.0 SP1 et 2.0 SP1 pour fournir la prise en charge IRI basée sur RFC 3987. Les utilisateurs des versions de .NET Framework avant la version 4.5 ne verront pas de toute modification du comportement de .NET Framework 2.0, sauf si ils activent spécifiquement les IRI. Cela garantit la compatibilité des applications avec les versions antérieures de .NET Framework.  
  
 Pour activer la prise en charge des IRI, la modification suivante est requise :  
  
-   Spécifiez si vous souhaitez que l’analyse de nom de domaine international (IDN) appliquée au nom de domaine et si les règles d’analyse IRI doivent être appliquée. Cela est possible le *machine.config* ou dans le *app.config* fichier. Par exemple, ajoutez ce qui suit :  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Les utilisateurs de .NET Framework 4.5 et versions ultérieures ont toujours des IRI est activée. L’analyse des IRI ne peut pas être modifié à l’aide un *.config* fichier.  
  
 L’activation des IDN entraîne la conversion de toutes les étiquettes Unicode d’un nom de domaine en leurs équivalents Punycode. Les noms Punycode contiennent uniquement des caractères ASCII et commencent toujours par le préfixe xn--. Cela permet de garantir la prise en charge des serveurs DNS existants sur Internet, la plupart d’entre eux prenant uniquement en charge les caractères ASCII (consultez la norme RFC 3940).  
  
 L’activation des IRI et des IDN entraîne une modification de la valeur de la propriété <xref:System.Uri.DnsSafeHost%2A?displayProperty=nameWithType>. Cela peut aussi changer le comportement des méthodes <xref:System.Uri.Equals%2A>, <xref:System.Uri.OriginalString%2A>, <xref:System.Uri.GetComponents%2A> et <xref:System.Uri.IsWellFormedOriginalString%2A>.  
  
 Il existe trois valeurs possibles pour l’IDN selon les serveurs DNS qui sont utilisés :  
  
-   IDN activé = All  
  
     Cette valeur convertit tous les noms de domaine Unicode en leurs équivalents Punycode (noms IDN).  
  
-   IDN activé = AllExceptIntranet  
  
     Cette valeur convertit tous les noms de domaine Unicode pas sur l’Intranet local pour utiliser les équivalents Punycode (noms IDN). Dans ce cas pour gérer des noms internationaux sur l’Intranet local, les serveurs DNS qui sont utilisés pour l’Intranet doivent prendre en charge résolution de noms Unicode.  
  
-   IDN activé = None  
  
     Cette valeur ne convertit aucun nom de domaine Unicode pour utiliser Punycode. Il s’agit de la valeur par défaut qui est cohérente avec le comportement de .NET Framework 2.0.  
  
 Lorsque l’analyse des IRI est activé (iriParsing activé = `true`) normalisation et la vérification des caractères sont effectuées selon les dernières règles IRI de RFC 3986 et RFC 3987. Lorsque l’analyse des IRI est désactivé, la normalisation et la vérification des caractères sont exécutées selon la norme RFC 2396 et RFC 2732 (pour les littéraux IPv6).  Dans les versions du .NET Framework avant la version 4.5, la valeur par défaut est `false`. Dans .NET Framework version 4.5 et versions ultérieures, la valeur par défaut est `true`, et l’état activé de l’analyse des IRI ne peut pas être modifiée par les paramètres dans un *.config* fichier.  
  
 IRI et traitement des IDN dans la <xref:System.Uri> classe peut également être contrôlée à l’aide de la <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType>, <xref:System.Configuration.IdnElement?displayProperty=nameWithType>, et <xref:System.Configuration.UriSection?displayProperty=nameWithType> classes de paramètres de configuration. Le paramètre <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> active ou désactive le traitement des IRI dans la classe <xref:System.Uri>. Le paramètre <xref:System.Configuration.IdnElement?displayProperty=nameWithType> active ou désactive le traitement des IDN dans la classe <xref:System.Uri>. Le paramètre <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> contrôle également indirectement les IDN. Le traitement des IRI doit être activé pour permettre le traitement des IDN. Si le traitement des IRI est désactivé, le traitement des IDN est effectué selon le paramètre par défaut (le comportement de .NET Framework 2.0 est utilisé pour la compatibilité et les noms IDN ne sont pas utilisés).  
  
 Le paramètre de configuration pour le <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> et <xref:System.Configuration.IdnElement?displayProperty=nameWithType> seront lues une fois lorsque la première <xref:System.Uri?displayProperty=nameWithType> construction de la classe. Les changements apportés ultérieurement aux paramètres de configuration sont ignorés.  
  
 La classe <xref:System.GenericUriParser?displayProperty=nameWithType> a également été étendue pour permettre la création d’un analyseur personnalisable qui prend en charge les IRI et les IDN. Le comportement d’un objet <xref:System.GenericUriParser?displayProperty=nameWithType> est spécifié en passant une combinaison d’opérations au niveau du bit des valeurs disponibles dans l’énumération <xref:System.GenericUriParserOptions?displayProperty=nameWithType> au constructeur <xref:System.GenericUriParser?displayProperty=nameWithType>. Le type <xref:System.GenericUriParserOptions.IriParsing?displayProperty=nameWithType> indique que l’analyseur prend en charge les règles d’analyse spécifiées dans la norme RFC 3987 pour les IRI (International Resource Identifier). IRI est dictée par les valeurs de configuration indiqués précédemment.  
  
 Le type <xref:System.GenericUriParserOptions.Idn?displayProperty=nameWithType> indique que l’analyseur prend en charge l’analyse des IDN pour les noms d’hôte. IDN est dictée par les valeurs de configuration indiqués précédemment.  
  
## <a name="performance-considerations"></a>Considérations sur les performances  
 Si vous utilisez un *Web.config * fichier qui contient l’URI pour initialiser votre application, d’autres temps est nécessaire pour traiter les URI si leurs identificateurs de schéma ne sont pas standard. Dans ce cas, initialisez les parties affectées de votre application lorsque les URI sont nécessaires, pas à l’heure de début.  
  
   
  
## Examples  
 L’exemple suivant crée une instance de la <xref:System.Uri> classe et l’utilise pour créer un <xref:System.Net.WebRequest> instance.  
  
 [!code-cpp[Classic Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>Pour des raisons de sécurité, votre application devez être prudent lors de l’acceptation <see cref="T:System.Uri" /> instances à partir de sources non fiables et avec <paramref name="dontEscape" /> défini sur <see langword="true" />. Vous pouvez vérifier la validité dans une chaîne URI en appelant le <see cref="M:System.Uri.IsWellFormedOriginalString" /> (méthode).</para>
    </block>
    <altmember cref="T:System.Configuration.IdnElement" />
    <altmember cref="T:System.Configuration.IriParsingElement" />
    <altmember cref="T:System.Configuration.UriSection" />
    <altmember cref="P:System.Uri.DnsSafeHost" />
    <altmember cref="M:System.Uri.MakeRelative(System.Uri)" />
    <altmember cref="M:System.Uri.IsWellFormedOriginalString" />
    <altmember cref="T:System.UriBuilder" />
    <related type="Article" href="http://msdn.microsoft.com/library/35883fe9-2d09-4d8b-80ca-cf23a941e459">Modifications apportées à l’espace de noms System.Uri dans la Version 2.0</related>
    <related type="Article" href="http://msdn.microsoft.com/library/b5e994c3-3535-4aff-8e1b-b69be22e9a22">La prise en charge des identificateur de ressource internationalisée dans System.UriSystem.Uri</related>
    <related type="Article" href="~/docs/framework/network-programming/index.md">Programmation réseau dans le .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Uri" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString);" />
      <MemberSignature Language="F#" Value="new Uri : string -&gt; Uri" Usage="new System.Uri uriString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriString">Chaîne qui identifie la ressource à représenter par l'instance de <see cref="T:System.Uri" />. Notez qu’une adresse IPv6 sous forme de chaîne doit être placée entre crochets, par exemple « http://[2607:f8b0:400d:c06::69] ».</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Uri" /> avec l'URI spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée un <xref:System.Uri> instance à partir d’une chaîne URI. Il analyse l’URI met dans un format canonique et rend les codages d’échappement requis.  
  
 Ce constructeur ne garantit pas que le <xref:System.Uri> fait référence à une ressource accessible.  
  
 Ce constructeur part du principe que le `string` paramètre fait référence à un URI absolu et équivaut à appeler le <xref:System.Uri.%23ctor%2A> constructeur avec <xref:System.UriKind> défini sur <xref:System.UriKind.Absolute>. Si le `string` paramètre passé au constructeur est un URI relatif, le constructeur lèvera une <xref:System.UriFormatException>.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> instance avec l’URI «http://www.contoso.com/».  
  
 [!code-cpp[Classic Uri.Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>Dans <see href="http://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.FormatException" />, à la place.</para>
          </block>
          <paramref name="uriString" /> est vide.  
  
- ou - 
Le schéma spécifié dans <paramref name="uriString" /> n’est pas correctement mis en forme. Consultez <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
- ou - 
 <paramref name="uriString" /> contient trop de barres obliques.  
  
- ou - 
Le mot de passe spécifié dans <paramref name="uriString" /> n’est pas valide.  
  
- ou - 
Le nom d’hôte spécifié dans <paramref name="uriString" /> n’est pas valide.  
  
- ou - 
Le nom de fichier spécifié dans <paramref name="uriString" /> n’est pas valide.  
  
- ou - 
Le nom d’utilisateur spécifié dans <paramref name="uriString" /> n’est pas valide.  
  
- ou - 
Le nom d’hôte ou d’autorité spécifié dans <paramref name="uriString" /> ne peut pas se terminer par des barres obliques inverses.  
  
- ou - 
Le numéro de port spécifié dans <paramref name="uriString" /> n’est pas valide ou ne peut pas être analysé.  
  
- ou - 
La longueur de <paramref name="uriString" /> dépasse 65 519 caractères.  
  
- ou - 
La longueur du schéma spécifié dans <paramref name="uriString" /> dépasse 1 023 caractères.  
  
- ou - 
Il existe une séquence de caractères non valide dans <paramref name="uriString" />.  
  
- ou - 
Le chemin MS-DOS spécifié dans <paramref name="uriString" /> doit commencer par c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Uri (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Uri(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new Uri : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Uri" Usage="new System.Uri (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Instance de la classe <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenant les informations requises pour sérialiser la nouvelle instance de <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Instance de la classe <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenant la source du flux sérialisé associé à la nouvelle instance de <see cref="T:System.Uri" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Uri" /> à partir des instances spécifiées des classes <see cref="T:System.Runtime.Serialization.SerializationInfo" /> et <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur implémente le <xref:System.Runtime.Serialization.ISerializable> interface pour la <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="serializationInfo" /> contient un URI <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">Le paramètre <paramref name="serializationInfo" /> contient un URI qui est vide.  
  
- ou - 
Le schéma spécifié n’est pas mis en forme correctement. Consultez <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
- ou - 
L’URI contient trop de barres obliques.  
  
- ou - 
Le mot de passe spécifié dans l’URI n’est pas valide.  
  
- ou - 
Le nom d’hôte spécifié dans l’URI n’est pas valide.  
  
- ou - 
Le nom de fichier spécifié dans l’URI n’est pas valide.  
  
- ou - 
Le nom d’utilisateur spécifié dans l’URI n’est pas valide.  
  
- ou - 
Le nom d’hôte ou d’autorité spécifié dans l’URI ne peut pas se terminer par des barres obliques inverses.  
  
- ou - 
Le numéro de port spécifié dans l’URI n’est pas valide ou ne peut pas être analysé.  
  
- ou - 
La longueur de l’URI dépasse 65 519 caractères.  
  
- ou - 
La longueur du schéma spécifié dans l’URI dépasse 1023 caractères.  
  
- ou - 
Il existe une séquence de caractères non valide dans l’URI.  
  
- ou - 
Le chemin MS-DOS spécifié dans l’URI doit commencer par c:\\\\.</exception>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Sérialisation XML et SOAP</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : string * bool -&gt; Uri" Usage="new System.Uri (uriString, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="uriString">Chaîne qui identifie la ressource à représenter par l'instance de <see cref="T:System.Uri" />. Notez qu’une adresse IPv6 sous forme de chaîne doit être placée entre crochets, par exemple « http://[2607:f8b0:400d:c06::69] ».</param>
        <param name="dontEscape">
          <see langword="true" /> si <c>uriString</c> est entièrement placé dans une séquence d’échappement ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Uri" /> avec l'URI spécifié et contrôle explicite de l'échappement des caractères.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée un <xref:System.Uri> instance à partir d’une chaîne URI. Il analyse l’URI et le place dans un format canonique.  
  
 Le `dontEscape` paramètre contrôle si des caractères réservés sont convertis en séquences d’échappement. Ce paramètre doit être défini sur `true` uniquement si vous êtes certain que tous les caractères réservés dans l’URI ont été échappés. Affectation de la valeur `true` pour un URI qui n’a pas été complètement échappé peut provoquer un comportement inattendu. Il est fortement recommandé de toujours définir ce paramètre `false`.  
  
 Si `dontEscape` est défini sur `false`, le constructeur d’échappement des caractères réservés en vérifiant que toutes les occurrences de pourcentage (%) sont suivies par une séquence d’échappement valide. Si la séquence de caractères suit un pourcentage n’est pas valide, le pourcentage est remplacé par % 25.  
  
 Ce constructeur ne garantit pas que le <xref:System.Uri> fait référence à une ressource accessible.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> instance pour l’URI http://www.contoso.com/Hello%20World.htm. Étant donné que l’URI de relation contenant-contenu est une séquence d’échappement et se présente sous forme canonique, le `dontEscape` peut être affectée au paramètre `true`.  
  
 [!code-cpp[Classic Uri.Uri1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="uriString" /> est vide ou contient uniquement des espaces.  
  
- ou - 
Le schéma spécifié dans <paramref name="uriString" /> n'est pas valide.  
  
- ou - 
 <paramref name="uriString" /> contient trop de barres obliques.  
  
- ou - 
Le mot de passe spécifié dans <paramref name="uriString" /> n’est pas valide.  
  
- ou - 
Le nom d’hôte spécifié dans <paramref name="uriString" /> n’est pas valide.  
  
- ou - 
Le nom de fichier spécifié dans <paramref name="uriString" /> n’est pas valide.  
  
- ou - 
Le nom d’utilisateur spécifié dans <paramref name="uriString" /> n’est pas valide.  
  
- ou - 
Le nom d’hôte ou d’autorité spécifié dans <paramref name="uriString" /> ne peut pas se terminer par des barres obliques inverses.  
  
- ou - 
Le numéro de port spécifié dans <paramref name="uriString" /> n’est pas valide ou ne peut pas être analysé.  
  
- ou - 
La longueur de <paramref name="uriString" /> dépasse 65 519 caractères.  
  
- ou - 
La longueur du schéma spécifié dans <paramref name="uriString" /> dépasse 1 023 caractères.  
  
- ou - 
Il existe une séquence de caractères non valide dans <paramref name="uriString" />.  
  
- ou - 
Le chemin MS-DOS spécifié dans <paramref name="uriString" /> doit commencer par c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="new Uri : string * UriKind -&gt; Uri" Usage="new System.Uri (uriString, uriKind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Chaîne qui identifie la ressource à représenter par l'instance de <see cref="T:System.Uri" />. Notez qu’une adresse IPv6 sous forme de chaîne doit être placée entre crochets, par exemple « http://[2607:f8b0:400d:c06::69] ».</param>
        <param name="uriKind">Spécifie si la chaîne d'URI est un URI relatif, un URI absolu ou si elle est indéterminée.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Uri" /> avec l'URI spécifié. Ce constructeur vous permet de spécifier si la chaîne d'URI est un URI relatif, un URI absolu ou si elle est indéterminée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URI relatif et absolu ont différentes restrictions sur leur format. Par exemple, un URI relatif ne nécessite pas un schéma ou une autorité. La valeur que vous spécifiez dans `uriKind` doit correspondre au type de l’URI passé dans `uriString`. Toutefois, si <xref:System.UriKind.RelativeOrAbsolute> est spécifié, la chaîne d’URI peut être relatif ou absolu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uriKind" /> n'est pas valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>Dans <see href="http://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.FormatException" />, à la place.</para>
          </block>
          <paramref name="uriString" /> contient un URI relatif et <paramref name="uriKind" /> est <see cref="F:System.UriKind.Absolute" />.  
  
ou 
 <paramref name="uriString" /> contient un URI absolu et <paramref name="uriKind" /> est <see cref="F:System.UriKind.Relative" />.  
  
ou 
 <paramref name="uriString" /> est vide.  
  
- ou - 
Le schéma spécifié dans <paramref name="uriString" /> n’est pas correctement mis en forme. Consultez <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
- ou - 
 <paramref name="uriString" /> contient trop de barres obliques.  
  
- ou - 
Le mot de passe spécifié dans <paramref name="uriString" /> n’est pas valide.  
  
- ou - 
Le nom d’hôte spécifié dans <paramref name="uriString" /> n’est pas valide.  
  
- ou - 
Le nom de fichier spécifié dans <paramref name="uriString" /> n’est pas valide.  
  
- ou - 
Le nom d’utilisateur spécifié dans <paramref name="uriString" /> n’est pas valide.  
  
- ou - 
Le nom d’hôte ou d’autorité spécifié dans <paramref name="uriString" /> ne peut pas se terminer par des barres obliques inverses.  
  
- ou - 
Le numéro de port spécifié dans <paramref name="uriString" /> n’est pas valide ou ne peut pas être analysé.  
  
- ou - 
La longueur de <paramref name="uriString" /> dépasse 65 519 caractères.  
  
- ou - 
La longueur du schéma spécifié dans <paramref name="uriString" /> dépasse 1 023 caractères.  
  
- ou - 
Il existe une séquence de caractères non valide dans <paramref name="uriString" />.  
  
- ou - 
Le chemin MS-DOS spécifié dans <paramref name="uriString" /> doit commencer par c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseUri">URI de base.</param>
        <param name="relativeUri">URI relatif à ajouter à l'identificateur de base.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Uri" /> fondée sur l'URI de base et la chaîne URI relative spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée un <xref:System.Uri> instance en combinant le `baseUri` et `relativeUri`. Si `relativeUri` est un URI absolu (contenant un schéma de nom d’hôte et éventuellement un numéro de port), le <xref:System.Uri> instance est créée à l’aide uniquement `relativeUri`.  
 
 Si le `baseUri` a des parties relatifs (comme `/api`), puis la partie relative doit se terminer par une barre oblique, (comme `/api/`), si la partie relative de `baseUri` doit être conservé dans construit <xref:System.Uri>. 

 En outre, si le `relativeUri` commence par une barre oblique, puis il remplacera toute partie relative de la `baseUri`

 Ce constructeur ne garantit pas que le <xref:System.Uri> fait référence à une ressource accessible.  
  
   
  
## Examples  
 L’exemple suivant crée une nouvelle instance de la <xref:System.Uri> classe en combinant les URI relatifs http://www.contoso.com et /catalog/shownew.htm pour former l’URI absolu http://www.contoso.com/catalog/shownew.htm.  
  
 [!code-cpp[Classic Uri.Uri3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> n’est pas une instance absolue de <see cref="T:System.Uri" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>Dans <see href="http://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.FormatException" />, à la place.</para>
          </block>
L’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> est vide ou contient uniquement des espaces.  
  
- ou - 
Le schéma spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide.  
  
- ou - 
L’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> contient trop de barres obliques.  
  
- ou - 
Le mot de passe spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide.  
  
- ou - 
Le nom d’hôte spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide.  
  
- ou - 
Le nom de fichier spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide.  
  
- ou - 
Le nom d’utilisateur spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide.  
  
- ou - 
Le nom d’hôte ou d’autorité spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> ne peut pas se terminer par des barres obliques inverses.  
  
- ou - 
Le numéro de port spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide ou ne peut pas être analysé.  
  
- ou - 
La longueur de l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> dépasse 65 519 caractères.  
  
- ou - 
La longueur du schéma spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> dépasse 1 023 caractères.  
  
- ou - 
L’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> contient une séquence de caractères non valide.  
  
- ou - 
Le chemin MS-DOS spécifié dans <paramref name="uriString" /> doit commencer par c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, Uri relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, class System.Uri relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, Uri ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * Uri -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseUri">
          <see cref="T:System.Uri" /> absolu qui est la base de la nouvelle instance de <see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Instance de <see cref="T:System.Uri" /> relative qui est combinée avec <c>baseUri</c>.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Uri" /> en s'appuyant sur la combinaison d'une instance de <see cref="T:System.Uri" /> de base et d'une instance de <see cref="T:System.Uri" /> relative.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée un nouveau <xref:System.Uri> instance en combinant une absolue <xref:System.Uri> instance, `baseUri`, avec une relative <xref:System.Uri> instance, `relativeUri`. Si `relativeUri` est absolu <xref:System.Uri> instance (contenant un schéma de nom d’hôte et éventuellement un numéro de port), le <xref:System.Uri> instance est créée à l’aide uniquement `relativeUri`.  
 
 Si le `baseUri` a des parties relatifs (comme `/api`), puis la partie relative doit se terminer par une barre oblique, (comme `/api/`), si la partie relative de `baseUri` doit être conservé dans construit <xref:System.Uri>. 

 En outre, si le `relativeUri` commence par une barre oblique, puis il remplacera toute partie relative de la `baseUri`
 
 Ce constructeur ne garantit pas que le <xref:System.Uri> fait référence à une ressource accessible.  
  
   
  
## Examples  
 Cet exemple crée une absolue <xref:System.Uri> instance, `absoluteUri`et relatif <xref:System.Uri> instance, `relativeUri`. Un nouveau <xref:System.Uri> instance, `combinedUri`, est ensuite créé à partir de ces deux instances.  
  
 [!code-cpp[NCLUriEnhancements#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#2)]
 [!code-csharp[NCLUriEnhancements#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#2)]
 [!code-vb[NCLUriEnhancements#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseUri" /> n’est pas une instance absolue de <see cref="T:System.Uri" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> n’est pas une instance absolue de <see cref="T:System.Uri" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>Dans <see href="http://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.FormatException" />, à la place.</para>
          </block>
L’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> est vide ou contient uniquement des espaces.  
  
- ou - 
Le schéma spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide.  
  
- ou - 
L’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> contient trop de barres obliques.  
  
- ou - 
Le mot de passe spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide.  
  
- ou - 
Le nom d’hôte spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide.  
  
- ou - 
Le nom de fichier spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide.  
  
- ou - 
Le nom d’utilisateur spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide.  
  
- ou - 
Le nom d’hôte ou d’autorité spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> ne peut pas se terminer par des barres obliques inverses.  
  
- ou - 
Le numéro de port spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide ou ne peut pas être analysé.  
  
- ou - 
La longueur de l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> dépasse 65 519 caractères.  
  
- ou - 
La longueur du schéma spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> dépasse 1 023 caractères.  
  
- ou - 
L’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> contient une séquence de caractères non valide.  
  
- ou - 
Le chemin MS-DOS spécifié dans <paramref name="uriString" /> doit commencer par c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string * bool -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="baseUri">URI de base.</param>
        <param name="relativeUri">URI relatif à ajouter à l'identificateur de base.</param>
        <param name="dontEscape">
          <see langword="true" /> si <c>uriString</c> est entièrement placé dans une séquence d’échappement ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Uri" /> fondée sur les URI de base et relatifs spécifiés, avec contrôle explicite de l'échappement des caractères.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée un <xref:System.Uri> instance en combinant `baseUri` et `relativeUri`. Si l’URI passé dans `relativeUri` est un URI absolu (contenant un schéma de nom d’hôte et éventuellement un numéro de port), le <xref:System.Uri> instance est créée à l’aide uniquement `relativeUri`.  
  
 Le `dontEscape` paramètre contrôle si des caractères réservés sont convertis en séquences d’échappement. Ce paramètre doit être défini sur `true` uniquement si vous êtes certain que tous les caractères réservés dans l’URI ont été échappés. Affectation de la valeur `true` pour un URI qui n’a pas été complètement échappé peut provoquer un comportement inattendu. Il est fortement recommandé de toujours définir ce paramètre `false`. Si `dontEscape` est défini sur `false`, le constructeur d’échappement des caractères réservés en vérifiant que toutes les occurrences de pourcentage (%) sont suivies par une séquence d’échappement valide. Si la séquence de caractères suit un pourcentage n’est pas valide, le pourcentage est remplacé par % 25.  
  
 Ce constructeur ne garantit pas que le <xref:System.Uri> fait référence à une ressource accessible.  
  
   
  
## Examples  
 L’exemple suivant crée une nouvelle instance de la <xref:System.Uri> classe en combinant les URI relatifs http://www.contoso.com et Hello%20World.htm pour former un URI absolu.  
  
 [!code-cpp[Classic Uri.Uri4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> n’est pas une instance absolue de <see cref="T:System.Uri" />.</exception>
        <exception cref="T:System.UriFormatException">L’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> est vide ou contient uniquement des espaces.  
  
- ou - 
Le schéma spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide.  
  
- ou - 
L’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> contient trop de barres obliques.  
  
- ou - 
Le mot de passe spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide.  
  
- ou - 
Le nom d’hôte spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide.  
  
- ou - 
Le nom de fichier spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide.  
  
- ou - 
Le nom d’utilisateur spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide.  
  
- ou - 
Le nom d’hôte ou d’autorité spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> ne peut pas se terminer par des barres obliques inverses.  
  
- ou - 
Le numéro de port spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> n’est pas valide ou ne peut pas être analysé.  
  
- ou - 
La longueur de l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> dépasse 65 519 caractères.  
  
- ou - 
La longueur du schéma spécifié dans l’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> dépasse 1 023 caractères.  
  
- ou - 
L’URI formé en combinant <paramref name="baseUri" /> et <paramref name="relativeUri" /> contient une séquence de caractères non valide.  
  
- ou - 
Le chemin MS-DOS spécifié dans <paramref name="uriString" /> doit commencer par c:\\\\.</exception>
        <block subset="none" type="usage">
          <para>Pour des raisons de sécurité, votre application ne doit pas appeler ce constructeur avec des chaînes URI à partir de sources non fiables et avec <paramref name="dontEscape" /> défini sur <see langword="true" />. Alternativement, vous pouvez vérifier la validité dans une chaîne URI en appelant le <see cref="M:System.Uri.IsWellFormedOriginalString" /> méthode avant d’appeler ce constructeur.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AbsolutePath">
      <MemberSignature Language="C#" Value="public string AbsolutePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsolutePath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsolutePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsolutePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsolutePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsolutePath : string" Usage="System.Uri.AbsolutePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le chemin d’accès absolu de l’URI.</summary>
        <value>
          <see cref="T:System.String" /> contenant le chemin d’accès absolu à la ressource.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.AbsolutePath%2A> propriété contient les informations de chemin d’accès que le serveur utilise pour résoudre les demandes d’informations. En général, il s’agit le chemin d’accès aux informations souhaitées sur le système de fichiers du serveur, bien que cela peut également indiquer l’application ou le script, que le serveur doit exécuter pour fournir les informations.  
  
 Les informations de chemin d’accès n’incluent pas le schéma, un nom d’hôte ou une partie de l’URI de requête.  
  
   
  
## Examples  
 L’exemple suivant écrit le chemin /catalog/shownew.htm dans la console.  
  
 [!code-cpp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsolutePath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsoluteUri">
      <MemberSignature Language="C#" Value="public string AbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsoluteUri As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsoluteUri { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsoluteUri : string" Usage="System.Uri.AbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'URI absolu.</summary>
        <value>
          <see cref="T:System.String" /> contenant l'URI complet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.AbsoluteUri%2A> propriété inclut l’URI complet stocké dans le <xref:System.Uri> instance, y compris tous les fragments et chaînes de requête.  
  
   
  
## Examples  
 L’exemple suivant écrit le contenu complet de le <xref:System.Uri> instance dans la console. Dans l’exemple illustré, http://www.contoso.com/catalog/shownew.htm?date=today est écrit dans la console.  
  
 [!code-cpp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Authority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authority As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Authority { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Authority : string" Usage="System.Uri.Authority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de l'hôte DNS (Domain Name System) ou l'adresse IP et le numéro de port pour un serveur.</summary>
        <value>
          <see cref="T:System.String" /> contenant le composant d'autorité de l'URI représenté par cette instance.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.Authority%2A> propriété est généralement une adresse IP ou nom d’hôte du serveur DNS. Cette propriété peut inclure le numéro de port de service s’il est différent du port par défaut pour l’URI. Si le <xref:System.Uri.Authority%2A> composant contient des caractères réservés, ceux-ci sont ignorés dans la valeur de la chaîne retournée par cette propriété.  
  
   
  
## Examples  
 L’exemple suivant écrit le nom d’hôte (www.contoso.com) et le numéro de port (8080) du serveur à la console.  
  
 [!code-cpp[Classic Uri.Authority Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Authority Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Authority Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Authority Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Authority Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Authority Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="Canonicalize">
      <MemberSignature Language="C#" Value="protected virtual void Canonicalize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Canonicalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Canonicalize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Canonicalize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Canonicalize();" />
      <MemberSignature Language="F#" Value="abstract member Canonicalize : unit -&gt; unit&#xA;override this.Canonicalize : unit -&gt; unit" Usage="uri.Canonicalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convertit l'URI stocké en interne au format réglementaire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stocke en interne la version canonique de l’URI.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif ; cette méthode est valide uniquement pour les URI absolus.</exception>
        <exception cref="T:System.UriFormatException">L'URI a une forme incorrecte.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckHostName">
      <MemberSignature Language="C#" Value="public static UriHostNameType CheckHostName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UriHostNameType CheckHostName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckHostName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckHostName (name As String) As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UriHostNameType CheckHostName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member CheckHostName : string -&gt; UriHostNameType" Usage="System.Uri.CheckHostName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom d'hôte à valider. Il peut s'agir d'une adresse IPv4 ou IPv6 ou d'un nom d'hôte Internet.</param>
        <summary>Détermine si le nom d'hôte spécifié est un nom DNS valide.</summary>
        <returns>
          <see cref="T:System.UriHostNameType" /> qui indique le type du nom d'hôte. S'il est impossible de déterminer le nom d'hôte ou si ce dernier est <see langword="null" /> ou une chaîne de longueur zéro, cette méthode retourne <see cref="F:System.UriHostNameType.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.CheckHostName%2A> méthode vérifie que le nom d’hôte fourni répond à la configuration requise pour un nom d’hôte Internet valide. Il n’effectue pas, toutefois, d’une recherche de nom d’hôte pour vérifier l’existence de l’hôte.  
  
   
  
## Examples  
 L’exemple suivant vérifie si le nom d’hôte est valide.  
  
 [!code-cpp[Classic Uri.CheckHostName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.CheckHostName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.CheckHostName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSchemeName">
      <MemberSignature Language="C#" Value="public static bool CheckSchemeName (string schemeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CheckSchemeName(string schemeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSchemeName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckSchemeName (schemeName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CheckSchemeName(System::String ^ schemeName);" />
      <MemberSignature Language="F#" Value="static member CheckSchemeName : string -&gt; bool" Usage="System.Uri.CheckSchemeName schemeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="schemeName">Nom de schéma à valider.</param>
        <summary>Détermine si le nom de schéma spécifié est valide.</summary>
        <returns>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si le nom du schéma est valide ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode vérifie le nom du schéma de validité selon RFC 2396 par défaut. Si International Resource Identifiers (IRIs) ou l’analyse du nom de domaine international (IDN) est activée, cette méthode vérifie le nom du schéma de validité conformément à la RFC 3986. Le nom du schéma doit commencer par une lettre et doit contenir uniquement des lettres, des chiffres et les caractères «. », « + » ou «- ».  
  
 Pour plus d’informations sur la prise en charge des IRI, consultez la section Notes pour la <xref:System.Uri> classe.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> de l’instance et vérifie si le nom du schéma est valid.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSecurity">
      <MemberSignature Language="C#" Value="protected virtual void CheckSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CheckSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSecurity" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CheckSecurity ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CheckSecurity();" />
      <MemberSignature Language="F#" Value="abstract member CheckSecurity : unit -&gt; unit&#xA;override this.CheckSecurity : unit -&gt; unit" Usage="uri.CheckSecurity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>L'appel à cette méthode n'a aucun effet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(class System.Uri uri1, class System.Uri uri2, valuetype System.UriComponents partsToCompare, valuetype System.UriFormat compareFormat, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Compare(System.Uri,System.Uri,System.UriComponents,System.UriFormat,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (uri1 As Uri, uri2 As Uri, partsToCompare As UriComponents, compareFormat As UriFormat, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(Uri ^ uri1, Uri ^ uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : Uri * Uri * UriComponents * UriFormat * StringComparison -&gt; int" Usage="System.Uri.Compare (uri1, uri2, partsToCompare, compareFormat, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
        <Parameter Name="partsToCompare" Type="System.UriComponents" />
        <Parameter Name="compareFormat" Type="System.UriFormat" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="uri1">Première <see cref="T:System.Uri" />.</param>
        <param name="uri2">Deuxième <see cref="T:System.Uri" />.</param>
        <param name="partsToCompare">Combinaison au niveau du bit des valeurs <see cref="T:System.UriComponents" /> qui spécifie les parties de <c>uri1</c> et <c>uri2</c> à comparer.</param>
        <param name="compareFormat">L'une des valeurs <see cref="T:System.UriFormat" /> qui spécifient la séquence d'échappement de caractères utilisée lors de la comparaison des composants d'URI.</param>
        <param name="comparisonType">Une des valeurs de <see cref="T:System.StringComparison" />.</param>
        <summary>Compare les parties spécifiées de deux URI à l'aide des règles de comparaison spécifiées.</summary>
        <returns>Valeur <see cref="T:System.Int32" /> qui indique la relation lexicale entre les composants <see cref="T:System.Uri" />.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Signification 
 </description></listheader><item><term> Inférieure à zéro 
 </term><description><paramref name="uri1" /> est inférieur à <paramref name="uri2" />.  
  
 </description></item><item><term> Zéro 
 </term><description><paramref name="uri1" /> est égal à <paramref name="uri2" />.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description><paramref name="uri1" /> est supérieur à <paramref name="uri2" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les deux `uri1` et `uri2` sont `null`, cette méthode retourne 0. Lors de la comparaison de valeurs URI, un URI relatif est toujours inférieur à un URI absolu et un URI non null est toujours supérieur à un URI null. Pour les cas où les deux `uri1` et `uri2` ne sont pas `null` et sont des URI relatifs ou des URI absolus, la <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> méthode effectue la comparaison.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur de <see cref="T:System.StringComparison" /> valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="DnsSafeHost">
      <MemberSignature Language="C#" Value="public string DnsSafeHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DnsSafeHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.DnsSafeHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DnsSafeHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DnsSafeHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DnsSafeHost : string" Usage="System.Uri.DnsSafeHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un nom d’hôte qui, une fois sans séquence d’échappement si nécessaire, peut être utilisé en toute sécurité pour la résolution DNS.</summary>
        <value>Un <see cref="T:System.String" /> qui contient la partie hôte de l’URI dans un format approprié pour la résolution DNS ; ou la chaîne d’origine de l’hôte, si elle convient déjà pour la résolution.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les adresses IPv6, les crochets ([]) sont supprimés et le <xref:System.Net.IPAddress.ScopeId%2A> propriété est définie, si elle a été spécifiée quand cette instance a été construite.

Si vous avez utilisé une chaîne avec séquence d’échappement pour construire cette instance (par exemple, « http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), puis DnsSafeHost renvoie une chaîne avec séquence d’échappement. Unescape n’importe quelle chaîne avec séquence d’échappement retourné à partir de `DnsSafeHost` avant d’utiliser cette chaîne pour la résolution DNS (voir l’exemple). Si vous avez utilisé une chaîne sans séquence d’échappement non valide pour construire cette instance (par exemple, « http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), puis DnsSafeHost renvoie une chaîne sans séquence d’échappement.
  
 Le <xref:System.Uri.DnsSafeHost%2A> propriété dépend des paramètres de configuration, comme indiqué plus loin dans cette rubrique. Paramètres de configuration ne peut pas être modifiés par les applications Windows Store, ce qui peuvent entraîner des résultats incohérents lorsque vous utilisez <xref:System.Uri.DnsSafeHost%2A>. Le <xref:System.Uri.IdnHost%2A> propriété est fournie en tant que l’alternative recommandée à l’utilisation de <xref:System.Uri.DnsSafeHost%2A>, car <xref:System.Uri.IdnHost%2A> est garantie comme étant toujours DNS sécurisé, quel que soit l’actuellement *app.config* peut-être des paramètres.  
  
 Le <xref:System.Uri.DnsSafeHost%2A> propriété a été étendue dans .NET Framework v3.5, 3.0 SP1 et 2.0 SP1 pour fournir l’identificateur IRI (International Resource) prend en charge selon la RFC 3987. Les utilisateurs actuels ne verront aucun changement dans le comportement de .NET Framework 2.0, sauf s’ils activent spécifiquement les IRI. Cela garantit la compatibilité des applications avec les versions antérieures de .NET Framework.  
  
 Pour activer la prise en charge des IRI, les deux modifications suivantes sont requises :  
  
1.  Ajoutez la ligne suivante à la *machine.config* fichier sous le répertoire .NET Framework 2.0  
  
     \<section name="uri" type="System.Configuration.UriSection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
  
2.  Spécifiez si vous souhaitez que l’analyse de nom de domaine international (IDN) appliquée au nom de domaine et si les règles d’analyse IRI doivent être appliquée. Cela est possible le *machine.config* ou dans le *app.config* fichier. Par exemple, ajoutez ce qui suit :  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 L’activation des IDN entraîne la conversion de toutes les étiquettes Unicode d’un nom de domaine en leurs équivalents Punycode. Les noms Punycode contiennent uniquement des caractères ASCII et commencent toujours par le préfixe xn--. Cela permet de garantir la prise en charge des serveurs DNS existants sur Internet, la plupart d’entre eux prenant uniquement en charge les caractères ASCII (consultez la norme RFC 3940).  
  
 L’activation des IDN affecte seulement la valeur de la <xref:System.Uri.DnsSafeHost%2A> propriété.  
  
 Il existe trois valeurs possibles pour l’IDN selon les serveurs DNS qui sont utilisés :  
  
-   IDN activé = All  
  
     Cette valeur convertit tous les noms de domaine Unicode en leurs équivalents Punycode (noms IDN).  
  
-   IDN activé = AllExceptIntranet  
  
     Cette valeur convertit tous les noms de domaine Unicode externes pour utiliser leurs équivalents Punycode (noms IDN). Dans ce cas, pour gérer des noms internationaux sur l'Intranet local, les serveurs DNS utilisés pour l'Intranet doivent prendre en charge les noms Unicode.  
  
-   IDN activé = None  
  
     Cette valeur ne convertit aucun nom de domaine Unicode pour utiliser Punycode. Il s’agit de la valeur par défaut qui est cohérente avec le comportement de .NET Framework 2.0.  
  
 L’activation de l’analyse des IRI (iriParsing activé = `true`) effectue la normalisation et la vérification des caractères selon le IRI les plus récentes des règles dans la RFC 3987. La valeur par défaut est `false` et permet la normalisation et caractères vérification selon RFC 2396 et RFC 2732 (pour les littéraux IPv6).  
  
 Pour plus d’informations sur la prise en charge des IRI, consultez la section Notes pour la <xref:System.Uri> classe.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> instance à partir d’une chaîne. Il illustre la différence entre la valeur retournée par <xref:System.Uri.Host%2A>, qui retourne le nom d’hôte ou l’adresse spécifié dans l’URI et la valeur retournée à partir de <xref:System.Uri.DnsSafeHost%2A>, qui retourne une adresse qui est sûr à utiliser dans la résolution DNS.  
  
 [!code-cpp[NCLUriEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#4)]
 [!code-csharp[NCLUriEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#4)]
 [!code-vb[NCLUriEnhancements#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#4)]  

 Comme expliqué dans la section Notes, unescape le nom d’hôte avant sa résolution. Vous pouvez utiliser la <xref:System.Uri.UnescapeDataString%2A> méthode puisse éliminer le nom d’hôte et vous pouvez y remédier en appelant le <xref:System.Net.Dns.GetHostEntry%2A> (méthode).

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uri.Equals comparand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">Instance de <see cref="T:System.Uri" /> ou URI à comparer à l'instance actuelle.</param>
        <summary>Compare si deux instances <see cref="T:System.Uri" /> sont égales.</summary>
        <returns>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si les deux instances représentent le même URI ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.Equals%2A> méthode compare les deux instances sans tenir compte des informations sur l’utilisateur (<xref:System.Uri.UserInfo%2A>) et du fragment (<xref:System.Uri.Fragment%2A>) qu’ils pourraient contenir. Par exemple, étant donné les URI http://www.contoso.com/index.htm#search et http://user:password@www.contoso.com/index.htm, le <xref:System.Uri.Equals%2A> méthode retournerait `true`.  
  
 Si un <xref:System.Uri> instance est formée avec un nom d’hôte Unicode et `comparand` paramètre contient un <xref:System.Uri> instance ou un identificateur qui est formée avec un nom d’hôte qui a le nom d’hôte Punycode équivalent, puis <xref:System.Uri.Equals%2A> retourne `true` uniquement si l’identificateur IRI (International Resource) et le nom de domaine international (IDN) prennent en charge sont activés. Les noms Punycode contiennent uniquement des caractères ASCII et commencent toujours par le préfixe xn--.  
  
 Pour plus d’informations sur la prise en charge des IRI, consultez la section Notes pour la <xref:System.Uri> classe.  
  
> [!NOTE]
>  Dans les versions de .NET Framework 1.0 et 1.1, le <xref:System.Uri.Query%2A> est également ignoré.  
  
> [!NOTE]
>  Le <xref:System.Uri.Equals%2A> méthode peut être substituée dans une classe dérivée ; soyez prudent, car une entité malveillante pourrait modifier la méthode. Vous ne devez pas utiliser cette méthode pour effectuer des vérifications de sécurité, sauf si vous savez que cette instance provient d’une source approuvée.  
  
   
  
## Examples  
 Cet exemple crée deux <xref:System.Uri> instances à partir de chaînes et les compare pour déterminer si elles représentent la même valeur. `address1` et `address2` sont identiques, car le <xref:System.Uri.Fragment%2A> partie est ignorée pour cette comparaison. Le résultat est écrit dans la console.  
  
 [!code-cpp[NCLUriExamples#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#8)]
 [!code-csharp[NCLUriExamples#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#8)]
 [!code-vb[NCLUriExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour empêcher la dérivation à partir du code partiellement fiable <see cref="T:System.Uri" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="protected virtual void Escape ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Escape() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Escape" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Escape ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Escape();" />
      <MemberSignature Language="F#" Value="abstract member Escape : unit -&gt; unit&#xA;override this.Escape : unit -&gt; unit" Usage="uri.Escape " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convertit tous les caractères non sécurisés ou réservés dans le composant de chemin d’accès en leurs présentations en caractères hexadécimaux.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">L'URI passé du constructeur n'est pas valide. Cette exception peut se produire si un URI contient trop de caractères ou s'il est relatif.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeDataString">
      <MemberSignature Language="C#" Value="public static string EscapeDataString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeDataString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeDataString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeDataString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeDataString : string -&gt; string" Usage="System.Uri.EscapeDataString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Chaîne à placer dans une séquence d'échappement.</param>
        <summary>Convertit une chaîne en sa représentation avec séquence d'échappement.</summary>
        <returns>
          <see cref="T:System.String" />  qui contient la représentation avec séquence d'échappement de <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, le <xref:System.Uri.EscapeDataString%2A> méthode convertit tous les caractères à l’exception des caractères non réservés de RFC 2396 dans leur représentation hexadécimale. Si International Resource Identifiers (IRIs) ou l’analyse du nom de domaine international (IDN) est activée, le <xref:System.Uri.EscapeDataString%2A> méthode convertit tous les caractères, à l’exception de RFC 3986 caractères non réservés, en leur représentation hexadécimale. Tous les caractères Unicode sont convertis au format UTF-8 avant d’être ignorés.  
  
 Cette méthode suppose que `stringToEscape` comporte les séquences d’échappement.  
  
 Par défaut, la chaîne est échappée selon la norme RFC 2396. Si International Resource Identifiers (IRIs) ou l’analyse du nom de domaine international (IDN) est activée, la chaîne est échappée selon la norme RFC 3986 et RFC 3987. Consultez ces RFC pour une définition des caractères réservés et non réservés.  
  
 Pour plus d’informations sur la prise en charge des IRI, consultez la section Notes pour la <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>Dans <see href="http://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.FormatException" />, à la place.</para>
          </block>  
  
 La longueur de <paramref name="stringToEscape" /> dépasse 32 766 caractères.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeString">
      <MemberSignature Language="C#" Value="protected static string EscapeString (string str);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig string EscapeString(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function EscapeString (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::String ^ EscapeString(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member EscapeString : string -&gt; string" Usage="System.Uri.EscapeString str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Chaîne à transformer en sa représentation avec séquence d'échappement.</param>
        <summary>Convertit une chaîne en sa représentation avec séquence d'échappement.</summary>
        <returns>Représentation avec séquence d'échappement de la chaîne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.EscapeString%2A> méthode convertit des caractères réservés RFC 2396 et tous les caractères avec une valeur supérieure à 127 en représentation hexadécimale. Tous les caractères Unicode sont convertis au format UTF-8 avant d’être ignorés.  
  
 Par défaut, la chaîne est échappée selon la norme RFC 2396. Si International Resource Identifiers (IRIs) ou l’analyse du nom de domaine international (IDN) est activée, la chaîne est échappée selon la norme RFC 3986 et RFC 3987.  
  
 Pour plus d’informations sur la prise en charge des IRI, consultez la section Notes pour la <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapeUriString">
      <MemberSignature Language="C#" Value="public static string EscapeUriString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeUriString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeUriString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeUriString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeUriString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeUriString : string -&gt; string" Usage="System.Uri.EscapeUriString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Chaîne à placer dans une séquence d'échappement.</param>
        <summary>Convertit une chaîne URI en sa représentation sans séquence d'échappement.</summary>
        <returns>
          <see cref="T:System.String" />  qui contient la représentation avec séquence d'échappement de <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Uri.EscapeUriString%2A> méthode pour préparer une chaîne URI sans séquence d’échappement pour être un paramètre à la <xref:System.Uri.%23ctor%2A> constructeur.  
  
 Par défaut, le <xref:System.Uri.EscapeUriString%2A> méthode convertit tous les caractères, à l’exception des caractères non réservés RFC 2396, en leur représentation hexadécimale. Si International Resource Identifiers (IRIs) ou l’analyse du nom de domaine international (IDN) est activée, le <xref:System.Uri.EscapeUriString%2A> méthode convertit tous les caractères, à l’exception de RFC 3986 caractères non réservés, en leur représentation hexadécimale. Tous les caractères Unicode sont convertis au format UTF-8 avant d’être ignorés.  
  
 Cette méthode suppose que `stringToEscape` comporte les séquences d’échappement.  
  
 Par défaut, la chaîne est échappée selon la norme RFC 2396. Si International Resource Identifiers (IRIs) ou l’analyse du nom de domaine international (IDN) est activée, la chaîne est échappée selon la norme RFC 3986 et RFC 3987. Consultez ces RFC pour une définition des caractères réservés et non réservés.  
  
 Pour plus d’informations sur la prise en charge des IRI, consultez la section Notes pour la <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>Dans <see href="http://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.FormatException" />, à la place.</para>
          </block>  
  
 La longueur de <paramref name="stringToEscape" /> dépasse 32 766 caractères.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fragment">
      <MemberSignature Language="C#" Value="public string Fragment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Fragment" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Fragment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Fragment As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Fragment { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Fragment : string" Usage="System.Uri.Fragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le fragment URI avec séquence d'échappement.</summary>
        <value>
          <see cref="T:System.String" /> qui contient toute information relative au fragment URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.Fragment%2A> propriété obtient le texte suivant un marqueur de fragment (#) dans l’URI, y compris le marqueur lui-même. Étant donné l’URI http://www.contoso.com/index.htm#main, le <xref:System.Uri.Fragment%2A> propriété retournerait #main.  
  
 Le <xref:System.Uri.Fragment%2A> propriété n’est pas considéré comme dans les <xref:System.Uri.Equals%2A> comparaison.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> de l’instance et écrit les informations de fragment dans la console.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromHex">
      <MemberSignature Language="C#" Value="public static int FromHex (char digit);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FromHex(char digit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.FromHex(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHex (digit As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FromHex(char digit);" />
      <MemberSignature Language="F#" Value="static member FromHex : char -&gt; int" Usage="System.Uri.FromHex digit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="digit" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="digit">Chiffre hexadécimal (0-9, a-f, A-F) à convertir.</param>
        <summary>Obtient la valeur décimale d'un chiffre hexadécimal.</summary>
        <returns>Valeur <see cref="T:System.Int32" /> qui contient un nombre de 0 à 15 qui correspond au chiffre hexadécimal spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.FromHex%2A> méthode convertit un caractère représentant un chiffre hexadécimal (0-9, a-f, A-F) en sa valeur décimale (0 à 15). Si `digit` n’est pas un chiffre hexadécimal valide, une <xref:System.ArgumentException> exception est levée.  
  
   
  
## Examples  
 L’exemple suivant détermine si un caractère est un caractère hexadécimal et, si elle est, écrit la valeur décimale correspondante dans la console.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="digit" /> n'est pas un chiffre hexadécimal valide (0-9, a-f, A-F).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponents">
      <MemberSignature Language="C#" Value="public string GetComponents (UriComponents components, UriFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComponents(valuetype System.UriComponents components, valuetype System.UriFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetComponents(System.UriComponents,System.UriFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComponents (components As UriComponents, format As UriFormat) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComponents(UriComponents components, UriFormat format);" />
      <MemberSignature Language="F#" Value="member this.GetComponents : UriComponents * UriFormat -&gt; string" Usage="uri.GetComponents (components, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="components" Type="System.UriComponents" />
        <Parameter Name="format" Type="System.UriFormat" />
      </Parameters>
      <Docs>
        <param name="components">Combinaison d'opérations de bits des valeurs <see cref="T:System.UriComponents" /> qui spécifie quelles parties de l'instance actuelle retourner à l'appelant.</param>
        <param name="format">L'une des valeurs <see cref="T:System.UriFormat" /> qui contrôlent la façon dont les caractères spéciaux sont placés dans une séquence d'échappement.</param>
        <summary>Obtient les composants spécifiés de l'instance actuelle à l'aide de la séquence d'échappement spécifiée pour les caractères spéciaux.</summary>
        <returns>
          <see cref="T:System.String" /> qui contient les composants.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.UriComponents.Query>, <xref:System.UriComponents.Fragment>, <xref:System.UriComponents.Scheme>, <xref:System.UriComponents.UserInfo>, <xref:System.UriComponents.Host>, <xref:System.UriComponents.Port>, et <xref:System.UriComponents.Path> composants n’incluent pas le délimiteur. Vous pouvez combiner la <xref:System.UriComponents.KeepDelimiter> indicateur (à l’aide de l’opérateur OR au niveau du bit) avec une de ces valeurs à obtenir la valeur avec le délimiteur. Pour tous les autres <xref:System.UriComponents> valeurs, ainsi que des combinaisons de valeurs, les délimiteurs sont inclus dans la valeur retournée.  
  
 Les composants sont retournés dans l’ordre où ils apparaissent dans l’URI. Par exemple, si <xref:System.UriComponents.Scheme> est spécifié, il apparaît en premier.  
  
 Lors de la prise en charge de l’identificateur IRI (International Resource) et le nom de domaine international (IDN) sont activées, le nombre de caractères retournés dans le <xref:System.String> augmente. Utilisé pour prendre en charge des IRI les noms Punycode contiennent uniquement des caractères ASCII et commencent toujours par le préfixe xn--. Lorsque les IRI et des IDN sont activées, les caractères de substitution Unicode sont gérés correctement par le <xref:System.Uri.GetComponents%2A> (méthode).  
  
 Pour plus d’informations sur la prise en charge des IRI, consultez la section Notes pour la <xref:System.Uri> classe.  
  
> [!NOTE]
>  Si le <xref:System.Uri.GetComponents%2A> méthode est appelée avec `format` définie sur <xref:System.UriFormat.Unescaped> , vous ne pouvez pas utiliser la valeur de retour en tant qu’argument à un <xref:System.Uri.%23ctor%2A> constructeur pour créer un équivalent <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="components" /> n'est pas une combinaison de valeurs <see cref="T:System.UriComponents" /> valides.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Uri" /> actuel n'est pas un URI absolu. Il est impossible d'utiliser des URI relatifs avec cette méthode.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uri.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient le code de hachage pour l'URI.</summary>
        <returns>
          <see cref="T:System.Int32" /> comportant la valeur de hachage générée pour cet URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> de l’instance et écrit le code de hachage dans la console.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeftPart">
      <MemberSignature Language="C#" Value="public string GetLeftPart (UriPartial part);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetLeftPart(valuetype System.UriPartial part) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetLeftPart(System.UriPartial)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLeftPart (part As UriPartial) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetLeftPart(UriPartial part);" />
      <MemberSignature Language="F#" Value="member this.GetLeftPart : UriPartial -&gt; string" Usage="uri.GetLeftPart part" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="part" Type="System.UriPartial" />
      </Parameters>
      <Docs>
        <param name="part">L'une des valeurs <see cref="T:System.UriPartial" /> qui spécifie la fin de la partie de l'URI à retourner.</param>
        <summary>Obtient la partie spécifiée d'une instance <see cref="T:System.Uri" />.</summary>
        <returns>
          <see cref="T:System.String" /> qui contient la partie spécifiée de l'instance de <see cref="T:System.Uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.GetLeftPart%2A> méthode retourne une chaîne contenant la partie la plus à gauche de la chaîne d’URI se terminant par la partie spécifiée par `part`.  
  
 <xref:System.Uri.GetLeftPart%2A> inclut les délimiteurs dans les cas suivants :  
  
-   <xref:System.UriPartial.Scheme> inclut le délimiteur de schéma.  
  
-   <xref:System.UriPartial.Authority> n’inclut pas le délimiteur de chemin d’accès.  
  
-   <xref:System.UriPartial.Path> inclut les délimiteurs dans l’URI d’origine jusqu'à la requête ou fragment délimiteur.  
  
-   <xref:System.UriPartial.Query> inclut le <xref:System.UriPartial.Path>, ainsi que la requête et son délimiteur.  
  
 Les exemples suivants montrent un URI et les résultats de l’appel <xref:System.Uri.GetLeftPart%2A> avec <xref:System.UriPartial.Scheme>, <xref:System.UriPartial.Authority>, <xref:System.UriPartial.Path>, ou <xref:System.UriPartial.Query>.  
  
|URI|Scheme|Autorité|Chemin d’accès|Query|  
|---------|------------|---------------|----------|-----------|  
|http://www.contoso.com/index.htm?date=today|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm?date=today|  
|http://www.contoso.com/index.htm#main|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm|  
|mailto:user@contoso.com?subject=uri|mailto :|mailto:user@contoso.com|mailto:user@contoso.com?subject=uri|\<Aucun >|  
|nntp://news.contoso.com/123456@contoso.com|NNTP : / /|NNTP://News.contoso.com|nntp://news.contoso.com/123456@contoso.com|nntp://news.contoso.com/123456@contoso.com|  
|news:123456@contoso.com|Actualités :|news:123456@contoso.com|news:123456@contoso.com|\<Aucun >|  
|file://Server/filename.ext|file://|file://Server|file://Server/filename.ext|file://Server/filename.ext|  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> de l’instance et écrit le chemin d’accès dans la console.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'instance de <see cref="T:System.Uri" /> en cours n'est pas une instance absolue.</exception>
        <exception cref="T:System.ArgumentException">La valeur <paramref name="part" /> spécifiée n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="member this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="uri.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenant les informations nécessaires pour sérialiser <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Objet <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenant la source et la destination du flux sérialisé associé à <see cref="T:System.Uri" />.</param>
        <summary>Retourne les données nécessaires à la sérialisation de l'instance actuelle.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser les méthodes de sérialisation. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="HexEscape">
      <MemberSignature Language="C#" Value="public static string HexEscape (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HexEscape(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexEscape(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexEscape (character As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ HexEscape(char character);" />
      <MemberSignature Language="F#" Value="static member HexEscape : char -&gt; string" Usage="System.Uri.HexEscape character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Caractère à convertir en sa représentation hexadécimale.</param>
        <summary>Convertit un caractère spécifié en son équivalent hexadécimal.</summary>
        <returns>Représentation hexadécimale du caractère spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant convertit un caractère en son équivalent hexadécimal et l’écrit dans la console.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="character" /> est supérieur à 255.</exception>
      </Docs>
    </Member>
    <Member MemberName="HexUnescape">
      <MemberSignature Language="C#" Value="public static char HexUnescape (string pattern, ref int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char HexUnescape(string pattern, int32&amp; index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexUnescape(System.String,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexUnescape (pattern As String, ByRef index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char HexUnescape(System::String ^ pattern, int % index);" />
      <MemberSignature Language="F#" Value="static member HexUnescape : string *  -&gt; char" Usage="System.Uri.HexUnescape (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="pattern">Représentation hexadécimale d'un caractère.</param>
        <param name="index">Emplacement dans <c>pattern</c> où la représentation hexadécimale d’un caractère commence.</param>
        <summary>Convertit une représentation hexadécimale spécifiée d'un caractère en ce caractère.</summary>
        <returns>Caractère représenté par l'encodage hexadécimal à la position <paramref name="index" />. Si le caractère à la position <paramref name="index" /> n'a pas un encodage hexadécimal, le caractère à la position <paramref name="index" /> est retourné. La valeur de <paramref name="index" /> est incrémentée pour pointer vers le caractère suivant celui qui est retourné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’exemple de code suivant détermine si un caractère est codé en hexadécimal et, si tel est le cas, écrit le caractère équivalent dans la console.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à 0 ou supérieur ou égal au nombre de caractères contenus dans <paramref name="pattern" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Host" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Host : string" Usage="System.Uri.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le composant hôte de cette instance.</summary>
        <value>
          <see cref="T:System.String" /> qui contient le nom d'hôte. Il s'agit généralement du nom de l'hôte DNS ou de l'adresse IP du serveur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à la <xref:System.Uri.Authority%2A> propriété, cette valeur de propriété n’inclut pas le numéro de port.  
  
   
  
## Examples  
 L’exemple suivant écrit le nom d’hôte (www.contoso.com) du serveur dans la console.  
  
 [!code-cpp[Classic Uri.Host Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Host Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Host Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Host Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Host Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Host Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="HostNameType">
      <MemberSignature Language="C#" Value="public UriHostNameType HostNameType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.UriHostNameType HostNameType" />
      <MemberSignature Language="DocId" Value="P:System.Uri.HostNameType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HostNameType As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property UriHostNameType HostNameType { UriHostNameType get(); };" />
      <MemberSignature Language="F#" Value="member this.HostNameType : UriHostNameType" Usage="System.Uri.HostNameType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type du nom d'hôte spécifié dans l'URI.</summary>
        <value>Membre de l'énumération <see cref="T:System.UriHostNameType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> instance et écrit le <xref:System.Uri.HostNameType%2A> à la console.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="IdnHost">
      <MemberSignature Language="C#" Value="public string IdnHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IdnHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IdnHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IdnHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ IdnHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IdnHost : string" Usage="System.Uri.IdnHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Nom de domaine international conforme à la norme RFC 3490 de l'hôte, avec Punycode le cas échéant. Cette chaîne, une fois sans séquence d’échappement si nécessaire, peut être utilisée en toute sécurité pour la résolution DNS.</summary>
        <value>Retourne le nom d'hôte, mis en forme avec Punycode conformément à la norme IDN<see cref="T:System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est fournie pour l’utilisation de protocoles de réseau de niveau inférieur qui nécessitent le nom de domaine sous forme de Punycode. Si votre code ne requiert pas ce format spécifique, utilisez <xref:System.Uri.Host%2A> pour le nom d’hôte.  
  
 Déconseillées <xref:System.Uri.DnsSafeHost%2A> propriété dépend de *app.config* paramètres, qui ne peut pas être modifiés par les applications du Windows Store. IdnHost est fourni en tant que l’alternative recommandée à l’utilisation de <xref:System.Uri.DnsSafeHost%2A>, car <xref:System.Uri.IdnHost%2A> est garantie comme étant toujours DNS sécurisé, quel que soit l’actuellement *app.config* peut-être des paramètres.  

 Si vous avez utilisé une chaîne avec séquence d’échappement pour construire cette instance (par exemple, « http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), puis IdnHost renvoie une chaîne avec séquence d’échappement. Vous devez unescape n’importe quelle chaîne avec séquence d’échappement retourné à partir de IdnHost avant d’utiliser cette chaîne pour la résolution DNS. N’oubliez pas qu’en cas que vous avez utilisé une chaîne sans séquence d’échappement non valide pour construire cette instance (par exemple, « http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), IdnHost retourne une chaîne sans séquence d’échappement.


 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAbsoluteUri">
      <MemberSignature Language="C#" Value="public bool IsAbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsAbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbsoluteUri As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbsoluteUri { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbsoluteUri : bool" Usage="System.Uri.IsAbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'instance <see cref="T:System.Uri" /> est absolue.</summary>
        <value>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si l'instance <see cref="T:System.Uri" /> est absolue ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est `true` si la chaîne ou <xref:System.Uri> instance qui a été passé au constructeur peut être analysée comme une absolue <xref:System.Uri> instance qui contient un schéma, une autorité et un chemin d’accès. Sinon, le <xref:System.Uri> instance est traitée comme étant relative et peut omettre le schéma ou autres composants URI.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBadFileSystemCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsBadFileSystemCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsBadFileSystemCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBadFileSystemCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsBadFileSystemCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsBadFileSystemCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsBadFileSystemCharacter : char -&gt; bool&#xA;override this.IsBadFileSystemCharacter : char -&gt; bool" Usage="uri.IsBadFileSystemCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">
          <see cref="T:System.Char" /> à tester.</param>
        <summary>Obtient une valeur indiquant si un caractère n'est pas valide dans un nom de système de fichiers.</summary>
        <returns>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si le caractère spécifié n'est pas valide ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le caractère est analysé selon les règles pour le système de fichiers NTFS.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBaseOf">
      <MemberSignature Language="C#" Value="public bool IsBaseOf (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBaseOf(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBaseOf(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBaseOf(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.IsBaseOf : Uri -&gt; bool" Usage="uri.IsBaseOf uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Instance de <see cref="T:System.Uri" /> spécifiée à tester.</param>
        <summary>Détermine si l'instance de <see cref="T:System.Uri" /> actuelle est une base de l'instance de <see cref="T:System.Uri" /> spécifiée.</summary>
        <returns>
          <see langword="true" /> si l'instance actuelle de <see cref="T:System.Uri" /> est une base de <paramref name="uri" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsBaseOf%2A> est utilisé pour comparer les cours <xref:System.Uri> instance à une certaine <xref:System.Uri> pour déterminer si cet URI est une base pour le texte spécifié <xref:System.Uri>. Lors de la comparaison de deux <xref:System.Uri> objets pour déterminer une relation de base, les informations de l’utilisateur (<xref:System.Uri.UserInfo%2A>) n’est pas évaluée. Lorsque vous comparez deux URI (uri1 et uri2), uri1 est la base d’uri2 si, lorsque vous ignorez tout dans l’uri2 après la dernière barre oblique (/), les deux URI sont identiques. À l’aide de http://host/path/path/file?query comme URI de base, le tableau suivant indique qu’il s’agisse d’une base pour les autres URI.  
  
|URI|http://host/path/path/file?query est la base|  
|---------|------------------------------------------------------|  
|http://host/path/path/file/|oui|  
|http://host/path/path/#fragment|oui|  
|http://host/path/path/MoreDir/"|oui|  
|http://host/path/path/OtherFile?Query|oui|  
|http://host/path/path/|oui|  
|http://host/path/path/file|oui|  
|http://host/path/path|Non|  
|http://host/path/path?query|Non|  
|http://host/path/path#Fragment|Non|  
|http://host/path/path2/|Non|  
: //host/path/path2/MoreDir|Non|  
|http://host/path/File|Non|  
  
   
  
## Examples  
 Cet exemple crée un <xref:System.Uri> instance qui représente une base <xref:System.Uri> instance. Il crée ensuite un deuxième <xref:System.Uri> instance à partir d’une chaîne. Il appelle <xref:System.Uri.IsBaseOf%2A> pour déterminer si l’instance de base est la base de la deuxième instance. Le résultat est écrit dans la console.  
  
 [!code-cpp[NCLUriEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#6)]
 [!code-csharp[NCLUriEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#6)]
 [!code-vb[NCLUriEnhancements#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultPort">
      <MemberSignature Language="C#" Value="public bool IsDefaultPort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefaultPort" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsDefaultPort" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDefaultPort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDefaultPort { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefaultPort : bool" Usage="System.Uri.IsDefaultPort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la valeur du port de l'URI est la valeur par défaut pour ce schéma.</summary>
        <value>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si la valeur de la propriété <see cref="P:System.Uri.Port" /> est le port par défaut de ce schéma ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> de l’instance et vérifie si elle utilise le port par défaut.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsExcludedCharacter">
      <MemberSignature Language="C#" Value="protected static bool IsExcludedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool IsExcludedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsExcludedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function IsExcludedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool IsExcludedCharacter(char character);" />
      <MemberSignature Language="F#" Value="static member IsExcludedCharacter : char -&gt; bool" Usage="System.Uri.IsExcludedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">
          <see cref="T:System.Char" /> à tester.</param>
        <summary>Obtient une valeur indiquant si le caractère spécifié doit être placé dans une séquence d'échappement.</summary>
        <returns>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si le caractère spécifié doit être placé dans une séquence d'échappement ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFile">
      <MemberSignature Language="C#" Value="public bool IsFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFile" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsFile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFile { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFile : bool" Usage="System.Uri.IsFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Uri" /> spécifié est un URI de fichier.</summary>
        <value>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si <see cref="T:System.Uri" /> est un URI de fichier ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.IsFile%2A> propriété est `true` lorsque le <xref:System.Uri.Scheme%2A> propriété equals <xref:System.Uri.UriSchemeFile>.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> de l’instance et détermine s’il est un URI de fichier.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsHexDigit">
      <MemberSignature Language="C#" Value="public static bool IsHexDigit (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexDigit(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexDigit (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexDigit(char character);" />
      <MemberSignature Language="F#" Value="static member IsHexDigit : char -&gt; bool" Usage="System.Uri.IsHexDigit character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Caractère à valider.</param>
        <summary>Détermine si un caractère spécifié est un chiffre hexadécimal valide.</summary>
        <returns>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si le caractère est un chiffre hexadécimal valide ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiffres hexadécimaux sont les chiffres 0 à 9 et les lettres A-F ou a-f.  
  
   
  
## Examples  
 L’exemple suivant détermine si un caractère est un caractère hexadécimal et, si elle est, écrit la valeur décimale correspondante dans la console.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHexEncoding">
      <MemberSignature Language="C#" Value="public static bool IsHexEncoding (string pattern, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexEncoding(string pattern, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexEncoding(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexEncoding (pattern As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexEncoding(System::String ^ pattern, int index);" />
      <MemberSignature Language="F#" Value="static member IsHexEncoding : string * int -&gt; bool" Usage="System.Uri.IsHexEncoding (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pattern">Chaîne à vérifier.</param>
        <param name="index">Emplacement dans <c>pattern</c> où l’encodage hexadécimal doit être vérifié.</param>
        <summary>Détermine si un caractère d'une chaîne est encodé en hexadécimal.</summary>
        <returns>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si <paramref name="pattern" /> a un encodage hexadécimal à l'emplacement spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.IsHexEncoding%2A> méthode vérifie l’encodage hexadécimal qui suit le modèle « %hexhex » dans une chaîne, où « hex » est un chiffre compris entre 0 à 9 ou une lettre de A à F (non-respect de la casse).  
  
   
  
## Examples  
 L’exemple de code suivant détermine si un caractère est codé en hexadécimal et, si tel est le cas, écrit le caractère équivalent dans la console.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public bool IsLoopback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsLoopback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoopback { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoopback : bool" Usage="System.Uri.IsLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Uri" /> spécifié référence l'hôte local.</summary>
        <value>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si ce <see cref="T:System.Uri" /> référence l'hôte local ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsLoopback%2A> Retourne `true` si l’URI spécifié lors de la création de cette instance était 127.0.0.1, loopback ou localhost, ou si l’URI ne spécifiait pas informations (par exemple, file:///c:Dir/file.txt) de l’hôte. Tous les autres URI retournent `false`.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> de l’instance et détermine si elle fait référence à un hôte local.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReservedCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsReservedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsReservedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsReservedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsReservedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsReservedCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsReservedCharacter : char -&gt; bool&#xA;override this.IsReservedCharacter : char -&gt; bool" Usage="uri.IsReservedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">
          <see cref="T:System.Char" /> à tester.</param>
        <summary>Obtient une valeur indiquant si le caractère spécifié est réservé.</summary>
        <returns>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si le caractère spécifié est un caractère réservé ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnc">
      <MemberSignature Language="C#" Value="public bool IsUnc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnc" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsUnc" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnc As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnc { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnc : bool" Usage="System.Uri.IsUnc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Uri" /> spécifié est un chemin d'accès UNC (Universal Naming Convention).</summary>
        <value>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si <see cref="T:System.Uri" /> est un chemin d’accès UNC (Universal Naming Convention) ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.IsUnc%2A> propriété est `true` si spécifié <xref:System.Uri> instance est un chemin d’accès UNC (tel que \\\server\folder ou file://server/folder). Cette propriété retourne toujours `true` si l’URI a le schéma file:// et spécifie un composant de l’hôte.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> de l’instance et détermine s’il s’agit d’un chemin d’accès UNC.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedOriginalString">
      <MemberSignature Language="C#" Value="public bool IsWellFormedOriginalString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsWellFormedOriginalString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedOriginalString" />
      <MemberSignature Language="VB.NET" Value="Public Function IsWellFormedOriginalString () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsWellFormedOriginalString();" />
      <MemberSignature Language="F#" Value="member this.IsWellFormedOriginalString : unit -&gt; bool" Usage="uri.IsWellFormedOriginalString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indique si la chaîne utilisée pour construire ce  <see cref="T:System.Uri" /> était bien formée et qu'elle ne doit pas également faire l'objet d'une séquence d'échappement.</summary>
        <returns>Valeur <see cref="T:System.Boolean" /> qui est <see langword="true" /> si la chaîne est de forme correcte ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chaîne est considéré comme correctement construit conformément à la norme RFC 2396 et RFC 2732 par défaut. Si International Resource Identifiers (IRIs) ou l’analyse du nom de domaine international (IDN) est activée, la chaîne est considéré comme correctement formée conformément à RFC 3986 et RFC 3987  
  
 La chaîne est considéré comme une forme incorrecte, à l’origine de la méthode retourne false, si une des conditions suivantes se produit.  
  
|Error|Exemple|  
|-----------|-------------|  
|La chaîne n’est pas correctement échappée.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Nom|  
|La chaîne est une absolue <xref:System.Uri> qui représente un fichier implicit <xref:System.Uri>.|c:\\\directory\filename|  
|La chaîne est un URI absolu auquel il manque une barre oblique avant le chemin d’accès.|file://c:/Directory/filename|  
|La chaîne contient des barres obliques inverses sans séquence d’échappement, même si elles sont traitées comme des barres obliques.|http :\\\host/path/file|  
|La chaîne représente une absolue hiérarchique <xref:System.Uri> et ne contient pas «  :// ».|www.contoso.com/path/file|  
|L’analyseur pour le <xref:System.Uri.Scheme%2A?displayProperty=nameWithType> indique que la chaîne d’origine n’a pas bien formée.|L’exemple varie selon le schéma de l’URI.|  
  
 Par défaut, la chaîne utilisée pour construire ce <xref:System.Uri> sont considérées comme correctement formée conformément à la norme RFC 2396 et RFC 2732.  
  
 Lorsque l’identificateur IRI (International Resource) et la prise en charge du nom de domaine international (IDN) sont activés, la chaîne utilisée pour construire ce <xref:System.Uri> sont considérés comme correctement formées conformément à RFC 3986 et RFC 3987. Utilisé pour prendre en charge des IRI les noms Punycode contiennent uniquement des caractères ASCII et commencent toujours par le préfixe xn--.  
  
 Pour plus d’informations sur la prise en charge des IRI, consultez la section Notes pour la <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://www.ietf.org/">http://www.ietf.org</related>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedUriString">
      <MemberSignature Language="C#" Value="public static bool IsWellFormedUriString (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWellFormedUriString(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedUriString(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWellFormedUriString(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="static member IsWellFormedUriString : string * UriKind -&gt; bool" Usage="System.Uri.IsWellFormedUriString (uriString, uriKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Chaîne utilisée pour tenter de construire un <see cref="T:System.Uri" />.</param>
        <param name="uriKind">Type de <see cref="T:System.Uri" /> dans <c>uriString</c>.</param>
        <summary>Indique si la chaîne est bien formée en essayant de construire un URI avec la chaîne et garantit que la chaîne ne doit pas également faire l'objet d'une séquence d'échappement.</summary>
        <returns>Valeur <see cref="T:System.Boolean" /> qui est <see langword="true" /> si la chaîne est de forme correcte ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans les versions de .NET avant la version 4.5, par défaut la chaîne est considéré comme correctement formées conformément à la norme RFC 2396 et RFC 2732. Si International Resource Identifiers (IRIs) ou l’analyse du nom de domaine international (IDN) est activé, la chaîne est considéré comme correctement formées conformément à RFC 3986 et RFC 3987.  
  
 À compter de .NET 4.5, les chaînes sont toujours considérées comme correctement formées conformément RFC 3986 et RFC 3987, ou non IRI ou des IDN sont activées. Notez, toutefois, cela n’est vrai pour les applications qui ciblent le .NET 4.5 ou version ultérieure. Les applications qui ciblent le .NET 4.0 appelle le code de compatibilité et expérience de l’ancien comportement (versions antérieures à la version 4.5).  
  
 La chaîne est considéré comme une forme incorrecte, à l’origine de la méthode retourne false, si une des conditions suivantes se produit  
  
|Error|Exemple|  
|-----------|-------------|  
|La chaîne n’est pas correctement échappée.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Nom|  
|La chaîne est une absolue <xref:System.Uri> qui représente un fichier implicit <xref:System.Uri>.|c:\\\directory\filename|  
|La chaîne est un URI absolu auquel il manque une barre oblique avant le chemin d’accès.|file://c:/Directory/filename|  
|La chaîne contient des barres obliques inverses sans séquence d’échappement, même si elles sont traitées comme des barres obliques|http :\\\host/path/file|  
|La chaîne représente une absolue hiérarchique <xref:System.Uri> et ne contient pas «  :// »|www.contoso.com/path/file|  
|L’analyseur pour le <xref:System.Uri.Scheme%2A> indique que la chaîne d’origine n’a pas bien formée.|L’exemple varie selon le schéma de l’URI.|  
|Depuis .NET 4.5, les URI relatifs avec un signe deux-points (« : ») dans leur premier segment ne sont pas considérés bien formé.|2013.05.29_14:33:41|  
  
 Pour plus d’informations sur la prise en charge des IRI, consultez la section Notes pour la <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://www.ietf.org/">http://www.ietf.org</related>
      </Docs>
    </Member>
    <Member MemberName="LocalPath">
      <MemberSignature Language="C#" Value="public string LocalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalPath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.LocalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LocalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalPath : string" Usage="System.Uri.LocalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une représentation du système d'exploitation local d'un nom de fichier.</summary>
        <value>
          <see cref="T:System.String" /> qui contient la représentation du système d'exploitation local d'un nom de fichier.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par cette propriété est sans séquence d’échappement. Si le chemin d’accès est reconnu comme un chemin d’accès de fichier Windows, toutes les barres obliques (/) sont remplacées par des barres obliques descendante (\\).  
  
 Pour l’URI `file://computer/file.ext`, le chemin d’accès absolu est `/file.ext` et le chemin d’accès local est `\\computer\file.ext`.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> de l’instance et écrit le chemin d’accès local dans la console.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelative">
      <MemberSignature Language="C#" Value="public string MakeRelative (Uri toUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MakeRelative(class System.Uri toUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelative(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function MakeRelative (toUri As Uri) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MakeRelative(Uri ^ toUri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelative : Uri -&gt; string" Usage="uri.MakeRelative toUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="toUri">URI à comparer à l'URI en cours.</param>
        <summary>Détermine la différence entre deux instances de <see cref="T:System.Uri" />.</summary>
        <returns>Si le nom d'hôte et le schéma de cette instance d'URI et <paramref name="toUri" /> sont identiques, cette méthode retourne une <see cref="T:System.String" /> qui représente un URI relatif qui, lorsqu'il est ajouté à l'instance d'URI actuelle, donne le paramètre <paramref name="toUri" />.  
  
Si le nom d'hôte ou le schéma est différent, cette méthode retourne une <see cref="T:System.String" /> qui représente le paramètre <paramref name="toUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant présente l’instance d’URI, `toUri`et les résultats de l’appel <xref:System.Uri.MakeRelative%2A>.  
  
|Instance d’URI actuelle|`toUri`|Valeur de retour|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|test/test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|Test1/test1.txt|  
  
 Informations de l’utilisateur, s’il est présent dans l’URI, sont ignorées.  
  
   
  
## Examples  
 L’exemple suivant crée 2 <xref:System.Uri> instances. La différence dans les informations de chemin d’accès est écrite dans la console.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toUri" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif ; cette méthode est valide uniquement pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelativeUri">
      <MemberSignature Language="C#" Value="public Uri MakeRelativeUri (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri MakeRelativeUri(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelativeUri(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ MakeRelativeUri(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelativeUri : Uri -&gt; Uri" Usage="uri.MakeRelativeUri uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">URI à comparer à l'URI en cours.</param>
        <summary>Détermine la différence entre deux instances de <see cref="T:System.Uri" />.</summary>
        <returns>Si le nom d'hôte et le schéma de cette instance d'URI et <paramref name="uri" /> sont identiques, cette méthode retourne un <see cref="T:System.Uri" /> relatif qui, lorsqu'il est ajouté à l'instance d'URI actuelle, donne <paramref name="uri" />.  
  
Si le nom d'hôte ou le schéma est différent, cette méthode retourne une <see cref="T:System.Uri" /> qui représente le paramètre <paramref name="uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant présente l’instance d’URI, `toUri`et les résultats de l’appel <xref:System.Uri.MakeRelativeUri%2A>.  
  
|Instance d’URI actuelle|`toUri`|Valeur de retour|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|test/test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|Test1/test1.txt|  
  
 Informations de l’utilisateur, s’il est présent dans l’URI, sont ignorées.  
  
   
  
## Examples  
 L’exemple suivant crée 2 <xref:System.Uri> instances. La différence dans les informations de chemin d’accès est écrite dans la console.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Equality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Uri * Uri -&gt; bool" Usage="uri1 = uri2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">Instance de <see cref="T:System.Uri" /> à comparer à <c>uri2</c>.</param>
        <param name="uri2">Instance de <see cref="T:System.Uri" /> à comparer à <c>uri1</c>.</param>
        <summary>Détermine si deux instances <see cref="T:System.Uri" /> ont la même valeur.</summary>
        <returns>Valeur <see cref="T:System.Boolean" /> qui est <see langword="true" /> si les instances <see cref="T:System.Uri" /> sont équivalentes ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge utilise le <xref:System.Uri.Equals%2A> méthode pour déterminer si les deux <xref:System.Uri> instances sont équivalentes. <xref:System.Uri.UserInfo%2A> et <xref:System.Uri.Fragment%2A> contenu est ignoré lors de cette comparaison.  
  
   
  
## Examples  
 Cet exemple crée trois <xref:System.Uri> instances à partir de chaînes et les compare pour déterminer si elles représentent la même valeur. `Address1` et `Address2` sont identiques, car le <xref:System.Uri.Fragment%2A> partie est ignorée pour cette comparaison. Le résultat est écrit dans la console.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Inequality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Uri * Uri -&gt; bool" Usage="System.Uri.op_Inequality (uri1, uri2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">Instance de <see cref="T:System.Uri" /> à comparer à <c>uri2</c>.</param>
        <param name="uri2">Instance de <see cref="T:System.Uri" /> à comparer à <c>uri1</c>.</param>
        <summary>Détermine si deux instances de <see cref="T:System.Uri" /> n'ont pas la même valeur.</summary>
        <returns>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si les deux instances <see cref="T:System.Uri" /> ne sont pas égales ; sinon, <see langword="false" />. Si l'un des deux paramètres est <see langword="null" />, cette méthode retourne <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge utilise le <xref:System.Uri.Equals%2A> méthode pour déterminer si les deux <xref:System.Uri> instances ne sont pas équivalentes. <xref:System.Uri.UserInfo%2A> et <xref:System.Uri.Fragment%2A> contenu est ignoré lors de cette comparaison.  
  
   
  
## Examples  
 Cet exemple crée trois <xref:System.Uri> instances à partir de chaînes et les compare pour déterminer si elles représentent la même valeur. `Address2` et `Address3` ne sont pas identiques, car `Address3` contient un <xref:System.Uri.Query%2A> qui est introuvable dans `Address2`. Le résultat est écrit dans la console.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalString">
      <MemberSignature Language="C#" Value="public string OriginalString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OriginalString" />
      <MemberSignature Language="DocId" Value="P:System.Uri.OriginalString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OriginalString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalString : string" Usage="System.Uri.OriginalString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la chaîne d'URI d'origine passée au constructeur <see cref="T:System.Uri" />.</summary>
        <value>
          <see cref="T:System.String" /> contenant l'URI exact spécifié lors de la construction de cette instance ; sinon, <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’URI spécifié au constructeur contenait des espaces à droite ni, ces espaces sont conservés.  
  
 La valeur retournée par cette propriété est différente de <xref:System.Uri.ToString%2A> et <xref:System.Uri.AbsoluteUri%2A>. <xref:System.Uri.ToString%2A> Retourne la forme réglementaire sans séquence d’échappement de l’URI. <xref:System.Uri.AbsoluteUri%2A> Retourne la forme réglementaire avec séquence d’échappement de l’URI.  
  
 Lors de la prise en charge de l’identificateur IRI (International Resource) et le nom de domaine international (IDN) sont activés, <xref:System.Uri.OriginalString%2A> retourne la chaîne non normalisée d’origine avec le nom d’hôte Punycode si un seul était utilisé pour initialiser le <xref:System.Uri> instance. Les noms Punycode contiennent uniquement des caractères ASCII et commencent toujours par le préfixe xn--.  
  
 Pour plus d’informations sur la prise en charge des IRI, consultez la section Notes pour la <xref:System.Uri> classe.  
  
 Quand un <xref:System.Uri> objet est sérialisé, le <xref:System.Uri.OriginalString%2A> n’est pas conservé. Le processus de sérialisation utilise entièrement avec séquence d’échappement et au format canonique <xref:System.Uri.AbsoluteUri%2A> propriété lors de la sérialisation. Pour un <xref:System.Uri> qui contient une adresse IPv6, l’adresse IPv6 et l’ID de portée sont inclus dans la liste sérialisée <xref:System.Uri> objet.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Uri> instance à partir d’une chaîne. Il illustre la différence entre la valeur retournée par <xref:System.Uri.OriginalString%2A>, qui retourne la chaîne qui a été passée au constructeur et à partir d’un appel à <xref:System.Uri.ToString%2A>, qui retourne la forme canonique de la chaîne.  
  
 [!code-cpp[NCLUriEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#3)]
 [!code-csharp[NCLUriEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#3)]
 [!code-vb[NCLUriEnhancements#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected virtual void Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Parse" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Parse ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Parse();" />
      <MemberSignature Language="F#" Value="abstract member Parse : unit -&gt; unit&#xA;override this.Parse : unit -&gt; unit" Usage="uri.Parse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analyse l'URI de l'instance actuelle pour s'assurer qu'il contient toutes les parties requises pour un URI valide.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">L'URI passé du constructeur n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="PathAndQuery">
      <MemberSignature Language="C#" Value="public string PathAndQuery { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathAndQuery" />
      <MemberSignature Language="DocId" Value="P:System.Uri.PathAndQuery" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathAndQuery As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathAndQuery { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathAndQuery : string" Usage="System.Uri.PathAndQuery" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les propriétés <see cref="P:System.Uri.AbsolutePath" /> et <see cref="P:System.Uri.Query" /> séparées par un point d'interrogation (?).</summary>
        <value>
          <see cref="T:System.String" /> qui contient les propriétés <see cref="P:System.Uri.AbsolutePath" /> et <see cref="P:System.Uri.Query" /> séparées par un point d'interrogatio (?).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.PathAndQuery%2A> propriété contient le chemin d’accès absolu sur le serveur et les informations de requête envoyées avec la demande. Il est identique à la concaténation du <xref:System.Uri.AbsolutePath%2A> et <xref:System.Uri.Query%2A> propriétés.  
  
 Le <xref:System.Uri.PathAndQuery%2A> propriété est échappée selon la norme RFC 2396 par défaut. Si International Resource Identifiers (IRIs) ou l’analyse du nom de domaine international (IDN) est activée, le <xref:System.Uri.PathAndQuery%2A> propriété est échappée selon la norme RFC 3986 et RFC 3987.  
  
 Pour plus d’informations sur la prise en charge des IRI, consultez la section Notes pour la <xref:System.Uri> classe.  
  
   
  
## Examples  
 L’exemple suivant écrit le chemin d’accès URI (/ /catalog/shownew.htm) et de requête (date = today) informations sur la console.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.PathAndQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Port" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Port As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Port { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Port : int" Usage="System.Uri.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le numéro de port de l'URI spécifié.</summary>
        <value>Valeur <see cref="T:System.Int32" /> qui contient le numéro de port pour cet URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le numéro de port définit le port de protocole utilisé pour contacter le serveur référencé dans l’URI. Si aucun port n’est pas spécifié dans le cadre de l’URI, le <xref:System.Uri.Port%2A> propriété retourne la valeur par défaut pour le protocole. S’il n’existe aucun numéro de port par défaut, cette propriété retourne -1.  
  
   
  
## Examples  
 L’exemple suivant écrit le numéro de port d’URI dans la console. Dans ce cas, la valeur est le numéro de port par défaut pour HTTP, le port 80.  
  
 [!code-cpp[Classic Uri.Port Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Port Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Port Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Port Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Port Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Port Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="Query">
      <MemberSignature Language="C#" Value="public string Query { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Query" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Query" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Query As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Query { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Query : string" Usage="System.Uri.Query" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les informations de requête incluses dans l'URI spécifié.</summary>
        <value>
          <see cref="T:System.String" /> contient les informations de requête incluses dans l'URI spécifié.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.Query%2A> propriété contient les informations de requête incluses dans l’URI. Informations de requête, les informations de chemin d’accès sont séparées par un point d’interrogation ( ?) et continuent jusqu'à la fin de l’URI. Les informations de requête retournées incluent le premier point d’interrogation.  
  
 Par défaut, les informations de requête sont ignorées en fonction de la norme RFC 2396. Si International Resource Identifiers (IRIs) ou l’analyse du nom de domaine international (IDN) est activée, les informations de requête sont échappées selon la norme RFC 3986 et RFC 3987.  
  
 Pour plus d’informations sur la prise en charge des IRI, consultez la section Notes pour la <xref:System.Uri> classe.  
  
   
  
## Examples  
 L’exemple suivant écrit la requête ? date = today dans la console.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#2)]
 [!code-vb[Classic Uri.PathAndQuery Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.Uri.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de schéma de cet URI.</summary>
        <value>
          <see cref="T:System.String" /> qui contient le schéma pour cet URI, converti en minuscules.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.Scheme%2A> propriété retourne le schéma utilisé pour initialiser le <xref:System.Uri> instance. Cette propriété n’indique pas que le schéma utilisé pour initialiser le <xref:System.Uri> instance a été reconnue.  
  
 Le tableau suivant présente des exemples de valeurs possibles retournées par la <xref:System.Uri.Scheme%2A> propriété.  
  
|Scheme|Description |  
|------------|-----------------|  
|fichier|La ressource est un fichier sur l’ordinateur local.|  
|ftp|La ressource est accessible via FTP.|  
|gopher|La ressource est accessible via le protocole Gopher.|  
|http|La ressource est accessible via HTTP.|  
|https|La ressource est accessible via HTTP cryptées SSL.|  
|LDAP|La ressource est accessible via le protocole LDAP.|  
|mailto|La ressource est une adresse de messagerie et accessible via le protocole SMTP.|  
|net.pipe|La ressource est accessible via un canal nommé.|  
|net.tcp|La ressource est accessible à partir du point de terminaison TCP.|  
|news|La ressource est accessible via le protocole NNTP.|  
|NNTP|La ressource est accessible via le protocole NNTP.|  
|telnet|La ressource est accessible via le protocole TELNET.|  
|uuid|La ressource est accessible via un nom de point de terminaison UUID unique pour communiquer avec un service.|  
  
   
  
## Examples  
 L’exemple suivant écrit le nom du schéma (http) dans la console pour la http://www.contoso.com/ URI.  
  
 [!code-cpp[Classic Uri.Scheme Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Scheme Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Scheme Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Scheme Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemeDelimiter">
      <MemberSignature Language="C#" Value="public static readonly string SchemeDelimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string SchemeDelimiter" />
      <MemberSignature Language="DocId" Value="F:System.Uri.SchemeDelimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SchemeDelimiter As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ SchemeDelimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable SchemeDelimiter : string" Usage="System.Uri.SchemeDelimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie les caractères qui séparent le schéma du protocole de communication de la partie adresse de l'URI. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée une chaîne à partir de <xref:System.Uri.UriSchemeHttp>, <xref:System.Uri.SchemeDelimiter>et une adresse. Un <xref:System.Uri> instance est ensuite créée à partir de la chaîne.  
  
 [!code-cpp[NCLUriExamples#17](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#17)]
 [!code-csharp[NCLUriExamples#17](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#17)]
 [!code-vb[NCLUriExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Segments">
      <MemberSignature Language="C#" Value="public string[] Segments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Segments" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Segments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Segments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Segments { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Segments : string[]" Usage="System.Uri.Segments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un tableau contenant des segments de chemin d’accès qui composent l’URI spécifié.</summary>
        <value>Tableau <see cref="T:System.String" /> qui contient les segments de chemin d’accès qui composent l’URI spécifié.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.Segments%2A> propriété retourne un tableau de chaînes contenant les « segments » (sous-chaînes) qui forment le chemin d’accès absolu de l’URI. Le premier segment est obtenu en analysant le chemin d’accès absolu à partir de son premier caractère jusqu'à ce que vous atteigniez une barre oblique (/) ou à la fin du chemin d’accès. Chaque segment supplémentaire commence au premier caractère après le segment précédent et se termine par une barre oblique suivante ou à la fin du chemin d’accès. (Chemin d’accès absolu d’un URI contient tous les éléments après l’hôte et le port et avant la requête et fragment).  
  
 L’exemple suivant montre les segments et le chemin d’accès absolu pour les deux URI. Le deuxième exemple montre que le fragment et la requête ne font pas partie du chemin d’accès absolu et ne sont donc pas segments.  
  
 URI absolu :  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm  
  
 Chemin d’accès absolu :  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segments :  
 - /
 - Chapitres /
 - Chapter1 /
 - Sections /
 - Section1.htm  
  
 URI absolu :  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm#page1?answer=NO  
  
 Chemin d’accès absolu :  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segments :  
 - /
 - Chapitres /
 - Chapter1 /
 - Sections /
 - Section1.htm  
  
 Notez que, étant donné que le chemin d’accès absolu commence par un « / », le premier segment contient, ainsi que rien d’autre.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> instance avec 3 segments et affiche les segments à l’écran.  
  
 [!code-cpp[NCLUriExamples#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#5)]
 [!code-csharp[NCLUriExamples#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#5)]
 [!code-vb[NCLUriExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenant les informations nécessaires pour sérialiser <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Objet <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenant la source et la destination du flux sérialisé associé à <see cref="T:System.Uri" />.</param>
        <summary>Retourne les données nécessaires à la sérialisation de l'instance actuelle.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser les méthodes de sérialisation. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="uri.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une représentation canonique sous forme de chaîne de l'instance de <see cref="T:System.Uri" />.</summary>
        <returns>Instance de <see cref="T:System.String" /> qui contient la représentation réglementaire sans séquence d'échappement de l'instance de <see cref="T:System.Uri" />. Tous les caractères sont sans séquence d'échappement, hormis #, ? et %.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chaîne retournée par cette méthode ne contient pas les informations de port lorsque le port est le port par défaut pour le schéma.  
  
> [!NOTE]
>  La chaîne retournée par la <xref:System.Uri.ToString%2A> méthode peut contenir des caractères de contrôle, ce qui peuvent endommager l’état d’une application console. Vous pouvez utiliser la <xref:System.Uri.GetComponents%2A> méthode avec le <xref:System.UriFormat.SafeUnescaped?displayProperty=nameWithType> format pour supprimer des caractères de contrôle de la chaîne retournée.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Uri> instance à partir d’une chaîne. Il illustre la différence entre la valeur retournée par <xref:System.Uri.OriginalString%2A>, qui retourne la chaîne qui a été passée au constructeur et à partir d’un appel à <xref:System.Uri.ToString%2A>, qui retourne la forme canonique de la chaîne.  
  
 [!code-cpp[NCLUriExamples#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#7)]
 [!code-csharp[NCLUriExamples#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#7)]
 [!code-vb[NCLUriExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#7)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour empêcher la dérivation à partir du code partiellement fiable <see cref="T:System.Uri" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryCreate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Uri" />. Ne lève pas d'exception si <see cref="T:System.Uri" /> ne peut pas être créé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (string uriString, UriKind uriKind, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(string uriString, valuetype System.UriKind uriKind, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.String,System.UriKind,System.Uri@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::String ^ uriString, UriKind uriKind, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : string * UriKind *  -&gt; bool" Usage="System.Uri.TryCreate (uriString, uriKind, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="uriString">
          <see cref="T:System.String" /> représentant <see cref="T:System.Uri" />.</param>
        <param name="uriKind">Type d'URI.</param>
        <param name="result">Cette méthode retourne le <see cref="T:System.Uri" /> construit.</param>
        <summary>Crée <see cref="T:System.Uri" /> à l'aide de l'instance de <see cref="T:System.String" /> spécifiée et de <see cref="T:System.UriKind" />.</summary>
        <returns>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si le <see cref="T:System.Uri" /> a été créé avec succès ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette méthode retourne `true`, la nouvelle <xref:System.Uri> est dans `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, string relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, string relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.String,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As String, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, System::String ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * string *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">
          <see cref="T:System.Uri" /> de base.</param>
        <param name="relativeUri">
          <see cref="T:System.Uri" /> relatif, représenté sous la forme de <see cref="T:System.String" /> à ajouter au <see cref="T:System.Uri" /> de base.</param>
        <param name="result">Quand cette méthode est retournée, contient un <see cref="T:System.Uri" /> construit à partir de <c>baseUri</c> et <c>relativeUri</c>. Ce paramètre est passé sans être initialisé.</param>
        <summary>Crée un <see cref="T:System.Uri" /> à l'aide des instances de <see cref="T:System.String" /> de base et relatives.</summary>
        <returns>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si le <see cref="T:System.Uri" /> a été créé avec succès ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette méthode retourne `true`, la nouvelle <xref:System.Uri> est dans `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, Uri relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, class System.Uri relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.Uri,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As Uri, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, Uri ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * Uri *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">
          <see cref="T:System.Uri" /> de base.</param>
        <param name="relativeUri">
          <see cref="T:System.Uri" /> relatif à ajouter à l'<see cref="T:System.Uri" /> de base.</param>
        <param name="result">Quand cette méthode est retournée, contient un <see cref="T:System.Uri" /> construit à partir de <c>baseUri</c> et <c>relativeUri</c>. Ce paramètre est passé sans être initialisé.</param>
        <summary>Crée un <see cref="T:System.Uri" /> à l'aide des instances de <see cref="T:System.Uri" /> de base et relatives.</summary>
        <returns>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si le <see cref="T:System.Uri" /> a été créé avec succès ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette méthode retourne `true`, la nouvelle <xref:System.Uri> est dans `result`.  
  
 Cette méthode construit l’URI, il met en forme canonique et le valide. Si une exception non gérée se produit, cette méthode intercepte. Si vous souhaitez créer un <xref:System.Uri> et obtenir des exceptions utilisent l’un de le <xref:System.Uri.%23ctor%2A> constructeurs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="protected virtual string Unescape (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string Unescape(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Unescape (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ Unescape(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member Unescape : string -&gt; string&#xA;override this.Unescape : string -&gt; string" Usage="uri.Unescape path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <see cref="T:System.String" /> à convertir.</param>
        <summary>Convertit la chaîne spécifiée en remplaçant toutes les séquences d'échappement par leur représentation sans séquence d'échappement.</summary>
        <returns>
          <see cref="T:System.String" /> qui contient la valeur sans séquence d'échappement du paramètre <paramref name="path" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnescapeDataString">
      <MemberSignature Language="C#" Value="public static string UnescapeDataString (string stringToUnescape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UnescapeDataString(string stringToUnescape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.UnescapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnescapeDataString (stringToUnescape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UnescapeDataString(System::String ^ stringToUnescape);" />
      <MemberSignature Language="F#" Value="static member UnescapeDataString : string -&gt; string" Usage="System.Uri.UnescapeDataString stringToUnescape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToUnescape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToUnescape">Chaîne à placer hors d'une séquence d'échappement.</param>
        <summary>Convertit une chaîne en sa représentation sans séquence d'échappement.</summary>
        <returns>
          <see cref="T:System.String" /> qui contient la représentation sans séquence d'échappement de <paramref name="stringToUnescape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez utiliser cette méthode avec précaution. Échappement et de chaîne qui a été précédemment sans séquence d’échappement non peut entraîner des erreurs et des ambiguïtés.  
  
 De plus, de nombreux navigateurs Web échappement espaces à l’intérieur d’URI caractères (« + ») ; Toutefois, la méthode UnescapeDataString ne convertit pas les caractères plus en espaces, car ce comportement n’est pas standard dans tous les schémas d’URI.  
  
   
  
## Examples  
 L’exemple de code suivant annule le remplacement d’un URI, puis convertit tous les caractères plus (« + ») en espaces.  
  
 [!code-csharp[NCLUriExamples#19](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToUnescape" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Uri.EscapeDataString(System.String)" />
        <altmember cref="M:System.Uri.EscapeUriString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFile">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFile" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFile As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFile;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFile : string" Usage="System.Uri.UriSchemeFile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie que l'URI est un pointeur vers un fichier. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans .NET Framework version 1.1, un «`file:///path`« URI a été converti en »`file:/path`». Ceci a été corrigé pour la version 2.0.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> d’instance et détermine si le schéma est <xref:System.Uri.UriSchemeFile>.  
  
 [!code-cpp[NCLUriExamples#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#10)]
 [!code-csharp[NCLUriExamples#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#10)]
 [!code-vb[NCLUriExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFtp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFtp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFtp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFtp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFtp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFtp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFtp : string" Usage="System.Uri.UriSchemeFtp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie que l'URI est accessible par l'intermédiaire du protocole FTP (File Transfer Protocol). Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> d’instance et détermine si le schéma est <xref:System.Uri.UriSchemeFtp>.  
  
 [!code-cpp[NCLUriExamples#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#15)]
 [!code-csharp[NCLUriExamples#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#15)]
 [!code-vb[NCLUriExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeGopher">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeGopher;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeGopher" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeGopher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeGopher As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeGopher;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeGopher : string" Usage="System.Uri.UriSchemeGopher" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie que l'URI est accessible par l'intermédiaire du protocole Gopher. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> d’instance et détermine si le schéma est <xref:System.Uri.UriSchemeGopher>.  
  
 [!code-cpp[NCLUriExamples#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#14)]
 [!code-csharp[NCLUriExamples#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#14)]
 [!code-vb[NCLUriExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttp : string" Usage="System.Uri.UriSchemeHttp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie que l'URI est accessible par l'intermédiaire du protocole HTTP (Hypertext Transfer Protocol). Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> d’instance et détermine si le schéma est <xref:System.Uri.UriSchemeHttp>.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttps">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttps;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttps" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttps" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttps As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttps;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttps : string" Usage="System.Uri.UriSchemeHttps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie que l'URI est accessible par l'intermédiaire du protocole HTTPS (Secure Hypertext Transfer Protocol). Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> d’instance et détermine si le schéma est <xref:System.Uri.UriSchemeHttps>.  
  
 [!code-cpp[NCLUriExamples#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#16)]
 [!code-csharp[NCLUriExamples#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#16)]
 [!code-vb[NCLUriExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeMailto">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeMailto;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeMailto" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeMailto" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeMailto As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeMailto;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeMailto : string" Usage="System.Uri.UriSchemeMailto" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie que l’URI est une adresse e-mail accessible par l’intermédiaire du protocole SMTP (Simple Mail Transport Protocol). Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> d’instance et détermine si le schéma est <xref:System.Uri.UriSchemeMailto>.  
  
 [!code-cpp[NCLUriExamples#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#11)]
 [!code-csharp[NCLUriExamples#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#11)]
 [!code-vb[NCLUriExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetPipe">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetPipe;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetPipe" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetPipe" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetPipe As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetPipe;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetPipe : string" Usage="System.Uri.UriSchemeNetPipe" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie que l'URI est accessible via le modèle NetPipe utilisé par Windows Communication Foundation (WCF). Ce champ est en lecture seule.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetTcp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetTcp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetTcp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetTcp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetTcp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetTcp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetTcp : string" Usage="System.Uri.UriSchemeNetTcp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie que l'URI est accessible via le modèle NetTcp utilisé par Windows Communication Foundation (WCF). Ce champ est en lecture seule.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNews">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNews;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNews" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNews" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNews As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNews;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNews : string" Usage="System.Uri.UriSchemeNews" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie que l'URI est un groupe de discussion Internet accessible par le protocole NNTP (Network News Transport Protocol). Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> d’instance et détermine si le schéma est <xref:System.Uri.UriSchemeNews>.  
  
 [!code-cpp[NCLUriExamples#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#12)]
 [!code-csharp[NCLUriExamples#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#12)]
 [!code-vb[NCLUriExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNntp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNntp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNntp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNntp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNntp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNntp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNntp : string" Usage="System.Uri.UriSchemeNntp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie que l'URI est un groupe de discussion Internet accessible par le protocole NNTP (Network News Transport Protocol). Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le protocole NNTP <xref:System.Uri> l’analyse des erreurs dans .NET Framework version 1.1 ont été corrigées.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> d’instance et détermine si le schéma est <xref:System.Uri.UriSchemeNntp>.  
  
 [!code-cpp[NCLUriExamples#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#13)]
 [!code-csharp[NCLUriExamples#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#13)]
 [!code-vb[NCLUriExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserEscaped">
      <MemberSignature Language="C#" Value="public bool UserEscaped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEscaped" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserEscaped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserEscaped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UserEscaped { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserEscaped : bool" Usage="System.Uri.UserEscaped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique que la chaîne de l'URI a été placée intégralement dans une séquence d'échappement avant la création de l'instance de <see cref="T:System.Uri" />.</summary>
        <value>Valeur <see cref="T:System.Boolean" /> égale à <see langword="true" /> si le paramètre <paramref name="dontEscape" /> a reçu la valeur <see langword="true" /> lors de la création de l'instance <see cref="T:System.Uri" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri.UserEscaped%2A> propriété est définie sur `true` pour indiquer que la chaîne utilisée pour créer le <xref:System.Uri> instance a été une séquence d’échappement avant d’être passée au constructeur ; autrement dit, le `dontEscape` paramètre de l’appel de constructeur a été défini sur `true`.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> de l’instance et détermine si elle a été entièrement échappé lors de sa création.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInfo">
      <MemberSignature Language="C#" Value="public string UserInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserInfo" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInfo : string" Usage="System.Uri.UserInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom d'utilisateur, le mot de passe et d'autres informations spécifiques à l'utilisateur associés à l'URI spécifié.</summary>
        <value>
          <see cref="T:System.String" /> qui contient les informations de l'utilisateur associées à l'URI. La valeur retournée ne comprend pas le caractère « @ » réservé pour délimiter la partie informations utilisateur de l'URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par cette propriété est généralement au format « username : Password ».  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Uri> de l’instance et écrit les informations utilisateur dans la console.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette instance représente un URI relatif, et cette propriété est uniquement valide pour les URI absolus.</exception>
      </Docs>
    </Member>
  </Members>
</Type>