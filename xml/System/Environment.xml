<Type Name="Environment" FullName="System.Environment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ee38aecf8b92514f99bd30fc6610189253e474c8" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37729406" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <TypeSignature Language="F#" Value="type Environment = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides information about, and means to manipulate, the current environment and platform. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Environment> classe à récupérer des informations telles que les arguments de ligne de commande, le code de sortie, les paramètres de variable d’environnement, le contenu de la pile des appels, le temps écoulé depuis le dernier démarrage du système ou la version du common language runtime.  
  
   
  
## Examples  
 L’exemple suivant montre affiche une liste d’informations sur l’environnement actuel.  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandLine : string" Usage="System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the command line for this process.</summary>
        <value>Chaîne contenant les arguments de la ligne de commande.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété fournit l’accès pour le nom du programme et tous les arguments spécifiés sur la ligne de commande lorsque le processus actuel a été démarré.  
  
 Le nom du programme peut inclure des informations de chemin d’accès, mais n’est pas nécessaire de le faire. Utilisez le <xref:System.Environment.GetCommandLineArgs%2A> méthode pour récupérer les informations de ligne de commande analysées et stockées dans un tableau de chaînes.  
  
 La taille maximale de la mémoire tampon de ligne de commande n’est pas définie pour un nombre spécifique de caractères ; Il varie selon le système d’exploitation Windows qui s’exécute sur l’ordinateur.  
  
   
  
## Examples  
 L’exemple suivant affiche sa propre ligne de commande.  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour l’accès en lecture à la variable d’environnement PATH. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the fully qualified path of the current working directory.</summary>
        <value>Chaîne contenant un chemin d'accès au répertoire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par définition, si ce processus démarre dans le répertoire racine d’une variable locale ou un lecteur réseau, la valeur de cette propriété est le nom du lecteur suivi d’une barre oblique de fin (par exemple, « C:\\»). Si ce processus démarre dans un sous-répertoire, la valeur de cette propriété est le chemin de lecteur et de sous-répertoire, sans barre oblique de fin (par exemple, « C:\mySubDirectory »).  
  
   
  
## Examples  
 L’exemple suivant montre comment définir le <xref:System.Environment.CurrentDirectory%2A> propriété.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Attempted to set to an empty string ("").</exception>
        <exception cref="T:System.ArgumentNullException">Attempted to set to <see langword="null." /></exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Attempted to set a local path that cannot be found.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the appropriate permission.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour écrire dans des fichiers ou répertoires dans une opération ensembliste. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations dans le chemin d’accès lui-même dans une opération get. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentManagedThreadId : int" Usage="System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a unique identifier for the current managed thread.</summary>
        <value>Entier représentant un identificateur unique pour ce thread managé.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberSignature Language="F#" Value="static member Exit : int -&gt; unit" Usage="System.Environment.Exit exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">The exit code to return to the operating system. Use 0 (zero) to indicate that the process completed successfully.</param>
        <summary>Terminates this process and returns an exit code to the operating system.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour le `exitCode` paramètre, le nombre d’utiliser une différente de zéro pour indiquer une erreur. Dans votre application, vous pouvez définir vos propres codes d’erreur dans une énumération et renvoyer le code d’erreur approprié selon le scénario. Par exemple, retourner une valeur de 1 pour indiquer que le fichier requis n’est pas présent et la valeur 2 pour indiquer que le fichier est dans un format incorrect. Pour obtenir la liste des codes de sortie utilisé par le système d’exploitation Windows, consultez [Codes d’erreurs système](http://msdn.microsoft.com/library/ms681381.aspx) dans la documentation de Windows.  
  
 Appel de la <xref:System.Environment.Exit%2A> méthode diffère de l’utilisation de votre langage de programmation `return` instruction comme suit :  
  
-   <xref:System.Environment.Exit%2A> toujours met fin à une application. À l’aide de la `return` instruction peut mettre fin à une application uniquement si elle sert de point d’entrée de l’application, comme dans le `Main` (méthode).  
  
-   <xref:System.Environment.Exit%2A> termine une application immédiatement, même si d’autres threads sont en cours d’exécution. Si la `return` instruction est appelée dans le point d’entrée de l’application, elle entraîne l’application mettre fin uniquement après que tous les threads de premier plan sont terminés.  
  
-   <xref:System.Environment.Exit%2A> requiert l’appelant est autorisé à appeler du code non managé. Le `return` n’est pas le cas de l’instruction.  
  
-   Si <xref:System.Environment.Exit%2A> est appelée à partir d’un `try` ou `catch` bloquer, le code dans les `finally` bloc ne s’exécute pas. Si le `return` instruction est utilisée, le code dans le `finally` bloc est exécutée.  
  
-   Si <xref:System.Environment.Exit%2A> est appelée lorsque le code dans un [région d’exécution limitée](~/docs/framework/performance/constrained-execution-regions.md) (CER) est en cours d’exécution, la région d’exécution limitée ne sera pas terminé son exécution. Si la `return` instruction est utilisée, la région d’exécution limitée a été exécutée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have sufficient security permission to perform this function.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the exit code of the process.</summary>
        <value>Entier signé 32 bits contenant le code de sortie. La valeur par défaut est 0 (zéro), qui indique que le processus s'est terminé correctement.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `Main` retourne de la méthode `void`, vous pouvez utiliser cette propriété pour définir le code de sortie qui sera retourné à l’environnement appelant. Si `Main` ne retourne pas `void`, cette propriété est ignorée. La valeur initiale de cette propriété est égale à zéro.  
  
> [!WARNING]
>  Le <xref:System.Environment.ExitCode%2A> propriété est un entier 32 bits signé. Pour empêcher la propriété de retourner un code de sortie négatif, vous ne devez pas utiliser des valeurs supérieures ou égales à 0 x 80000000.  
  
 Utilisez un nombre différent de zéro pour indiquer une erreur. Dans votre application, vous pouvez définir vos propres codes d’erreur dans une énumération et renvoyer le code d’erreur approprié selon le scénario. Par exemple, retourner une valeur de 1 pour indiquer que le fichier requis n’est pas présent et la valeur 2 pour indiquer que le fichier est dans un format incorrect. Pour obtenir la liste des codes de sortie utilisé par le système d’exploitation Windows, consultez [Codes d’erreurs système](http://msdn.microsoft.com/library/ms681381\(v=vs.85\)) dans la documentation de Windows.  
  
   
  
## Examples  
 Voici une application simple nommée Double.exe qui double la valeur entière passée comme un argument de ligne de commande. La valeur affecte les codes d’erreur à la <xref:System.Environment.ExitCode%2A> propriété pour indiquer les conditions d’erreur. Notez que vous devez ajouter une référence à l’assembly System.Numerics.dll pour compiler l’exemple.  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 L’exemple peut ensuite être appelé à partir d’un fichier de commandes telles que la commande suivante, ce qui rend ses codes d’erreur accessible à l’aide de la `ERRORLEVEL` commande.  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 L’exemple suivant montre un exemple de sortie produite en appelant le fichier de commandes.  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Notez que le code de Double.exe est identique dans la fonction à l’exemple suivant, à ceci près que l’ancienne base de données définit un point d’entrée nommé `Main` qui n’a aucune valeur de retour, alors que cet exemple définit un point d’entrée nommé `Main` qui retourne un entier.  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member ExpandEnvironmentVariables : string -&gt; string" Usage="System.Environment.ExpandEnvironmentVariables name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A string containing the names of zero or more environment variables. Each environment variable is quoted with the percent sign character (%).</param>
        <summary>Replaces the name of each environment variable embedded in the specified string with the string equivalent of the value of the variable, then returns the resulting string.</summary>
        <returns>A string with each environment variable replaced by its value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Interopérabilité COM permet de récupérer les variables d’environnement du système d’exploitation. Si les variables d’environnement ne peut pas être récupérées en raison d’une erreur COM, la valeur HRESULT qui explique la cause de l’échec est utilisé pour générer une des diverses exceptions ; Autrement dit, l’exception dépend de la valeur HRESULT. Pour plus d’informations sur la façon dont le traitement de HRESULT, consultez la section Notes de la <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> (méthode).  
  
 Remplacement se produit uniquement pour les variables d’environnement sont définies. Par exemple, supposons que `name` est « MyENV = % MyENV % ». Si la variable d’environnement MyENV, a la valeur 42, cette méthode retourne « MyENV = 42 ». Si MyENV n’est pas définie, aucune modification n’intervient ; Cette méthode retourne « MyENV = % MyENV % ».  
  
 La taille de la valeur de retour est limitée à 32 Ko.  
  
   
  
## Examples  
 L’exemple suivant montre comment obtenir le lecteur système et les variables de la racine système.  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Pour pouvoir accéder aux variables d’environnement dans <paramref name="name" />. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Immediately terminates a process after writing a message to the Windows Application event log, and then includes the message and optional exception information in error reporting to Microsoft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member FailFast : string -&gt; unit" Usage="System.Environment.FailFast message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">A message that explains why the process was terminated, or <see langword="null" /> if no explanation is provided.</param>
        <summary>Immediately terminates a process after writing a message to the Windows Application event log, and then includes the message in error reporting to Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode met fin à un processus sans exécuter n’importe quel actif `try` / `finally` finaliseurs ou les blocs.  
  
 Le <xref:System.Environment.FailFast%2A> méthode écrit le `message` chaîne dans le journal des événements Windows, crée un dump de votre application, puis termine le processus actuel. Le `message` chaîne est également incluse dans le rapport d’erreurs à Microsoft.  
  
 Utilisez le <xref:System.Environment.FailFast%2A> méthode au lieu du <xref:System.Environment.Exit%2A> méthode pour mettre fin à votre application si l’état de votre application est irréparable et l’exécution de votre application `try` / `finally` finaliseurs et ces blocs endommagera les ressources du programme.  
  
 À l’aide de rapport d’erreurs Windows, les informations sont signalées à Microsoft. Pour plus d’informations, consultez [rapport d’erreurs Windows : mise en route](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx).  
  
   
  
## Examples  
 L’exemple suivant écrit une entrée de journal dans le journal des événements Windows et met fin au processus actuel.  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FailFast : string * Exception -&gt; unit" Usage="System.Environment.FailFast (message, exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">A message that explains why the process was terminated, or <see langword="null" /> if no explanation is provided.</param>
        <param name="exception">An exception that represents the error that caused the termination. This is typically the exception in a <see langword="catch" /> block.</param>
        <summary>Immediately terminates a process after writing a message to the Windows Application event log, and then includes the message and exception information in error reporting to Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode met fin au processus sans exécuter n’importe quel actif `try` / `finally` finaliseurs ou les blocs.  
  
 Le <xref:System.Environment.FailFast%2A> méthode écrit le `message` chaîne dans le journal des événements Windows, crée un dump de votre application, puis termine le processus actuel.  
  
 À l’aide de rapport d’erreurs Windows, les informations sont signalées à Microsoft. Pour plus d’informations, consultez [rapport d’erreurs Windows : mise en route](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx). Rapport d’erreurs à Microsoft inclut `message` et `exception` plus d’informations, qui fournit des détails permet de classifier l’erreur. Bien que `exception` est ne pas géré, car le processus est arrêté, les informations contextuelles qui a déclenché l’exception sont encore obtenues.  
  
 Si `exception` est `null`, ou si `exception` est ne pas levée, cette méthode fonctionne comme le <xref:System.Environment.FailFast%28System.String%29> surcharge de méthode.  
  
 Utilisez le <xref:System.Environment.FailFast%2A> méthode au lieu du <xref:System.Environment.Exit%2A> méthode pour mettre fin à votre application si l’état de votre application est irréparable et l’exécution de votre application `try` / `finally` finaliseurs et ces blocs endommagera les ressources du programme.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberSignature Language="F#" Value="static member GetCommandLineArgs : unit -&gt; string[]" Usage="System.Environment.GetCommandLineArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string array containing the command-line arguments for the current process.</summary>
        <returns>An array of string where each element contains a command-line argument. The first element is the executable file name, and the following zero or more elements contain the remaining command-line arguments.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le premier élément du tableau contient le nom de fichier du programme en cours d’exécution. Si le nom de fichier n’est pas disponible, le premier élément est égal à <xref:System.String.Empty?displayProperty=nameWithType>. Les éléments restants comportent des jetons supplémentaires entrés sur la ligne de commande.  
  
 Le nom de fichier du programme peut, mais n’est pas nécessaire pour inclure des informations de chemin d’accès.  
  
 Arguments de ligne de commande sont délimitées par des espaces. Vous pouvez utiliser des guillemets doubles (") pour inclure des espaces dans un argument. Le guillemet-apostrophe ('), toutefois, ne fournit pas de cette fonctionnalité.  
  
 Si un guillemet double suit deux ou un nombre pair de barres obliques inverses, chaque paire de barre oblique inverse continuer est remplacé par une barre oblique inverse et le guillemet double est supprimé. Si un guillemet double suit un nombre impair de barres obliques inverses, y compris un seul, chaque paire précédente est remplacée par une barre oblique inverse et la barre oblique inverse restante est supprimée ; Toutefois, dans ce cas le guillemet double n’est pas supprimé.  
  
 Le tableau suivant indique comment les arguments de ligne de commande peuvent être délimités et suppose `MyApp` que l’application en cours d’exécution actuelle.  
  
|Entrée à la ligne de commande|Arguments de ligne de commande qui en résulte|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 Pour obtenir la ligne de commande sous forme de chaîne unique, utilisez le <xref:System.Environment.CommandLine%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant affiche les arguments de ligne de commande de l’application.  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The system does not support command-line arguments.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour l’accès en lecture à la variable d’environnement PATH. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves the value of an environment variable.</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string -&gt; string" Usage="System.Environment.GetEnvironmentVariable variable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">The name of the environment variable.</param>
        <summary>Retrieves the value of an environment variable from the current process.</summary>
        <returns>The value of the environment variable specified by <paramref name="variable" />, or <see langword="null" /> if the environment variable is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Environment.GetEnvironmentVariable%28System.String%29> méthode récupère une variable d’environnement à partir du bloc d’environnement du processus en cours uniquement. Il équivaut à appeler le <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> méthode avec un `target` valeur <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Le bloc d’environnement du processus en cours inclut les variables d’environnement suivantes :  
  
-   Toutes les machine variables d’environnement qui sont définis au moment que le processus est créé, ainsi que leurs valeurs.  
  
-   Toutes les variables d’environnement par l’utilisateur qui sont définies au moment où le processus est créé, ainsi que leurs valeurs.  
  
-   Les variables ajoutées au bloc de processus tandis que le processus est en cours d’exécution en appelant le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> méthode ou le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> méthode avec un `target` valeur de <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  
  
 Si les variables d’environnement sont créés une fois que le processus a démarré, vous pouvez utiliser cette méthode pour récupérer uniquement les variables qui ont été créés en appelant le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> méthode ou le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> méthode avec un `target` valeur de.<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  
  
 Pour récupérer toutes les variables d’environnement, ainsi que leurs valeurs, appelez le <xref:System.Environment.GetEnvironmentVariables%2A> (méthode).  
  
 Noms de variables d’environnement ne respectent pas la casse.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Environment.GetEnvironmentVariable%2A> méthode pour récupérer le `windir` variable d’environnement, qui contient le chemin d’accès du répertoire Windows.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 L’exemple suivant tente de récupérer la valeur d’une variable d’environnement nommée `Test1` à partir du bloc d’environnement de processus. Si la variable n’existe pas, l’exemple crée ses et récupère sa valeur. L’exemple affiche la valeur de la variable. Si l’exemple créé la variable, il appelle également la <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> méthode avec chaque membre de la <xref:System.EnvironmentVariableTarget> énumération pour établir que la variable peut être extraites uniquement le bloc d’environnement de processus en cours. Enfin, si l’exemple créé la variable, il la supprime.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour la capacité à lire la valeur de <paramref name="variable" />. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string * EnvironmentVariableTarget -&gt; string" Usage="System.Environment.GetEnvironmentVariable (variable, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">The name of an environment variable.</param>
        <param name="target">One of the <see cref="T:System.EnvironmentVariableTarget" /> values.</param>
        <summary>Retrieves the value of an environment variable from the current process or from the Windows operating system registry key for the current user or local machine.</summary>
        <returns>The value of the environment variable specified by the <paramref name="variable" /> and <paramref name="target" /> parameters, or <see langword="null" /> if the environment variable is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `target` paramètre spécifie si la variable d’environnement est récupérée à partir du processus en cours ou à partir de la clé de Registre du système d’exploitation Windows pour l’utilisateur actuel ou l’ordinateur local. Toutes les variables d’environnement par utilisateur et par ordinateur sont automatiquement copiées dans le bloc d’environnement du processus en cours. Toutefois, les variables d’environnement ajoutées uniquement pour le bloc d’environnement du processus en cours sont conservées uniquement pour la durée du processus.  
  
 Pour récupérer toutes les variables d’environnement, ainsi que leurs valeurs, appelez le <xref:System.Environment.GetEnvironmentVariables%2A> (méthode).  
  
 Noms de variables d’environnement ne respectent pas la casse.  
  
   
  
## Examples  
 L’exemple suivant crée des variables d’environnement pour les cibles de processus, utilisateur et ordinateur, vérifie si le Registre du système d’exploitation contient les variables d’environnement utilisateur et ordinateur, puis supprime les variables d’environnement.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> is not a valid <see cref="T:System.EnvironmentVariableTarget" /> value.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour la capacité à lire la valeur de <paramref name="variable" /> si <paramref name="target" /> est <see cref="F:System.EnvironmentVariableTarget.Process" /> (énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), ou pour un accès complet aux variables d’environnement si <paramref name="target" /> est <see cref="F:System.EnvironmentVariableTarget.User" /> ou <see cref="F:System.EnvironmentVariableTarget.Machine" /> (associé énumération : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves all environment variable names and their values.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : unit -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves all environment variable names and their values from the current process.</summary>
        <returns>A dictionary that contains all environment variable names and their values; otherwise, an empty dictionary if no environment variables are found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les noms et valeurs pour les variables d’environnement sont stockés sous forme de paires clé-valeur dans la liste retournée <xref:System.Collections.IDictionary>.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Environment.GetEnvironmentVariables%2A> (méthode).  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <exception cref="T:System.OutOfMemoryException">The buffer is out of memory.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour la capacité à lire les noms et valeurs des variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : EnvironmentVariableTarget -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="target">One of the <see cref="T:System.EnvironmentVariableTarget" /> values.</param>
        <summary>Retrieves all environment variable names and their values from the current process, or from the Windows operating system registry key for the current user or local machine.</summary>
        <returns>A dictionary that contains all environment variable names and their values from the source specified by the <paramref name="target" /> parameter; otherwise, an empty dictionary if no environment variables are found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `target` paramètre spécifie si la source est le processus en cours, la clé de Registre pour l’utilisateur actuel ou la clé de Registre pour l’ordinateur local.  
  
 Les noms et valeurs des variables d’environnement sont stockés sous forme de paires clé/valeur dans la liste retournée <xref:System.Collections.IDictionary> objet.  
  
   
  
## Examples  
 L’exemple suivant crée des variables d’environnement pour les cibles de processus, utilisateur et ordinateur, vérifie si le Registre du système d’exploitation contient les variables d’environnement utilisateur et ordinateur, puis supprime les variables d’environnement.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation for the specified value of <paramref name="target" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> contains an illegal value.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour la capacité à lire les noms et valeurs des variables d’environnement si <paramref name="target" /> est <see cref="F:System.EnvironmentVariableTarget.Process" /> (énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), ou pour un accès complet aux variables d’environnement si <paramref name="target" /> est <see cref="F:System.EnvironmentVariableTarget.User" /> ou <see cref="F:System.EnvironmentVariableTarget.Machine" /> () Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the path to the system special folder that is identified by the specified enumeration.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder -&gt; string" Usage="System.Environment.GetFolderPath folder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
      </Parameters>
      <Docs>
        <param name="folder">An enumerated constant that identifies a system special folder.</param>
        <summary>Gets the path to the system special folder that is identified by the specified enumeration.</summary>
        <returns>The path to the specified system special folder, if that folder physically exists on your computer; otherwise, an empty string ("").  A folder will not physically exist if the operating system did not create it, the existing folder was deleted, or the folder is a virtual directory, such as My Computer, which does not correspond to a physical path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode récupère le chemin d’accès à un dossier spécial du système, tel que Program Files, de programmes, de système ou de démarrage, ce qui peut être utilisé pour accéder aux informations courantes. Dossiers spéciaux sont définis par défaut par le système, ou explicitement par l’utilisateur, lors de l’installation d’une version de Windows.  
  
 Le `folder` paramètre désigne le dossier spécial pour récupérer et doit être une des valeurs dans le <xref:System.Environment.SpecialFolder> énumération ; aucun autre valeur lève une exception.  
  
 Pour plus d’informations sur les dossiers spéciaux, consultez la [CSIDL](http://go.microsoft.com/fwlink/?LinkId=116664) rubrique de valeurs.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Environment.GetFolderPath%2A> méthode pour retourner et afficher le chemin d’accès associé à le `folder` paramètre.  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> is not a member of <see cref="T:System.Environment.SpecialFolder" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The current platform is not supported.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations dans le chemin d’accès lui-même. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder * Environment.SpecialFolderOption -&gt; string" Usage="System.Environment.GetFolderPath (folder, option)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" />
      </Parameters>
      <Docs>
        <param name="folder">An enumerated constant that identifies a system special folder.</param>
        <param name="option">Specifies options to use for accessing a special folder.</param>
        <summary>Gets the path to the system special folder that is identified by the specified enumeration, and uses a specified option for accessing special folders.</summary>
        <returns>The path to the specified system special folder, if that folder physically exists on your computer; otherwise, an empty string ("").  A folder will not physically exist if the operating system did not create it, the existing folder was deleted, or the folder is a virtual directory, such as My Computer, which does not correspond to a physical path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode récupère le chemin d’accès à un dossier spécial du système, tel que Program Files, de programmes, de système ou de démarrage, ce qui peut être utilisé pour accéder aux informations courantes. Dossiers spéciaux sont définis par défaut par le système, ou explicitement par l’utilisateur, lors de l’installation d’une version de Windows.  
  
 Le `folder` paramètre désigne le dossier spécial pour récupérer et doit être une des valeurs dans le <xref:System.Environment.SpecialFolder> énumération ; aucun autre valeur lève une exception.  
  
 Pour plus d’informations sur les dossiers spéciaux, consultez la [CSIDL](http://go.microsoft.com/fwlink/?LinkId=116664) rubrique de valeurs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> is not a member of <see cref="T:System.Environment.SpecialFolder" /></exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.PlatformNotSupportedException" />
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations dans le chemin d’accès lui-même. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.Environment.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an array of string containing the names of the logical drives on the current computer.</summary>
        <returns>An array of strings where each element contains the name of a logical drive. For example, if the computer's hard drive is the first logical drive, the first element returned is "C:\\".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment afficher les lecteurs logiques de l’ordinateur actuel en utilisant le <xref:System.Environment.GetLogicalDrives%2A> (méthode).  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permissions.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour un accès complet à la ressource protégée par cette autorisation. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current application domain is being unloaded or the common language runtime (CLR) is shutting down.</summary>
        <value>
          <see langword="true" /> si le domaine d'application actuel est déchargé ou si le CLR s'arrête ; sinon, <see langword="false." /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le CLR décharge un domaine d’application, elle exécute des finaliseurs sur tous les objets qui ont une méthode de finaliseur dans ce domaine d’application. Lorsque le CLR s’arrête, il démarre le thread finaliseur sur tous les objets qui ont une méthode de finaliseur. Le <xref:System.Environment.HasShutdownStarted%2A> propriété retourne `true` uniquement une fois que le thread finaliseur a été démarré. Lorsque la propriété retourne `true`, vous pouvez déterminer si un domaine d’application est déchargé ou que le CLR lui-même s’arrête en appelant le <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> (méthode). Cette méthode retourne `true` si les finaliseurs sont appelés, car le déchargement du domaine d’application est en cours ou `false` si le CLR s’arrête.  
  
 Le <xref:System.Environment.HasShutdownStarted%2A> retourne de la propriété `false` si le thread finaliseur n’a pas été démarré.  
  
 À l’aide de cette propriété, vous pouvez déterminer s’il faut accéder à des variables statiques dans votre code de finalisation. Si un domaine d’application ou le CLR s’arrête, vous ne pouvez pas accéder de manière fiable n’importe quel objet qui a une méthode de finalisation et qui est référencé par un champ statique. Il s’agit, car ces objets peuvent avoir déjà été finalisées.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitOperatingSystem : bool" Usage="System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the current operating system is a 64-bit operating system.</summary>
        <value>
          <see langword="true" /> s'il s'agit d'un système d'exploitation 64 bits ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitProcess : bool" Usage="System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the current process is a 64-bit process.</summary>
        <value>
          <see langword="true" /> s'il s'agit d'un processus 64 bits ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the NetBIOS name of this local computer.</summary>
        <value>Chaîne contenant le nom de cet ordinateur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le nom de cet ordinateur est établi au démarrage du système lorsque le nom est lu à partir du Registre. Si cet ordinateur est un nœud dans un cluster, le nom du nœud est retourné.  
  
   
  
## Examples  
 L’exemple suivant affiche le nom de l’ordinateur qui exécute l’exemple de code. (Le nom de l’ordinateur est omis de l’exemple de sortie pour des raisons de sécurité.)  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The name of this computer cannot be obtained.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour l’accès en lecture à la variable d’environnement COMPUTERNAME. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string" Usage="System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the newline string defined for this environment.</summary>
        <value>Chaîne contenant « \r\n » pour les plateformes non-Unix, ou une chaîne contenant « \n » pour les plateformes Unix.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de propriété <xref:System.Environment.NewLine%2A> est une constante personnalisée spécifiquement pour la plateforme actuelle et l’implémentation du .NET Framework. Pour plus d’informations sur les caractères d’échappement dans la valeur de propriété, consultez [caractères d’échappement](~/docs/standard/base-types/character-escapes-in-regular-expressions.md).  
  
 La fonctionnalité fournie par <xref:System.Environment.NewLine%2A> est souvent qu’entend-on par les termes du contrat de saut de ligne, saut de ligne, saut de ligne, retour chariot, CRLF et fin de ligne.  
  
 <xref:System.Environment.NewLine%2A> peut être utilisé conjointement avec prise en charge de saut de ligne spécifiques au langage telles que les caractères d’échappement '\r' et '\n' en Microsoft c# et C/C++, ou `vbCrLf` dans Microsoft Visual Basic.  
  
 <xref:System.Environment.NewLine%2A> est ajouté automatiquement au texte traité par le <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> et <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> méthodes.  
  
   
  
## Examples  
 L’exemple suivant affiche trois lignes séparées par des sauts de ligne.  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OSVersion : OperatingSystem" Usage="System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an <see cref="T:System.OperatingSystem" /> object that contains the current platform identifier and version number.</summary>
        <value>Objet qui contient l'identificateur et le numéro de version de la plateforme.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  En commençant par Windows 8, le <xref:System.Environment.OSVersion%2A> propriété retourne les mêmes numéros de version majeure et mineure pour toutes les plateformes Windows. Par conséquent, nous déconseillons que récupérer la valeur de cette propriété pour déterminer la version de système d’exploitation.  
  
 En règle générale, le <xref:System.Environment.OSVersion%2A> propriété est utilisée pour vous assurer qu’une application s’exécute sur une version de base du système d’exploitation dans lequel une fonctionnalité particulière a été introduite. Lorsque c’est le cas, vous devez effectuer une vérification de la version en vérifiant si la version de système d’exploitation actuel est retourné par la <xref:System.Environment.OSVersion%2A> propriété est identique ou supérieure à la version de système d’exploitation. Pour plus d’informations, consultez le <xref:System.Version> rubrique de la classe.  
  
 À Windows 8, le <xref:System.Environment.OSVersion%2A> propriété retourne la version indiquée par le Windows [GetVersionEx](http://msdn.microsoft.com/library/windows/desktop/ms724451\(v=vs.85\).aspx) (fonction). Pour obtenir la liste des versions de système d’exploitation Windows et leurs numéros de version correspondant, consultez [Version du système d’exploitation](https://msdn.microsoft.com/library/windows/desktop/ms724832.aspx) dans le centre de développement Windows.  
  
> [!NOTE]
>  Le <xref:System.Environment.OSVersion%2A> propriété signale le même numéro de version (6.2.0.0) pour les deux [!INCLUDE[win8](~/includes/win8-md.md)] et [!INCLUDE[win81](~/includes/win81-md.md)] et le même numéro de version majeure et mineure pour Windows 10.  
  
 Dans certains cas, le <xref:System.Environment.OSVersion%2A> propriété ne peut pas retourner la version de système d’exploitation qui correspond à la version spécifiée pour la fonctionnalité de mode de compatibilité des programmes Windows.  
  
   
  
## Examples  
 L’exemple suivant affiche l’identificateur de plateforme et le numéro de version de l’ordinateur qui exécute l’exemple de code.  
  
 [!code-cpp[environment.osversion#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.OSVersion/CPP/osversion.cpp#1)]
 [!code-csharp[environment.osversion#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.OSVersion/CS/osversion.cs#1)]
 [!code-vb[environment.osversion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.OSVersion/VB/osversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was unable to obtain the system version.  -or-  The obtained platform identifier is not a member of <see cref="T:System.PlatformID" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorCount : int" Usage="System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of processors on the current machine.</summary>
        <value>Entier signé 32 bits qui spécifie le nombre de processeurs de l'ordinateur actuel. Il n'y a pas de valeur par défaut. Si l'ordinateur actuel contient plusieurs groupes de processeurs, cette propriété retourne le nombre de processeurs logiques disponibles pour le Common Language Runtime (CLR).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur les groupes de processeurs et les processeurs logiques, consultez [groupes de processeurs](http://msdn.microsoft.com/library/windows/desktop/dd405503.aspx).  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Environment.ProcessorCount%2A> propriété.  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates, modifies, or deletes an environment variable.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">The name of an environment variable.</param>
        <param name="value">A value to assign to <c>variable</c>.</param>
        <summary>Creates, modifies, or deletes an environment variable stored in the current process.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette méthode équivaut à appeler le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> surcharge avec une valeur de <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> pour le `target` argument.  
  
 Si le `value` argument n’est pas vide (voir la discussion de la suppression d’une variable d’environnement plus loin dans cette section pour la définition d’une valeur vide) et la variable d’environnement nommée par le `variable` paramètre n’existe pas, l’environnement variable est créée et reçoit le contenu de `value`. S’il n’existe pas, sa valeur est modifiée. Étant donné que la variable d’environnement est définie dans le bloc d’environnement du processus actuel uniquement, il ne conserve pas une fois que le processus s’est terminée.  
  
 Si `variable` contient un non initiale zéro caractère hexadécimal, les caractères avant le caractère zéro sont considérés comme le nom de variable d’environnement et tous les caractères suivants sont ignorés.  
  
 Si `value` contient un non initiale zéro caractère hexadécimal, les caractères avant le caractère zéro sont affectés à la variable d’environnement et tous les caractères suivants sont ignorés.  
  
 Si `value` est vide et la variable d’environnement nommée par `variable` existe, la variable d’environnement est supprimée. Si `variable` n’existe pas, aucune erreur ne se produit même si l’opération ne peut pas être exécutée. `value` est considéré comme vide si l’une des conditions suivantes :  
  
-   Il est `null`.  
  
-   Il est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Il se compose d’un seul caractère dont la valeur est U + 0000.  
  
   
  
## Examples  
 L’exemple suivant teste si une variable d’environnement nommée `APPDOMAIN` existe dans le processus en cours. Si elle n’est pas le cas, il crée et définit sa valeur sur « True ». Si la valeur de la `APPDOMAIN` variable d’environnement est « True », elle appelle le `Message.Display` méthode dans un nouveau domaine d’application. Sinon, il exécute la `Message.Display` méthode dans le domaine d’application actuel.  
  
 [!code-csharp[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/cs/setenvironmentvariable1.cs#1)]
 [!code-vb[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/vb/setenvironmentvariable1.vb#1)]  
  
 Si vous exécutez l’exemple pour la première fois, le message « En cours d’exécution dans le domaine domaine2 » s’affiche dans la console. Si vous définissez la variable d’environnement à partir de la ligne de commande à l’aide de la commande :  
  
 `Set AppDomain=False`  
  
 l’exemple affiche le message « l’exécution dans le domaine *nom-exe*.exe », où *nom-exe* est le nom de l’exécutable.  
  
 L’exemple suivant tente de récupérer la valeur d’une variable d’environnement nommée `Test1` à partir du bloc d’environnement de processus. Si la variable n’existe pas, l’exemple crée la variable et récupère sa valeur. L’exemple affiche la valeur de la variable. Si l’exemple créé la variable, il appelle également la <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> méthode avec chaque membre de la <xref:System.EnvironmentVariableTarget> énumération pour établir que la variable peut être extraites uniquement le bloc d’environnement de processus en cours. Enfin, si l’exemple créé la variable, il la supprime.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" /> contains a zero-length string, an initial hexadecimal zero character (0x00), or an equal sign ("=").  -or-  The length of <paramref name="variable" /> or <paramref name="value" /> is greater than or equal to 32,767 characters.  -or-  An error occurred during the execution of this operation.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour un accès complet aux variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string * EnvironmentVariableTarget -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">The name of an environment variable.</param>
        <param name="value">A value to assign to <c>variable</c>.</param>
        <param name="target">One of the enumeration values that specifies the location of the environment variable.</param>
        <summary>Creates, modifies, or deletes an environment variable stored in the current process or in the Windows operating system registry key reserved for the current user or local machine.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> méthode vous permet de définir une variable d’environnement qui est disponible pour tous les processus qui s’exécutent sur un ordinateur (le <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> valeur), à tous les processus exécutés par un utilisateur (le <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> valeur), ou pour le processus en cours (la <xref:System.EnvironmentVariableTarget.Process> valeur). Variables d’environnement par ordinateur et par utilisateur sont copiés dans le bloc d’environnement du processus en cours. Toutefois, les variables d’environnement sont uniques pour le bloc d’environnement de processus en cours persistent uniquement jusqu'à ce que le processus se termine.  
  
 Si le `value` argument n’est pas vide (voir la discussion de la suppression d’une variable d’environnement plus loin dans cette section pour la définition d’une valeur vide) et la variable d’environnement nommée par le `variable` paramètre n’existe pas, l’environnement variable est créée et reçoit le contenu de `value`.  S’il n’existe pas, sa valeur est modifiée.  
  
 Si `variable` contient un non initiale zéro caractère hexadécimal, les caractères avant le caractère zéro sont considérés comme le nom de variable d’environnement et tous les caractères suivants sont ignorés.  
  
 Si `value` contient un non initiale zéro caractère hexadécimal, les caractères avant le caractère zéro sont affectés à la variable d’environnement et tous les caractères suivants sont ignorés.  
  
 Si `value` est vide et la variable d’environnement nommée par `variable` existe, la variable d’environnement est supprimée. `value` est considéré comme vide si l’une des conditions suivantes :  
  
-   Il est `null`.  
  
-   Il est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Il se compose d’un seul caractère dont la valeur est U + 0000.  
  
 Si `variable` n’existe pas, aucune erreur ne se produit même si l’opération ne peut pas être effectuée. Soyez prudent quand `target` est <xref:System.EnvironmentVariableTarget.Machine>, car vous pouvez supprimer accidentellement une variable d’environnement qui affecte l’ordinateur local entier, et pas seulement le processus en cours ou un utilisateur.  
  
 Si `target` est <xref:System.EnvironmentVariableTarget.User>, la variable d’environnement est stockée dans la clé HKEY_CURRENT_USER\Environment du Registre de l’ordinateur local. Il est également copié dans les instances de l’Explorateur de fichiers qui sont en cours d’exécution en tant que l’utilisateur actuel. La variable d’environnement est ensuite héritée par tous les processus lancés par l’utilisateur à partir de l’Explorateur de fichiers.  
  
 De même, si `target` est <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, la variable d’environnement est stockée dans la clé HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment du Registre de l’ordinateur local. Il est également copié dans toutes les instances de l’Explorateur de fichiers. La variable d’environnement est ensuite héritée par tous les processus qui sont lancées à partir de l’Explorateur de fichiers.  
  
 Si `target` est <xref:System.EnvironmentVariableTarget.User> ou <xref:System.EnvironmentVariableTarget.Machine>, autres applications sont averties de l’opération définie par un Windows `WM_SETTINGCHANGE` message.  
  
 Si `target` est <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> ou <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, il est recommandé que la longueur de `value` être inférieure à 2 048 caractères.  
  
   
  
## Examples  
 L’exemple suivant crée des variables d’environnement pour le <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, et <xref:System.EnvironmentVariableTarget.Machine> cible, vérifie si le Registre du système d’exploitation contient les variables d’environnement machine, puis supprime l’environnement variables.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" /> contains a zero-length string, an initial hexadecimal zero character (0x00), or an equal sign ("=").  -or-  The length of <paramref name="variable" /> is greater than or equal to 32,767 characters.  -or-  <paramref name="target" /> is not a member of the <see cref="T:System.EnvironmentVariableTarget" /> enumeration.  -or-  <paramref name="target" /> is <see cref="F:System.EnvironmentVariableTarget.Machine" /> or <see cref="F:System.EnvironmentVariableTarget.User" />, and the length of <paramref name="variable" /> is greater than or equal to 255.  -or-  <paramref name="target" /> is <see cref="F:System.EnvironmentVariableTarget.Process" /> and the length of <paramref name="value" /> is greater than or equal to 32,767 characters.  -or-  An error occurred during the execution of this operation.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour un accès complet aux variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets current stack trace information.</summary>
        <value>Chaîne contenant les informations de trace de la pile. Cette valeur peut être <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Environment.StackTrace%2A> propriété répertorie les appels de méthode dans l’ordre chronologique inverse, autrement dit, l’appel de méthode la plus récente est décrit en premier, et une ligne d’informations de trace de pile est répertoriée pour chaque appel de méthode sur la pile. Toutefois, le <xref:System.Environment.StackTrace%2A> propriété peut ne pas rapporter autant d’appels de méthode comme prévu en raison des transformations de code qui se produisent pendant l’optimisation.  
  
> [!NOTE]
>  Pour obtenir une vue hiérarchique des informations de trace de pile par classe, utilisez la <xref:System.Diagnostics.StackTrace> classe.  
  
 Le <xref:System.Environment.StackTrace%2A> propriété formate les informations de trace de pile pour chaque appel de méthode comme suit :  
  
 « à `FullClassName`.`MethodName` (`MethodParams`) dans `FileName` : ligne `LineNumber` »  
  
 Le littéral « à » est précédé de trois espaces, et que l’intégralité de la sous-chaîne commençant par « in » est omis si les symboles de débogage ne sont pas disponibles. Les espaces réservés, `FullClassName`, `MethodName`, `MethodParams`, `FileName`, et `LineNumber`, sont remplacés par les valeurs réelles et sont définis comme suit :  
  
 FullClassName  
 Le nom complet de la classe, y compris l’espace de noms.  
  
 `MethodName`  
 Nom de la méthode.  
  
 `MethodParams`  
 La liste de paires type/nom de paramètre. Chaque paire est séparée par une virgule («, »). Ces informations sont omises si `MethodName` n’accepte aucun paramètre.  
  
 `FileName`  
 Le nom de la source de fichier où le `MethodName` méthode est déclarée. Ces informations sont omises si les symboles de débogage ne sont pas disponibles.  
  
 `LineNumber`  
 Le numéro de la ligne dans `FileName` qui contient le code source à partir de `MethodName` pour obtenir des instructions qui se trouve sur la pile des appels. Ces informations sont omises si les symboles de débogage ne sont pas disponibles.  
  
 Le <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> chaîne termine à chaque ligne de la trace de pile.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Environment.StackTrace%2A> propriété.  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour un accès complet à la ressource protégée par l’autorisation. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemDirectory : string" Usage="System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the fully qualified path of the system directory.</summary>
        <value>Chaîne contenant un chemin d'accès au répertoire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un exemple de la valeur retournée est la chaîne « C:\WinNT\System32 ».  
  
   
  
## Examples  
 L’exemple suivant affiche le répertoire système de l’ordinateur qui exécute l’exemple de code. (Le répertoire système est omis de l’exemple de sortie pour des raisons de sécurité.)  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations dans le chemin d’accès lui-même. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemPageSize : int" Usage="System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of bytes in the operating system's memory page.</summary>
        <value>Nombre d'octets dans la page de mémoire système.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ces informations peuvent être utiles pour déterminer s’il faut utiliser le <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType> option lorsque vous travaillez avec des fichiers mappés en mémoire.  
  
 Dans Windows, cette valeur est la `dwPageSize` membre dans le `SYSTEM_INFO` structure.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Pour accéder aux variables d’environnement système et utilisateur. Exception associée :  <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount : int" Usage="System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of milliseconds elapsed since the system started.</summary>
        <value>Entier signé 32 bits contenant la durée écoulée en millisecondes depuis le dernier démarrage de l'ordinateur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette propriété est dérivée de l’horloge système et est stockée comme un entier signé 32 bits. Notez que, car elle est dérivée de l’horloge système, la résolution de la <xref:System.Environment.TickCount%2A> propriété est limitée à la résolution de l’horloge système, qui se trouve généralement dans la plage de 10 à 16 millisecondes.  
  
> [!IMPORTANT]
>  Étant donné que la valeur de la <xref:System.Environment.TickCount%2A> valeur de propriété est un entier signé 32 bits, si le système s’exécute en continu, <xref:System.Environment.TickCount%2A> incrémente de zéro à <xref:System.Int32.MaxValue?displayProperty=nameWithType> pendant environ 24,9 jours, puis atteindre <xref:System.Int32.MinValue?displayProperty=nameWithType>, qui est un nombre négatif, incrémenter puis remettre à zéro pendant les 24,9 jours. Vous pouvez contourner ce problème en appelant le Windows [GetTickCount](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx) (fonction), ce qui remet à zéro après environ 49,7 jours, ou en appelant le [GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx) (fonction).  
  
 <xref:System.Environment.TickCount%2A> diffère la <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> propriété, qui est le nombre d’intervalles de 100 nanosecondes écoulés depuis le 1/1/0001 12:00 am.  
  
 Utilisez le <xref:System.DateTime.Now%2A?displayProperty=nameWithType> propriété pour obtenir la date du jour et l’heure sur cet ordinateur.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer la plage positive des valeurs retournées par la <xref:System.Environment.TickCount%2A> propriété. Le <xref:System.Environment.TickCount%2A> propriété cycles entre <xref:System.Int32.MinValue?displayProperty=nameWithType>, qui est un nombre négatif, et <xref:System.Int32.MaxValue?displayProperty=nameWithType> tous les 49,8 jours. Cet exemple de code supprime le bit de signe pour produire un nombre non négatif qui alterne entre zéro et <xref:System.Int32.MaxValue> tous les 24,9 jours.  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserDomainName : string" Usage="System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the network domain name associated with the current user.</summary>
        <value>Nom de domaine réseau associé à l'utilisateur actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les informations d’identification du compte de domaine pour un utilisateur sont mis en forme en tant que nom de domaine de l’utilisateur, le «\\' nom d’utilisateur et les caractères. Utilisez le <xref:System.Environment.UserDomainName%2A> propriété pour obtenir le nom de domaine de l’utilisateur sans le nom d’utilisateur et le <xref:System.Environment.UserName%2A> propriété pour obtenir le nom d’utilisateur sans le nom de domaine.  Par exemple, si le nom d’utilisateur et le nom de domaine de l’utilisateur sont CORPORATENETWORK\john, le <xref:System.Environment.UserDomainName%2A> propriété retourne « CORPORATENETWORK ».  
  
 Le <xref:System.Environment.UserDomainName%2A> propriété tente tout d’abord obtenir le composant de nom de domaine du nom de compte Windows pour l’utilisateur actuel. Si cette tentative échoue, cette propriété essaie d’obtenir le nom de domaine associé au nom d’utilisateur fourni par le <xref:System.Environment.UserName%2A> propriété. Si cette tentative échoue, car l’ordinateur hôte n’est pas joint à un domaine, le nom d’ordinateur hôte est retourné.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The operating system does not support retrieving the network domain name.</exception>
        <exception cref="T:System.InvalidOperationException">The network domain name cannot be retrieved.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour l’accès en lecture à la variable d’environnement USERDOMAIN. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInteractive : bool" Usage="System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current process is running in user interactive mode.</summary>
        <value>
          <see langword="true" /> si le processus en cours est exécuté en mode interactif avec l'utilisateur ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Environment.UserInteractive%2A> propriété rapports `false` pour un processus Windows ou un service comme IIS qui s’exécute sans interface utilisateur. Si cette propriété est `false`, ne pas afficher les boîtes de dialogue modales ou boîtes de message, car il n’existe aucune interface utilisateur graphique pour l’utilisateur d’interagir avec.  
  
   
  
## Examples  
 L’exemple suivant affiche si le processus actuel est en cours d’exécution en mode utilisateur interactif.  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string" Usage="System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the user name of the person who is currently logged on to the operating system.</summary>
        <value>Le nom d’utilisateur de la personne qui a ouvert une session le système d’exploitation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le <xref:System.Environment.UserName%2A> propriété pour identifier l’utilisateur sur le thread actuel, le système et l’application pour des raisons de sécurité ou d’accès. Il peut également servir à personnaliser une application particulière pour chaque utilisateur.  
 
 Sur Windows le <xref:System.Environment.UserName%2A> propriété encapsule un appel vers le Windows [GetUserName](http://msdn.microsoft.com/library/windows/desktop/ms724432.aspx) (fonction). Les informations d’identification du compte de domaine pour un utilisateur sont mis en forme en tant que nom de domaine de l’utilisateur, le «\\' nom d’utilisateur et les caractères. Utilisez le <xref:System.Environment.UserDomainName%2A> propriété pour obtenir le nom de domaine de l’utilisateur et le <xref:System.Environment.UserName%2A> propriété pour obtenir le nom d’utilisateur.  
 
 Sur les plateformes Unix le <xref:System.Environment.UserName%2A> propriété encapsule un appel à la `getpwuid_r` (fonction).
 
 Si une application ASP.NET s’exécute dans un environnement de développement, le <xref:System.Environment.UserName%2A> propriété retourne le nom de l’utilisateur actuel. Dans une application ASP.NET publiée, cette propriété retourne le nom du compte de pool d’applications (par exemple, le pool d’applications par défaut).  
  
   
  
## Examples  
 L’exemple suivant affiche le nom d’utilisateur de la personne qui a démarré le thread actuel.  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour l’accès en lecture à la variable d’environnement de nom d’utilisateur. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Version" /> object that describes the major, minor, build, and revision numbers of the common language runtime.</summary>
        <value>Objet qui affiche la version du Common Language Runtime.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour .NET Framework versions 4, 4.5, 4.5.1 et 4.5.2, la propriété <xref:System.Environment.Version%2A?displayProperty=nameWithType> retourne un objet <xref:System.Version> dont la représentation sous forme de chaîne se présente sous la forme `4.0.30319.xxxxx`. Pour le .NET Framework 4.6 et les versions ultérieures, il présente sous la forme `4.0.30319.42000`.  
  
> [!WARNING]
>  Pour le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] et versions ultérieures, nous déconseillons l’utilisation du <xref:System.Environment.Version%2A> propriété pour détecter la version du runtime ; au lieu de cela, vous pouvez déterminer la version du common language runtime en interrogeant le Registre. Pour plus d’informations, consultez [Comment : déterminer les .NET Framework Versions installées](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md).  
  
 Pour plus d’informations sur la version du common language runtime est installé avec chaque version du .NET Framework, consultez [Versions et dépendances](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 L’exemple suivant affiche la version du common language runtime. (La version est omise à partir de l’exemple de sortie pour des raisons de sécurité).  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int64" Usage="System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of physical memory mapped to the process context.</summary>
        <value>Entier signé 64 bits contenant le nombre d'octets de mémoire physique mappée au contexte du processus.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant affiche la taille de la plage de travail de l’ordinateur qui exécute l’exemple de code.  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour un accès complet à la ressource protégée par cette autorisation. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>