<Type Name="UriTemplateTable" FullName="System.UriTemplateTable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9bfbbeac3ac9481879e51ac1eed6abc1f0cfb6ec" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32694291" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UriTemplateTable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UriTemplateTable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.UriTemplateTable" />
  <TypeSignature Language="VB.NET" Value="Public Class UriTemplateTable" />
  <TypeSignature Language="C++ CLI" Value="public ref class UriTemplateTable" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Web</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Classe qui représente un jeu associatif d'objets <see cref="T:System.UriTemplate" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un objet <xref:System.UriTemplateTable> est un jeu associatif d'objets <xref:System.UriTemplate> liés à un objet choisi par le développeur. Elle vous permet de faire correspondre les URI (Uniform Resource Identifiers) des candidats par rapport aux modèles du jeu et de récupérer les données associées aux modèles correspondants. Le contenu de l'objet <xref:System.UriTemplateTable> peut être modifié jusqu'à ce que la méthode <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> soit appelée, auquel cas l'un des types de validation suivants intervient :  
  
-   Lorsque <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> est appelée en passant dans `false`, le <xref:System.UriTemplateTable> vérifie la table ne contient aucun plusieurs modèles structurellement équivalents. Si elle recherche des modèles de ce type, elle lève une exception. Ce type de validation est utilisé conjointement à la méthode <xref:System.UriTemplateTable.MatchSingle%28System.Uri%29> lorsque vous souhaitez garantir qu'un seul modèle correspond à un URI entrant.  
  
-   Lorsque <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> est appelée en passant dans `true`, plusieurs modèles structurellement équivalents peuvent être contenus dans un <xref:System.UriTemplateTable>. Toutefois, toutes les chaînes de demande des modèles ne doivent pas être ambiguës ; les chaînes de demande identiques sont autorisées. Pour plus d’informations sur les chaînes de demande ambiguës, consultez [UriTemplate et UriTemplateTable](~/docs/framework/wcf/feature-details/uritemplate-and-uritemplatetable.md).  
  
   
  
## Examples  
 Le code suivant indique comment créer un objet <xref:System.UriTemplateTable>, le remplir et l'utiliser pour établir une correspondance par rapport à un objet <xref:System.Uri> de candidat.  
  
 [!code-csharp[UriTemplateTable#0](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/program.cs#0)]
 [!code-vb[UriTemplateTable#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/program1.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.UriTemplateTable" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UriTemplateTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplateTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.UriTemplateTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant montre comment instancier la classe <xref:System.UriTemplateTable>.  
  
 [!code-csharp[UriTemplateTable#1](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/program.cs#1)]
 [!code-vb[UriTemplateTable#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/program1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UriTemplateTable (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;UriTemplate,object&gt;&gt; keyValuePairs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.UriTemplate, object&gt;&gt; keyValuePairs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.UriTemplate,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (keyValuePairs As IEnumerable(Of KeyValuePair(Of UriTemplate, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplateTable(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;UriTemplate ^, System::Object ^&gt;&gt; ^ keyValuePairs);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="keyValuePairs" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.UriTemplate,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePairs">Collection de paires clé/valeur qui se composent de modèles URI et de données associées.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.UriTemplateTable" /> avec la collection spécifiée de paires clé/valeur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant montre comment instancier la classe <xref:System.UriTemplateTable>.  
  
 [!code-csharp[UriTemplateTable#2](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#2)]
 [!code-vb[UriTemplateTable#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UriTemplateTable (Uri baseAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.#ctor(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseAddress As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplateTable(Uri ^ baseAddress);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseAddress" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseAddress">Instance <see cref="T:System.Uri" /> qui contient l'adresse de base.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.UriTemplateTable" /> avec l'adresse de base spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant montre comment appeler ce constructeur.  
  
 [!code-csharp[UriTemplateTable#3](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/program.cs#3)]
 [!code-vb[UriTemplateTable#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/program1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UriTemplateTable (Uri baseAddress, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;UriTemplate,object&gt;&gt; keyValuePairs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseAddress, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.UriTemplate, object&gt;&gt; keyValuePairs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.#ctor(System.Uri,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.UriTemplate,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseAddress As Uri, keyValuePairs As IEnumerable(Of KeyValuePair(Of UriTemplate, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplateTable(Uri ^ baseAddress, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;UriTemplate ^, System::Object ^&gt;&gt; ^ keyValuePairs);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseAddress" Type="System.Uri" />
        <Parameter Name="keyValuePairs" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.UriTemplate,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="baseAddress">Instance <see cref="T:System.Uri" /> qui contient l'adresse de base.</param>
        <param name="keyValuePairs">Collection de paires clé/valeur qui se composent de modèles URI et de données associées.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.UriTemplateTable" /> avec l'adresse de base spécifiée et la collection de paires clé/valeur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant montre comment appeler ce constructeur.  
  
 [!code-csharp[UriTemplateTable#4](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#4)]
 [!code-vb[UriTemplateTable#4](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseAddress">
      <MemberSignature Language="C#" Value="public Uri BaseAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri BaseAddress" />
      <MemberSignature Language="DocId" Value="P:System.UriTemplateTable.BaseAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property BaseAddress As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ BaseAddress { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient et définit l'adresse de base de l'instance <see cref="T:System.UriTemplateTable" />.</summary>
        <value>
          <see cref="T:System.Uri" /> qui contient l'adresse de base.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propriété <xref:System.UriTemplateTable.BaseAddress%2A> ne peut être définie qu'avant d'appeler la méthode <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29>, <xref:System.UriTemplateTable.Match%28System.Uri%29> ou <xref:System.UriTemplateTable.MatchSingle%28System.Uri%29> ; sinon, un objet <xref:System.InvalidOperationException> est levé.  
  
   
  
## Examples  
 L'exemple suivant montre comment accéder à la propriété <xref:System.UriTemplateTable.BaseAddress%2A>.  
  
 [!code-csharp[UriTemplateTable#5](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#5)]
 [!code-vb[UriTemplateTable#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.UriTemplateTable.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui spécifie si l'objet <see cref="T:System.UriTemplateTable" /> est en lecture seule.</summary>
        <value>
          <see langword="true" /> si la propriété <see cref="T:System.UriTemplateTable" /> est en lecture seule ; sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un objet <xref:System.UriTemplateTable> est en lecture seule après l'appel de la méthode <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29>.  
  
   
  
## Examples  
 L'exemple suivant montre comment accéder à la propriété <xref:System.UriTemplateTable.IsReadOnly%2A>.  
  
 [!code-csharp[UriTemplateTable#6](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#6)]
 [!code-vb[UriTemplateTable#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyValuePairs">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Collections.Generic.KeyValuePair&lt;UriTemplate,object&gt;&gt; KeyValuePairs { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.UriTemplate, object&gt;&gt; KeyValuePairs" />
      <MemberSignature Language="DocId" Value="P:System.UriTemplateTable.KeyValuePairs" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyValuePairs As IList(Of KeyValuePair(Of UriTemplate, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Collections::Generic::KeyValuePair&lt;UriTemplate ^, System::Object ^&gt;&gt; ^ KeyValuePairs { System::Collections::Generic::IList&lt;System::Collections::Generic::KeyValuePair&lt;UriTemplate ^, System::Object ^&gt;&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Collections.Generic.KeyValuePair&lt;System.UriTemplate,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection de paires clé/valeur qui se composent d'objets <see cref="T:System.UriTemplate" /> et de leurs données associées.</summary>
        <value>Collection de paires clé/valeur qui se composent d'objets <see cref="T:System.UriTemplate" /> et de leurs données associées.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque instance <xref:System.UriTemplate> de la table contient des données qui lui sont associées. La propriété <xref:System.UriTemplateTable.KeyValuePairs%2A> contient une collection de paires clé/valeur, où la clé est une instance <xref:System.UriTemplate> et où la valeur correspond aux données associées à l'objet <xref:System.UriTemplate>. Les valeurs ne peuvent être ajoutées qu'à la propriété <xref:System.UriTemplateTable.KeyValuePairs%2A> avant d'appeler <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29>, <xref:System.UriTemplateTable.Match%28System.Uri%29> ou <xref:System.UriTemplateTable.MatchSingle%28System.Uri%29> , sinon, un objet <xref:System.NotSupportedException> est levé.  
  
   
  
## Examples  
 L'exemple suivant montre comment accéder à la propriété <xref:System.UriTemplateTable.KeyValuePairs%2A>.  
  
 [!code-csharp[UriTemplateTable#7](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#7)]
 [!code-vb[UriTemplateTable#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeReadOnly">
      <MemberSignature Language="C#" Value="public void MakeReadOnly (bool allowDuplicateEquivalentUriTemplates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MakeReadOnly(bool allowDuplicateEquivalentUriTemplates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.MakeReadOnly(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MakeReadOnly (allowDuplicateEquivalentUriTemplates As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MakeReadOnly(bool allowDuplicateEquivalentUriTemplates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowDuplicateEquivalentUriTemplates" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="allowDuplicateEquivalentUriTemplates">Spécifie si des instances <see cref="T:System.UriTemplate" /> équivalentes en double doivent être autorisées dans <see cref="T:System.UriTemplateTable" />.</param>
        <summary>Met <see cref="T:System.UriTemplateTable" /> en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque la méthode <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> est appelée, l'un des types de validation suivants intervient :  
  
-   Lorsque <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> est appelée en passant dans `false`, le <xref:System.UriTemplateTable> vérifie la table ne contient aucun plusieurs modèles structurellement équivalents. Si elle recherche des modèles de ce type, une exception est levée. Ce type de validation est utilisé conjointement à la méthode <xref:System.UriTemplateTable.MatchSingle%28System.Uri%29> lorsque vous souhaitez garantir qu'un seul modèle correspond à un URI entrant.  
  
-   Lorsque <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> est appelée en passant dans `true`, plusieurs modèles structurellement équivalents peuvent être contenus dans un <xref:System.UriTemplateTable>. Toutefois, toutes les chaînes de demande des modèles ne doivent pas être ambiguës ; les chaînes de demande identiques sont autorisées. Ce type de validation est utilisé conjointement à la méthode <xref:System.UriTemplateTable.Match%28System.Uri%29> lorsque plusieurs correspondances de modèles sont autorisées sur l'URI candidat.  
  
 Seul le premier appel à <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> est pris en compte, les appels suivants sont ignorés sans qu'aucune exception ne soit levée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;UriTemplateMatch&gt; Match (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.Collection`1&lt;class System.UriTemplateMatch&gt; Match(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.Match(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::Collection&lt;UriTemplateMatch ^&gt; ^ Match(Uri ^ uri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.UriTemplateMatch&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">URI candidat.</param>
        <summary>Tente de faire correspondre un <see cref="T:System.Uri" /> candidat et <see cref="T:System.UriTemplateTable" />.</summary>
        <returns>Collection d'instances <see cref="T:System.UriTemplateMatch" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut retourner plusieurs correspondances.  
  
   
  
## Examples  
 L'exemple suivant montre comment appeler la méthode <xref:System.UriTemplateTable.Match%28System.Uri%29>.  
  
 [!code-csharp[UriTemplateTable#9](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#9)]
 [!code-vb[UriTemplateTable#9](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MatchSingle">
      <MemberSignature Language="C#" Value="public UriTemplateMatch MatchSingle (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.UriTemplateMatch MatchSingle(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.MatchSingle(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplateMatch ^ MatchSingle(Uri ^ uri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriTemplateMatch</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">URI candidat.</param>
        <summary>Tente de faire correspondre un <see cref="T:System.Uri" /> candidat et <see cref="T:System.UriTemplateTable" />.</summary>
        <returns>Instance unique <see cref="T:System.UriTemplateMatch" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au maximum, cette méthode retourne une correspondance. Si plusieurs correspondances sont trouvées, un <xref:System.UriTemplateMatchException> est levé.  
  
   
  
## Examples  
 L'exemple suivant montre comment appeler la méthode <xref:System.UriTemplateTable.MatchSingle%28System.Uri%29>.  
  
 [!code-csharp[UriTemplateTable#10](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#10)]
 [!code-vb[UriTemplateTable#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalBaseAddress">
      <MemberSignature Language="C#" Value="public Uri OriginalBaseAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri OriginalBaseAddress" />
      <MemberSignature Language="DocId" Value="P:System.UriTemplateTable.OriginalBaseAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalBaseAddress As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ OriginalBaseAddress { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'adresse de base d'origine.</summary>
        <value>Adresse de base d'origine.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>