<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Lazy`1.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5ad53c03faf661b5a698d5ef0c4fcd9d0451bbc14.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ad53c03faf661b5a698d5ef0c4fcd9d0451bbc14</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The type of object that is being lazily initialized.</source>
          <target state="translated">Type d’objet initialisé tardivement.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Lazy`1">
          <source>Provides support for lazy initialization.</source>
          <target state="translated">Prend en charge l'initialisation tardive.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Use lazy initialization to defer the creation of a large or resource-intensive object, or the execution of a resource-intensive task, particularly when such creation or execution might not occur during the lifetime of the program.</source>
          <target state="translated">Utiliser une initialisation tardive pour différer la création d’un objet volumineux ou beaucoup de ressources, ou l’exécution d’une tâche gourmande en ressources, en particulier lorsqu’une telle création ou exécution ne peut pas se produire pendant la durée de vie du programme.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>To prepare for lazy initialization, you create an instance of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>.</source>
          <target state="translated">Pour préparer l’initialisation tardive, vous créez une instance de <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The type argument of the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object that you create specifies the type of the object that you want to initialize lazily.</source>
          <target state="translated">L’argument de type de la <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> objet que vous créez Spécifie le type de l’objet que vous souhaitez initialiser tardivement.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The constructor that you use to create the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object determines the characteristics of the initialization.</source>
          <target state="translated">Le constructeur qui vous permet de créer le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> objet détermine les caractéristiques de l’initialisation.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Lazy initialization occurs the first time the <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A?displayProperty=nameWithType&gt;</ph> property is accessed.</source>
          <target state="translated">L’initialisation tardive se produit lors du premier accès à la propriété <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>In most cases, choosing a constructor depends on your answers to two questions:</source>
          <target state="translated">Dans la plupart des cas, en choisissant un constructeur dépend de vos réponses aux deux questions :</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Will the lazily initialized object be accessed from more than one thread?</source>
          <target state="translated">L’objet initialisé tardivement est accessible à partir de plusieurs threads ?</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>If so, the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object might create it on any thread.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> objet peut créer le certificat sur n’importe quel thread.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>You can use one of the simple constructors whose default behavior is to create a thread-safe <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object, so that only one instance of the lazily instantiated object is created no matter how many threads try to access it.</source>
          <target state="translated">Vous pouvez utiliser un des constructeurs simples dont le comportement par défaut consiste à créer un thread-safe <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> de l’objet, afin que seule une instance de l’objet instancié tardivement est créée, quel que soit le nombre de threads tentent d’y accéder.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>To create a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object that is not thread safe, you must use a constructor that enables you to specify no thread safety.</source>
          <target state="translated">Pour créer un <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> objet qui n’est pas thread-safe, vous devez utiliser un constructeur qui vous permet de spécifier la sécurité des threads.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Making the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object thread safe does not protect the lazily initialized object.</source>
          <target state="translated">Rendre le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> objet thread-safe ne protège pas l’objet initialisé tardivement.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>If multiple threads can access the lazily initialized object, you must make its properties and methods safe for multithreaded access.</source>
          <target state="translated">Si plusieurs threads peuvent accéder à l’objet initialisé tardivement, vous devez apporter ses propriétés et méthodes sécurisés pour l’accès multithread.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Does lazy initialization require a lot of code, or does the lazily initialized object have a default constructor that does everything you need and doesn't throw exceptions?</source>
          <target state="translated">L’initialisation tardive nécessite beaucoup de code, ou l’objet initialisé tardivement possède un constructeur par défaut qui fait tout ce dont vous avez besoin et ne lève pas d’exceptions ?</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>If you need to write initialization code or if exceptions need to be handled, use one of the constructors that takes a factory method.</source>
          <target state="translated">Si vous avez besoin d’écrire du code d’initialisation ou si les exceptions doivent être traitées, utilisez un des constructeurs qui prend une méthode de fabrique.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Write your initialization code in the factory method.</source>
          <target state="translated">Écrivez votre code d’initialisation dans la méthode de fabrique.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The following table shows which constructor to choose, based on these two factors:</source>
          <target state="translated">Le tableau suivant montre le constructeur à choisir, en fonction de ces deux facteurs :</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Object will be accessed by</source>
          <target state="translated">Objet est accessible par</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>If no initialization code is required (default constructor), use</source>
          <target state="translated">Si aucun code d’initialisation n’est requis (constructeur par défaut), utilisez</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>If initialization code is required, use</source>
          <target state="translated">Si le code d’initialisation est requis, utilisez</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Multiple threads</source>
          <target state="translated">Plusieurs threads</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>One thread</source>
          <target state="translated">Un thread</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source><ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Boolean%29&gt;</ph> with <ph id="ph2">`isThreadSafe`</ph> set to <ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Boolean%29&gt;</ph> avec <ph id="ph2">`isThreadSafe`</ph> la valeur <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source><ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> with <ph id="ph2">`isThreadSafe`</ph> set to <ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> avec <ph id="ph2">`isThreadSafe`</ph> la valeur <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>You can use a lambda expression to specify the factory method.</source>
          <target state="translated">Vous pouvez utiliser une expression lambda pour spécifier la méthode de fabrique.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>This keeps all the initialization code in one place.</source>
          <target state="translated">Cela permet de conserver tout le code d’initialisation dans un seul emplacement.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The lambda expression captures the context, including any arguments you pass to the lazily initialized object's constructor.</source>
          <target state="translated">L’expression lambda capture le contexte, y compris les arguments que vous passez au constructeur de l’objet initialisé tardivement.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source><bpt id="p1">**</bpt>Exception caching<ept id="p1">**</ept> When you use factory methods, exceptions are cached.</source>
          <target state="translated"><bpt id="p1">**</bpt>La mise en cache d’exception<ept id="p1">**</ept> lorsque vous utilisez les méthodes de fabrique, les exceptions sont mises en cache.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>That is, if the factory method throws an exception the first time a thread tries to access the <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> object, the same exception is thrown on every subsequent attempt.</source>
          <target state="translated">Autrement dit, si la méthode de fabrique lève une heure de l’exception de la première un thread tente d’accéder à la <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> propriété de la <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> de l’objet, la même exception est levée à chaque tentative ultérieure.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>This ensures that every call to the <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property produces the same result and avoids subtle errors that might arise if different threads get different results.</source>
          <target state="translated">Cela garantit que chaque appel à la <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> propriété produit le même résultat et permet d’éviter des erreurs subtiles qui peuvent survenir si différents threads obtiennent des résultats différents.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> stands in for an actual <ph id="ph2">`T`</ph> that otherwise would have been initialized at some earlier point, usually during startup.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> remplace une réelle <ph id="ph2">`T`</ph> qui sinon aurait été initialisé à un moment antérieur, généralement lors du démarrage.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>A failure at that earlier point is usually fatal.</source>
          <target state="translated">Il est généralement irrécupérable d’une défaillance à ce moment antérieur.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>If there is a potential for a recoverable failure, we recommend that you build the retry logic into the initialization routine (in this case, the factory method), just as you would if you weren’t using lazy initialization.</source>
          <target state="translated">S’il existe un risque potentiel pour une erreur récupérable, nous vous recommandons de créer la logique de nouvelle tentative dans la routine d’initialisation (dans ce cas, la méthode de fabrique), comme vous le feriez si vous n’utilisiez l’initialisation tardive.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source><bpt id="p1">**</bpt>Alternative to locking<ept id="p1">**</ept> In certain situations, you might want to avoid the overhead of the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object's default locking behavior.</source>
          <target state="translated"><bpt id="p1">**</bpt>Alternative au verrouillage<ept id="p1">**</ept> dans certaines situations, vous pouvez souhaiter éviter la surcharge de la <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> comportement de verrouillage par défaut de l’objet.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>In rare situations, there might be a potential for deadlocks.</source>
          <target state="translated">Dans de rares cas, il peut être un risque potentiel de blocages.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>In such cases, you can use the <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> constructor, and specify <ph id="ph3">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Dans ce cas, vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> ou <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> constructeur et spécifiez <ph id="ph3">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>This enables the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object to create a copy of the lazily initialized object on each of several threads if the threads call the <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property simultaneously.</source>
          <target state="translated">Cela permet la <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> objet pour créer une copie de l’objet initialisé tardivement sur chacun des nombreux threads si les threads appellent le <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> propriété simultanément.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object ensures that all threads use the same instance of the lazily initialized object and discards the instances that are not used.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> objet garantit que tous les threads utilisent la même instance de l’objet initialisé tardivement et ignore les instances qui ne sont pas utilisés.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Thus, the cost of reducing the locking overhead is that your program might sometimes create and discard extra copies of an expensive object.</source>
          <target state="translated">Par conséquent, le coût de réduire la surcharge de verrouillage est que votre programme peut parfois créer et supprimer des copies supplémentaires d’un objet coûteux.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>In most cases, this is unlikely.</source>
          <target state="translated">Dans la plupart des cas, il est peu probable.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The examples for the <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> constructors demonstrate this behavior.</source>
          <target state="translated">Les exemples pour le <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> et <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> constructeurs illustrent ce comportement.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>When you specify <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, exceptions are never cached, even if you specify a factory method.</source>
          <target state="translated">Lorsque vous spécifiez <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, les exceptions sont jamais mises en cache, même si vous spécifiez une méthode de fabrique.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source><bpt id="p1">**</bpt>Equivalent constructors<ept id="p1">**</ept> In addition to enabling the use of <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, the <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> and <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> constructors can duplicate the functionality of the other constructors.</source>
          <target state="translated"><bpt id="p1">**</bpt>Constructeurs équivalents<ept id="p1">**</ept> non seulement activer l’utilisation de <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, le <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> et <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> constructeurs peuvent de dupliquer les fonctionnalités d’autres constructeurs.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The following table shows the parameter values that produce equivalent behavior.</source>
          <target state="translated">Le tableau suivant montre les valeurs de paramètre qui produisent un comportement équivalent.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>To create a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object that is</source>
          <target state="translated">Pour créer un <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> qui est de l’objet</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>For constructors that have a <ph id="ph1">`LazyThreadSafetyMode`</ph> <ph id="ph2">`mode`</ph> parameter, set <ph id="ph3">`mode`</ph> to</source>
          <target state="translated">Pour les constructeurs qui ont un <ph id="ph1">`LazyThreadSafetyMode`</ph> <ph id="ph2">`mode`</ph> paramètre, la valeur <ph id="ph3">`mode`</ph> à</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>For constructors that have a Boolean <ph id="ph1">`isThreadSafe`</ph> parameter, set <ph id="ph2">`isThreadSafe`</ph> to</source>
          <target state="translated">Pour les constructeurs qui ont une valeur booléenne <ph id="ph1">`isThreadSafe`</ph> paramètre, la valeur <ph id="ph2">`isThreadSafe`</ph> à</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>For constructors with no thread safety parameters</source>
          <target state="translated">Pour les constructeurs sans paramètre de sécurité des threads</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Fully thread safe; uses locking to ensure that only one thread initializes the value.</source>
          <target state="translated">Entièrement les thread-safe ; utilise le verrouillage pour vous assurer qu’un seul thread initialise la valeur.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>All such constructors are fully thread safe.</source>
          <target state="translated">Tous les constructeurs de ce type sont totalement thread-safe.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Not thread safe.</source>
          <target state="translated">Pas thread-safe.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Not applicable.</source>
          <target state="translated">Non applicable.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Fully thread safe; threads race to initialize the value.</source>
          <target state="translated">Entièrement les thread-safe ; concurrence de threads pour initialiser la valeur.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Not applicable.</source>
          <target state="translated">Non applicable.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Not applicable.</source>
          <target state="translated">Non applicable.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source><bpt id="p1">**</bpt>Other capabilities<ept id="p1">**</ept> For information about the use of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> with thread-static fields, or as the backing store for properties, see <bpt id="p2">[</bpt>Lazy Initialization<ept id="p2">](~/docs/framework/performance/lazy-initialization.md)</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Autres fonctionnalités<ept id="p1">**</ept> pour plus d’informations sur l’utilisation de <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> avec les champs static de thread, ou comme magasin de stockage pour les propriétés, consultez <bpt id="p2">[</bpt>l’initialisation tardive<ept id="p2">](~/docs/framework/performance/lazy-initialization.md)</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> class to provide lazy initialization with access from multiple threads.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> classe afin de fournir l’initialisation tardive avec accès depuis plusieurs threads.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph> constructor.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>It also demonstrates the use of the <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> constructor (specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`isThreadSafe`</ph>) and the <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> constructor (specifying <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> for <ph id="ph6">`mode`</ph>).</source>
          <target state="translated">Il montre également l’utilisation de la <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> constructeur (spécifiant <ph id="ph2">`true`</ph> pour <ph id="ph3">`isThreadSafe`</ph>) et le <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> constructeur (spécification <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> pour <ph id="ph6">`mode`</ph>).</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>To switch to a different constructor, just change which constructors are commented out.</source>
          <target state="translated">Pour basculer vers un autre constructeur, modifiez simplement les constructeurs sont commentées.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>For an example that demonstrates exception caching using the same constructors, see the <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph> constructor.</source>
          <target state="translated">Pour obtenir un exemple qui illustre l’exception, la mise en cache à l’aide des constructeurs de mêmes, consultez le <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The example defines a <ph id="ph1">`LargeObject`</ph> class that will be initialized lazily by one of several threads.</source>
          <target state="translated">L'exemple définit une classe <ph id="ph1">`LargeObject`</ph> qui sera initialisée tardivement par l'un des nombreux threads.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The four key sections of code illustrate the creation of the initializer, the factory method, the actual initialization, and the constructor of the <ph id="ph1">`LargeObject`</ph> class, which displays a message when the object is created.</source>
          <target state="translated">Les quatre sections clés de code illustrent la création de l’initialiseur, la méthode de fabrique, l’initialisation réelle et le constructeur de la <ph id="ph1">`LargeObject`</ph> (classe), qui affiche un message lorsque l’objet est créé.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>At the beginning of the <ph id="ph1">`Main`</ph> method, the example creates the thread-safe lazy initializer for <ph id="ph2">`LargeObject`</ph>:</source>
          <target state="translated">Au début de la méthode <ph id="ph1">`Main`</ph>, l'exemple crée l'initialiseur de type lazy thread-safe pour <ph id="ph2">`LargeObject`</ph> :</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The factory method shows the creation of the object, with a placeholder for further initialization:</source>
          <target state="translated">La méthode de fabrique illustre la création de l’objet, avec un espace réservé pour une initialisation supplémentaire :</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Note that the first two code sections could be combined by using a lambda function, as shown here:</source>
          <target state="translated">Notez que les sections de code tout d’abord deux peuvent être combinées à l’aide d’une fonction lambda, comme indiqué ici :</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The example pauses, to indicate that an indeterminate period may elapse before lazy initialization occurs.</source>
          <target state="translated">L’exemple suspend, pour indiquer qu’une période indéterminée peut s’écouler avant l’initialisation tardive se produit.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>When you press the <bpt id="p1">**</bpt>Enter<ept id="p1">**</ept> key, the example creates and starts three threads.</source>
          <target state="translated">Lorsque vous appuyez sur la <bpt id="p1">**</bpt>entrée<ept id="p1">**</ept> clé, l’exemple crée et démarre trois threads.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The <ph id="ph1">`ThreadProc`</ph> method that's used by all three threads calls the <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property.</source>
          <target state="translated">Le <ph id="ph1">`ThreadProc`</ph> méthode qui est utilisée par tous les appels de trois threads le <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The first time this happens, the <ph id="ph1">`LargeObject`</ph> instance is created:</source>
          <target state="translated">La première fois dans ce cas, le <ph id="ph1">`LargeObject`</ph> instance est créée :</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The constructor of the <ph id="ph1">`LargeObject`</ph> class, which includes the last key section of code, displays a message and records the identity of the initializing thread.</source>
          <target state="translated">Le constructeur de la <ph id="ph1">`LargeObject`</ph> (classe), qui inclut la clé dernière section de code, affiche un message et enregistre l’identité du thread lors de l’initialisation.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The output from the program appears at the end of the full code listing.</source>
          <target state="translated">La sortie du programme s’affiche à la fin de la liste de code complet.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>For simplicity, this example uses a global instance of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>, and all the methods are <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">Pour plus de simplicité, cet exemple utilise une instance globale de <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> et toutes les méthodes sont <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>These are not requirements for the use of lazy initialization.</source>
          <target state="translated">Ce ne sont pas des exigences pour l’utilisation de l’initialisation tardive.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>By default, all public and protected members of the <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> class are thread safe and may be used concurrently from multiple threads.</source>
          <target state="translated">Par défaut, tous les membres publics et protégés de la <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> classe sont thread-safe et peuvent être utilisés simultanément à partir de plusieurs threads.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>These thread-safety guarantees may be removed optionally and per instance, using parameters to the type's constructors.</source>
          <target state="translated">Ces garanties de sécurité des threads peuvent être éventuellement supprimées par instance, à l’aide des paramètres pour les constructeurs du type.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="T:System.Lazy`1">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor">
          <source>When lazy initialization occurs, the default constructor of the target type is used.</source>
          <target state="translated">Quand l’initialisation tardive se produit, le constructeur par défaut du type cible est utilisé.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>An instance that is created with this constructor may be used concurrently from multiple threads.</source>
          <target state="translated">Une instance est créée avec ce constructeur peut être utilisée simultanément depuis plusieurs threads.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The thread safety mode of a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance that is initialized with this constructor is <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Le mode de sécurité des threads d’un <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance qui est initialisée avec ce constructeur est <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The thread safety mode describes the behavior when multiple threads try to initialize the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Le mode de sécurité des threads décrit le comportement lorsque plusieurs threads essaient d’initialiser le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>A <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance that is created with this constructor does not cache exceptions.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance est créée avec ce constructeur ne met pas en cache les exceptions.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> class or the <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Pour plus d'informations, consultez la classe <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> ou l'énumération <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The following example demonstrates the use of this constructor.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de ce constructeur.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>It also illustrates the use of the <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Boolean%29&gt;</ph> constructor (specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`isThreadSafe`</ph>) and the <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> constructor (specifying <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> for <ph id="ph6">`mode`</ph>).</source>
          <target state="translated">Il illustre également l’utilisation de la <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Boolean%29&gt;</ph> constructeur (spécification <ph id="ph2">`true`</ph> pour <ph id="ph3">`isThreadSafe`</ph>) et le <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> constructeur (spécification <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> pour <ph id="ph6">`mode`</ph>).</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>To switch to a different constructor, just change which constructors are commented out.</source>
          <target state="translated">Pour basculer vers un autre constructeur, modifiez simplement les constructeurs sont commentées.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The example defines a <ph id="ph1">`LargeObject`</ph> class that will be initialized lazily by one of several threads.</source>
          <target state="translated">L'exemple définit une classe <ph id="ph1">`LargeObject`</ph> qui sera initialisée tardivement par l'un des nombreux threads.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The two key lines of code in this example are the creation of the initializer and the actual initialization.</source>
          <target state="translated">Les deux lignes de clés de code dans cet exemple sont la création de l’initialiseur et l’initialisation réelle.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>At the beginning of the <ph id="ph1">`Main`</ph> method, the example creates the thread-safe lazy initializer for <ph id="ph2">`LargeObject`</ph>:</source>
          <target state="translated">Au début de la méthode <ph id="ph1">`Main`</ph>, l'exemple crée l'initialiseur de type lazy thread-safe pour <ph id="ph2">`LargeObject`</ph> :</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The example creates and starts three threads that block on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> object, so that the example can release the threads all at once.</source>
          <target state="translated">L’exemple crée et démarre trois threads se bloquent sur un <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> de l’objet, afin que l’exemple peut libérer les threads à la fois.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The <ph id="ph1">`ThreadProc`</ph> method that's used by all three threads calls the <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property to get the <ph id="ph3">`LargeObject`</ph> instance:</source>
          <target state="translated">Le <ph id="ph1">`ThreadProc`</ph> méthode qui est utilisée par tous les appels de trois threads le <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> propriété à obtenir le <ph id="ph3">`LargeObject`</ph> instance :</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> class provides locking, so that only one thread is allowed to create the <ph id="ph2">`LargeObject`</ph> instance.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> classe fournit le verrouillage, afin que seul un thread est autorisé à créer le <ph id="ph2">`LargeObject`</ph> instance.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The example demonstrates that the other threads all get the same instance.</source>
          <target state="translated">L’exemple montre que tous les autres threads obtiennent la même instance.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>For simplicity, this example uses a global instance of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>, and all the methods are <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">Pour plus de simplicité, cet exemple utilise une instance globale de <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> et toutes les méthodes sont <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>These are not requirements for the use of lazy initialization.</source>
          <target state="translated">Ce ne sont pas des exigences pour l’utilisation de l’initialisation tardive.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to make this instance usable concurrently by multiple threads; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to make the instance usable by only one thread at a time.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour que cette instance puisse être utilisée simultanément par plusieurs threads ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour que l'instance ne puisse être utilisée que par un thread à la fois.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>When lazy initialization occurs, the default constructor of the target type and the specified initialization mode are used.</source>
          <target state="translated">Quand une initialisation tardive se produit, le constructeur par défaut du type cible et le mode d’initialisation spécifié sont utilisés.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>The thread safety mode of a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance that is initialized with this constructor is <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> if <ph id="ph3">`isThreadSafe`</ph> is <ph id="ph4">`true`</ph>; otherwise, the mode is <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Le mode de sécurité des threads d’un <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance qui est initialisée avec ce constructeur est <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> si <ph id="ph3">`isThreadSafe`</ph> est <ph id="ph4">`true`</ph>; sinon, le mode est <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>The thread safety mode describes the behavior when multiple threads try to initialize the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Le mode de sécurité des threads décrit le comportement lorsque plusieurs threads essaient d’initialiser le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>To specify the <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph> mode, use the <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> or <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> constructor.</source>
          <target state="translated">Pour spécifier le <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph> mode, utilisez le <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> ou <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance that is created with this constructor does not cache exceptions.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance est créée avec ce constructeur ne met pas en cache les exceptions.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> class or the <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Pour plus d'informations, consultez la classe <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> ou l'énumération <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>The following example demonstrates the use of this constructor to create a lazy initializer that is not thread safe, for scenarios where all access to the lazily initialized object occurs on the same thread.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de ce constructeur pour créer un initialiseur de type lazy qui n’est pas thread-safe, pour les scénarios où tous les accès à l’objet initialisé tardivement se produit sur le même thread.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>It also demonstrates the use of the <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> constructor (specifying <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph> for <ph id="ph3">`mode`</ph>.</source>
          <target state="translated">Il montre également l’utilisation de la <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> constructeur (spécification <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph> pour <ph id="ph3">`mode`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>To switch to a different constructor, just change which constructor is commented out.</source>
          <target state="translated">Pour basculer vers un autre constructeur, modifiez simplement le constructeur est commenté.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>For code that demonstrates how to use this constructor in multithreaded scenarios (specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`isThreadSafe`</ph>), see the example for the <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor&gt;</ph> constructor.</source>
          <target state="translated">Pour le code qui montre comment utiliser ce constructeur dans les scénarios multithread (spécification <ph id="ph1">`true`</ph> pour <ph id="ph2">`isThreadSafe`</ph>), consultez l’exemple de la <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>The example defines a <ph id="ph1">`LargeObject`</ph> class that will be initialized lazily.</source>
          <target state="translated">L’exemple définit un <ph id="ph1">`LargeObject`</ph> classe qui sera initialisée tardivement.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>In the <ph id="ph1">`Main`</ph> method, the example creates a <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> instance and then pauses.</source>
          <target state="translated">Dans le <ph id="ph1">`Main`</ph> (méthode), l’exemple crée un <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> instance, puis s’arrête.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>When you press the <bpt id="p1">**</bpt>Enter<ept id="p1">**</ept> key, the example accesses the <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> instance, which causes initialization to occur.</source>
          <target state="translated">Lorsque vous appuyez sur la <bpt id="p1">**</bpt>entrée<ept id="p1">**</ept> clé, l’exemple accède à la <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> propriété de la <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> instance, ce qui provoque l’initialisation se produit.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>The constructor of the <ph id="ph1">`LargeObject`</ph> class displays a console message.</source>
          <target state="translated">Le constructeur de la <ph id="ph1">`LargeObject`</ph> classe affiche un message de console.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>For simplicity, this example uses a global instance of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>, and all the methods are <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">Pour plus de simplicité, cet exemple utilise une instance globale de <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> et toutes les méthodes sont <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>These are not requirements for the use of lazy initialization.</source>
          <target state="translated">Ce ne sont pas des exigences pour l’utilisation de l’initialisation tardive.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>The delegate that is invoked to produce the lazily initialized value when it is needed.</source>
          <target state="translated">Délégué qui est appelé pour produire la valeur initialisée tardivement si nécessaire.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>When lazy initialization occurs, the specified initialization function is used.</source>
          <target state="translated">Quand l’initialisation tardive se produit, la fonction d’initialisation spécifiée est utilisée.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>An instance that is created with this constructor may be used concurrently from multiple threads.</source>
          <target state="translated">Une instance est créée avec ce constructeur peut être utilisée simultanément depuis plusieurs threads.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>The thread safety mode of a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance that is initialized with this constructor is <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Le mode de sécurité des threads d’un <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance qui est initialisée avec ce constructeur est <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>The thread safety mode describes the behavior when multiple threads try to initialize the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Le mode de sécurité des threads décrit le comportement lorsque plusieurs threads essaient d’initialiser le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>Exceptions that are thrown by <ph id="ph1">`valueFactory`</ph> are cached.</source>
          <target state="translated">Les exceptions levées par <ph id="ph1">`valueFactory`</ph> sont mis en cache.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> class or the <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Pour plus d'informations, consultez la classe <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> ou l'énumération <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>The following example demonstrates the use of this constructor to provide lazy initialization with exception caching.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de ce constructeur pour fournir une initialisation tardive avec mise en cache de l’exception.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>It also demonstrates the use of the <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> constructor (specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`isThreadSafe`</ph>) and the <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> constructor (specifying <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> for <ph id="ph6">`mode`</ph>).</source>
          <target state="translated">Il montre également l’utilisation de la <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> constructeur (spécifiant <ph id="ph2">`true`</ph> pour <ph id="ph3">`isThreadSafe`</ph>) et le <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> constructeur (spécification <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> pour <ph id="ph6">`mode`</ph>).</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>To switch to a different constructor, just change which constructors are commented out.</source>
          <target state="translated">Pour basculer vers un autre constructeur, modifiez simplement les constructeurs sont commentées.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>The example defines a <ph id="ph1">`LargeObject`</ph> class that will be initialized lazily by one of several threads.</source>
          <target state="translated">L'exemple définit une classe <ph id="ph1">`LargeObject`</ph> qui sera initialisée tardivement par l'un des nombreux threads.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>The three key sections of code illustrate the creation of the initializer, the actual initialization, and the constructor of the <ph id="ph1">`LargeObject`</ph> class, which demonstrates exception caching.</source>
          <target state="translated">Les trois sections clés de code illustrent la création de l’initialiseur, l’initialisation réelle et le constructeur de la <ph id="ph1">`LargeObject`</ph> (classe), qui illustre la mise en cache de l’exception.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>At the beginning of the <ph id="ph1">`Main`</ph> method, the example creates the thread-safe lazy initializer for <ph id="ph2">`LargeObject`</ph>:</source>
          <target state="translated">Au début de la méthode <ph id="ph1">`Main`</ph>, l'exemple crée l'initialiseur de type lazy thread-safe pour <ph id="ph2">`LargeObject`</ph> :</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>The example creates and starts three threads.</source>
          <target state="translated">L’exemple crée et démarre trois threads.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>The <ph id="ph1">`ThreadProc`</ph> method that's used by all three threads calls the <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property to get the <ph id="ph3">`LargeObject`</ph> instance:</source>
          <target state="translated">Le <ph id="ph1">`ThreadProc`</ph> méthode qui est utilisée par tous les appels de trois threads le <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> propriété à obtenir le <ph id="ph3">`LargeObject`</ph> instance :</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>In the constructor of the <ph id="ph1">`LargeObject`</ph> class, the third key section of code throws an exception the first time a <ph id="ph2">`LargeObject`</ph> instance is created, but thereafter allows instance creation to occur:</source>
          <target state="translated">Dans le constructeur de la <ph id="ph1">`LargeObject`</ph> (classe), la troisième section clée du code lève une exception de la première fois un <ph id="ph2">`LargeObject`</ph> instance est créée, mais par la suite permet la création d’instances se produise :</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>When the example is run, the first thread that tries to create an instance of <ph id="ph1">`LargeObject`</ph> fails, and the exception is caught.</source>
          <target state="translated">Lorsque l’exemple est exécuté, le premier thread qui essaie de créer une instance de <ph id="ph1">`LargeObject`</ph> échoue et l’exception est interceptée.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>You might expect that the next thread would successfully create an instance, but the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object has cached the exception.</source>
          <target state="translated">Vous pouvez attendre que le thread suivant créerait avec succès une instance, mais la <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> objet a mis en cache de l’exception.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>Because of this, all three threads throw the exception.</source>
          <target state="translated">Pour cette raison, les trois threads lèvent l’exception.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>For simplicity, this example uses a global instance of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>, and all the methods are <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">Pour plus de simplicité, cet exemple utilise une instance globale de <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> et toutes les méthodes sont <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>These are not requirements for the use of lazy initialization.</source>
          <target state="translated">Ce ne sont pas des exigences pour l’utilisation de l’initialisation tardive.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source><ph id="ph1">&lt;paramref name="valueFactory" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="valueFactory" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>One of the enumeration values that specifies the thread safety mode.</source>
          <target state="translated">Une des valeurs d’énumération qui spécifie le mode de cohérence de thread.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> class that uses the default constructor of <ph id="ph2">&lt;paramref name="T" /&gt;</ph> and the specified thread-safety mode.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> qui utilise le constructeur par défaut de <ph id="ph2">&lt;paramref name="T" /&gt;</ph> et le mode de cohérence de thread spécifié.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>The thread safety mode of a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance describes the behavior when multiple threads try to initialize the <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Le mode de sécurité des threads d’un <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance décrit le comportement lorsque plusieurs threads essaient d’initialiser le <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>A <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance that is created with this constructor does not cache exceptions.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance est créée avec ce constructeur ne met pas en cache les exceptions.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> class or the <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Pour plus d'informations, consultez la classe <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> ou l'énumération <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>The following example demonstrates the use of this constructor to create a lazy initializer that enables multiple threads to race to create an object lazily.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de ce constructeur pour créer un initialiseur de type lazy qui permet à plusieurs threads à concurrence pour créer un objet tardivement.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>Multiple threads might succeed in creating instances, but all threads use the instance that was created first.</source>
          <target state="translated">Plusieurs threads peuvent réussir à créer des instances, mais tous les threads utilisent l’instance qui a été créé en premier.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>For an example that demonstrates how to use this constructor in single-threaded scenarios (specifying <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`mode`</ph>), see the <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Pour obtenir un exemple qui montre comment utiliser ce constructeur dans des scénarios monothread (spécification <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph> pour <ph id="ph2">`mode`</ph>), consultez le <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Boolean%29&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>For an example that demonstrates how to use this constructor to provide locking instead of race conditions in multithreaded scenarios (specifying <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`mode`</ph>), see the <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor&gt;</ph> constructor.</source>
          <target state="translated">Pour obtenir un exemple qui montre comment utiliser ce constructeur pour fournir le verrouillage au lieu des conditions de concurrence dans les scénarios multithread (spécification <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> pour <ph id="ph2">`mode`</ph>), consultez le <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>The example defines a <ph id="ph1">`LargeObject`</ph> class that will be initialized lazily by any of several threads.</source>
          <target state="translated">L’exemple définit un <ph id="ph1">`LargeObject`</ph> classe qui sera initialisée tardivement par un des nombreux threads.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>The three key sections of code illustrate the creation of the initializer, the actual initialization, and the constructor and finalizer of the <ph id="ph1">`LargeObject`</ph> class.</source>
          <target state="translated">Les trois sections clés de code illustrent la création de l’initialiseur, l’initialisation réelle et que le constructeur et le finaliseur de le <ph id="ph1">`LargeObject`</ph> classe.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>At the beginning of the <ph id="ph1">`Main`</ph> method, the example creates the <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> object that performs lazy initialization of the <ph id="ph3">`LargeObject`</ph>:</source>
          <target state="translated">Au début de la <ph id="ph1">`Main`</ph> (méthode), l’exemple crée le <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> objet qui effectue une initialisation tardive de la <ph id="ph3">`LargeObject`</ph>:</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>The example creates and starts three threads that block on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> object, so that the example can release the threads all at once.</source>
          <target state="translated">L’exemple crée et démarre trois threads se bloquent sur un <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> de l’objet, afin que l’exemple peut libérer les threads à la fois.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>In the <ph id="ph1">`ThreadProc`</ph> method that's used by all three threads, calling the <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property creates the <ph id="ph3">`LargeObject`</ph> instance:</source>
          <target state="translated">Dans le <ph id="ph1">`ThreadProc`</ph> méthode qui est utilisée par les trois threads, en appelant le <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> propriété crée les <ph id="ph3">`LargeObject`</ph> instance :</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>Because the constructor for the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance specified <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, all three threads are allowed to create <ph id="ph3">`LargeObject`</ph> instances.</source>
          <target state="translated">Étant donné que le constructeur de la <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance spécifiée <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, tous les trois threads sont autorisés à créer <ph id="ph3">`LargeObject`</ph> instances.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>The example demonstrates this by displaying console messages in the constructor and in the finalizer of the <ph id="ph1">`LargeObject`</ph> class:</source>
          <target state="translated">L’exemple illustre cela en affichant les messages de la console dans le constructeur et le finaliseur de le <ph id="ph1">`LargeObject`</ph> classe :</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>However, the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object ensures that only one instance is used by all threads.</source>
          <target state="translated">Toutefois, le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> objet garantit que seule une instance est utilisée par tous les threads.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>The output from the example shows that all three threads use the same instance, and also shows that the other two instances can be reclaimed by garbage collection.</source>
          <target state="translated">La sortie de l’exemple montre que les trois threads utilisent la même instance et indique que les deux autres instances peuvent être récupérées par le garbage collection.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>For simplicity, this example uses a global instance of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>, and all the methods are <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">Pour plus de simplicité, cet exemple utilise une instance globale de <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> et toutes les méthodes sont <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>These are not requirements for the use of lazy initialization.</source>
          <target state="translated">Ce ne sont pas des exigences pour l’utilisation de l’initialisation tardive.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contient une valeur non valide.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>The delegate that is invoked to produce the lazily initialized value when it is needed.</source>
          <target state="translated">Délégué qui est appelé pour produire la valeur initialisée tardivement si nécessaire.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to make this instance usable concurrently by multiple threads; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to make this instance usable by only one thread at a time.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour que cette instance puisse être utilisée simultanément par plusieurs threads ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour que cette instance ne puisse être utilisée que par un thread à la fois.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>When lazy initialization occurs, the specified initialization function and initialization mode are used.</source>
          <target state="translated">Quand l’initialisation tardive se produit, la fonction d’initialisation spécifiée et le mode d’initialisation sont utilisés.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>The thread safety mode of a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance that is initialized with this constructor is <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> if <ph id="ph3">`isThreadSafe`</ph> is <ph id="ph4">`true`</ph>; otherwise, the mode is <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Le mode de sécurité des threads d’un <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance qui est initialisée avec ce constructeur est <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> si <ph id="ph3">`isThreadSafe`</ph> est <ph id="ph4">`true`</ph>; sinon, le mode est <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>The thread safety mode describes the behavior when multiple threads try to initialize the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Le mode de sécurité des threads décrit le comportement lorsque plusieurs threads essaient d’initialiser le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>To specify the <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph> mode, use the <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> or <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> constructor.</source>
          <target state="translated">Pour spécifier le <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph> mode, utilisez le <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> ou <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>Exceptions that are thrown by <ph id="ph1">`valueFactory`</ph> are cached.</source>
          <target state="translated">Les exceptions levées par <ph id="ph1">`valueFactory`</ph> sont mis en cache.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> class or the <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Pour plus d'informations, consultez la classe <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> ou l'énumération <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>The following example demonstrates the use of this constructor to provide lazy initialization with exception caching, in a scenario with a single thread.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de ce constructeur pour fournir une initialisation tardive avec l’exception de la mise en cache dans un scénario avec un thread unique.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>It also demonstrates the use of the  <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%2A&gt;</ph> constructor (specifying <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph> for <ph id="ph3">`mode`</ph>).</source>
          <target state="translated">Il montre également l’utilisation de la <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%2A&gt;</ph> constructeur (spécification <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph> pour <ph id="ph3">`mode`</ph>).</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>To switch to that constructor, just change which constructor is commented out.</source>
          <target state="translated">Pour basculer vers ce constructeur, modifiez simplement le constructeur est commenté.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>For code that demonstrates how to use this constructor in multithreaded scenarios (specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`isThreadSafe`</ph>), see the example for the <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph> constructor.</source>
          <target state="translated">Pour le code qui montre comment utiliser ce constructeur dans les scénarios multithread (spécification <ph id="ph1">`true`</ph> pour <ph id="ph2">`isThreadSafe`</ph>), consultez l’exemple de la <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>The example defines a <ph id="ph1">`LargeObject`</ph> class that will be initialized lazily by one of several threads.</source>
          <target state="translated">L'exemple définit une classe <ph id="ph1">`LargeObject`</ph> qui sera initialisée tardivement par l'un des nombreux threads.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>The three key sections of code illustrate the creation of the initializer, the actual initialization, and the constructor of the <ph id="ph1">`LargeObject`</ph> class, which demonstrates exception caching.</source>
          <target state="translated">Les trois sections clés de code illustrent la création de l’initialiseur, l’initialisation réelle et le constructeur de la <ph id="ph1">`LargeObject`</ph> (classe), qui illustre la mise en cache de l’exception.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>At the beginning of the <ph id="ph1">`Main`</ph> method, the example creates the thread-safe lazy initializer for <ph id="ph2">`LargeObject`</ph>:</source>
          <target state="translated">Au début de la méthode <ph id="ph1">`Main`</ph>, l'exemple crée l'initialiseur de type lazy thread-safe pour <ph id="ph2">`LargeObject`</ph> :</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>In the call to the constructor, the <ph id="ph1">`isThreadSafe`</ph> parameter is <ph id="ph2">`false`</ph>, so the <ph id="ph3">&lt;xref:System.Lazy%601&gt;</ph> is not thread safe.</source>
          <target state="translated">Dans l’appel au constructeur, le <ph id="ph1">`isThreadSafe`</ph> paramètre est <ph id="ph2">`false`</ph>, donc le <ph id="ph3">&lt;xref:System.Lazy%601&gt;</ph> n’est pas thread-safe.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>Because it's not thread safe, the example calls the <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property three times on the same thread:</source>
          <target state="translated">Comme il n’est pas thread-safe, l’exemple appelle la <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> propriété trois fois sur le même thread :</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>In the constructor of the <ph id="ph1">`LargeObject`</ph> class, the third key section of code throws an exception the first time a <ph id="ph2">`LargeObject`</ph> instance is created, but thereafter allows instance creation to occur:</source>
          <target state="translated">Dans le constructeur de la <ph id="ph1">`LargeObject`</ph> (classe), la troisième section clée du code lève une exception de la première fois un <ph id="ph2">`LargeObject`</ph> instance est créée, mais par la suite permet la création d’instances se produise :</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>When the example is run, the first attempt to create an instance of <ph id="ph1">`LargeObject`</ph> fails, and the exception is caught.</source>
          <target state="translated">Lorsque l’exemple est exécuté, la première tentative de créer une instance de <ph id="ph1">`LargeObject`</ph> échoue et l’exception est interceptée.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>You might expect that the next attempt would succeed, but the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object has cached the exception.</source>
          <target state="translated">Vous pouvez attendre que la prochaine tentative réussit, mais la <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> objet a mis en cache de l’exception.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>Because of this, all three attempts throw the exception.</source>
          <target state="translated">Pour cette raison, les trois tentatives lèvent l’exception.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>For simplicity, this example uses a global instance of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>, and all the methods are <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">Pour plus de simplicité, cet exemple utilise une instance globale de <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> et toutes les méthodes sont <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>These are not requirements for the use of lazy initialization.</source>
          <target state="translated">Ce ne sont pas des exigences pour l’utilisation de l’initialisation tardive.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="valueFactory" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="valueFactory" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The delegate that is invoked to produce the lazily initialized value when it is needed.</source>
          <target state="translated">Délégué qui est appelé pour produire la valeur initialisée tardivement si nécessaire.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>One of the enumeration values that specifies the thread safety mode.</source>
          <target state="translated">Une des valeurs d’énumération qui spécifie le mode de cohérence de thread.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> class that uses the specified initialization function and thread-safety mode.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> qui utilise la fonction d'initialisation et le mode de cohérence de thread spécifiés.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The thread safety mode of a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance describes the behavior when multiple threads try to initialize the <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Le mode de sécurité des threads d’un <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance décrit le comportement lorsque plusieurs threads essaient d’initialiser le <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>Exceptions that are thrown by <ph id="ph1">`valueFactory`</ph> are cached, unless <ph id="ph2">`mode`</ph> is <ph id="ph3">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Les exceptions levées par <ph id="ph1">`valueFactory`</ph> sont mis en cache, sauf si <ph id="ph2">`mode`</ph> est <ph id="ph3">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> class or the <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Pour plus d'informations, consultez la classe <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> ou l'énumération <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The following example demonstrates the use of this constructor to create a lazy initializer that enables multiple threads to race to create an object lazily.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de ce constructeur pour créer un initialiseur de type lazy qui permet à plusieurs threads à concurrence pour créer un objet tardivement.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>Multiple threads might succeed in creating instances, but all threads use the instance that was created first.</source>
          <target state="translated">Plusieurs threads peuvent réussir à créer des instances, mais tous les threads utilisent l’instance qui a été créé en premier.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>In addition, the example demonstrates that exceptions are never cached when you specify <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, even if initialization is performed by a function instead of by the default constructor of the lazily created type.</source>
          <target state="translated">En outre, l’exemple montre que les exceptions ne sont jamais mises en cache lorsque vous spécifiez <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, même si l’initialisation est effectuée par une fonction à la place de par le constructeur par défaut du type créé tardivement.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>For an example that demonstrates how to use this constructor in single-threaded scenarios (specifying <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`mode`</ph>), see the <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Pour obtenir un exemple qui montre comment utiliser ce constructeur dans des scénarios monothread (spécification <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph> pour <ph id="ph2">`mode`</ph>), consultez le <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Boolean%29&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>For an example that demonstrates how to use this constructor to provide locking instead of race conditions in multithreaded scenarios (specifying <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`mode`</ph>), see the <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor&gt;</ph> constructor.</source>
          <target state="translated">Pour obtenir un exemple qui montre comment utiliser ce constructeur pour fournir le verrouillage au lieu des conditions de concurrence dans les scénarios multithread (spécification <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> pour <ph id="ph2">`mode`</ph>), consultez le <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The example defines a <ph id="ph1">`LargeObject`</ph> class that will be initialized lazily by any of several threads.</source>
          <target state="translated">L’exemple définit un <ph id="ph1">`LargeObject`</ph> classe qui sera initialisée tardivement par un des nombreux threads.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The four key sections of code illustrate the creation of the initializer, the actual initialization, the initialization function, and the constructor and finalizer of the <ph id="ph1">`LargeObject`</ph> class.</source>
          <target state="translated">Les quatre sections clés de code illustrent la création de l’initialiseur, l’initialisation réelle, la fonction d’initialisation et le constructeur et le finaliseur de le <ph id="ph1">`LargeObject`</ph> classe.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>At the beginning of the <ph id="ph1">`Main`</ph> method, the example creates the <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> object that performs lazy initialization of the <ph id="ph3">`LargeObject`</ph>:</source>
          <target state="translated">Au début de la <ph id="ph1">`Main`</ph> (méthode), l’exemple crée le <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> objet qui effectue une initialisation tardive de la <ph id="ph3">`LargeObject`</ph>:</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The lazy initializer uses a function to perform the initialization.</source>
          <target state="translated">L’initialiseur de type lazy utilise une fonction pour effectuer l’initialisation.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>In this case, a function is required because there is no default constructor for the <ph id="ph1">`LargeObject`</ph> class.</source>
          <target state="translated">Dans ce cas, une fonction est requise, car il n’existe aucun constructeur par défaut pour la <ph id="ph1">`LargeObject`</ph> classe.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The example creates and starts three threads that block on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> object, so that the example can release the threads all at once.</source>
          <target state="translated">L’exemple crée et démarre trois threads se bloquent sur un <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> de l’objet, afin que l’exemple peut libérer les threads à la fois.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>In the <ph id="ph1">`ThreadProc`</ph> method that's used by all three threads, calling the <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property creates the <ph id="ph3">`LargeObject`</ph> instance:</source>
          <target state="translated">Dans le <ph id="ph1">`ThreadProc`</ph> méthode qui est utilisée par les trois threads, en appelant le <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> propriété crée les <ph id="ph3">`LargeObject`</ph> instance :</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>In the third key section of code, the lazy initialization function is called to create the <ph id="ph1">`LargeObject`</ph> instance.</source>
          <target state="translated">Dans la troisième section clée du code, la fonction de l’initialisation tardive est appelée pour créer le <ph id="ph1">`LargeObject`</ph> instance.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The function throws an exception the first time it's called:</source>
          <target state="translated">La fonction lève une exception, le premier appel :</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>With any other <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode&gt;</ph> setting, an unhandled exception in the initialization function would be cached.</source>
          <target state="translated">Avec n’importe quel autre <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode&gt;</ph> définition, une exception non gérée dans la fonction d’initialisation est mise en cache.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>However, <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph> suppresses exception caching.</source>
          <target state="translated">Toutefois, <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph> supprime la mise en cache de l’exception.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The output from the example demonstrates that a subsequent attempt to initialize the object succeeds.</source>
          <target state="translated">La sortie de l’exemple montre que la prochaine tentative d’initialisation de l’objet réussit.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The exception message usually appears after messages indicating that other threads have successfully initialized the object.</source>
          <target state="translated">Le message d’exception apparaît généralement après les messages indiquant que les autres threads ont initialisé avec succès de l’objet.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>This is because of the delay introduced by throwing and catching the exception.</source>
          <target state="translated">Il s’agit en raison du délai introduit par lever et intercepter l’exception.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>Because the constructor for the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance specified <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, all three threads are allowed to create <ph id="ph3">`LargeObject`</ph> instances.</source>
          <target state="translated">Étant donné que le constructeur de la <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance spécifiée <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, tous les trois threads sont autorisés à créer <ph id="ph3">`LargeObject`</ph> instances.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The example demonstrates this by displaying console messages in the constructor and in the finalizer of the <ph id="ph1">`LargeObject`</ph> class:</source>
          <target state="translated">L’exemple illustre cela en affichant les messages de la console dans le constructeur et le finaliseur de le <ph id="ph1">`LargeObject`</ph> classe :</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object ensures that only one instance is used by all threads (except the thread where the initialization function throws an exception).</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> objet garantit que seule une instance est utilisée par tous les threads (à l’exception du thread sur lequel la fonction d’initialisation lève une exception).</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The output from the example shows this.</source>
          <target state="translated">La sortie de l’exemple illustre ce point.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>For simplicity, this example uses a global instance of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>, and all the methods are <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">Pour plus de simplicité, cet exemple utilise une instance globale de <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> et toutes les méthodes sont <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>These are not requirements for the use of lazy initialization.</source>
          <target state="translated">Ce ne sont pas des exigences pour l’utilisation de l’initialisation tardive.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contient une valeur non valide.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source><ph id="ph1">&lt;paramref name="valueFactory" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="valueFactory" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="P:System.Lazy`1.IsValueCreated">
          <source>Gets a value that indicates whether a value has been created for this <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> instance.</source>
          <target state="translated">Obtient une valeur qui indique si une valeur a été créée pour cette instance <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if a value has been created for this <ph id="ph2">&lt;see cref="T:System.Lazy`1" /&gt;</ph> instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si une valeur a été créée pour cette instance <ph id="ph2">&lt;see cref="T:System.Lazy`1" /&gt;</ph> ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>When lazy initialization occurs for a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance, it may result in either a value being created or an exception being thrown.</source>
          <target state="translated">Lorsque l’initialisation tardive se produit pour un <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance, il peut entraîner une valeur en cours de création ou une exception est levée.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>If an exception is thrown, subsequent behavior of the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance depends on whether exception caching is in effect.</source>
          <target state="translated">Si une exception est levé, le comportement suivant de le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance dépend de la mise en cache de l’exception en vigueur.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>If the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance was created by using a constructor that does not specify an initialization function, then exception caching is not in effect.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance a été créée à l’aide d’un constructeur qui ne spécifie pas une fonction d’initialisation, puis la mise en cache de l’exception n’est pas en vigueur.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>A subsequent attempt to initialize the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> might succeed, and after successful initialization the <ph id="ph2">&lt;xref:System.Lazy%601.IsValueCreated%2A&gt;</ph> property returns <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Une tentative suivante d’initialiser le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> peut réussir et après une initialisation réussie du <ph id="ph2">&lt;xref:System.Lazy%601.IsValueCreated%2A&gt;</ph> propriété renvoie <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>If the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance was created with an initialization function (specified by the <ph id="ph2">`valueFactory`</ph> parameter of the <ph id="ph3">&lt;xref:System.Lazy%601&gt;</ph> constructor), then exception caching is controlled by the thread safety mode.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance a été créée avec une fonction d’initialisation (spécifié par le <ph id="ph2">`valueFactory`</ph> paramètre de la <ph id="ph3">&lt;xref:System.Lazy%601&gt;</ph> constructeur), puis la mise en cache de l’exception est contrôlé par le mode de sécurité des threads.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>If the mode is <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph>, there is no second chance to initialize the <ph id="ph3">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Si le mode est <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph>, il n’existe pas de deuxième chance pour initialiser le <ph id="ph3">&lt;xref:System.Lazy%601&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>If an exception occurs and is unhandled in the initialization function, that exception is cached and rethrown on subsequent accesses of the <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Si une exception se produit et n’est pas gérée dans la fonction d’initialisation, cette exception est mis en cache et levée à nouveau lors des accès de le <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>No value is created if an exception is thrown, so in such cases <ph id="ph1">&lt;xref:System.Lazy%601.IsValueCreated%2A&gt;</ph> returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Aucune valeur n’est créée si une exception est levée, dans ce cas <ph id="ph1">&lt;xref:System.Lazy%601.IsValueCreated%2A&gt;</ph> retourne <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>If the mode is <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, the first thread that succeeds in running the initialization function (or the default constructor) creates the value for the <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Si le mode est <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, le premier thread qui réussit l’exécution de la fonction d’initialisation (ou le constructeur par défaut) crée la valeur pour le <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>If the initialization function throws an exception on one thread, other threads can still try to initialize the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Si la fonction d’initialisation lève une exception sur un thread, les autres threads peuvent toujours essayer d’initialiser le <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>Until the value is created, the <ph id="ph1">&lt;xref:System.Lazy%601.IsValueCreated%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Jusqu'à ce que la valeur est créée, le <ph id="ph1">&lt;xref:System.Lazy%601.IsValueCreated%2A&gt;</ph> propriété renvoie <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.ToString">
          <source>Creates and returns a string representation of the <ph id="ph1">&lt;see cref="P:System.Lazy`1.Value" /&gt;</ph> property for this instance.</source>
          <target state="translated">Crée et retourne une représentation sous forme de chaîne de la propriété <ph id="ph1">&lt;see cref="P:System.Lazy`1.Value" /&gt;</ph> de cette instance.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.ToString">
          <source>The result of calling the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method on the <ph id="ph2">&lt;see cref="P:System.Lazy`1.Value" /&gt;</ph> property for this instance, if the value has been created (that is, if the <ph id="ph3">&lt;see cref="P:System.Lazy`1.IsValueCreated" /&gt;</ph> property returns <ph id="ph4">&lt;see langword="true" /&gt;</ph>).</source>
          <target state="translated">Résultat de l'appel à la méthode <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> sur la propriété <ph id="ph2">&lt;see cref="P:System.Lazy`1.Value" /&gt;</ph> pour cette instance, si la valeur a été créée (en d'autres termes, si la propriété <ph id="ph3">&lt;see cref="P:System.Lazy`1.IsValueCreated" /&gt;</ph> retourne <ph id="ph4">&lt;see langword="true" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.ToString">
          <source>Otherwise, a string indicating that the value has not been created.</source>
          <target state="translated">Sinon, chaîne indiquant que la valeur n’a pas été créée.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.ToString">
          <source>Calling this method does not cause initialization.</source>
          <target state="translated">Appel de cette méthode ne provoque pas l’initialisation.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.ToString">
          <source>The <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A?displayProperty=nameWithType&gt;</ph> property can be <ph id="ph2">`null`</ph> after lazy initialization if the factory method that was specified for the <ph id="ph3">`valueFactory`</ph> parameter of the <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph>, <ph id="ph5">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph>, or <ph id="ph6">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> constructor returns <ph id="ph7">`null`</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A?displayProperty=nameWithType&gt;</ph> propriété peut être <ph id="ph2">`null`</ph> après l’initialisation tardive si la méthode de fabrique qui a été spécifié pour le <ph id="ph3">`valueFactory`</ph> paramètre de la <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph>, <ph id="ph5">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph>, ou <ph id="ph6">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> constructeur retourne <ph id="ph7">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.ToString">
          <source>The <ph id="ph1">&lt;see cref="P:System.Lazy`1.Value" /&gt;</ph> property is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see cref="P:System.Lazy`1.Value" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="P:System.Lazy`1.Value">
          <source>Gets the lazily initialized value of the current <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> instance.</source>
          <target state="translated">Obtient la valeur initialisée tardivement de l'objet <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.Value">
          <source>The lazily initialized value of the current <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> instance.</source>
          <target state="translated">Valeur initialisée tardivement de l'instance <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.Value">
          <source>If the <ph id="ph1">&lt;xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType&gt;</ph> property is <ph id="ph2">`false`</ph>, accessing the <ph id="ph3">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property forces initialization.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType&gt;</ph> propriété <ph id="ph2">`false`</ph>, l’accès à la <ph id="ph3">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> propriété force l’initialisation.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.Value">
          <source>In addition to the exceptions that are listed, the <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property can throw any unhandled exception that is thrown by the factory method that was passed to the <ph id="ph2">`valueFactory`</ph> parameter of the <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph>, <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph>, or <ph id="ph5">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Outre les exceptions qui sont répertoriées, le <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> propriété peut lever toute exception non gérée est levée par la méthode de fabrique qui a été passée à la <ph id="ph2">`valueFactory`</ph> paramètre de la <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph>, <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="P:System.Lazy`1.Value">
          <source>The <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> instance is initialized to use the default constructor of the type that is being lazily initialized, and permissions to access the constructor are missing.</source>
          <target state="translated">L'instance <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> est initialisée pour utiliser le constructeur par défaut du type initialisé tardivement et les autorisations pour accéder au constructeur manquent.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="P:System.Lazy`1.Value">
          <source>The <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> instance is initialized to use the default constructor of the type that is being lazily initialized, and that type does not have a public, parameterless constructor.</source>
          <target state="translated">L'instance <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> est initialisée pour utiliser le constructeur par défaut du type initialisé tardivement et ce type n'a pas de constructeur public sans paramètre.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="P:System.Lazy`1.Value">
          <source>The initialization function tries to access <ph id="ph1">&lt;see cref="P:System.Lazy`1.Value" /&gt;</ph> on this instance.</source>
          <target state="translated">La fonction d'initialisation essaie d'accéder à <ph id="ph1">&lt;see cref="P:System.Lazy`1.Value" /&gt;</ph> sur cette instance.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>