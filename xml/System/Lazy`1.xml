<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9f2183fb6e4009548ee3cd3573c2bc4d71b628b0" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39745684" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <TypeSignature Language="F#" Value="type Lazy&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Type d’objet initialisé tardivement.</typeparam>
    <summary>Prend en charge l'initialisation tardive.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez l’initialisation tardive pour différer la création d’un objet volumineux ou gourmandes en ressources ou l’exécution d’une tâche gourmande en ressources, en particulier lorsqu’une telle création ou exécution ne peut pas se produire pendant la durée de vie du programme.  
  
 Pour préparer l’initialisation tardive, vous créez une instance de <xref:System.Lazy%601>. L’argument de type de la <xref:System.Lazy%601> objet que vous créez Spécifie le type de l’objet que vous souhaitez initialiser tardivement. Le constructeur qui vous permet de créer le <xref:System.Lazy%601> objet détermine les caractéristiques de l’initialisation. L’initialisation tardive se produit lors du premier accès à la propriété <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>.  
  
 Dans la plupart des cas, en choisissant un constructeur dépend de vos réponses aux deux questions :  
  
-   L’objet initialisé tardivement est accessible à partir de plusieurs threads ? Dans ce cas, le <xref:System.Lazy%601> objet peut créer le certificat sur n’importe quel thread. Vous pouvez utiliser un des constructeurs simples dont le comportement par défaut consiste à créer un thread-safe <xref:System.Lazy%601> de l’objet, afin que seule une instance de l’objet instancié de manière différée est créée, quel que soit le nombre de threads essayez d’y accéder. Pour créer un <xref:System.Lazy%601> objet qui n’est pas thread-safe, vous devez utiliser un constructeur qui vous permet de spécifier aucune sécurité des threads.  
  
    > [!CAUTION]
    >  Rendre le <xref:System.Lazy%601> objet thread-safe ne protège pas l’objet initialisé tardivement. Si plusieurs threads peuvent accéder à l’objet initialisé tardivement, vous devez apporter ses propriétés et méthodes sécurisés pour l’accès multithread.  
  
-   Initialisation tardive nécessite-t-il une grande quantité de code, ou l’objet initialisé tardivement ont un constructeur par défaut qui effectue tout ce dont vous avez besoin et ne lèvent des exceptions ? Si vous avez besoin d’écrire du code d’initialisation ou si les exceptions doivent être traitées, utilisez un des constructeurs qui prend une méthode de fabrique. Écrire votre code d’initialisation dans la méthode de fabrique.  
  
 Le tableau suivant montre le constructeur à choisir, en fonction de ces deux facteurs :  
  
|Objet est accessible par|Si aucun code d’initialisation n’est requis (constructeur par défaut), utilisez|Si le code d’initialisation est requis, utilisez|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|Plusieurs threads|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|Un thread|<xref:System.Lazy%601.%23ctor%28System.Boolean%29> avec `isThreadSafe` défini sur `false`.|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> avec `isThreadSafe` défini sur `false`.|  
  
 Vous pouvez utiliser une expression lambda pour spécifier la méthode de fabrique. Cela permet de conserver tout le code d’initialisation au même endroit. L’expression lambda capture le contexte, y compris les arguments que vous passez au constructeur de l’objet initialisé tardivement.  
  
 **La mise en cache de l’exception** lorsque vous utilisez des méthodes de fabrique, les exceptions sont mises en cache. Autrement dit, si la méthode de fabrique lève une heure de l’exception du premier un thread tente d’accéder à la <xref:System.Lazy%601.Value%2A> propriété de la <xref:System.Lazy%601> de l’objet, la même exception est levée à chaque tentative suivante. Cela garantit que chaque appel à la <xref:System.Lazy%601.Value%2A> propriété produit le même résultat et permet d’éviter des erreurs subtiles qui peuvent survenir si différents threads obtiennent des résultats différents. Le <xref:System.Lazy%601> est l’acronyme réel `T` qui sinon aurait été initialisé à un moment antérieur, généralement lors du démarrage. Il est généralement irrécupérable d’une défaillance à ce point antérieur. S’il existe un risque potentiel pour une erreur récupérable, nous vous recommandons de générer la logique de nouvelle tentative dans la routine d’initialisation (dans ce cas, la méthode de fabrique), comme vous le feriez si vous n’utilisiez l’initialisation tardive.  
  
 **Alternative au verrouillage** dans certaines situations, vous souhaiterez peut-être éviter la surcharge de la <xref:System.Lazy%601> comportement de verrouillage par défaut de l’objet. Dans de rares cas, il existe peut-être des interblocages. Dans ce cas, vous pouvez utiliser la <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> ou <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> constructeur et spécifiez <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Cela permet la <xref:System.Lazy%601> objet pour créer une copie de l’objet initialisé tardivement sur chacun de plusieurs threads si les threads appellent le <xref:System.Lazy%601.Value%2A> propriété simultanément. Le <xref:System.Lazy%601> objet garantit que tous les threads utilisent la même instance de l’objet initialisé tardivement et qu’il rejette les instances qui ne sont pas utilisés. Par conséquent, le coût de réduire la surcharge de verrouillage est que votre programme peut parfois créer et à éliminer des copies supplémentaires d’un objet coûteux. Dans la plupart des cas, il est peu probable. Les exemples pour le <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> et <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> constructeurs illustrent ce comportement.  
  
> [!IMPORTANT]
>  Lorsque vous spécifiez <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, les exceptions sont jamais mises en cache, même si vous spécifiez une méthode de fabrique.  
  
 **Constructeurs équivalents** en plus de permettre l’utilisation de <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, le <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> et <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> constructeurs peuvent dupliquer les fonctionnalités des autres constructeurs. Le tableau suivant montre les valeurs de paramètre qui produisent un comportement équivalent.  
  
|Pour créer un <xref:System.Lazy%601> qui est l’objet|Pour les constructeurs qui ont un `LazyThreadSafetyMode` `mode` paramètre, la valeur `mode` à|Pour les constructeurs qui ont une valeur booléenne `isThreadSafe` paramètre, la valeur `isThreadSafe` à|Pour les constructeurs sans paramètres de sécurité de thread|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|Entièrement les thread-safe ; utilise le verrouillage pour vous assurer que seul un thread initialise la valeur.|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|Tous les constructeurs de ce type sont entièrement thread-safe.|  
|Pas thread-safe.|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|Non applicable.|  
|Entièrement les thread-safe ; concurrence de threads pour initialiser la valeur.|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|Non applicable.|Non applicable.|  
  
 **Autres fonctionnalités** pour plus d’informations sur l’utilisation de <xref:System.Lazy%601> avec les champs thread-static, ou en tant que magasin de stockage pour les propriétés, consultez [l’initialisation tardive](~/docs/framework/performance/lazy-initialization.md).  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Lazy%601> classe pour fournir l’initialisation tardive avec accès à partir de plusieurs threads.  
  
> [!NOTE]
>  L’exemple utilise le <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> constructeur. Il illustre également l’utilisation de la <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> constructeur (spécifiant `true` pour `isThreadSafe`) et le <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> constructeur (spécifiant <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> pour `mode`). Pour basculer vers un autre constructeur, modifiez simplement les constructeurs sont commentées.  
>   
>  Pour obtenir un exemple qui illustre l’exception, la mise en cache à l’aide des constructeurs de mêmes, consultez le <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> constructeur.  
  
 L'exemple définit une classe `LargeObject` qui sera initialisée tardivement par l'un des nombreux threads. Les quatre principales sections de code illustrent la création de l’initialiseur, la méthode de fabrique, l’initialisation réelle et le constructeur de la `LargeObject` (classe), qui affiche un message lorsque l’objet est créé. Au début de la méthode `Main`, l'exemple crée l'initialiseur de type lazy thread-safe pour `LargeObject` :  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 La méthode de fabrique illustre la création de l’objet, avec un espace réservé pour une initialisation supplémentaire :  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 Notez que les sections de code tout d’abord deux peuvent être combinées à l’aide d’une fonction lambda, comme illustré ici :  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 L’exemple met en pause, pour indiquer qu’une période indéterminée peut-être s’écouler avant l’initialisation tardive se produit. Quand vous appuyez sur la **entrée** clé, l’exemple crée et démarre trois threads. Le `ThreadProc` méthode qui est utilisée par tous les appels de trois threads le <xref:System.Lazy%601.Value%2A> propriété. La première fois dans ce cas, le `LargeObject` instance est créée :  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 Le constructeur de la `LargeObject` (classe), qui inclut la dernière section clée du code, affiche un message et enregistre l’identité du thread lors de l’initialisation. La sortie du programme s’affiche à la fin de la liste de code complet.  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  Pour plus de simplicité, cet exemple utilise une instance globale de <xref:System.Lazy%601> et toutes les méthodes sont `static` (`Shared` en Visual Basic). Ce ne sont pas des exigences pour l’utilisation de l’initialisation tardive.  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Par défaut, tous les membres publics et protégés de la <see cref="T:System.Lazy`1" /> classe sont thread-safe et peuvent être utilisés simultanément par plusieurs threads. Ces garanties de sécurité des threads peuvent être éventuellement supprimées par instance, à l’aide des paramètres pour les constructeurs du type.</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Lazy`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Lazy`1" />. Quand l’initialisation tardive se produit, le constructeur par défaut du type cible est utilisé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une instance est créée avec ce constructeur peut-être être utilisée simultanément par plusieurs threads.  
  
 Le mode de sécurité des threads d’un <xref:System.Lazy%601> instance qui est initialisée avec ce constructeur est <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Le mode de sécurité des threads décrit le comportement lorsque plusieurs threads essaient d’initialiser le <xref:System.Lazy%601> instance.  
  
 Un <xref:System.Lazy%601> instance est créée avec ce constructeur ne met pas en cache les exceptions. Pour plus d'informations, consultez la classe <xref:System.Lazy%601> ou l'énumération <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> .  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de ce constructeur. Il illustre également l’utilisation de la <xref:System.Lazy%601.%23ctor%28System.Boolean%29> constructeur (spécifiant `true` pour `isThreadSafe`) et le <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> constructeur (spécifiant <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> pour `mode`). Pour basculer vers un autre constructeur, modifiez simplement les constructeurs sont commentées.  
  
 L'exemple définit une classe `LargeObject` qui sera initialisée tardivement par l'un des nombreux threads. Les deux principales lignes de code dans cet exemple sont la création de l’initialiseur et l’initialisation réelle. Au début de la méthode `Main`, l'exemple crée l'initialiseur de type lazy thread-safe pour `LargeObject` :  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 L’exemple crée et démarre trois threads se bloquent sur un <xref:System.Threading.ManualResetEvent> de l’objet, afin que l’exemple peut libérer les threads à la fois. Le `ThreadProc` méthode qui est utilisée par tous les appels de trois threads le <xref:System.Lazy%601.Value%2A> propriété à obtenir le `LargeObject` instance :  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 Le <xref:System.Lazy%601> classe fournit le verrouillage, afin que seul un thread est autorisé à créer le `LargeObject` instance. L’exemple montre que tous les autres threads obtiennent la même instance.  
  
> [!NOTE]
>  Pour plus de simplicité, cet exemple utilise une instance globale de <xref:System.Lazy%601> et toutes les méthodes sont `static` (`Shared` en Visual Basic). Ce ne sont pas des exigences pour l’utilisation de l’initialisation tardive.  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; isThreadSafe" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe">
          <see langword="true" /> pour que cette instance puisse être utilisée simultanément par plusieurs threads ; <see langword="false" /> pour que l'instance ne puisse être utilisée que par un thread à la fois.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Lazy`1" />. Quand une initialisation tardive se produit, le constructeur par défaut du type cible et le mode d’initialisation spécifié sont utilisés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le mode de sécurité des threads d’un <xref:System.Lazy%601> instance qui est initialisée avec ce constructeur est <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> si `isThreadSafe` est `true`; sinon, le mode est <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Le mode de sécurité des threads décrit le comportement lorsque plusieurs threads essaient d’initialiser le <xref:System.Lazy%601> instance. Pour spécifier le <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> mode, utilisez le <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> ou <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> constructeur.  
  
 Un <xref:System.Lazy%601> instance est créée avec ce constructeur ne met pas en cache les exceptions. Pour plus d'informations, consultez la classe <xref:System.Lazy%601> ou l'énumération <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> .  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de ce constructeur pour créer un initialiseur de type lazy qui n’est pas thread-safe, pour les scénarios où tous les accès à l’objet initialisé tardivement se produit sur le même thread. Il illustre également l’utilisation de la <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> constructeur (spécifiant <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> pour `mode`. Pour basculer vers un autre constructeur, modifiez simplement le constructeur est commenté.  
  
> [!NOTE]
>  Pour le code qui montre comment utiliser ce constructeur dans les scénarios multithreads (spécifiant `true` pour `isThreadSafe`), consultez l’exemple de la <xref:System.Lazy%601.%23ctor> constructeur.  
  
 L’exemple définit un `LargeObject` classe sera initialisée tardivement. Dans le `Main` (méthode), l’exemple crée un <xref:System.Lazy%601> instance, puis s’arrête. Quand vous appuyez sur la **entrée** clé, l’exemple accède à la <xref:System.Lazy%601.Value%2A> propriété de la <xref:System.Lazy%601> instance, ce qui provoque l’initialisation se produise. Le constructeur de la `LargeObject` classe affiche un message de console.  
  
> [!NOTE]
>  Pour plus de simplicité, cet exemple utilise une instance globale de <xref:System.Lazy%601> et toutes les méthodes sont `static` (`Shared` en Visual Basic). Ce ne sont pas des exigences pour l’utilisation de l’initialisation tardive.  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; valueFactory" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Délégué qui est appelé pour produire la valeur initialisée tardivement si nécessaire.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Lazy`1" />. Quand l’initialisation tardive se produit, la fonction d’initialisation spécifiée est utilisée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une instance est créée avec ce constructeur peut-être être utilisée simultanément par plusieurs threads.  
  
 Le mode de sécurité des threads d’un <xref:System.Lazy%601> instance qui est initialisée avec ce constructeur est <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Le mode de sécurité des threads décrit le comportement lorsque plusieurs threads essaient d’initialiser le <xref:System.Lazy%601> instance.  
  
 Les exceptions levées par `valueFactory` sont mis en cache. Pour plus d'informations, consultez la classe <xref:System.Lazy%601> ou l'énumération <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> .  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de ce constructeur pour fournir l’initialisation tardive avec la mise en cache de l’exception. Il illustre également l’utilisation de la <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> constructeur (spécifiant `true` pour `isThreadSafe`) et le <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> constructeur (spécifiant <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> pour `mode`). Pour basculer vers un autre constructeur, modifiez simplement les constructeurs sont commentées.  
  
 L'exemple définit une classe `LargeObject` qui sera initialisée tardivement par l'un des nombreux threads. Les trois principales sections de code illustrent la création de l’initialiseur, l’initialisation réelle et le constructeur de la `LargeObject` (classe), qui montre la mise en cache de l’exception. Au début de la méthode `Main`, l'exemple crée l'initialiseur de type lazy thread-safe pour `LargeObject` :  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 L’exemple crée et démarre trois threads. Le `ThreadProc` méthode qui est utilisée par tous les appels de trois threads le <xref:System.Lazy%601.Value%2A> propriété à obtenir le `LargeObject` instance :  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 Dans le constructeur de la `LargeObject` (classe), la troisième section clée du code lève une exception de la première fois un `LargeObject` instance est créée, mais par la suite permet la création d’instance se produise :  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 Lorsque l’exemple est exécuté, le premier thread qui tente de créer une instance de `LargeObject` échoue et l’exception est interceptée. Vous pouvez attendre que le thread suivant créerait avec succès une instance, mais le <xref:System.Lazy%601> objet a mis en cache de l’exception. Pour cette raison, les trois threads lèvent l’exception.  
  
> [!NOTE]
>  Pour plus de simplicité, cet exemple utilise une instance globale de <xref:System.Lazy%601> et toutes les méthodes sont `static` (`Shared` en Visual Basic). Ce ne sont pas des exigences pour l’utilisation de l’initialisation tardive.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; mode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="mode">Une des valeurs d’énumération qui spécifie le mode de cohérence de thread.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Lazy`1" /> qui utilise le constructeur par défaut de <paramref name="T" /> et le mode de cohérence de thread spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le mode de sécurité des threads d’un <xref:System.Lazy%601> instance décrit le comportement lorsque plusieurs threads essaient d’initialiser le <xref:System.Lazy%601> instance.  
  
 Un <xref:System.Lazy%601> instance est créée avec ce constructeur ne met pas en cache les exceptions. Pour plus d'informations, consultez la classe <xref:System.Lazy%601> ou l'énumération <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> .  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de ce constructeur pour créer un initialiseur de type lazy qui permet à plusieurs threads à concurrence pour créer un objet de manière différée. Plusieurs threads peuvent réussir à créer des instances, mais tous les threads utilisent l’instance qui a été créé en premier.  
  
> [!NOTE]
>  Pour obtenir un exemple qui montre comment utiliser ce constructeur dans les scénarios mono-thread (en spécifiant <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> pour `mode`), consultez le <xref:System.Lazy%601.%23ctor%28System.Boolean%29> constructeur. Pour obtenir un exemple qui montre comment utiliser ce constructeur pour permettre un verrouillage au lieu de conditions de concurrence dans les scénarios multithreads (spécifiant <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> pour `mode`), consultez le <xref:System.Lazy%601.%23ctor> constructeur.  
  
 L’exemple définit un `LargeObject` classe sera initialisée tardivement par une de plusieurs threads. Les trois principales sections de code illustrent la création de l’initialiseur, l’initialisation réelle et que le constructeur et le finaliseur de la `LargeObject` classe. Au début de la `Main` (méthode), l’exemple crée le <xref:System.Lazy%601> objet qui effectue l’initialisation tardive de la `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 L’exemple crée et démarre trois threads se bloquent sur un <xref:System.Threading.ManualResetEvent> de l’objet, afin que l’exemple peut libérer les threads à la fois. Dans le `ThreadProc` méthode qui est utilisée par les trois threads, en appelant le <xref:System.Lazy%601.Value%2A> propriété crée les `LargeObject` instance :  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 Étant donné que le constructeur de la <xref:System.Lazy%601> instance spécifiée <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, tous les trois threads sont autorisés à créer `LargeObject` instances. L’exemple illustre cela en affichant des messages de la console dans le constructeur et le finaliseur de la `LargeObject` classe :  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 Toutefois, le <xref:System.Lazy%601> objet garantit que seule une instance est utilisée par tous les threads. La sortie de l’exemple montre que les trois threads utilisent la même instance et indique que les deux autres instances peuvent être récupérées par le garbage collection.  
  
> [!NOTE]
>  Pour plus de simplicité, cet exemple utilise une instance globale de <xref:System.Lazy%601> et toutes les méthodes sont `static` (`Shared` en Visual Basic). Ce ne sont pas des exigences pour l’utilisation de l’initialisation tardive.  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contient une valeur non valide.</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : 'T -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, isThreadSafe)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Délégué qui est appelé pour produire la valeur initialisée tardivement si nécessaire.</param>
        <param name="isThreadSafe">
          <see langword="true" /> pour que cette instance puisse être utilisée simultanément par plusieurs threads ; <see langword="false" /> pour que cette instance ne puisse être utilisée que par un thread à la fois.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Lazy`1" />. Quand l’initialisation tardive se produit, la fonction d’initialisation spécifiée et le mode d’initialisation sont utilisés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le mode de sécurité des threads d’un <xref:System.Lazy%601> instance qui est initialisée avec ce constructeur est <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> si `isThreadSafe` est `true`; sinon, le mode est <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Le mode de sécurité des threads décrit le comportement lorsque plusieurs threads essaient d’initialiser le <xref:System.Lazy%601> instance.  
  
 Pour spécifier le <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> mode, utilisez le <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> ou <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> constructeur.  
  
 Les exceptions levées par `valueFactory` sont mis en cache. Pour plus d'informations, consultez la classe <xref:System.Lazy%601> ou l'énumération <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> .  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de ce constructeur pour fournir l’initialisation tardive avec l’exception de la mise en cache dans un scénario avec un seul thread. Il illustre également l’utilisation de la <xref:System.Lazy%601.%23ctor%2A> constructeur (spécifiant <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> pour `mode`). Pour basculer vers ce constructeur, modifiez simplement le constructeur est commenté.  
  
> [!NOTE]
>  Pour le code qui montre comment utiliser ce constructeur dans les scénarios multithreads (spécifiant `true` pour `isThreadSafe`), consultez l’exemple de la <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> constructeur.  
  
 L'exemple définit une classe `LargeObject` qui sera initialisée tardivement par l'un des nombreux threads. Les trois principales sections de code illustrent la création de l’initialiseur, l’initialisation réelle et le constructeur de la `LargeObject` (classe), qui montre la mise en cache de l’exception. Au début de la méthode `Main`, l'exemple crée l'initialiseur de type lazy thread-safe pour `LargeObject` :  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 Dans l’appel au constructeur, le `isThreadSafe` paramètre est `false`, la <xref:System.Lazy%601> n’est pas thread-safe. Comme il n’est pas thread-safe, l’exemple appelle la <xref:System.Lazy%601.Value%2A> propriété trois fois sur le même thread :  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 Dans le constructeur de la `LargeObject` (classe), la troisième section clée du code lève une exception de la première fois un `LargeObject` instance est créée, mais par la suite permet la création d’instance se produise :  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 Lorsque l’exemple est exécuté, la première tentative pour créer une instance de `LargeObject` échoue et l’exception est interceptée. Vous pouvez attendre que la tentative suivante réussira, mais le <xref:System.Lazy%601> objet a mis en cache de l’exception. Pour cette raison, les trois tentatives lèvent l’exception.  
  
> [!NOTE]
>  Pour plus de simplicité, cet exemple utilise une instance globale de <xref:System.Lazy%601> et toutes les méthodes sont `static` (`Shared` en Visual Basic). Ce ne sont pas des exigences pour l’utilisation de l’initialisation tardive.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Délégué qui est appelé pour produire la valeur initialisée tardivement si nécessaire.</param>
        <param name="mode">Une des valeurs d’énumération qui spécifie le mode de cohérence de thread.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Lazy`1" /> qui utilise la fonction d'initialisation et le mode de cohérence de thread spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le mode de sécurité des threads d’un <xref:System.Lazy%601> instance décrit le comportement lorsque plusieurs threads essaient d’initialiser le <xref:System.Lazy%601> instance.  
  
 Les exceptions levées par `valueFactory` sont mis en cache, sauf si `mode` est <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Pour plus d'informations, consultez la classe <xref:System.Lazy%601> ou l'énumération <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> .  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de ce constructeur pour créer un initialiseur de type lazy qui permet à plusieurs threads à concurrence pour créer un objet de manière différée. Plusieurs threads peuvent réussir à créer des instances, mais tous les threads utilisent l’instance qui a été créé en premier. En outre, l’exemple montre que les exceptions ne sont jamais être mis en cache lorsque vous spécifiez <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, même si l’initialisation est effectuée par une fonction au lieu de par le constructeur par défaut du type créé de manière différée.  
  
> [!NOTE]
>  Pour obtenir un exemple qui montre comment utiliser ce constructeur dans les scénarios mono-thread (en spécifiant <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> pour `mode`), consultez le <xref:System.Lazy%601.%23ctor%28System.Boolean%29> constructeur. Pour obtenir un exemple qui montre comment utiliser ce constructeur pour permettre un verrouillage au lieu de conditions de concurrence dans les scénarios multithreads (spécifiant <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> pour `mode`), consultez le <xref:System.Lazy%601.%23ctor> constructeur.  
  
 L’exemple définit un `LargeObject` classe sera initialisée tardivement par une de plusieurs threads. Les quatre principales sections de code illustrent la création de l’initialiseur, l’initialisation réelle, la fonction d’initialisation et le constructeur et le finaliseur de la `LargeObject` classe. Au début de la `Main` (méthode), l’exemple crée le <xref:System.Lazy%601> objet qui effectue l’initialisation tardive de la `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 L’initialiseur de type lazy utilise une fonction pour effectuer l’initialisation. Dans ce cas, une fonction est nécessaire, car il n’existe aucun constructeur par défaut pour le `LargeObject` classe.  
  
 L’exemple crée et démarre trois threads se bloquent sur un <xref:System.Threading.ManualResetEvent> de l’objet, afin que l’exemple peut libérer les threads à la fois. Dans le `ThreadProc` méthode qui est utilisée par les trois threads, en appelant le <xref:System.Lazy%601.Value%2A> propriété crée les `LargeObject` instance :  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 Dans la troisième section clée du code, la fonction de l’initialisation tardive est appelée pour créer le `LargeObject` instance. La fonction lève une exception, le premier appel :  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 Avec n’importe quel autre <xref:System.Threading.LazyThreadSafetyMode> définition, une exception non gérée dans la fonction d’initialisation est mise en cache. Toutefois, <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> supprime la mise en cache de l’exception. La sortie de l’exemple montre qu’une nouvelle tentative pour initialiser l’objet réussit.  
  
> [!NOTE]
>  Le message d’exception s’affiche généralement après les messages indiquant que les autres threads ont initialisé avec succès de l’objet. Il s’agit en raison de la latence introduite par la levée et l’interception de l’exception.  
  
 Étant donné que le constructeur de la <xref:System.Lazy%601> instance spécifiée <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, tous les trois threads sont autorisés à créer `LargeObject` instances. L’exemple illustre cela en affichant des messages de la console dans le constructeur et le finaliseur de la `LargeObject` classe :  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 Le <xref:System.Lazy%601> objet garantit que seule une instance est utilisée par tous les threads (, sauf celui où la fonction d’initialisation lève une exception). La sortie de l’exemple illustre ce point.  
  
> [!NOTE]
>  Pour plus de simplicité, cet exemple utilise une instance globale de <xref:System.Lazy%601> et toutes les méthodes sont `static` (`Shared` en Visual Basic). Ce ne sont pas des exigences pour l’utilisation de l’initialisation tardive.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contient une valeur non valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueCreated : bool" Usage="System.Lazy&lt;'T&gt;.IsValueCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si une valeur a été créée pour cette instance <see cref="T:System.Lazy`1" />.</summary>
        <value>
          <see langword="true" /> si une valeur a été créée pour cette instance <see cref="T:System.Lazy`1" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’initialisation tardive se produit pour un <xref:System.Lazy%601> instance, cela peut entraîner une valeur en cours de création ou une exception est levée. Si une exception est levé, le comportement suivant de la <xref:System.Lazy%601> instance varie selon que la mise en cache de l’exception est en vigueur. Si le <xref:System.Lazy%601> instance a été créée à l’aide d’un constructeur qui ne spécifie pas une fonction d’initialisation, puis la mise en cache de l’exception n’est pas en vigueur. Une nouvelle tentative pour initialiser le <xref:System.Lazy%601> peut réussir et après l’initialisation réussie du <xref:System.Lazy%601.IsValueCreated%2A> retourne de la propriété `true`. Si le <xref:System.Lazy%601> instance a été créée avec une fonction d’initialisation (spécifié par le `valueFactory` paramètre de la <xref:System.Lazy%601> constructeur), puis la mise en cache de l’exception est contrôlée par le mode de cohérence de thread.  
  
-   Si le mode est <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> ou <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, il n’existe pas de deuxième chance pour initialiser le <xref:System.Lazy%601> instance. Si une exception se produit et n’est pas gérée dans la fonction d’initialisation, cette exception est mis en cache et levée à nouveau lors des accès de le <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> propriété. Aucune valeur n’est créée si une exception est levée, donc dans ce cas <xref:System.Lazy%601.IsValueCreated%2A> retourne `false`.  
  
-   Si le mode est <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, le premier thread qui réussit l’exécution de la fonction d’initialisation (ou le constructeur par défaut) crée la valeur pour le <xref:System.Lazy%601> instance. Si la fonction d’initialisation lève une exception sur un thread, les autres threads peuvent toujours essayer d’initialiser le <xref:System.Lazy%601> instance. Jusqu'à ce que la valeur est créée, le <xref:System.Lazy%601.IsValueCreated%2A> retourne de la propriété `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="lazy.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée et retourne une représentation sous forme de chaîne de la propriété <see cref="P:System.Lazy`1.Value" /> de cette instance.</summary>
        <returns>Résultat de l'appel à la méthode <see cref="M:System.Object.ToString" /> sur la propriété <see cref="P:System.Lazy`1.Value" /> pour cette instance, si la valeur a été créée (en d'autres termes, si la propriété <see cref="P:System.Lazy`1.IsValueCreated" /> retourne <see langword="true" />). Sinon, chaîne indiquant que la valeur n’a pas été créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette méthode ne provoque pas l’initialisation.  
  
 Le <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> propriété peut être `null` après l’initialisation différée si la méthode de fabrique qui a été spécifié pour le `valueFactory` paramètre de la <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, ou <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> constructeur retourne `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La propriété <see cref="P:System.Lazy`1.Value" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : 'T" Usage="System.Lazy&lt;'T&gt;.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur initialisée tardivement de l'objet <see cref="T:System.Lazy`1" /> en cours.</summary>
        <value>Valeur initialisée tardivement de l'instance <see cref="T:System.Lazy`1" /> en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType> propriété est `false`, l’accès à la <xref:System.Lazy%601.Value%2A> propriété force l’initialisation.  
  
 Outre les exceptions qui sont répertoriées, le <xref:System.Lazy%601.Value%2A> propriété peut lever toute exception non gérée levée par la méthode de fabrique qui a été passée à la `valueFactory` paramètre de la <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, ou <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">L'instance <see cref="T:System.Lazy`1" /> est initialisée pour utiliser le constructeur par défaut du type initialisé tardivement et les autorisations pour accéder au constructeur manquent.</exception>
        <exception cref="T:System.MissingMemberException">L'instance <see cref="T:System.Lazy`1" /> est initialisée pour utiliser le constructeur par défaut du type initialisé tardivement et ce type n'a pas de constructeur public sans paramètre.</exception>
        <exception cref="T:System.InvalidOperationException">La fonction d'initialisation essaie d'accéder à <see cref="P:System.Lazy`1.Value" /> sur cette instance.</exception>
      </Docs>
    </Member>
  </Members>
</Type>