<Type Name="GC" FullName="System.GC">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="df6c8515f979bac3eb8e948b4bb6025a6577640e" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37481424" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="00615-101">Controls the system garbage collector, a service that automatically reclaims unused memory.</span>
      <span class="sxs-lookup">
        <span data-stu-id="00615-101">Controls the system garbage collector, a service that automatically reclaims unused memory.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-102">Le garbage collector est un composant du common language runtime qui contrôle l’allocation et la libération de mémoire managée.</span><span class="sxs-lookup"><span data-stu-id="00615-102">The garbage collector is a common language runtime component that controls the allocation and release of managed memory.</span></span> <span data-ttu-id="00615-103">Les méthodes dans cette classe influencent lorsque le garbage collection est effectué sur un objet lorsque les ressources allouées par un objet sont libérées.</span><span class="sxs-lookup"><span data-stu-id="00615-103">The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.</span></span> <span data-ttu-id="00615-104">Propriétés de cette classe fournissent des informations sur la quantité totale de mémoire disponible dans le système et la catégorie d’âge ou la génération, de mémoire allouée à un objet.</span><span class="sxs-lookup"><span data-stu-id="00615-104">Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</span></span>  
  
 <span data-ttu-id="00615-105">Le garbage collector effectue le suivi et libère des objets alloués dans la mémoire managée.</span><span class="sxs-lookup"><span data-stu-id="00615-105">The garbage collector tracks and reclaims objects allocated in managed memory.</span></span> <span data-ttu-id="00615-106">Périodiquement, le garbage collector exécute le garbage collection pour libérer de la mémoire allouée aux objets pour lesquels il n’existe pas de références valides.</span><span class="sxs-lookup"><span data-stu-id="00615-106">Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.</span></span> <span data-ttu-id="00615-107">Le garbage collection se produit automatiquement quand une demande de mémoire ne peut pas être satisfaite à l’aide de la mémoire disponible.</span><span class="sxs-lookup"><span data-stu-id="00615-107">Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.</span></span> <span data-ttu-id="00615-108">Une application peut également forcer un garbage collection à l’aide du <xref:System.GC.Collect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-108">Alternatively, an application can force garbage collection using the <xref:System.GC.Collect%2A> method.</span></span>  
  
 <span data-ttu-id="00615-109">Le garbage collection se compose des étapes suivantes :</span><span class="sxs-lookup"><span data-stu-id="00615-109">Garbage collection consists of the following steps:</span></span>  
  
1.  <span data-ttu-id="00615-110">Le garbage collector recherche les objets managés qui sont référencés dans le code managé.</span><span class="sxs-lookup"><span data-stu-id="00615-110">The garbage collector searches for managed objects that are referenced in managed code.</span></span>  
  
2.  <span data-ttu-id="00615-111">Le garbage collector tente de finaliser des objets qui ne sont pas référencés.</span><span class="sxs-lookup"><span data-stu-id="00615-111">The garbage collector tries to finalize objects that are not referenced.</span></span>  
  
3.  <span data-ttu-id="00615-112">Le garbage collector libère des objets qui ne sont pas référencés et récupère leur mémoire.</span><span class="sxs-lookup"><span data-stu-id="00615-112">The garbage collector frees objects that are not referenced and reclaims their memory.</span></span>  
  
 <span data-ttu-id="00615-113">Cette rubrique comporte les sections suivantes :</span><span class="sxs-lookup"><span data-stu-id="00615-113">This topic includes the following sections:</span></span>  
  
 <span data-ttu-id="00615-114">[Le garbage collector et les ressources non managées](#unmanaged) </span><span class="sxs-lookup"><span data-stu-id="00615-114">[The garbage collector and unmanaged resources](#unmanaged) </span></span>  
 <span data-ttu-id="00615-115">[Vieillissement des objets et des générations](#generations) </span><span class="sxs-lookup"><span data-stu-id="00615-115">[Object aging and generations](#generations) </span></span>  
 [<span data-ttu-id="00615-116">Interdire le garbage collection</span><span class="sxs-lookup"><span data-stu-id="00615-116">Disallowing garbage collection</span></span>](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a><span data-ttu-id="00615-117">Le garbage collector et les ressources non managées</span><span class="sxs-lookup"><span data-stu-id="00615-117">The garbage collector and unmanaged resources</span></span>  
 <span data-ttu-id="00615-118">Au cours d’une collection, le garbage collector ne libère pas un objet s’il trouve une ou plusieurs références à l’objet dans le code managé.</span><span class="sxs-lookup"><span data-stu-id="00615-118">During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.</span></span> <span data-ttu-id="00615-119">Toutefois, le garbage collector ne reconnaît pas les références à un objet à partir de code non managé et peut libérer des objets qui sont utilisés exclusivement en code non managé, sauf si explicitement empêché.</span><span class="sxs-lookup"><span data-stu-id="00615-119">However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.</span></span> <span data-ttu-id="00615-120">Le <xref:System.GC.KeepAlive%2A> méthode fournit un mécanisme qui empêche le garbage collector de collecter des objets qui sont en cours d’utilisation dans le code non managé.</span><span class="sxs-lookup"><span data-stu-id="00615-120">The <xref:System.GC.KeepAlive%2A> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</span></span>  
  
 <span data-ttu-id="00615-121">À l’exception des allocations de mémoire managée, les implémentations du garbage collector ne conservent pas les informations sur les ressources détenues par un objet, telles que les descripteurs de fichiers ou des connexions de base de données.</span><span class="sxs-lookup"><span data-stu-id="00615-121">Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.</span></span> <span data-ttu-id="00615-122">Lorsqu’un type utilise des ressources non managées doivent être libérées avant que les instances du type sont récupérés, le type peut implémenter un finaliseur.</span><span class="sxs-lookup"><span data-stu-id="00615-122">When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</span></span>  
  
 <span data-ttu-id="00615-123">Dans la plupart des cas, les finaliseurs sont implémentés en substituant la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> méthode ; Toutefois, les types écrits en c# ou C++ implémentent des destructeurs que les compilateurs transforment en une substitution de <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="00615-123">In most cases, finalizers are implemented by overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="00615-124">Dans la plupart des cas, si un objet a un finaliseur, le garbage collector l’appelle avant de libérer l’objet.</span><span class="sxs-lookup"><span data-stu-id="00615-124">In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.</span></span> <span data-ttu-id="00615-125">Toutefois, le garbage collector n’est pas nécessaire d’appeler les finaliseurs dans toutes les situations ; par exemple, le <xref:System.GC.SuppressFinalize%2A> méthode empêche explicitement un finaliseur d’objet d’être appelée.</span><span class="sxs-lookup"><span data-stu-id="00615-125">However, the garbage collector is not required to call finalizers in all situations; for example, the <xref:System.GC.SuppressFinalize%2A> method explicitly prevents an object's finalizer from being called.</span></span> <span data-ttu-id="00615-126">En outre, le garbage collector n’est pas nécessaire d’utiliser un thread spécifique pour finaliser les objets, ou garantit l’ordre dans lequel les finaliseurs sont appelés pour les objets qui se référencent mutuellement, mais sont disponibles pour le garbage collection.</span><span class="sxs-lookup"><span data-stu-id="00615-126">Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</span></span>  
  
 <span data-ttu-id="00615-127">Dans les scénarios où les ressources doivent être libérées à un moment donné, les classes peuvent implémenter la <xref:System.IDisposable> interface, qui contient le <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> méthode qui effectue les tâches de gestion et de nettoyage des ressources.</span><span class="sxs-lookup"><span data-stu-id="00615-127">In scenarios where resources must be released at a specific time, classes can implement the <xref:System.IDisposable> interface, which contains the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method that performs resource management and cleanup tasks.</span></span> <span data-ttu-id="00615-128">Classes qui implémentent <xref:System.IDisposable.Dispose%2A> doit spécifier, dans le cadre de leur contrat, si et quand les consommateurs de classe appellent la méthode pour nettoyer l’objet.</span><span class="sxs-lookup"><span data-stu-id="00615-128">Classes that implement <xref:System.IDisposable.Dispose%2A> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.</span></span> <span data-ttu-id="00615-129">Le garbage collector ne pas, par défaut, appelez le <xref:System.IDisposable.Dispose%2A> (méthode) ; Toutefois, les implémentations de la <xref:System.IDisposable.Dispose%2A> méthode peut appeler des méthodes dans la <xref:System.GC> classe pour personnaliser le comportement de la finalisation du garbage collector.</span><span class="sxs-lookup"><span data-stu-id="00615-129">The garbage collector does not, by default, call the <xref:System.IDisposable.Dispose%2A> method; however, implementations of the <xref:System.IDisposable.Dispose%2A> method can call methods in the <xref:System.GC> class to customize the finalization behavior of the garbage collector.</span></span>  
  
 <span data-ttu-id="00615-130">Pour plus d’informations sur la finalisation de l’objet et le modèle de suppression, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="00615-130">For more information on object finalization and the dispose pattern, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a><span data-ttu-id="00615-131">Vieillissement des objets et des générations</span><span class="sxs-lookup"><span data-stu-id="00615-131">Object aging and generations</span></span>  
 <span data-ttu-id="00615-132">Le garbage collector dans le common language runtime prend en charge le vieillissement des objets à l’aide de générations.</span><span class="sxs-lookup"><span data-stu-id="00615-132">The garbage collector in the common language runtime supports object aging using generations.</span></span> <span data-ttu-id="00615-133">Une génération est une unité de mesure de l’âge relatif des objets en mémoire.</span><span class="sxs-lookup"><span data-stu-id="00615-133">A generation is a unit of measure of the relative age of objects in memory.</span></span> <span data-ttu-id="00615-134">Le numéro de génération, ou l’âge, d’un objet indique la génération à laquelle appartient un objet.</span><span class="sxs-lookup"><span data-stu-id="00615-134">The generation number, or age, of an object indicates the generation to which an object belongs.</span></span> <span data-ttu-id="00615-135">Objets créés plus récemment font partie des nouvelles générations et possèdent des numéros de génération plus faibles que le cycle des objets créés précédemment dans la vie de l’application.</span><span class="sxs-lookup"><span data-stu-id="00615-135">Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.</span></span> <span data-ttu-id="00615-136">Les objets dans la génération la plus récente sont dans la génération 0.</span><span class="sxs-lookup"><span data-stu-id="00615-136">Objects in the most recent generation are in generation 0.</span></span> <span data-ttu-id="00615-137">Cette implémentation du garbage collector prend en charge trois générations d’objets, les générations 0, 1 et 2.</span><span class="sxs-lookup"><span data-stu-id="00615-137">This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.</span></span> <span data-ttu-id="00615-138">Vous pouvez récupérer la valeur de la <xref:System.GC.MaxGeneration%2A> propriété afin de déterminer le nombre maximal de générations prises en charge par le système.</span><span class="sxs-lookup"><span data-stu-id="00615-138">You can retrieve the value of the <xref:System.GC.MaxGeneration%2A> property to determine the maximum generation number supported by the system.</span></span>  
  
 <span data-ttu-id="00615-139">Vieillissement des objets permet aux applications de nettoyage de la cible à un ensemble spécifique de générations au lieu de demander au garbage collector évaluer toutes les générations.</span><span class="sxs-lookup"><span data-stu-id="00615-139">Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</span></span> <span data-ttu-id="00615-140">Les surcharges de la <xref:System.GC.Collect%2A> méthode qui incluent un `generation` paramètre permettent de spécifier la génération la plus ancienne pour être nettoyées.</span><span class="sxs-lookup"><span data-stu-id="00615-140">Overloads of the <xref:System.GC.Collect%2A> method that include a `generation` parameter allow you to specify the oldest generation to be garbage collected.</span></span>  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a><span data-ttu-id="00615-141">Interdire le garbage collection</span><span class="sxs-lookup"><span data-stu-id="00615-141">Disallowing garbage collection</span></span>  
 <span data-ttu-id="00615-142">En commençant par le [!INCLUDE[net_v46](~/includes/net-v46-md.md)], le garbage collector prend en charge un mode sans région GC latence qui peut être utilisé pendant l’exécution de chemins critiques dans laquelle les garbage collection peut nuire aux performances de l’application.</span><span class="sxs-lookup"><span data-stu-id="00615-142">Starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.</span></span> <span data-ttu-id="00615-143">Le mode sans région GC latence nécessite que vous spécifiez une quantité de mémoire pouvant être allouée sans interférence du garbage collector.</span><span class="sxs-lookup"><span data-stu-id="00615-143">The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.</span></span> <span data-ttu-id="00615-144">Si le runtime peut allouer cette mémoire, le runtime ne sera pas effectuer un garbage collection pendant l’exécution de code dans le chemin critique.</span><span class="sxs-lookup"><span data-stu-id="00615-144">If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.</span></span>  
  
 <span data-ttu-id="00615-145">Vous définissez le début du chemin critique sans région GC en appelant une des surcharges de la <xref:System.GC.TryStartNoGCRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="00615-145">You define the beginning of the critical path of the no GC region by calling one of the overloads of the <xref:System.GC.TryStartNoGCRegion%2A>.</span></span> <span data-ttu-id="00615-146">Vous spécifiez la fin de son chemin d’accès critique en appelant le <xref:System.GC.EndNoGCRegion%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-146">You specify the end of its critical path by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 <span data-ttu-id="00615-147">Vous ne pouvez pas imbriquer des appels à la <xref:System.GC.TryStartNoGCRegion%2A> (méthode) et vous devez appeler uniquement la <xref:System.GC.EndNoGCRegion%2A> méthode si le runtime est actuellement en mode de latence sans région GC.</span><span class="sxs-lookup"><span data-stu-id="00615-147">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="00615-148">En d’autres termes, vous ne devez pas appeler <xref:System.GC.TryStartNoGCRegion%2A> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <xref:System.GC.EndNoGCRegion%2A> réussisse parce que le premier appel à <xref:System.GC.TryStartNoGCRegion%2A> a réussi.</span><span class="sxs-lookup"><span data-stu-id="00615-148">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00615-149">L’exemple suivant utilise plusieurs méthodes GC pour obtenir la génération et les informations de mémoire sur un bloc d’objets inutilisés et l’imprimer à la console.</span><span class="sxs-lookup"><span data-stu-id="00615-149">The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console.</span></span> <span data-ttu-id="00615-150">Les objets inutilisés sont ensuite recueillies et les totaux de mémoire sont affichées.</span><span class="sxs-lookup"><span data-stu-id="00615-150">The unused objects are then collected, and the resulting memory totals are displayed.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">
          <span data-ttu-id="00615-151">The incremental amount of unmanaged memory that has been allocated.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-151">The incremental amount of unmanaged memory that has been allocated.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-152">Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-152">Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-153">Détermination des cas planifier le garbage collection, le runtime prend en compte la quantité de mémoire managé est alloué.</span><span class="sxs-lookup"><span data-stu-id="00615-153">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="00615-154">Si un petit objet managé alloue une grande quantité de mémoire non managée, le runtime prend en compte uniquement la mémoire managée et par conséquent sous-estime l’urgence de la planification du garbage collection.</span><span class="sxs-lookup"><span data-stu-id="00615-154">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="00615-155">Le <xref:System.GC.AddMemoryPressure%2A> méthode informe l’exécution de cette sollicitation supplémentaire sur la mémoire système.</span><span class="sxs-lookup"><span data-stu-id="00615-155">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory.</span></span>  
  
 <span data-ttu-id="00615-156">Dans le modèle d’utilisation la plus simple, un objet managé alloue la mémoire non managée dans le constructeur et la libère dans la `Dispose` ou `Finalize` (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-156">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="00615-157">Appelez le <xref:System.GC.AddMemoryPressure%2A> méthode après avoir alloué la mémoire non managée et appelez le <xref:System.GC.RemoveMemoryPressure%2A> méthode après l’avoir libéré.</span><span class="sxs-lookup"><span data-stu-id="00615-157">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="00615-158">Dans les scénarios plus complexes, où l’allocation de mémoire non managée change substantiellement pendant la durée de vie de l’objet managé, vous pouvez appeler la <xref:System.GC.AddMemoryPressure%2A> et <xref:System.GC.RemoveMemoryPressure%2A> méthodes permettant de communiquer ces modifications incrémentielles à l’exécution.</span><span class="sxs-lookup"><span data-stu-id="00615-158">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="00615-159">Vous devez vous assurer que vous supprimez la quantité exacte de pression que vous ajoutez.</span><span class="sxs-lookup"><span data-stu-id="00615-159">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="00615-160">Ne parvient pas à le faire peut nuire aux performances du système dans les applications qui s’exécutent pendant de longues périodes de temps.</span><span class="sxs-lookup"><span data-stu-id="00615-160">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="00615-161">
            <paramref name="bytesAllocated" /> is less than or equal to 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-161">
              <paramref name="bytesAllocated" /> is less than or equal to 0.</span>
          </span>
          <span data-ttu-id="00615-162">-or-  On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-162">-or-  On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="00615-163">pour avoir la possibilité d’appeler du code non managé lors de la manipulation de priorité de garbage collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-163">for the ability to call unmanaged code when manipulating garbage-collection priority.</span>
          </span>
          <span data-ttu-id="00615-164">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-164">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="00615-165">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-165">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="00615-166">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-166">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="00615-167">Cancels the registration of a garbage collection notification.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-167">Cancels the registration of a garbage collection notification.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-168">Cette méthode annule une notification de garbage collection qui a été inscrite à l’aide de la <xref:System.GC.RegisterForFullGCNotification%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-168">This method cancels a garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="00615-169">Il est inutile d’appeler cette méthode avant de régler les valeurs de paramètre de seuil dans les appels suivants à la <xref:System.GC.RegisterForFullGCNotification%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-169">You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00615-170">L’exemple suivant annule une inscription de garbage collection.</span><span class="sxs-lookup"><span data-stu-id="00615-170">The following example cancels a garbage collection registration.</span></span> <span data-ttu-id="00615-171">Cet exemple fait partie d’un exemple plus complet fourni pour le [Notifications de Garbage Collection](~/docs/standard/garbage-collection/notifications.md) rubrique.</span><span class="sxs-lookup"><span data-stu-id="00615-171">This example is part of a larger example provided for the [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="00615-172">This member is not available when concurrent garbage collection is enabled.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-172">This member is not available when concurrent garbage collection is enabled.</span>
          </span>
          <span data-ttu-id="00615-173">See the [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-173">See the [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="00615-174">pour la confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-174">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="00615-175">Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-175">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="00615-176">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-176">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="00615-177">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-177">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="00615-178">Forces garbage collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-178">Forces garbage collection.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="00615-179">Forces an immediate garbage collection of all generations.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-179">Forces an immediate garbage collection of all generations.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-180">Utilisez cette méthode pour tenter de récupérer toute la mémoire qui n’est pas accessible.</span><span class="sxs-lookup"><span data-stu-id="00615-180">Use this method to try to reclaim all memory that is inaccessible.</span></span> <span data-ttu-id="00615-181">Il effectue une garbage collection de blocage de toutes les générations.</span><span class="sxs-lookup"><span data-stu-id="00615-181">It performs a blocking garbage collection of all generations.</span></span>  
  
 <span data-ttu-id="00615-182">Tous les objets, quelle que soit la durée pendant laquelle ils ont été en mémoire, sont considérées comme dans la collection ; Toutefois, les objets qui sont référencés dans le code managé ne sont pas collectés.</span><span class="sxs-lookup"><span data-stu-id="00615-182">All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.</span></span> <span data-ttu-id="00615-183">Utilisez cette méthode pour forcer le système à tenter de récupérer la quantité maximale de mémoire disponible.</span><span class="sxs-lookup"><span data-stu-id="00615-183">Use this method to force the system to try to reclaim the maximum amount of available memory.</span></span>  
  
 <span data-ttu-id="00615-184">En commençant par le [!INCLUDE[net_v451](~/includes/net-v451-md.md)], vous pouvez également compacter le tas d’objets volumineux (LOH) en définissant le <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propriété <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> avant d’appeler le <xref:System.GC.Collect%2A> (méthode), comme dans l’exemple suivant illustre.</span><span class="sxs-lookup"><span data-stu-id="00615-184">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], you can compact the large object heap (LOH) by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="00615-185">L’exemple suivant montre comment utiliser le <xref:System.GC.Collect%2A> méthode pour exécuter une collecte sur toutes les générations de mémoire.</span><span class="sxs-lookup"><span data-stu-id="00615-185">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on all generations of memory.</span></span> <span data-ttu-id="00615-186">Le code génère un nombre d’objets inutilisés, puis appelle la <xref:System.GC.Collect%2A> méthode pour les supprimer de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="00615-186">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="00615-187">The number of the oldest generation to be garbage collected.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-187">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-188">Forces an immediate garbage collection from generation 0 through a specified generation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-188">Forces an immediate garbage collection from generation 0 through a specified generation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-189">Utilisez cette méthode pour tenter de récupérer la mémoire qui n’est pas accessible.</span><span class="sxs-lookup"><span data-stu-id="00615-189">Use this method to try to reclaim memory that is inaccessible.</span></span> <span data-ttu-id="00615-190">Toutefois, à l’aide de cette méthode ne garantit pas que la mémoire inaccessible dans la génération spécifiée soit libérée.</span><span class="sxs-lookup"><span data-stu-id="00615-190">However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="00615-191">Si le vieillissement des objets est implémenté, le garbage collector ne collecte pas les objets avec un numéro de génération qui est supérieur à la génération spécifiée.</span><span class="sxs-lookup"><span data-stu-id="00615-191">If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.</span></span> <span data-ttu-id="00615-192">Si la chronologie de l’objet n’est pas implémentée, le garbage collector considère que tous les objets pendant le garbage collection.</span><span class="sxs-lookup"><span data-stu-id="00615-192">If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</span></span>  
  
 <span data-ttu-id="00615-193">Utilisez le <xref:System.GC.MaxGeneration%2A> propriété afin de déterminer la valeur maximale valide de le `generation` paramètre.</span><span class="sxs-lookup"><span data-stu-id="00615-193">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of the `generation` parameter.</span></span>  
  
 <span data-ttu-id="00615-194">Pour que le garbage collector considère tous les objets, quel que soit leur génération, utilisez la version de cette méthode qui n’accepte aucun paramètre.</span><span class="sxs-lookup"><span data-stu-id="00615-194">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span> <span data-ttu-id="00615-195">Pour que le garbage collector récupère les objets selon un <xref:System.GCCollectionMode> , utilisez le <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="00615-195">To have the garbage collector reclaim objects based on a <xref:System.GCCollectionMode> setting, use the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00615-196">L’exemple suivant montre comment utiliser le <xref:System.GC.Collect%2A> méthode pour effectuer un regroupement sur des couches individuelles de mémoire.</span><span class="sxs-lookup"><span data-stu-id="00615-196">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on individual layers of memory.</span></span> <span data-ttu-id="00615-197">Le code génère un nombre d’objets inutilisés, puis appelle la <xref:System.GC.Collect%2A> méthode pour les supprimer de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="00615-197">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="00615-198">
            <paramref name="generation" /> is not valid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-198">
              <paramref name="generation" /> is not valid.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="00615-199">The number of the oldest generation to be garbage collected.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-199">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="00615-200">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-200">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-201">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-201">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-202">Utilisez le `mode` paramètre pour spécifier si le garbage collection doit être effectuée immédiatement ou uniquement si le moment est opportun pour récupérer des objets.</span><span class="sxs-lookup"><span data-stu-id="00615-202">Use the `mode` parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.</span></span> <span data-ttu-id="00615-203">À l’aide de cette méthode ne garantit pas que la mémoire inaccessible dans la génération spécifiée soit libérée.</span><span class="sxs-lookup"><span data-stu-id="00615-203">Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="00615-204">Pour ajuster le niveau d’intrusion du garbage collection pendant des périodes critiques dans votre application, définissez le <xref:System.Runtime.GCSettings.LatencyMode%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="00615-204">To adjust the intrusiveness of garbage collection during critical periods in your application, set the <xref:System.Runtime.GCSettings.LatencyMode%2A> property.</span></span>  
  
 <span data-ttu-id="00615-205">Le garbage collector ne collecte pas les objets avec un numéro de génération supérieur à celui spécifié par le `generation` paramètre.</span><span class="sxs-lookup"><span data-stu-id="00615-205">The garbage collector does not collect objects with a generation number higher than specified by the `generation` parameter.</span></span> <span data-ttu-id="00615-206">Utilisez le <xref:System.GC.MaxGeneration%2A> propriété afin de déterminer la valeur maximale valide de `generation`.</span><span class="sxs-lookup"><span data-stu-id="00615-206">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of `generation`.</span></span>  
  
 <span data-ttu-id="00615-207">Pour que le garbage collector considère tous les objets, quel que soit leur génération, utilisez la version de cette méthode qui n’accepte aucun paramètre.</span><span class="sxs-lookup"><span data-stu-id="00615-207">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span>  
  
 <span data-ttu-id="00615-208">Pour que le garbage collector récupère des objets jusqu'à une génération spécifiée d’objets, utilisez le <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="00615-208">To have the garbage collector reclaim objects up to a specified generation of objects, use the <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="00615-209">Lorsque vous spécifiez la génération maximale, tous les objets sont collectés.</span><span class="sxs-lookup"><span data-stu-id="00615-209">When you specify the maximum generation, all objects are collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00615-210">L’exemple suivant force un garbage collection pour les objets de génération 2 avec le <xref:System.GCCollectionMode.Optimized> paramètre.</span><span class="sxs-lookup"><span data-stu-id="00615-210">The following example forces a garbage collection for generation 2 objects with the <xref:System.GCCollectionMode.Optimized> setting.</span></span>  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="00615-211">
            <paramref name="generation" /> is not valid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-211">
              <paramref name="generation" /> is not valid.</span>
          </span>
          <span data-ttu-id="00615-212">-or-  <paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-212">-or-  <paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="00615-213">The number of the oldest generation to be garbage collected.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-213">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="00615-214">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-214">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          </span>
        </param>
        <param name="blocking">
          <span data-ttu-id="00615-215">
            <see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-215">
              <see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-216">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with a value specifying whether the collection should be blocking.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-216">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with a value specifying whether the collection should be blocking.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-217">Le tableau suivant résume l’interaction de le `mode` et `blocking` paramètres :</span><span class="sxs-lookup"><span data-stu-id="00615-217">The following table summarizes the interaction of the `mode` and `blocking` parameters:</span></span>  
  
|`mode`|<span data-ttu-id="00615-218">`blocking` a la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="00615-218">`blocking` is `true`</span></span>|<span data-ttu-id="00615-219">`blocking` a la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="00615-219">`blocking` is `false`</span></span>|  
|-|-|-|  
|<span data-ttu-id="00615-220"><xref:System.GCCollectionMode.Forced> ou <xref:System.GCCollectionMode.Default></span><span class="sxs-lookup"><span data-stu-id="00615-220"><xref:System.GCCollectionMode.Forced> or <xref:System.GCCollectionMode.Default></span></span>|<span data-ttu-id="00615-221">Une collection de blocage est exécutée dès que possible.</span><span class="sxs-lookup"><span data-stu-id="00615-221">A blocking collection is performed as soon as possible.</span></span> <span data-ttu-id="00615-222">Si une collection d’arrière-plan est en cours et `generation` est 0 ou 1, le <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> méthode déclenche une collection de blocage immédiatement et retourne quand la collection est terminée.</span><span class="sxs-lookup"><span data-stu-id="00615-222">If a background collection is in progress and `generation` is 0 or 1, the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method immediately triggers a blocking collection and returns when the collection is finished.</span></span> <span data-ttu-id="00615-223">Si une collection d’arrière-plan est en cours et `generation` est 2, la méthode attend la collection d’arrière-plan est terminée, déclenche une collection de génération 2 blocage et renvoie.</span><span class="sxs-lookup"><span data-stu-id="00615-223">If a background collection is in progress and `generation` is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</span></span>|<span data-ttu-id="00615-224">Une collection est exécutée dès que possible.</span><span class="sxs-lookup"><span data-stu-id="00615-224">A collection is performed as soon as possible.</span></span> <span data-ttu-id="00615-225">La méthode <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> demande une collection d'arrière-plan, mais cela n'est pas garanti ; selon les cas, une collection bloquante peut toujours être exécutée.</span><span class="sxs-lookup"><span data-stu-id="00615-225">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="00615-226">Si une collection d’arrière-plan est déjà en cours, la méthode retourne immédiatement une valeur.</span><span class="sxs-lookup"><span data-stu-id="00615-226">If a background collection is already in progress, the method returns immediately.</span></span>|  
|<xref:System.GCCollectionMode.Optimized>|<span data-ttu-id="00615-227">Une collecte bloquante peut être exécutée, selon l'état du récupérateur de mémoire et du paramètre `generation`.</span><span class="sxs-lookup"><span data-stu-id="00615-227">A blocking collection may be performed, depending on the state of the garbage collector and the `generation` parameter.</span></span> <span data-ttu-id="00615-228">Le Garbage collector tente de fournir des performances optimales.</span><span class="sxs-lookup"><span data-stu-id="00615-228">The garbage collector tries to provide optimal performance.</span></span>|<span data-ttu-id="00615-229">Une collection de blocage peut être effectuée, en fonction de l’état du Garbage collector.</span><span class="sxs-lookup"><span data-stu-id="00615-229">A collection may be performed, depending on the state of the garbage collector.</span></span> <span data-ttu-id="00615-230">La méthode <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> demande une collection d'arrière-plan, mais cela n'est pas garanti ; selon les cas, une collection bloquante peut toujours être exécutée.</span><span class="sxs-lookup"><span data-stu-id="00615-230">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="00615-231">Le Garbage collector tente de fournir des performances optimales.</span><span class="sxs-lookup"><span data-stu-id="00615-231">The garbage collector tries to provide optimal performance.</span></span> <span data-ttu-id="00615-232">Si une collection d’arrière-plan est déjà en cours, la méthode retourne immédiatement une valeur.</span><span class="sxs-lookup"><span data-stu-id="00615-232">If a background collection is already in progress, the method returns immediately.</span></span>|  
  
 <span data-ttu-id="00615-233">Si un appel à la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> méthode effectue une garbage collection de blocage, vous pouvez également compacter le tas d’objets volumineux en définissant le <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propriété <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> avant d’appeler le <xref:System.GC.Collect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-233">If a call to the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="00615-234">
            <paramref name="generation" /> is not valid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-234">
              <paramref name="generation" /> is not valid.</span>
          </span>
          <span data-ttu-id="00615-235">-or-  <paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-235">-or-  <paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
        <Parameter Name="compacting" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="00615-236">The number of the oldest generation to be garbage collected.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-236">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="00615-237">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-237">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          </span>
        </param>
        <param name="blocking">
          <span data-ttu-id="00615-238">
            <see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-238">
              <see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span>
          </span>
        </param>
        <param name="compacting">
          <span data-ttu-id="00615-239">
            <see langword="true" /> to compact the small object heap; <see langword="false" /> to sweep only.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-239">
              <see langword="true" /> to compact the small object heap; <see langword="false" /> to sweep only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-240">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with values that specify whether the collection should be blocking and compacting.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-240">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with values that specify whether the collection should be blocking and compacting.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-241">Si `blocking` est `false`, le GC décide s’il faut effectuer un arrière-plan ou une garbage collection de blocage.</span><span class="sxs-lookup"><span data-stu-id="00615-241">If `blocking` is `false`, the GC decides whether to perform a background or a blocking garbage collection.</span></span> <span data-ttu-id="00615-242">Si `compacting` est `true`, il effectue une garbage collection de blocage.</span><span class="sxs-lookup"><span data-stu-id="00615-242">If `compacting` is `true`, it performs a blocking garbage collection.</span></span>  
  
 <span data-ttu-id="00615-243">Si `compacting` est `true`, le runtime compacte le tas de petits objets (SOH).</span><span class="sxs-lookup"><span data-stu-id="00615-243">If `compacting` is `true`, the runtime compacts the small object heap (SOH).</span></span> <span data-ttu-id="00615-244">Le tas d’objets volumineux (LOH) n’est pas compacté, sauf si le <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propriété est définie sur <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="00615-244">The large object heap (LOH) is not compacted unless the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property is set to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span></span> <span data-ttu-id="00615-245">Notez que cela inclut tous les garbage collections de blocage, pas simplement tous les garbage collections bloquants.</span><span class="sxs-lookup"><span data-stu-id="00615-245">Note that this includes all blocking garbage collections, not just full blocking garbage collections.</span></span>  
  
 <span data-ttu-id="00615-246">Vous pouvez appeler la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> méthode afin de réduire le tas managé la plus petite taille possible, comme l’illustre le fragment de code suivant.</span><span class="sxs-lookup"><span data-stu-id="00615-246">You can call the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.</span></span>  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 <span data-ttu-id="00615-247">Spécification `true` pour le `compacting` argument garantit une compactage, complète garbage collection de blocage.</span><span class="sxs-lookup"><span data-stu-id="00615-247">Specifying `true` for the `compacting` argument guarantees a compacting, full blocking garbage collection.</span></span> <span data-ttu-id="00615-248">Définition de la <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propriété <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> garantit que le LOH et la déclaration d’intégrité sont compactées.</span><span class="sxs-lookup"><span data-stu-id="00615-248">Setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> ensures that both the LOH and SOH are compacted.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="00615-249">The generation of objects for which the garbage collection count is to be determined.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-249">The generation of objects for which the garbage collection count is to be determined.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-250">Returns the number of times garbage collection has occurred for the specified generation of objects.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-250">Returns the number of times garbage collection has occurred for the specified generation of objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="00615-251">The number of times garbage collection has occurred for the specified generation since the process was started.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-251">The number of times garbage collection has occurred for the specified generation since the process was started.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-252">Si vous implémentez votre propre gestion des ressources, vous devrez peut-être forcer le garbage collection régulièrement en appelant le <xref:System.GC.Collect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-252">If you implement your own resource management, you might need to force garbage collection periodically by calling the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="00615-253">Comme il s’agit d’une opération coûteuse, vous pouvez améliorer les performances en ignorant l’appel lorsqu’un garbage collection s’est produite récemment.</span><span class="sxs-lookup"><span data-stu-id="00615-253">Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.</span></span> <span data-ttu-id="00615-254">Enregistrez la valeur retournée par <xref:System.GC.CollectionCount%2A> immédiatement après l’appel <xref:System.GC.Collect%2A>.</span><span class="sxs-lookup"><span data-stu-id="00615-254">Save the value returned by <xref:System.GC.CollectionCount%2A> immediately after calling <xref:System.GC.Collect%2A>.</span></span> <span data-ttu-id="00615-255">La prochaine fois que vous devez appeler <xref:System.GC.Collect%2A>, comparer la valeur actuelle retournée par <xref:System.GC.CollectionCount%2A> à la valeur enregistrée.</span><span class="sxs-lookup"><span data-stu-id="00615-255">The next time you need to call <xref:System.GC.Collect%2A>, compare the current value returned by <xref:System.GC.CollectionCount%2A> to the saved value.</span></span> <span data-ttu-id="00615-256">Si les deux valeurs sont égales, aucune collection se n’est produite dans l’intervalle et il est raisonnable d’appeler <xref:System.GC.Collect%2A> à nouveau.</span><span class="sxs-lookup"><span data-stu-id="00615-256">If the two values are equal, no collection has occurred in the interim and it is reasonable to call <xref:System.GC.Collect%2A> again.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="00615-257">
            <paramref name="generation" /> is less than 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-257">
              <paramref name="generation" /> is less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="00615-258">Ends the no GC region latency mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-258">Ends the no GC region latency mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-259">Le <xref:System.GC.EndNoGCRegion%2A> méthode lève un <xref:System.InvalidOperationException> si le garbage collector n’est pas en mode de latence sans région GC.</span><span class="sxs-lookup"><span data-stu-id="00615-259">The <xref:System.GC.EndNoGCRegion%2A> method throws an <xref:System.InvalidOperationException> if the garbage collector is not in no GC region latency mode.</span></span> <span data-ttu-id="00615-260">Cela se produit si l’une des conditions suivantes :</span><span class="sxs-lookup"><span data-stu-id="00615-260">This occurs under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="00615-261">Le <xref:System.GC.TryStartNoGCRegion%2A> (méthode) n’a pas été appelée précédemment.</span><span class="sxs-lookup"><span data-stu-id="00615-261">The <xref:System.GC.TryStartNoGCRegion%2A> method was not called previously.</span></span>  
  
-   <span data-ttu-id="00615-262">L’appel à la <xref:System.GC.TryStartNoGCRegion%2A> méthode retournée `false`.</span><span class="sxs-lookup"><span data-stu-id="00615-262">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method returned `false`.</span></span>  
  
-   <span data-ttu-id="00615-263">L’appel à la <xref:System.GC.TryStartNoGCRegion%2A> méthode a levé une exception.</span><span class="sxs-lookup"><span data-stu-id="00615-263">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method threw an exception.</span></span>  
  
 <span data-ttu-id="00615-264">Vous pouvez éviter qu’une exception pour une des raisons suivantes à l’aide de code semblable au suivant :</span><span class="sxs-lookup"><span data-stu-id="00615-264">You can prevent an exception for any of these reasons by using code such as the following:</span></span>  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="00615-265">The garbage collector is not in no GC region latency mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-265">The garbage collector is not in no GC region latency mode.</span>
          </span>
          <span data-ttu-id="00615-266">-or-  The no GC region latency mode was ended previously because a garbage collection was induced.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-266">-or-  The no GC region latency mode was ended previously because a garbage collection was induced.</span>
          </span>
          <span data-ttu-id="00615-267">-or-  A memory allocation exceeded the amount specified in the call to the <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> method.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-267">-or-  A memory allocation exceeded the amount specified in the call to the <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> method.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="00615-268">Returns the current generation number of an object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-268">Returns the current generation number of an object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="00615-269">The object that generation information is retrieved for.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-269">The object that generation information is retrieved for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-270">Returns the current generation number of the specified object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-270">Returns the current generation number of the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="00615-271">The current generation number of <paramref name="obj" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-271">The current generation number of <paramref name="obj" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-272">Utilisez cette méthode pour déterminer l’âge d’un objet et ensuite utiliser ces informations avec la <xref:System.GC.Collect%2A> méthode pour forcer le garbage collector pour collecter des objets dans la même génération.</span><span class="sxs-lookup"><span data-stu-id="00615-272">Use this method to determine the age of an object, and then use that information with the <xref:System.GC.Collect%2A> method to force the garbage collector to collect objects in the same generation.</span></span> <span data-ttu-id="00615-273">Par exemple, utilisez cette méthode lorsque vous avez un ensemble d’objets qui sont créés en tant que groupe et qui deviennent inaccessibles en même temps.</span><span class="sxs-lookup"><span data-stu-id="00615-273">For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00615-274">L’exemple suivant montre comment utiliser le <xref:System.GC.GetGeneration%2A> méthode pour déterminer l’âge d’un objet.</span><span class="sxs-lookup"><span data-stu-id="00615-274">The following example demonstrates how to use the <xref:System.GC.GetGeneration%2A> method to determine the age of an object.</span></span> <span data-ttu-id="00615-275">L’exemple effectue ensuite les garbage collection pour nettoyer la mémoire et de comparer les versions antérieures et de valider les totaux de mémoire dans la console.</span><span class="sxs-lookup"><span data-stu-id="00615-275">The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" />
      </Parameters>
      <Docs>
        <param name="wo">
          <span data-ttu-id="00615-276">A <see cref="T:System.WeakReference" /> that refers to the target object whose generation number is to be determined.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-276">A <see cref="T:System.WeakReference" /> that refers to the target object whose generation number is to be determined.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-277">Returns the current generation number of the target of a specified weak reference.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-277">Returns the current generation number of the target of a specified weak reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="00615-278">The current generation number of the target of <paramref name="wo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-278">The current generation number of the target of <paramref name="wo" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="00615-279">L’exemple suivant illustre l’utilisation de la <xref:System.GC.GetGeneration%2A> méthode pour déterminer l’âge d’un objet de référence faible.</span><span class="sxs-lookup"><span data-stu-id="00615-279">The following example demonstrates the use of the <xref:System.GC.GetGeneration%2A> method to determine the age of a weak reference object.</span></span>  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="00615-280">Garbage collection has already been performed on <paramref name="wo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-280">Garbage collection has already been performed on <paramref name="wo" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection">
          <span data-ttu-id="00615-281">
            <see langword="true" /> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-281">
              <see langword="true" /> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-282">Retrieves the number of bytes currently thought to be allocated.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-282">Retrieves the number of bytes currently thought to be allocated.</span>
          </span>
          <span data-ttu-id="00615-283">A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-283">A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="00615-284">A number that is the best available approximation of the number of bytes currently allocated in managed memory.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-284">A number that is the best available approximation of the number of bytes currently allocated in managed memory.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-285">Si le `forceFullCollection` paramètre est `true`, cette méthode attend un court intervalle avant de retourner tandis que le système de garbage collection et finalise les objets.</span><span class="sxs-lookup"><span data-stu-id="00615-285">If the `forceFullCollection` parameter is `true`, this method waits a short interval before returning while the system collects garbage and finalizes objects.</span></span> <span data-ttu-id="00615-286">La durée de l’intervalle est une limite spécifiée en interne déterminée par le nombre de garbage collection cycles terminée et la modification de la quantité de mémoire récupérée entre les cycles.</span><span class="sxs-lookup"><span data-stu-id="00615-286">The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.</span></span> <span data-ttu-id="00615-287">Le garbage collector ne garantit pas que la mémoire inaccessible est collectée.</span><span class="sxs-lookup"><span data-stu-id="00615-287">The garbage collector does not guarantee that all inaccessible memory is collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00615-288">L’exemple suivant montre comment utiliser le <xref:System.GC.GetTotalMemory%2A> méthode pour obtenir et afficher le nombre d’octets actuellement alloués dans la mémoire managée.</span><span class="sxs-lookup"><span data-stu-id="00615-288">The following example demonstrates how to use the <xref:System.GC.GetTotalMemory%2A> method to get and display the number of bytes currently allocated in managed memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="00615-289">The object to reference.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-289">The object to reference.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-290">References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-290">References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-291">L’objectif de la <xref:System.GC.KeepAlive%2A> méthode consiste à s’assurer de l’existence d’une référence à un objet qui risque d’être récupéré prématurément par le garbage collector.</span><span class="sxs-lookup"><span data-stu-id="00615-291">The purpose of the <xref:System.GC.KeepAlive%2A> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.</span></span> <span data-ttu-id="00615-292">Il est fréquent où cela peut se produire lorsqu’il n’existe aucune référence à l’objet dans le code managé ou de données, mais l’objet est en cours d’utilisation dans le code non managé, telles que les API Win32, les DLL non managées, ou les méthodes à l’aide de COM.</span><span class="sxs-lookup"><span data-stu-id="00615-292">A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.</span></span>  
  
 <span data-ttu-id="00615-293">Cette méthode référence le `obj` paramètre, rendant cet objet inéligible pour le garbage collection à partir du début de la routine au point, dans l’ordre d’exécution, où cette méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="00615-293">This method references the `obj` parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.</span></span> <span data-ttu-id="00615-294">Cette méthode à la fin, et non au début de la plage d’instructions de code où `obj` doit être disponible.</span><span class="sxs-lookup"><span data-stu-id="00615-294">Code this method at the end, not the beginning, of the range of instructions where `obj` must be available.</span></span>  
  
 <span data-ttu-id="00615-295">Le <xref:System.GC.KeepAlive%2A> méthode n’effectue aucune opération et ne produit aucun effet secondaire autre que l’extension de la durée de vie de l’objet passé en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="00615-295">The <xref:System.GC.KeepAlive%2A> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00615-296">L’exemple de code suivant crée un objet au début de son `Main` (méthode) et ne fait pas référence à l’objet jusqu'à la fin, lorsque le <xref:System.GC.KeepAlive%2A> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="00615-296">The following code example creates an object at the beginning of its `Main` method and does not refer to the object again until the end, when the <xref:System.GC.KeepAlive%2A> method is called.</span></span> <span data-ttu-id="00615-297">L’objet persiste pendant la durée de 30 secondes de la `Main` (méthode), en dépit des appels à la <xref:System.GC.Collect%2A> et <xref:System.GC.WaitForPendingFinalizers%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="00615-297">The object persists for the 30-second duration of the `Main` method, despite calls to the <xref:System.GC.Collect%2A> and <xref:System.GC.WaitForPendingFinalizers%2A> methods.</span></span>  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="00615-298">Gets the maximum number of generations that the system currently supports.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-298">Gets the maximum number of generations that the system currently supports.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="00615-299">Valeur comprise entre zéro et le nombre maximal de générations prises en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-299">A value that ranges from zero to the maximum number of supported generations.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-300">Le numéro de génération, ou l’âge, d’un objet est une mesure relative défini par l’implémentation de la durée de vie d’un objet.</span><span class="sxs-lookup"><span data-stu-id="00615-300">The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.</span></span> <span data-ttu-id="00615-301">Les objets plus récemment créés sont dans la génération 0 et les objets les plus anciens sont dans une génération inférieure ou égale à la génération retournée par la <xref:System.GC.MaxGeneration%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="00615-301">The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <xref:System.GC.MaxGeneration%2A> property.</span></span>  
  
 <span data-ttu-id="00615-302">Le garbage collector suppose que la mémoire la plus récente est plus susceptible d’être éligibles pour le garbage collection que la mémoire plus anciens.</span><span class="sxs-lookup"><span data-stu-id="00615-302">The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.</span></span> <span data-ttu-id="00615-303">Par conséquent, le garbage collector améliore ses performances en ajustant les numéros de génération chaque fois qu’il récupère la mémoire, et le <xref:System.GC.MaxGeneration%2A> valeur de propriété peut augmenter au fil du temps.</span><span class="sxs-lookup"><span data-stu-id="00615-303">Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <xref:System.GC.MaxGeneration%2A> property value can grow over time.</span></span>  
  
 <span data-ttu-id="00615-304">Si le vieillissement des objets est implémenté, la <xref:System.GC.MaxGeneration%2A> propriété retourne le nombre maximal de générations utilisé par le système ; sinon, cette propriété retourne la valeur zéro.</span><span class="sxs-lookup"><span data-stu-id="00615-304">If object aging is implemented, the <xref:System.GC.MaxGeneration%2A> property returns the maximum generation number used by the system; otherwise, this property returns zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00615-305">L’exemple suivant montre comment utiliser la propriété MaxGeneration pour afficher le plus grand nombre de génération actuellement en cours d’utilisation.</span><span class="sxs-lookup"><span data-stu-id="00615-305">The following example demonstrates how to use the MaxGeneration property to display the largest generation number currently in use.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="00615-306">
            <para>Pour cette implémentation, la valeur retournée par la <see cref="P:System.GC.MaxGeneration" /> propriété est garantie reste constante pour la durée de vie d’une application en cours d’exécution.  Utilisez le <see cref="P:System.GC.MaxGeneration" /> propriété afin de déterminer la valeur maximale que vous pouvez spécifier lors de l’appel la <see cref="M:System.GC.Collect(System.Int32)" /> méthode qui accepte un paramètre de génération.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-306">
              <para>For this implementation, the value returned by the <see cref="P:System.GC.MaxGeneration" /> property is guaranteed to remain constant for the lifetime of an executing application.  Use the <see cref="P:System.GC.MaxGeneration" /> property to determine the maximum value you can specify when calling the <see cref="M:System.GC.Collect(System.Int32)" /> method that takes a generation parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">
          <span data-ttu-id="00615-307">A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-307">A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</span>
          </span>
        </param>
        <param name="largeObjectHeapThreshold">
          <span data-ttu-id="00615-308">A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-308">A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-309">Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-309">Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-310">Pour chaque génération, le garbage collector définit un seuil pour les allocations dans cette génération.</span><span class="sxs-lookup"><span data-stu-id="00615-310">For each generation, the garbage collector sets a threshold for allocations into that generation.</span></span> <span data-ttu-id="00615-311">Lorsque la taille des allocations dépasse ce seuil, un garbage collection est déclenché sur cette génération.</span><span class="sxs-lookup"><span data-stu-id="00615-311">When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.</span></span> <span data-ttu-id="00615-312">Pour exemple, si le seuil de génération 2 est de 20 Mo (ce qui signifie que 20 Mo survit aux collections de génération 1 est promue dans la génération 2) et plus de 20 Mo a survécu à la génération 1 et est invité à entrer dans la génération 2, le garbage collection suivant sera tenté. comme une collection de génération 2.</span><span class="sxs-lookup"><span data-stu-id="00615-312">For example, if generation 2’s threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.</span></span> <span data-ttu-id="00615-313">De même, si le tas d’objets volumineux 's (LOH) seuil est de 20 Mo et que votre application a alloué le plus de 20 Mo des objets volumineux, le garbage collection suivant sera tenté également comme une collection de génération 2 (puisque le LOH est collecté uniquement dans les garbage collections de génération 2).</span><span class="sxs-lookup"><span data-stu-id="00615-313">Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).</span></span>  
  
 <span data-ttu-id="00615-314">Le `maxGenerationThreshold` et `largeObjectHeapThreshold` seuils contrôlent avance combien vous êtes averti avant une garbage collection complet.</span><span class="sxs-lookup"><span data-stu-id="00615-314">The `maxGenerationThreshold` and `largeObjectHeapThreshold` thresholds control how much in advance you are notified before a full garbage collection occurs.</span></span> <span data-ttu-id="00615-315">Plus le seuil les plus d’allocations qui peuvent se produire entre la notification et la prochain garbage collection complet.</span><span class="sxs-lookup"><span data-stu-id="00615-315">The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.</span></span>  
  
 <span data-ttu-id="00615-316">Si vous avez des situations dans lesquelles un garbage collection complet par le common language runtime peut gêner les performances de votre application, vous pouvez demander à être averti lorsque le runtime est sur le point d’effectuer une garbage collection complet et le contrecarrer par induire vous-même une collection (à l’aide de la <xref:System.GC.Collect%2A> méthode) lorsque les conditions sont toujours favorables.</span><span class="sxs-lookup"><span data-stu-id="00615-316">If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <xref:System.GC.Collect%2A> method) when conditions are still favorable.</span></span> <span data-ttu-id="00615-317">En plus de la modification de la garbage collection vous-même, notification GC complète est utile dans les scénarios suivants :</span><span class="sxs-lookup"><span data-stu-id="00615-317">In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:</span></span>  
  
-   <span data-ttu-id="00615-318">Vous surveillez pour l’approche d’une garbage collection complet et, lorsque vous êtes informé qu’un est proche, vous réduisez la taille des données en temps réel (par exemple, en libérant des entrées de cache).</span><span class="sxs-lookup"><span data-stu-id="00615-318">You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).</span></span> <span data-ttu-id="00615-319">Par conséquent, lorsque le garbage collection se produit, il est en mesure de libérer plus de mémoire.</span><span class="sxs-lookup"><span data-stu-id="00615-319">As a result, when the garbage collection occurs, it is able to reclaim more memory.</span></span>  
  
-   <span data-ttu-id="00615-320">Vous surveillez l’achèvement d’une garbage collection complet afin que vous pouvez collecter des statistiques.</span><span class="sxs-lookup"><span data-stu-id="00615-320">You monitor for the completion of a full garbage collection so that you can collect some statistics.</span></span>  <span data-ttu-id="00615-321">Par exemple, vous souhaiterez peut-être mesurer la taille du tas à l’achèvement de GC afin que vous connaissez la taille des données en direct.</span><span class="sxs-lookup"><span data-stu-id="00615-321">For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.</span></span> <span data-ttu-id="00615-322">(Après un GC complet, le segment de mémoire est à sa taille plus petite).</span><span class="sxs-lookup"><span data-stu-id="00615-322">(After a full GC, the heap is at its smallest size.)</span></span>  
  
 <span data-ttu-id="00615-323">Pour plus d’informations sur ce que représente une garbage collection complet, consultez [Notifications de Garbage Collection](~/docs/standard/garbage-collection/notifications.md).</span><span class="sxs-lookup"><span data-stu-id="00615-323">For more information about what represents a full garbage collection, see [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md).</span></span>  
  
 <span data-ttu-id="00615-324">Lorsque vous inscrivez pour une notification de garbage collection, vous pouvez être averti quand une garbage collection complet est imminent et lorsqu’il est terminé.</span><span class="sxs-lookup"><span data-stu-id="00615-324">When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.</span></span> <span data-ttu-id="00615-325">Ce modèle est similaire à la façon dont le système d’exploitation surveille pour les notifications de mémoire insuffisante.</span><span class="sxs-lookup"><span data-stu-id="00615-325">This pattern resembles how the operating system monitors for low memory notifications.</span></span>  
  
 <span data-ttu-id="00615-326">Utilisez les instructions suivantes pour spécifier le `maxGenerationThreshold` et `largeObjectHeapThreshold` paramètres :</span><span class="sxs-lookup"><span data-stu-id="00615-326">Use the following guidelines for specifying the `maxGenerationThreshold` and `largeObjectHeapThreshold` parameters:</span></span>  
  
-   <span data-ttu-id="00615-327">Plus la valeur de seuil, les allocations plus seront produit entre la notification et la garbage collection complet.</span><span class="sxs-lookup"><span data-stu-id="00615-327">The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.</span></span>  
  
     <span data-ttu-id="00615-328">Une valeur de seuil élevée fournit davantage d’opportunités pour le runtime vérifier à l’imminence d’une collection.</span><span class="sxs-lookup"><span data-stu-id="00615-328">A larger threshold value provides more opportunities for the runtime to check for an approaching collection.</span></span> <span data-ttu-id="00615-329">Cela augmente la probabilité que vous êtes averti.</span><span class="sxs-lookup"><span data-stu-id="00615-329">This increases the likelihood that you will be notified.</span></span> <span data-ttu-id="00615-330">Toutefois, vous ne devez pas définir le seuil trop élevé, car cela entraîne une allocations plus avant que le runtime déclenche le garbage collection suivant.</span><span class="sxs-lookup"><span data-stu-id="00615-330">However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.</span></span>  
  
     <span data-ttu-id="00615-331">Lorsque vous déclencher vous-même une collection dès la notification à l’aide d’une valeur de seuil élevée, moins d’objets sont récupérés que serait récupéré par la collection suivante.</span><span class="sxs-lookup"><span data-stu-id="00615-331">When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.</span></span>  
  
-   <span data-ttu-id="00615-332">Plus la valeur de seuil, moins les allocations entre la notification et la garbage collection complet.</span><span class="sxs-lookup"><span data-stu-id="00615-332">The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00615-333">L’exemple suivant montre comment inscrire une notification de garbage collection et démarrer un thread pour surveiller l’état de la notification de garbage collection.</span><span class="sxs-lookup"><span data-stu-id="00615-333">The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification.</span></span> <span data-ttu-id="00615-334">Cet exemple de code fait partie d’un exemple plus complet fourni pour [Notifications de Garbage Collection](~/docs/standard/garbage-collection/notifications.md) rubrique.</span><span class="sxs-lookup"><span data-stu-id="00615-334">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="00615-335">
            <paramref name="maxGenerationThreshold" /> or <paramref name="largeObjectHeapThreshold" /> is not between 1 and 99.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-335">
              <paramref name="maxGenerationThreshold" /> or <paramref name="largeObjectHeapThreshold" /> is not between 1 and 99.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="00615-336">pour la confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-336">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="00615-337">Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-337">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="00615-338">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-338">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="00615-339">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-339">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">
          <span data-ttu-id="00615-340">The amount of unmanaged memory that has been released.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-340">The amount of unmanaged memory that has been released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-341">Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-341">Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-342">Détermination des cas planifier le garbage collection, le runtime prend en compte la quantité de mémoire managé est alloué.</span><span class="sxs-lookup"><span data-stu-id="00615-342">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="00615-343">Si un petit objet managé alloue une grande quantité de mémoire non managée, le runtime prend en compte uniquement la mémoire managée et par conséquent sous-estime l’urgence de la planification du garbage collection.</span><span class="sxs-lookup"><span data-stu-id="00615-343">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="00615-344">Le <xref:System.GC.AddMemoryPressure%2A> méthode informe l’exécution de cette sollicitation supplémentaire sur la mémoire système et le <xref:System.GC.RemoveMemoryPressure%2A> méthode informe le runtime que la pression supplémentaire a été publiée.</span><span class="sxs-lookup"><span data-stu-id="00615-344">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory, and the <xref:System.GC.RemoveMemoryPressure%2A> method informs the runtime that the additional pressure has been released.</span></span>  
  
 <span data-ttu-id="00615-345">Dans le modèle d’utilisation la plus simple, un objet managé alloue la mémoire non managée dans le constructeur et la libère dans la `Dispose` ou `Finalize` (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-345">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="00615-346">Appelez le <xref:System.GC.AddMemoryPressure%2A> méthode après avoir alloué la mémoire non managée et appelez le <xref:System.GC.RemoveMemoryPressure%2A> méthode après l’avoir libéré.</span><span class="sxs-lookup"><span data-stu-id="00615-346">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="00615-347">Dans les scénarios plus complexes, où l’allocation de mémoire non managée change substantiellement pendant la durée de vie de l’objet managé, vous pouvez appeler la <xref:System.GC.AddMemoryPressure%2A> et <xref:System.GC.RemoveMemoryPressure%2A> méthodes permettant de communiquer ces modifications incrémentielles à l’exécution.</span><span class="sxs-lookup"><span data-stu-id="00615-347">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="00615-348">Vous devez vous assurer que vous supprimez la quantité exacte de pression que vous ajoutez.</span><span class="sxs-lookup"><span data-stu-id="00615-348">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="00615-349">Ne parvient pas à le faire peut nuire aux performances du système dans les applications qui s’exécutent pendant de longues périodes de temps.</span><span class="sxs-lookup"><span data-stu-id="00615-349">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="00615-350">
            <paramref name="bytesAllocated" /> is less than or equal to 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-350">
              <paramref name="bytesAllocated" /> is less than or equal to 0.</span>
          </span>
          <span data-ttu-id="00615-351">-or-  On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-351">-or-  On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="00615-352">pour avoir la possibilité d’appeler du code non managé lors de la manipulation de priorité de garbage collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-352">for the ability to call unmanaged code when manipulating garbage-collection priority.</span>
          </span>
          <span data-ttu-id="00615-353">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-353">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="00615-354">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-354">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="00615-355">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-355">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="00615-356">The object that a finalizer must be called for.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-356">The object that a finalizer must be called for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-357">Requests that the system call the finalizer for the specified object for which <see cref="M:System.GC.SuppressFinalize(System.Object)" /> has previously been called.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-357">Requests that the system call the finalizer for the specified object for which <see cref="M:System.GC.SuppressFinalize(System.Object)" /> has previously been called.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-358">Le <xref:System.GC.ReRegisterForFinalize%2A> méthode ajoute la `obj` paramètre à la liste des objets qui demandent la finalisation avant que le garbage collector libère l’objet.</span><span class="sxs-lookup"><span data-stu-id="00615-358">The <xref:System.GC.ReRegisterForFinalize%2A> method adds the `obj` parameter to the list of objects that request finalization before the garbage collector frees the object.</span></span> <span data-ttu-id="00615-359">Le `obj` paramètre doit être l’appelant de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="00615-359">The `obj` parameter must be the caller of this method.</span></span>  
  
 <span data-ttu-id="00615-360">Appel de la <xref:System.GC.ReRegisterForFinalize%2A> méthode ne garantit pas que le garbage collector appellera le finaliseur d’un objet.</span><span class="sxs-lookup"><span data-stu-id="00615-360">Calling the <xref:System.GC.ReRegisterForFinalize%2A> method does not guarantee that the garbage collector will call an object's finalizer.</span></span>  
  
 <span data-ttu-id="00615-361">Par défaut, tous les objets qui implémentent les finaliseurs sont ajoutés à la liste des objets qui nécessitent une finalisation ; Toutefois, un objet peut déjà avoir été finalisé ou avoir désactivé la finalisation en appelant le <xref:System.GC.SuppressFinalize%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-361">By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <xref:System.GC.SuppressFinalize%2A> method.</span></span>  
  
 <span data-ttu-id="00615-362">Un finaliseur peut utiliser cette méthode pour se réactiver ou réactiver un objet qu’il référence.</span><span class="sxs-lookup"><span data-stu-id="00615-362">A finalizer can use this method to resurrect itself or an object that it references.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00615-363">L’exemple suivant montre comment utiliser la méthode ReRegisterForFinalize pour finaliser un objet une deuxième fois après le garbage collection.</span><span class="sxs-lookup"><span data-stu-id="00615-363">The following example demonstrates how to use the ReRegisterForFinalize method to finalize an object a second time after garbage collection.</span></span>  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="00615-364">
            <paramref name="obj" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-364">
              <paramref name="obj" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="00615-365">The object whose finalizer must not be executed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-365">The object whose finalizer must not be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-366">Requests that the common language runtime not call the finalizer for the specified object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-366">Requests that the common language runtime not call the finalizer for the specified object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-367">Cette méthode définit un bit dans l’en-tête de l’objet de `obj`, dont le runtime vérifie lors de l’appel de finaliseurs.</span><span class="sxs-lookup"><span data-stu-id="00615-367">This method sets a bit in the object header of `obj`, which the runtime checks when calling finalizers.</span></span> <span data-ttu-id="00615-368">Un finaliseur, qui est représenté par la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> méthode, est utilisée pour libérer les ressources non managées avant un objet est une opération de garbage collection.</span><span class="sxs-lookup"><span data-stu-id="00615-368">A finalizer, which is represented by the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method, is used to release unmanaged resources before an object is garbage-collected.</span></span> <span data-ttu-id="00615-369">Si `obj` n’a pas d’un finaliseur, l’appel à la <xref:System.GC.SuppressFinalize%2A> méthode n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="00615-369">If `obj` does not have a finalizer, the call to the <xref:System.GC.SuppressFinalize%2A> method has no effect.</span></span>  
  
 <span data-ttu-id="00615-370">Objets qui implémentent le <xref:System.IDisposable> interface peut appeler cette méthode à partir de l’objet <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> mise en œuvre pour empêcher le garbage collector d’appeler <xref:System.Object.Finalize%2A?displayProperty=nameWithType> sur un objet qui ne l’impose pas.</span><span class="sxs-lookup"><span data-stu-id="00615-370">Objects that implement the <xref:System.IDisposable> interface can call this method from the object's <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation to prevent the garbage collector from calling <xref:System.Object.Finalize%2A?displayProperty=nameWithType> on an object that does not require it.</span></span> <span data-ttu-id="00615-371">En règle générale, cela permet d’empêcher le finaliseur de libérer des ressources non managées qui ont déjà été libérées par la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implémentation.</span><span class="sxs-lookup"><span data-stu-id="00615-371">Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00615-372">L’exemple suivant montre comment utiliser le <xref:System.GC.SuppressFinalize%2A> méthode dans une classe de ressources pour empêcher un garbage collection redondant d’être appelée.</span><span class="sxs-lookup"><span data-stu-id="00615-372">The following example demonstrates how to use the <xref:System.GC.SuppressFinalize%2A> method in a resource class to prevent a redundant garbage collection from being called.</span></span> <span data-ttu-id="00615-373">L’exemple utilise le [dispose, modèle](~/docs/standard/design-guidelines/dispose-pattern.md) pour libérer à la fois les ressources managées (autrement dit, des objets qui implémentent <xref:System.IDisposable>) et les ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="00615-373">The example uses the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) to free both managed resources (that is, objects that implement <xref:System.IDisposable>) and unmanaged resources.</span></span>  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="00615-374">
            <paramref name="obj" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-374">
              <paramref name="obj" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="00615-375">Attempts to disallow garbage collection during the execution of a critical path.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-375">Attempts to disallow garbage collection during the execution of a critical path.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="00615-376">Vous ne pouvez pas imbriquer des appels à la <xref:System.GC.TryStartNoGCRegion%2A> (méthode) et vous devez appeler uniquement la <xref:System.GC.EndNoGCRegion%2A> méthode si le runtime est actuellement en mode de latence sans région GC.</span><span class="sxs-lookup"><span data-stu-id="00615-376">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="00615-377">En d’autres termes, vous ne devez pas appeler <xref:System.GC.TryStartNoGCRegion%2A> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <xref:System.GC.EndNoGCRegion%2A> réussisse parce que le premier appel à <xref:System.GC.TryStartNoGCRegion%2A> a réussi.</span><span class="sxs-lookup"><span data-stu-id="00615-377">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="00615-378">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-378">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="00615-379">It must be less than or equal to the size of an ephemeral segment.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-379">It must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="00615-380">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-380">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-381">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-381">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="00615-382">
            <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-382">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-383">Le <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> méthode tente de placer le garbage collector dans aucun mode de latence de région GC, qui n’autorise pas le garbage collection pendant une application exécute une zone critique de code.</span><span class="sxs-lookup"><span data-stu-id="00615-383">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="00615-384">Si le runtime ne parvient pas initialement allouer la quantité de mémoire demandée, le garbage collector effectue une garbage collection de blocage en essayant de libérer la mémoire supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="00615-384">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="00615-385">Le garbage collector passe le mode de latence sans région GC s’il est en mesure d’allouer la quantité de mémoire, ce qui est dans ce cas 2 réellement requise \* `totalSize` octets (il tente d’allouer `totalSize` octets pour le tas de petits objets et `totalSize` octets pour le tas d’objets volumineux).</span><span class="sxs-lookup"><span data-stu-id="00615-385">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` bytes (it attempts to allocate `totalSize` bytes for the small object heap and `totalSize` bytes for the large object heap).</span></span>  
  
 <span data-ttu-id="00615-386">`totalSize` doit être suffisamment grand pour gérer toutes les allocations de mémoire qui se produisent dans le chemin critique.</span><span class="sxs-lookup"><span data-stu-id="00615-386">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="00615-387">Cela inclut les allocations par l’application, ainsi que les allocations par le runtime sur le nom de l’application.</span><span class="sxs-lookup"><span data-stu-id="00615-387">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="00615-388">Vous ne pouvez pas imbriquer des appels à la <xref:System.GC.TryStartNoGCRegion%2A> (méthode) et vous devez appeler uniquement la <xref:System.GC.EndNoGCRegion%2A> méthode si le runtime est actuellement en mode de latence sans région GC.</span><span class="sxs-lookup"><span data-stu-id="00615-388">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="00615-389">En d’autres termes, vous ne devez pas appeler <xref:System.GC.TryStartNoGCRegion%2A> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <xref:System.GC.EndNoGCRegion%2A> réussisse parce que le premier appel à <xref:System.GC.TryStartNoGCRegion%2A> a réussi.</span><span class="sxs-lookup"><span data-stu-id="00615-389">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="00615-390">Vous quittez le mode sans région GC latence en appelant le <xref:System.GC.EndNoGCRegion%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-390">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="00615-391">
            <paramref name="totalSize" /> exceeds the ephemeral segment size.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-391">
              <paramref name="totalSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="00615-392">The process is already in no GC region latency mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-392">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="00615-393">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-393">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="00615-394">It must be less than or equal to the size of an ephemeral segment.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-394">It must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="00615-395">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-395">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <param name="disallowFullBlockingGC">
          <span data-ttu-id="00615-396">
            <see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <c>totalSize</c> bytes; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-396">
              <see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <c>totalSize</c> bytes; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-397">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-397">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="00615-398">
            <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-398">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-399">Le <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> méthode tente de placer le garbage collector dans aucun mode de latence de région GC, qui n’autorise pas le garbage collection pendant une application exécute une zone critique de code.</span><span class="sxs-lookup"><span data-stu-id="00615-399">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="00615-400">Si le runtime ne parvient pas initialement allouer la quantité de mémoire demandée et la `disallowFullBlockingGC` argument est `false`, le garbage collector effectue une garbage collection de blocage en essayant de libérer de la mémoire supplémentaire ; sinon, l’allocation échoue et la méthode retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="00615-400">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="00615-401">Le garbage collector passe le mode de latence sans région GC s’il est en mesure d’allouer la quantité de mémoire, ce qui est dans ce cas 2 réellement requise \* `totalSize` (il tente d’allouer `totalSize` pour le tas de petits objets et `totalSize` pour l’objet volumineux segment de mémoire).</span><span class="sxs-lookup"><span data-stu-id="00615-401">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` (it attempts to allocate `totalSize` for the small object heap and `totalSize` for the large object heap).</span></span>  
  
 <span data-ttu-id="00615-402">`totalSize` doit être suffisamment grand pour gérer toutes les allocations de mémoire qui se produisent dans le chemin critique.</span><span class="sxs-lookup"><span data-stu-id="00615-402">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="00615-403">Cela inclut les allocations par l’application, ainsi que les allocations par le runtime sur le nom de l’application.</span><span class="sxs-lookup"><span data-stu-id="00615-403">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="00615-404">Paramètre `disallowFullBlockingGC` à `true` pour empêcher un garbage de blocage complet collection s’il n’est pas suffisamment de mémoire initialement disponible est particulièrement utile dans les scénarios d’équilibrage de charge : un système peut appeler cette méthode et signaler lui-même comme prêt à accepter les demandes si elle retourne `true`, et l’équilibrage de charge rediriger les demandes vers d’autres systèmes si elle retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="00615-404">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="00615-405">Il peut ensuite faire une garbage collection de blocage quand il ne gère pas les demandes en appelant le <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-405">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="00615-406">Vous ne pouvez pas imbriquer des appels à la <xref:System.GC.TryStartNoGCRegion%2A> (méthode) et vous devez appeler uniquement la <xref:System.GC.EndNoGCRegion%2A> méthode si le runtime est actuellement en mode de latence sans région GC.</span><span class="sxs-lookup"><span data-stu-id="00615-406">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="00615-407">En d’autres termes, vous ne devez pas appeler <xref:System.GC.TryStartNoGCRegion%2A> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <xref:System.GC.EndNoGCRegion%2A> réussisse parce que le premier appel à <xref:System.GC.TryStartNoGCRegion%2A> a réussi.</span><span class="sxs-lookup"><span data-stu-id="00615-407">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="00615-408">Vous quittez le mode sans région GC latence en appelant le <xref:System.GC.EndNoGCRegion%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-408">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="00615-409">
            <paramref name="totalSize" /> exceeds the ephemeral segment size.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-409">
              <paramref name="totalSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="00615-410">The process is already in no GC region latency mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-410">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="00615-411">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-411">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="00615-412">
            <c>totalSize</c> –<c>lohSize</c> must be less than or equal to the size of an ephemeral segment.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-412">
              <c>totalSize</c> –<c>lohSize</c> must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="00615-413">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-413">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <param name="lohSize">
          <span data-ttu-id="00615-414">The number of bytes in <c>totalSize</c> to use for large object heap (LOH) allocations.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-414">The number of bytes in <c>totalSize</c> to use for large object heap (LOH) allocations.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-415">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-415">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="00615-416">
            <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-416">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-417">Le <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> méthode tente de placer le garbage collector dans aucun mode de latence de région GC, qui n’autorise pas le garbage collection pendant une application exécute une zone critique de code.</span><span class="sxs-lookup"><span data-stu-id="00615-417">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="00615-418">Si le runtime ne parvient pas initialement allouer la quantité de mémoire demandée, le garbage collector effectue une garbage collection de blocage en essayant de libérer la mémoire supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="00615-418">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="00615-419">Le garbage collector passe le mode de latence sans région GC s’il est en mesure d’allouer `lohSize` pour le LOH et `totalSize` – `lohSize` pour le tas de petits objets (SOH).</span><span class="sxs-lookup"><span data-stu-id="00615-419">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="00615-420">`lohSize` doit être suffisamment grand pour gérer toutes les allocations de mémoire qui se produisent dans le chemin critique pour le LOH, et `totalSize` – `lohSize` doit être suffisamment grand pour gérer toutes les allocations de mémoire qui se produisent dans le chemin critique pour la déclaration d’intégrité.</span><span class="sxs-lookup"><span data-stu-id="00615-420">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="00615-421">Cela inclut les allocations par l’application, ainsi que les allocations par le runtime sur le nom de l’application.</span><span class="sxs-lookup"><span data-stu-id="00615-421">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="00615-422">Vous ne pouvez pas imbriquer des appels à la <xref:System.GC.TryStartNoGCRegion%2A> (méthode) et vous devez appeler uniquement la <xref:System.GC.EndNoGCRegion%2A> méthode si le runtime est actuellement en mode de latence sans région GC.</span><span class="sxs-lookup"><span data-stu-id="00615-422">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="00615-423">En d’autres termes, vous ne devez pas appeler <xref:System.GC.TryStartNoGCRegion%2A> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <xref:System.GC.EndNoGCRegion%2A> réussisse parce que le premier appel à <xref:System.GC.TryStartNoGCRegion%2A> a réussi.</span><span class="sxs-lookup"><span data-stu-id="00615-423">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="00615-424">Vous quittez le mode sans région GC latence en appelant le <xref:System.GC.EndNoGCRegion%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-424">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="00615-425">
            <paramref name="totalSize" /> – <paramref name="lohSize" /> exceeds the ephemeral segment size.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-425">
              <paramref name="totalSize" /> – <paramref name="lohSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="00615-426">The process is already in no GC region latency mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-426">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="00615-427">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-427">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="00615-428">
            <c>totalSize</c> –<c>lohSize</c> must be less than or equal to the size of an ephemeral segment.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-428">
              <c>totalSize</c> –<c>lohSize</c> must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="00615-429">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-429">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <param name="lohSize">
          <span data-ttu-id="00615-430">The number of bytes in <c>totalSize</c> to use for large object heap (LOH) allocations.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-430">The number of bytes in <c>totalSize</c> to use for large object heap (LOH) allocations.</span>
          </span>
        </param>
        <param name="disallowFullBlockingGC">
          <span data-ttu-id="00615-431">
            <see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-431">
              <see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-432">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-432">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="00615-433">
            <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-433">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-434">Le <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> méthode tente de placer le garbage collector dans aucun mode de latence de région GC, qui n’autorise pas le garbage collection pendant une application exécute une zone critique de code.</span><span class="sxs-lookup"><span data-stu-id="00615-434">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="00615-435">Si le runtime ne parvient pas initialement allouer la quantité de mémoire demandée et la `disallowFullBlockingGC` argument est `false`, le garbage collector effectue une garbage collection de blocage en essayant de libérer de la mémoire supplémentaire ; sinon, l’allocation échoue et la méthode retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="00615-435">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="00615-436">Le garbage collector passe le mode de latence sans région GC s’il est en mesure d’allouer `lohSize` pour le LOH et `totalSize` – `lohSize` pour le tas de petits objets (SOH).</span><span class="sxs-lookup"><span data-stu-id="00615-436">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="00615-437">`lohSize` doit être suffisamment grand pour gérer toutes les allocations de mémoire qui se produisent dans le chemin critique pour le LOH, et `totalSize` – `lohSize` doit être suffisamment grand pour gérer toutes les allocations de mémoire qui se produisent dans le chemin critique pour la déclaration d’intégrité.</span><span class="sxs-lookup"><span data-stu-id="00615-437">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="00615-438">Cela inclut les allocations par l’application, ainsi que les allocations par le runtime sur le nom de l’application.</span><span class="sxs-lookup"><span data-stu-id="00615-438">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="00615-439">Paramètre `disallowFullBlockingGC` à `true` pour empêcher un garbage de blocage complet collection s’il n’est pas suffisamment de mémoire initialement disponible est particulièrement utile dans les scénarios d’équilibrage de charge : un système peut appeler cette méthode et signaler lui-même comme prêt à accepter les demandes si elle retourne `true`, et l’équilibrage de charge rediriger les demandes vers d’autres systèmes si elle retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="00615-439">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="00615-440">Il peut ensuite faire une garbage collection de blocage quand il ne gère pas les demandes en appelant le <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-440">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="00615-441">Vous ne pouvez pas imbriquer des appels à la <xref:System.GC.TryStartNoGCRegion%2A> (méthode) et vous devez appeler uniquement la <xref:System.GC.EndNoGCRegion%2A> méthode si le runtime est actuellement en mode de latence sans région GC.</span><span class="sxs-lookup"><span data-stu-id="00615-441">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="00615-442">En d’autres termes, vous ne devez pas appeler <xref:System.GC.TryStartNoGCRegion%2A> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <xref:System.GC.EndNoGCRegion%2A> réussisse parce que le premier appel à <xref:System.GC.TryStartNoGCRegion%2A> a réussi.</span><span class="sxs-lookup"><span data-stu-id="00615-442">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="00615-443">Vous quittez le mode sans région GC latence en appelant le <xref:System.GC.EndNoGCRegion%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-443">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="00615-444">
            <paramref name="totalSize" /> – <paramref name="lohSize" /> exceeds the ephemeral segment size.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-444">
              <paramref name="totalSize" /> – <paramref name="lohSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="00615-445">The process is already in no GC region latency mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-445">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="00615-446">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-446">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="00615-447">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-447">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="00615-448">The status of the registered garbage collection notification.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-448">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-449">Utilisez le <xref:System.GCNotificationStatus> énumération retournée par cette méthode pour déterminer l’état de la notification de garbage collection actuelle qui a été inscrite à l’aide de la <xref:System.GC.RegisterForFullGCNotification%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-449">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="00615-450">Vous pouvez également utiliser le <xref:System.GC.WaitForFullGCComplete%2A> méthode pour déterminer si la garbage collection complet est terminé.</span><span class="sxs-lookup"><span data-stu-id="00615-450">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="00615-451">Lorsque l’énumération retourne <xref:System.GCNotificationStatus.Succeeded>, vous pouvez effectuer des tâches telles que des objets supplémentaires empêchant d’allouées et induire vous-même une collection avec la <xref:System.GC.Collect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-451">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="00615-452">Notez que la notification ne garantit pas qu’une garbage collection complet se produira, uniquement qui conditions ont atteint le seuil auquel un garbage collection complet se produise.</span><span class="sxs-lookup"><span data-stu-id="00615-452">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="00615-453">Cette méthode attend indéfiniment une notification de garbage collection doit être obtenu.</span><span class="sxs-lookup"><span data-stu-id="00615-453">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="00615-454">Si vous souhaitez spécifier un délai d’attente pour la méthode à retourner si la notification ne peut pas être obtenue, utilisez le <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="00615-454">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="00615-455">Si vous appelez cette méthode sans spécifier un délai d’attente, vous pouvez appeler la <xref:System.GC.CancelFullGCNotification%2A> méthode si vous attendez plus longtemps que préféré.</span><span class="sxs-lookup"><span data-stu-id="00615-455">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="00615-456">Vous devez suivre cette méthode avec un appel à la <xref:System.GC.WaitForFullGCComplete%2A> méthode pour vous assurer que vous avez eu une garbage collection complet.</span><span class="sxs-lookup"><span data-stu-id="00615-456">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="00615-457">L’appel de cette méthode seule donne des résultats indéterminés.</span><span class="sxs-lookup"><span data-stu-id="00615-457">Calling this method alone causes indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00615-458">L’exemple suivant montre comment utiliser cette méthode pour déterminer si une opération garbage collection de blocage complète est proche.</span><span class="sxs-lookup"><span data-stu-id="00615-458">The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching.</span></span> <span data-ttu-id="00615-459">Chaque fois que l’état de la notification est <xref:System.GCNotificationStatus.Succeeded>, la méthode utilisateur `OnFullGCApproachNotify` est appelée pour effectuer des actions en réponse à la collection.</span><span class="sxs-lookup"><span data-stu-id="00615-459">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCApproachNotify` is called to perform actions in response to the approaching collection.</span></span> <span data-ttu-id="00615-460">Cet exemple de code fait partie d’un exemple plus complet fourni pour [Notifications de Garbage Collection](~/docs/standard/garbage-collection/notifications.md) rubrique.</span><span class="sxs-lookup"><span data-stu-id="00615-460">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="00615-461">pour la confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-461">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="00615-462">Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-462">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="00615-463">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-463">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="00615-464">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-464">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="00615-465">The length of time to wait before a notification status can be obtained.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-465">The length of time to wait before a notification status can be obtained.</span>
          </span>
          <span data-ttu-id="00615-466">Specify -1 to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-466">Specify -1 to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-467">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-467">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="00615-468">The status of the registered garbage collection notification.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-468">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-469">Utilisez le <xref:System.GCNotificationStatus> énumération retournée par cette méthode pour déterminer l’état de la notification de garbage collection actuelle qui a été inscrite à l’aide de la <xref:System.GC.RegisterForFullGCNotification%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-469">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="00615-470">Vous pouvez également utiliser le <xref:System.GC.WaitForFullGCComplete%2A> méthode pour déterminer si la garbage collection complet est terminé.</span><span class="sxs-lookup"><span data-stu-id="00615-470">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="00615-471">Notez que cette méthode retourne immédiatement chaque fois qu’un état de notification de garbage collection est obtenu, quelle que soit la valeur spécifiée par `millisecondsTimeout`.</span><span class="sxs-lookup"><span data-stu-id="00615-471">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="00615-472">Si un état de notification de garbage collection n’est pas obtenu avant `millisecondsTimeout` heures, cette méthode retourne <xref:System.GCNotificationStatus.NotApplicable>.</span><span class="sxs-lookup"><span data-stu-id="00615-472">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="00615-473">Lorsque l’énumération retourne <xref:System.GCNotificationStatus.Succeeded>, vous pouvez effectuer des tâches telles que des objets supplémentaires empêchant d’allouées et induire vous-même une collection avec la <xref:System.GC.Collect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-473">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="00615-474">Notez que la notification ne garantit pas qu’une garbage collection complet se produira, uniquement qui conditions ont atteint le seuil auquel un garbage collection complet se produise.</span><span class="sxs-lookup"><span data-stu-id="00615-474">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="00615-475">Vous pouvez appeler la <xref:System.GC.CancelFullGCNotification%2A> méthode lorsque vous ne pouvez pas attendre la période de délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="00615-475">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="00615-476">Vous devez suivre cette méthode avec un appel à la <xref:System.GC.WaitForFullGCComplete%2A> méthode pour vous assurer que vous avez eu une garbage collection complet.</span><span class="sxs-lookup"><span data-stu-id="00615-476">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="00615-477">L’appel de cette méthode seule donne des résultats indéterminés.</span><span class="sxs-lookup"><span data-stu-id="00615-477">Calling this method alone causes indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="00615-478">
            <paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-478">
              <paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="00615-479">pour la confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-479">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="00615-480">Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-480">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="00615-481">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-481">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="00615-482">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-482">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="00615-483">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-483">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="00615-484">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-484">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="00615-485">The status of the registered garbage collection notification.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-485">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-486">Utilisez le <xref:System.GCNotificationStatus> énumération retournée par cette méthode pour déterminer l’état de la notification de garbage collection actuelle qui a été inscrite à l’aide de la <xref:System.GC.RegisterForFullGCNotification%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-486">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="00615-487">Vous pouvez également utiliser le <xref:System.GC.WaitForFullGCApproach%2A> méthode pour déterminer si une garbage collection complet est imminente.</span><span class="sxs-lookup"><span data-stu-id="00615-487">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="00615-488">Lorsque l’énumération retourne <xref:System.GCNotificationStatus.Succeeded>, vous pouvez effectuer des tâches telles que la reprise du travail et obtenir le nombre de collection avec le <xref:System.GC.CollectionCount%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="00615-488">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="00615-489">Cette méthode attend indéfiniment une notification de garbage collection doit être obtenu.</span><span class="sxs-lookup"><span data-stu-id="00615-489">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="00615-490">Si vous souhaitez spécifier un délai d’attente pour la méthode à retourner si la notification ne peut pas être obtenue, utilisez le <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="00615-490">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="00615-491">Si vous appelez cette méthode sans spécifier un délai d’attente, vous pouvez appeler la <xref:System.GC.CancelFullGCNotification%2A> méthode si vous attendez plus longtemps que préféré.</span><span class="sxs-lookup"><span data-stu-id="00615-491">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="00615-492">Cet appel de méthode doit être précédé d’un appel à la <xref:System.GC.WaitForFullGCApproach%2A> méthode pour vous assurer que vous avez eu une garbage collection complet.</span><span class="sxs-lookup"><span data-stu-id="00615-492">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="00615-493">L’appel de cette méthode seule peut produire des résultats indéterminés.</span><span class="sxs-lookup"><span data-stu-id="00615-493">Calling this method alone can produce indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00615-494">L’exemple suivant montre comment utiliser cette méthode pour déterminer si une garbage collection complet est terminé.</span><span class="sxs-lookup"><span data-stu-id="00615-494">The following example shows how to use this method to determine whether a full garbage collection has completed.</span></span> <span data-ttu-id="00615-495">Chaque fois que l’état de la notification est <xref:System.GCNotificationStatus.Succeeded>, la méthode utilisateur `OnFullGCCompletedNotify` est appelée pour effectuer des actions en réponse à la collection terminée.</span><span class="sxs-lookup"><span data-stu-id="00615-495">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCCompletedNotify` is called to perform actions in response to the completed collection.</span></span> <span data-ttu-id="00615-496">Cet exemple de code fait partie d’un exemple plus complet fourni pour [Notifications de Garbage Collection](~/docs/standard/garbage-collection/notifications.md) rubrique.</span><span class="sxs-lookup"><span data-stu-id="00615-496">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="00615-497">pour la confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-497">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="00615-498">Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-498">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="00615-499">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-499">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="00615-500">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-500">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="00615-501">The length of time to wait before a notification status can be obtained.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-501">The length of time to wait before a notification status can be obtained.</span>
          </span>
          <span data-ttu-id="00615-502">Specify -1 to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-502">Specify -1 to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="00615-503">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-503">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="00615-504">The status of the registered garbage collection notification.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-504">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-505">Utilisez le <xref:System.GCNotificationStatus> énumération retournée par cette méthode pour déterminer l’état de la notification de garbage collection actuelle qui a été inscrite à l’aide de la <xref:System.GC.RegisterForFullGCNotification%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="00615-505">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="00615-506">Vous pouvez également utiliser le <xref:System.GC.WaitForFullGCApproach%2A> méthode pour déterminer si une garbage collection complet est imminente.</span><span class="sxs-lookup"><span data-stu-id="00615-506">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="00615-507">Notez que cette méthode retourne immédiatement chaque fois qu’un état de notification de garbage collection est obtenu, quelle que soit la valeur spécifiée par `millisecondsTimeout`.</span><span class="sxs-lookup"><span data-stu-id="00615-507">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="00615-508">Si un état de notification de garbage collection n’est pas obtenu avant `millisecondsTimeout` heures, cette méthode retourne <xref:System.GCNotificationStatus.NotApplicable>.</span><span class="sxs-lookup"><span data-stu-id="00615-508">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="00615-509">Lorsque l’énumération retourne <xref:System.GCNotificationStatus.Succeeded>, vous pouvez effectuer des tâches telles que la reprise du travail et obtenir le nombre de collection avec le <xref:System.GC.CollectionCount%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="00615-509">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="00615-510">Vous pouvez appeler la <xref:System.GC.CancelFullGCNotification%2A> méthode lorsque vous ne pouvez pas attendre la période de délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="00615-510">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="00615-511">Cet appel de méthode doit être précédé d’un appel à la <xref:System.GC.WaitForFullGCApproach%2A> méthode pour vous assurer que vous avez eu une garbage collection complet.</span><span class="sxs-lookup"><span data-stu-id="00615-511">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="00615-512">L’appel de cette méthode seule peut produire des résultats indéterminés.</span><span class="sxs-lookup"><span data-stu-id="00615-512">Calling this method alone can produce indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="00615-513">
            <paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-513">
              <paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="00615-514">pour la confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-514">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="00615-515">Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-515">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="00615-516">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-516">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="00615-517">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-517">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="00615-518">Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</span>
          <span class="sxs-lookup">
            <span data-stu-id="00615-518">Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00615-519">Lorsque le garbage collector recherche les objets qui peuvent être récupérées, il vérifie chaque objet pour déterminer les exigences de la finalisation de l’objet.</span><span class="sxs-lookup"><span data-stu-id="00615-519">When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.</span></span> <span data-ttu-id="00615-520">Si un objet implémente un finaliseur et n’a pas désactivé la finalisation en appelant <xref:System.GC.SuppressFinalize%2A>, l’objet est placé dans une liste d’objets qui sont marquées comme prêtes pour la finalisation.</span><span class="sxs-lookup"><span data-stu-id="00615-520">If an object implements a finalizer and has not disabled finalization by calling <xref:System.GC.SuppressFinalize%2A>, the object is placed in a list of objects that are marked as ready for finalization.</span></span> <span data-ttu-id="00615-521">Le garbage collector appelle la <xref:System.Object.Finalize%2A> méthodes pour les objets dans cette liste et supprime les entrées dans la liste.</span><span class="sxs-lookup"><span data-stu-id="00615-521">The garbage collector calls the <xref:System.Object.Finalize%2A> methods for the objects in this list and removes the entries from the list.</span></span> <span data-ttu-id="00615-522">Cette méthode se bloque jusqu'à ce que tous les finaliseurs s’exécutaient jusqu'à la fin.</span><span class="sxs-lookup"><span data-stu-id="00615-522">This method blocks until all finalizers have run to completion.</span></span>  
  
 <span data-ttu-id="00615-523">Le thread sur lequel les finaliseurs sont exécutés n’est pas spécifié, il n’existe aucune garantie que cette méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="00615-523">The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.</span></span> <span data-ttu-id="00615-524">Cependant, ce thread peut être interrompu par un autre thread pendant le <xref:System.GC.WaitForPendingFinalizers%2A> méthode est en cours.</span><span class="sxs-lookup"><span data-stu-id="00615-524">However, this thread can be interrupted by another thread while the <xref:System.GC.WaitForPendingFinalizers%2A> method is in progress.</span></span> <span data-ttu-id="00615-525">Par exemple, vous pouvez démarrer un autre thread qui attend pendant une période de temps, puis interrompt ce thread si ce thread est toujours suspendu.</span><span class="sxs-lookup"><span data-stu-id="00615-525">For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00615-526">L’exemple suivant montre comment utiliser le <xref:System.GC.WaitForPendingFinalizers%2A> méthode pour interrompre le thread actuel jusqu'à la fin de la finalisation de tous les objets collectés.</span><span class="sxs-lookup"><span data-stu-id="00615-526">The following example demonstrates how to use the <xref:System.GC.WaitForPendingFinalizers%2A> method to suspend the current thread until finalization of all the collected objects is complete.</span></span>  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>