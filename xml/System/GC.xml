<Type Name="GC" FullName="System.GC">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="49d7f123c5b7e13096e48237964ba4928d5d2ae9" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52244358" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Contrôle le garbage collector du système, un service qui récupère automatiquement la mémoire inutilisée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le garbage collector est un composant du common language runtime qui contrôle l’allocation et la libération de mémoire managée. Les méthodes dans cette classe influencent lorsque le garbage collection est effectué sur un objet lorsque les ressources allouées par un objet sont libérées. Propriétés de cette classe fournissent des informations sur la quantité totale de mémoire disponible dans le système et la catégorie d’âge ou la génération, de mémoire allouée à un objet.  
  
 Le garbage collector effectue le suivi et libère des objets alloués dans la mémoire managée. Périodiquement, le garbage collector exécute le garbage collection pour libérer de la mémoire allouée aux objets pour lesquels il n’existe pas de références valides. Le garbage collection se produit automatiquement quand une demande de mémoire ne peut pas être satisfaite à l’aide de la mémoire disponible. Une application peut également forcer un garbage collection à l’aide du <xref:System.GC.Collect%2A> (méthode).  
  
 Le garbage collection se compose des étapes suivantes :  
  
1.  Le garbage collector recherche les objets managés qui sont référencés dans le code managé.  
  
2.  Le garbage collector tente de finaliser des objets qui ne sont pas référencés.  
  
3.  Le garbage collector libère des objets qui ne sont pas référencés et récupère leur mémoire.  
  
 Cette rubrique comporte les sections suivantes :  
  
 [Le garbage collector et les ressources non managées](#unmanaged)   
 [Vieillissement des objets et des générations](#generations)   
 [Interdire le garbage collection](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a>Le garbage collector et les ressources non managées  
 Au cours d’une collection, le garbage collector ne libère pas un objet s’il trouve une ou plusieurs références à l’objet dans le code managé. Toutefois, le garbage collector ne reconnaît pas les références à un objet à partir de code non managé et peut libérer des objets qui sont utilisés exclusivement en code non managé, sauf si explicitement empêché. Le <xref:System.GC.KeepAlive%2A> méthode fournit un mécanisme qui empêche le garbage collector de collecter des objets qui sont en cours d’utilisation dans le code non managé.  
  
 À l’exception des allocations de mémoire managée, les implémentations du garbage collector ne conservent pas les informations sur les ressources détenues par un objet, telles que les descripteurs de fichiers ou des connexions de base de données. Lorsqu’un type utilise des ressources non managées doivent être libérées avant que les instances du type sont récupérés, le type peut implémenter un finaliseur.  
  
 Dans la plupart des cas, les finaliseurs sont implémentés en substituant la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> méthode ; Toutefois, les types écrits en c# ou C++ implémentent des destructeurs que les compilateurs transforment en une substitution de <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. Dans la plupart des cas, si un objet a un finaliseur, le garbage collector l’appelle avant de libérer l’objet. Toutefois, le garbage collector n’est pas nécessaire d’appeler les finaliseurs dans toutes les situations ; par exemple, le <xref:System.GC.SuppressFinalize%2A> méthode empêche explicitement un finaliseur d’objet d’être appelée. En outre, le garbage collector n’est pas nécessaire d’utiliser un thread spécifique pour finaliser les objets, ou garantit l’ordre dans lequel les finaliseurs sont appelés pour les objets qui se référencent mutuellement, mais sont disponibles pour le garbage collection.  
  
 Dans les scénarios où les ressources doivent être libérées à un moment donné, les classes peuvent implémenter la <xref:System.IDisposable> interface, qui contient le <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> méthode qui effectue les tâches de gestion et de nettoyage des ressources. Classes qui implémentent <xref:System.IDisposable.Dispose%2A> doit spécifier, dans le cadre de leur contrat, si et quand les consommateurs de classe appellent la méthode pour nettoyer l’objet. Le garbage collector ne pas, par défaut, appelez le <xref:System.IDisposable.Dispose%2A> (méthode) ; Toutefois, les implémentations de la <xref:System.IDisposable.Dispose%2A> méthode peut appeler des méthodes dans la <xref:System.GC> classe pour personnaliser le comportement de la finalisation du garbage collector.  
  
 Pour plus d’informations sur la finalisation de l’objet et le modèle de suppression, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a>Vieillissement des objets et des générations  
 Le garbage collector dans le common language runtime prend en charge le vieillissement des objets à l’aide de générations. Une génération est une unité de mesure de l’âge relatif des objets en mémoire. Le numéro de génération, ou l’âge, d’un objet indique la génération à laquelle appartient un objet. Objets créés plus récemment font partie des nouvelles générations et possèdent des numéros de génération plus faibles que le cycle des objets créés précédemment dans la vie de l’application. Les objets dans la génération la plus récente sont dans la génération 0. Cette implémentation du garbage collector prend en charge trois générations d’objets, les générations 0, 1 et 2. Vous pouvez récupérer la valeur de la <xref:System.GC.MaxGeneration%2A> propriété afin de déterminer le nombre maximal de générations prises en charge par le système.  
  
 Vieillissement des objets permet aux applications de nettoyage de la cible à un ensemble spécifique de générations au lieu de demander au garbage collector évaluer toutes les générations. Les surcharges de la <xref:System.GC.Collect%2A> méthode qui incluent un `generation` paramètre permettent de spécifier la génération la plus ancienne pour être nettoyées.  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a>Interdire le garbage collection  
 En commençant par le [!INCLUDE[net_v46](~/includes/net-v46-md.md)], le garbage collector prend en charge un mode sans région GC latence qui peut être utilisé pendant l’exécution de chemins critiques dans laquelle les garbage collection peut nuire aux performances de l’application. Le mode sans région GC latence nécessite que vous spécifiez une quantité de mémoire pouvant être allouée sans interférence du garbage collector. Si le runtime peut allouer cette mémoire, le runtime ne sera pas effectuer un garbage collection pendant l’exécution de code dans le chemin critique.  
  
 Vous définissez le début du chemin critique sans région GC en appelant une des surcharges de la <xref:System.GC.TryStartNoGCRegion%2A>. Vous spécifiez la fin de son chemin d’accès critique en appelant le <xref:System.GC.EndNoGCRegion%2A> (méthode).  
  
 Vous ne pouvez pas imbriquer des appels à la <xref:System.GC.TryStartNoGCRegion%2A> (méthode) et vous devez appeler uniquement la <xref:System.GC.EndNoGCRegion%2A> méthode si le runtime est actuellement en mode de latence sans région GC. En d’autres termes, vous ne devez pas appeler <xref:System.GC.TryStartNoGCRegion%2A> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <xref:System.GC.EndNoGCRegion%2A> réussisse parce que le premier appel à <xref:System.GC.TryStartNoGCRegion%2A> a réussi.  
  
   
  
## Examples  
 L’exemple suivant utilise plusieurs méthodes GC pour obtenir la génération et les informations de mémoire sur un bloc d’objets inutilisés et l’imprimer à la console. Les objets inutilisés sont ensuite recueillies et les totaux de mémoire sont affichées.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
    <related type="Article" href="~/docs/standard/garbage-collection/index.md">Garbage Collection</related>
    <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Notions de base du garbage collection</related>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Quantité incrémentielle de mémoire non managée qui a été allouée.</param>
        <summary>Informe l’exécution d’une allocation volumineuse de mémoire non managée qui doit être prise en considération lors de la planification du garbage collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Détermination des cas planifier le garbage collection, le runtime prend en compte la quantité de mémoire managé est alloué. Si un petit objet managé alloue une grande quantité de mémoire non managée, le runtime prend en compte uniquement la mémoire managée et par conséquent sous-estime l’urgence de la planification du garbage collection. Le <xref:System.GC.AddMemoryPressure%2A> méthode informe l’exécution de cette sollicitation supplémentaire sur la mémoire système.  
  
 Dans le modèle d’utilisation la plus simple, un objet managé alloue la mémoire non managée dans le constructeur et la libère dans la `Dispose` ou `Finalize` (méthode). Appelez le <xref:System.GC.AddMemoryPressure%2A> méthode après avoir alloué la mémoire non managée et appelez le <xref:System.GC.RemoveMemoryPressure%2A> méthode après l’avoir libéré.  
  
 Dans les scénarios plus complexes, où l’allocation de mémoire non managée change substantiellement pendant la durée de vie de l’objet managé, vous pouvez appeler la <xref:System.GC.AddMemoryPressure%2A> et <xref:System.GC.RemoveMemoryPressure%2A> méthodes permettant de communiquer ces modifications incrémentielles à l’exécution.  
  
> [!CAUTION]
>  Vous devez vous assurer que vous supprimez la quantité exacte de pression que vous ajoutez. Ne parvient pas à le faire peut nuire aux performances du système dans les applications qui s’exécutent pendant de longues périodes de temps.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bytesAllocated" /> est inférieur ou égal à 0.  
  
- ou - 
Sur un ordinateur à 32 bits, <paramref name="bytesAllocated" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la manipulation de priorité de garbage collection. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annule l’inscription de la notification de garbage collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode annule une notification de garbage collection qui a été inscrite à l’aide de la <xref:System.GC.RegisterForFullGCNotification%2A> (méthode). Il est inutile d’appeler cette méthode avant de régler les valeurs de paramètre de seuil dans les appels suivants à la <xref:System.GC.RegisterForFullGCNotification%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant annule une inscription de garbage collection. Cet exemple fait partie d’un exemple plus complet fourni pour le [Notifications de Garbage Collection](~/docs/standard/garbage-collection/notifications.md) rubrique.  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ce membre n’est pas disponible quand le garbage collection simultané est activé. Pour plus d’informations sur la désactivation d’une opération garbage collection simultanée, consultez le paramètre d’exécution [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Notifications de garbage collection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Force un garbage collection.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Force un garbage collection immédiat sur toutes les générations.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour tenter de récupérer toute la mémoire qui n’est pas accessible. Il effectue une garbage collection de blocage de toutes les générations.  
  
 Tous les objets, quelle que soit la durée pendant laquelle ils ont été en mémoire, sont considérées comme dans la collection ; Toutefois, les objets qui sont référencés dans le code managé ne sont pas collectés. Utilisez cette méthode pour forcer le système à tenter de récupérer la quantité maximale de mémoire disponible.  
  
 En commençant par le [!INCLUDE[net_v451](~/includes/net-v451-md.md)], vous pouvez également compacter le tas d’objets volumineux (LOH) en définissant le <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propriété <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> avant d’appeler le <xref:System.GC.Collect%2A> (méthode), comme dans l’exemple suivant illustre.  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.GC.Collect%2A> méthode pour exécuter une collecte sur toutes les générations de mémoire. Le code génère un nombre d’objets inutilisés, puis appelle la <xref:System.GC.Collect%2A> méthode pour les supprimer de la mémoire.  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">Collections forcées</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">Numéro de la génération la plus ancienne devant faire l'objet d'un garbage collection.</param>
        <summary>Force un garbage collection immédiat de la génération 0 jusqu'à une génération spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour tenter de récupérer la mémoire qui n’est pas accessible. Toutefois, à l’aide de cette méthode ne garantit pas que la mémoire inaccessible dans la génération spécifiée soit libérée.  
  
 Si le vieillissement des objets est implémenté, le garbage collector ne collecte pas les objets avec un numéro de génération qui est supérieur à la génération spécifiée. Si la chronologie de l’objet n’est pas implémentée, le garbage collector considère que tous les objets pendant le garbage collection.  
  
 Utilisez le <xref:System.GC.MaxGeneration%2A> propriété afin de déterminer la valeur maximale valide de le `generation` paramètre.  
  
 Pour que le garbage collector considère tous les objets, quel que soit leur génération, utilisez la version de cette méthode qui n’accepte aucun paramètre. Pour que le garbage collector récupère les objets selon un <xref:System.GCCollectionMode> , utilisez le <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> surcharge de méthode.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.GC.Collect%2A> méthode pour effectuer un regroupement sur des couches individuelles de mémoire. Le code génère un nombre d’objets inutilisés, puis appelle la <xref:System.GC.Collect%2A> méthode pour les supprimer de la mémoire.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> n'est pas valide.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">Collections forcées</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
      </Parameters>
      <Docs>
        <param name="generation">Numéro de la génération la plus ancienne devant faire l'objet d'un garbage collection.</param>
        <param name="mode">Valeur d'énumération qui spécifie si le garbage collection est forcé (<see cref="F:System.GCCollectionMode.Default" /> ou <see cref="F:System.GCCollectionMode.Forced" />) ou optimisé (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <summary>Force un garbage collection de la génération 0 jusqu'à une génération spécifiée, à une heure indiquée par une valeur <see cref="T:System.GCCollectionMode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le `mode` paramètre pour spécifier si le garbage collection doit être effectuée immédiatement ou uniquement si le moment est opportun pour récupérer des objets. À l’aide de cette méthode ne garantit pas que la mémoire inaccessible dans la génération spécifiée soit libérée.  
  
 Pour ajuster le niveau d’intrusion du garbage collection pendant des périodes critiques dans votre application, définissez le <xref:System.Runtime.GCSettings.LatencyMode%2A> propriété.  
  
 Le garbage collector ne collecte pas les objets avec un numéro de génération supérieur à celui spécifié par le `generation` paramètre. Utilisez le <xref:System.GC.MaxGeneration%2A> propriété afin de déterminer la valeur maximale valide de `generation`.  
  
 Pour que le garbage collector considère tous les objets, quel que soit leur génération, utilisez la version de cette méthode qui n’accepte aucun paramètre.  
  
 Pour que le garbage collector récupère des objets jusqu'à une génération spécifiée d’objets, utilisez le <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> surcharge de méthode. Lorsque vous spécifiez la génération maximale, tous les objets sont collectés.  
  
   
  
## Examples  
 L’exemple suivant force un garbage collection pour les objets de génération 2 avec le <xref:System.GCCollectionMode.Optimized> paramètre.  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> n'est pas valide.  
  
- ou - 
 <paramref name="mode" /> ne fait pas partie des valeurs <see cref="T:System.GCCollectionMode" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">Collections forcées</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">Numéro de la génération la plus ancienne devant faire l'objet d'un garbage collection.</param>
        <param name="mode">Valeur d'énumération qui spécifie si le garbage collection est forcé (<see cref="F:System.GCCollectionMode.Default" /> ou <see cref="F:System.GCCollectionMode.Forced" />) ou optimisé (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">
          <see langword="true" /> pour effectuer un garbage collection de blocage ; <see langword="false" /> pour effectuer un garbage collection d'arrière-plan, si possible.</param>
        <summary>Force un garbage collection de la génération 0 jusqu'à une génération spécifiée, à une heure indiquée par une valeur <see cref="T:System.GCCollectionMode" />, avec une valeur indiquant si le garbage collection doit effectuer le blocage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant résume l’interaction de le `mode` et `blocking` paramètres :  
  
|`mode`|`blocking` a la valeur `true`.|`blocking` a la valeur `false`.|  
|-|-|-|  
|<xref:System.GCCollectionMode.Forced> ou <xref:System.GCCollectionMode.Default>|Une collection de blocage est exécutée dès que possible. Si une collection d’arrière-plan est en cours et `generation` est 0 ou 1, le <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> méthode déclenche une collection de blocage immédiatement et retourne quand la collection est terminée. Si une collection d’arrière-plan est en cours et `generation` est 2, la méthode attend la collection d’arrière-plan est terminée, déclenche une collection de génération 2 blocage et renvoie.|Une collection est exécutée dès que possible. La méthode <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> demande une collection d'arrière-plan, mais cela n'est pas garanti ; selon les cas, une collection bloquante peut toujours être exécutée. Si une collection d’arrière-plan est déjà en cours, la méthode retourne immédiatement une valeur.|  
|<xref:System.GCCollectionMode.Optimized>|Une collecte bloquante peut être exécutée, selon l'état du récupérateur de mémoire et du paramètre `generation`. Le Garbage collector tente de fournir des performances optimales.|Une collection de blocage peut être effectuée, en fonction de l’état du Garbage collector. La méthode <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> demande une collection d'arrière-plan, mais cela n'est pas garanti ; selon les cas, une collection bloquante peut toujours être exécutée. Le Garbage collector tente de fournir des performances optimales. Si une collection d’arrière-plan est déjà en cours, la méthode retourne immédiatement une valeur.|  
  
 Si un appel à la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> méthode effectue une garbage collection de blocage, vous pouvez également compacter le tas d’objets volumineux en définissant le <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propriété <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> avant d’appeler le <xref:System.GC.Collect%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> n'est pas valide.  
  
- ou - 
 <paramref name="mode" /> ne fait pas partie des valeurs <see cref="T:System.GCCollectionMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
        <Parameter Name="compacting" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">Numéro de la génération la plus ancienne devant faire l'objet d'un garbage collection.</param>
        <param name="mode">Valeur d'énumération qui spécifie si le garbage collection est forcé (<see cref="F:System.GCCollectionMode.Default" /> ou <see cref="F:System.GCCollectionMode.Forced" />) ou optimisé (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">
          <see langword="true" /> pour effectuer un garbage collection de blocage ; <see langword="false" /> pour effectuer un garbage collection d'arrière-plan, si possible.</param>
        <param name="compacting">
          <see langword="true" /> pour compacter le tas de petits objets. <see langword="false" /> pour effectuer un balayage uniquement.</param>
        <summary>Force un garbage collection de la génération 0 jusqu'à une génération spécifiée, à une heure indiquée par une valeur <see cref="T:System.GCCollectionMode" />, avec des valeurs indiquant si le garbage collection doit effectuer le blocage et le compactage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `blocking` est `false`, le GC décide s’il faut effectuer un arrière-plan ou une garbage collection de blocage. Si `compacting` est `true`, il effectue une garbage collection de blocage.  
  
 Si `compacting` est `true`, le runtime compacte le tas de petits objets (SOH). Le tas d’objets volumineux (LOH) n’est pas compacté, sauf si le <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propriété est définie sur <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>. Notez que cela inclut tous les garbage collections de blocage, pas simplement tous les garbage collections bloquants.  
  
 Vous pouvez appeler la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> méthode afin de réduire le tas managé la plus petite taille possible, comme l’illustre le fragment de code suivant.  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 Spécification `true` pour le `compacting` argument garantit une compactage, complète garbage collection de blocage. Définition de la <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propriété <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> garantit que le LOH et la déclaration d’intégrité sont compactées.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">Génération d'objets pour lesquels le compteur de garbage collection doit être déterminé.</param>
        <summary>Retourne le nombre de fois que le garbage collection s’est produit pour la génération d’objets spécifiée.</summary>
        <returns>Nombre de fois où le garbage collection s’est produit pour la génération spécifiée, depuis que le processus a été démarré.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous implémentez votre propre gestion des ressources, vous devrez peut-être forcer le garbage collection régulièrement en appelant le <xref:System.GC.Collect%2A> (méthode). Comme il s’agit d’une opération coûteuse, vous pouvez améliorer les performances en ignorant l’appel lorsqu’un garbage collection s’est produite récemment. Enregistrez la valeur retournée par <xref:System.GC.CollectionCount%2A> immédiatement après l’appel <xref:System.GC.Collect%2A>. La prochaine fois que vous devez appeler <xref:System.GC.Collect%2A>, comparer la valeur actuelle retournée par <xref:System.GC.CollectionCount%2A> à la valeur enregistrée. Si les deux valeurs sont égales, aucune collection se n’est produite dans l’intervalle et il est raisonnable d’appeler <xref:System.GC.Collect%2A> à nouveau.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> est inférieur à 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termine le mode de latence sans région GC.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.GC.EndNoGCRegion%2A> méthode lève un <xref:System.InvalidOperationException> si le garbage collector n’est pas en mode de latence sans région GC. Cela se produit si l’une des conditions suivantes :  
  
-   Le <xref:System.GC.TryStartNoGCRegion%2A> (méthode) n’a pas été appelée précédemment.  
  
-   L’appel à la <xref:System.GC.TryStartNoGCRegion%2A> méthode retournée `false`.  
  
-   L’appel à la <xref:System.GC.TryStartNoGCRegion%2A> méthode a levé une exception.  
  
 Vous pouvez éviter qu’une exception pour une des raisons suivantes à l’aide de code semblable au suivant :  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le garbage collector n’est pas en mode de latence sans région GC.  
  
- ou - 
Le mode de latence sans région GC a été interrompu précédemment, car un garbage collection a été induit.  
  
- ou - 
Une allocation de mémoire a dépassé la quantité spécifiée dans l’appel à la méthode <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />.</exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Modes de latence</related>
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient le nombre total d’octets alloués au thread actuel depuis le début de sa durée de vie.</summary>
        <returns>Nombre total d’octets alloués au thread actuel depuis le début de sa durée de vie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Le `GetAllocatedBytesForCurrentThread` méthode retourne le nombre total d’octets alloués sur le tas managé pendant la durée de vie d’un thread, pas le nombre total d’octets qui ont survécu garbage collection. La valeur retournée n’inclut pas toutes les allocations natives.

Cette méthode est particulièrement utile dans l’analyse scenarious pour mesurer la différence de l’allocation de mémoire entre les intervalles de temps ou des événements.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne le numéro de la génération actuelle d'un objet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet pour lequel les informations de génération sont récupérées.</param>
        <summary>Retourne le numéro de la génération actuelle de l'objet spécifié.</summary>
        <returns>Numéro de génération actuelle de <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour déterminer l’âge d’un objet et ensuite utiliser ces informations avec la <xref:System.GC.Collect%2A> méthode pour forcer le garbage collector pour collecter des objets dans la même génération. Par exemple, utilisez cette méthode lorsque vous avez un ensemble d’objets qui sont créés en tant que groupe et qui deviennent inaccessibles en même temps.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.GC.GetGeneration%2A> méthode pour déterminer l’âge d’un objet. L’exemple effectue ensuite les garbage collection pour nettoyer la mémoire et de comparer les versions antérieures et de valider les totaux de mémoire dans la console.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" />
      </Parameters>
      <Docs>
        <param name="wo">
          <see cref="T:System.WeakReference" /> qui fait référence à l'objet cible dont le numéro de génération doit être déterminé.</param>
        <summary>Retourne le numéro de la génération actuelle de la cible d'une référence faible spécifiée.</summary>
        <returns>Numéro de génération actuelle de la cible de <paramref name="wo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.GC.GetGeneration%2A> méthode pour déterminer l’âge d’un objet de référence faible.  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le garbage collection a déjà été exécuté sur <paramref name="wo" />.</exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection">
          <see langword="true" /> pour indiquer que cette méthode peut attendre le garbage collection avant de retourner une réponse ; sinon, <see langword="false" />.</param>
        <summary>Récupère le nombre d'octets qu'il est actuellement prévu d'allouer. Un paramètre indique si cette méthode peut attendre une courte période de temps avant de retourner une réponse, pour permettre au système d'effectuer un garbage collection et de finaliser les objets.</summary>
        <returns>Nombre correspondant à la meilleure approximation possible du nombre d'octets actuellement alloués dans la mémoire managée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `forceFullCollection` paramètre est `true`, cette méthode attend un court intervalle avant de retourner tandis que le système de garbage collection et finalise les objets. La durée de l’intervalle est une limite spécifiée en interne déterminée par le nombre de garbage collection cycles terminée et la modification de la quantité de mémoire récupérée entre les cycles. Le garbage collector ne garantit pas que la mémoire inaccessible est collectée.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.GC.GetTotalMemory%2A> méthode pour obtenir et afficher le nombre d’octets actuellement alloués dans la mémoire managée.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à référencer.</param>
        <summary>Référence l’objet spécifié, ce qui le rend inéligible pour le garbage collection du début de la routine actuelle jusqu’au point où cette méthode est appelée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’objectif de la <xref:System.GC.KeepAlive%2A> méthode consiste à s’assurer de l’existence d’une référence à un objet qui risque d’être récupéré prématurément par le garbage collector. Il est fréquent où cela peut se produire lorsqu’il n’existe aucune référence à l’objet dans le code managé ou de données, mais l’objet est en cours d’utilisation dans le code non managé, telles que les API Win32, les DLL non managées, ou les méthodes à l’aide de COM.  
  
 Cette méthode référence le `obj` paramètre, rendant cet objet inéligible pour le garbage collection à partir du début de la routine au point, dans l’ordre d’exécution, où cette méthode est appelée. Cette méthode à la fin, et non au début de la plage d’instructions de code où `obj` doit être disponible.  
  
 Le <xref:System.GC.KeepAlive%2A> méthode n’effectue aucune opération et ne produit aucun effet secondaire autre que l’extension de la durée de vie de l’objet passé en tant que paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant crée un objet au début de son `Main` (méthode) et ne fait pas référence à l’objet jusqu'à la fin, lorsque le <xref:System.GC.KeepAlive%2A> méthode est appelée. L’objet persiste pendant la durée de 30 secondes de la `Main` (méthode), en dépit des appels à la <xref:System.GC.Collect%2A> et <xref:System.GC.WaitForPendingFinalizers%2A> méthodes.  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre maximal de générations actuellement pris en charge par le système.</summary>
        <value>Valeur comprise entre zéro et le nombre maximal de générations prises en charge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le numéro de génération, ou l’âge, d’un objet est une mesure relative défini par l’implémentation de la durée de vie d’un objet. Les objets plus récemment créés sont dans la génération 0 et les objets les plus anciens sont dans une génération inférieure ou égale à la génération retournée par la <xref:System.GC.MaxGeneration%2A> propriété.  
  
 Le garbage collector suppose que la mémoire la plus récente est plus susceptible d’être éligibles pour le garbage collection que la mémoire plus anciens. Par conséquent, le garbage collector améliore ses performances en ajustant les numéros de génération chaque fois qu’il récupère la mémoire, et le <xref:System.GC.MaxGeneration%2A> valeur de propriété peut augmenter au fil du temps.  
  
 Si le vieillissement des objets est implémenté, la <xref:System.GC.MaxGeneration%2A> propriété retourne le nombre maximal de générations utilisé par le système ; sinon, cette propriété retourne la valeur zéro.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser la propriété MaxGeneration pour afficher le plus grand nombre de génération actuellement en cours d’utilisation.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Pour cette implémentation, la valeur retournée par la <see cref="P:System.GC.MaxGeneration" /> propriété est garantie reste constante pour la durée de vie d’une application en cours d’exécution.  
  
Utilisez le <see cref="P:System.GC.MaxGeneration" /> propriété afin de déterminer la valeur maximale que vous pouvez spécifier lors de l’appel la <see cref="M:System.GC.Collect(System.Int32)" /> méthode qui accepte un paramètre de génération.</para>
        </block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">Nombre entre 1 et 99 qui spécifie le moment auquel la notification doit être émise selon les objets alloués dans la génération 2.</param>
        <param name="largeObjectHeapThreshold">Nombre entre 1 et 99 qui spécifie le moment auquel la notification doit être émise selon les objets alloués dans le tas d'objets volumineux.</param>
        <summary>Spécifie qu’une notification de garbage collection doit être émise quand les conditions sont favorables à un garbage collection complet et quand celui-ci est terminé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour chaque génération, le garbage collector définit un seuil pour les allocations dans cette génération. Lorsque la taille des allocations dépasse ce seuil, un garbage collection est déclenché sur cette génération. Pour exemple, si le seuil de génération 2 est de 20 Mo (ce qui signifie que 20 Mo survit aux collections de génération 1 est promue dans la génération 2) et plus de 20 Mo a survécu à la génération 1 et est invité à entrer dans la génération 2, le garbage collection suivant sera tenté. comme une collection de génération 2. De même, si le tas d’objets volumineux 's (LOH) seuil est de 20 Mo et que votre application a alloué le plus de 20 Mo des objets volumineux, le garbage collection suivant sera tenté également comme une collection de génération 2 (puisque le LOH est collecté uniquement dans les garbage collections de génération 2).  
  
 Le `maxGenerationThreshold` et `largeObjectHeapThreshold` seuils contrôlent avance combien vous êtes averti avant une garbage collection complet. Plus le seuil les plus d’allocations qui peuvent se produire entre la notification et la prochain garbage collection complet.  
  
 Si vous avez des situations dans lesquelles un garbage collection complet par le common language runtime peut gêner les performances de votre application, vous pouvez demander à être averti lorsque le runtime est sur le point d’effectuer une garbage collection complet et le contrecarrer par induire vous-même une collection (à l’aide de la <xref:System.GC.Collect%2A> méthode) lorsque les conditions sont toujours favorables. En plus de la modification de la garbage collection vous-même, notification GC complète est utile dans les scénarios suivants :  
  
-   Vous surveillez pour l’approche d’une garbage collection complet et, lorsque vous êtes informé qu’un est proche, vous réduisez la taille des données en temps réel (par exemple, en libérant des entrées de cache). Par conséquent, lorsque le garbage collection se produit, il est en mesure de libérer plus de mémoire.  
  
-   Vous surveillez l’achèvement d’une garbage collection complet afin que vous pouvez collecter des statistiques.  Par exemple, vous souhaiterez peut-être mesurer la taille du tas à l’achèvement de GC afin que vous connaissez la taille des données en direct. (Après un GC complet, le segment de mémoire est à sa taille plus petite).  
  
 Pour plus d’informations sur ce que représente une garbage collection complet, consultez [Notifications de Garbage Collection](~/docs/standard/garbage-collection/notifications.md).  
  
 Lorsque vous inscrivez pour une notification de garbage collection, vous pouvez être averti quand une garbage collection complet est imminent et lorsqu’il est terminé. Ce modèle est similaire à la façon dont le système d’exploitation surveille pour les notifications de mémoire insuffisante.  
  
 Utilisez les instructions suivantes pour spécifier le `maxGenerationThreshold` et `largeObjectHeapThreshold` paramètres :  
  
-   Plus la valeur de seuil, les allocations plus seront produit entre la notification et la garbage collection complet.  
  
     Une valeur de seuil élevée fournit davantage d’opportunités pour le runtime vérifier à l’imminence d’une collection. Cela augmente la probabilité que vous êtes averti. Toutefois, vous ne devez pas définir le seuil trop élevé, car cela entraîne une allocations plus avant que le runtime déclenche le garbage collection suivant.  
  
     Lorsque vous déclencher vous-même une collection dès la notification à l’aide d’une valeur de seuil élevée, moins d’objets sont récupérés que serait récupéré par la collection suivante.  
  
-   Plus la valeur de seuil, moins les allocations entre la notification et la garbage collection complet.  
  
   
  
## Examples  
 L’exemple suivant montre comment inscrire une notification de garbage collection et démarrer un thread pour surveiller l’état de la notification de garbage collection. Cet exemple de code fait partie d’un exemple plus complet fourni pour [Notifications de Garbage Collection](~/docs/standard/garbage-collection/notifications.md) rubrique.  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Ni <paramref name="maxGenerationThreshold" /> ni <paramref name="largeObjectHeapThreshold" /> n’est compris entre 1 et 99.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Notifications de garbage collection</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Quantité de mémoire non managée qui a été libérée.</param>
        <summary>Informe l’exécution que la mémoire non managée a été libérée et n’a plus besoin d’être prise en compte lors de la planification du garbage collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Détermination des cas planifier le garbage collection, le runtime prend en compte la quantité de mémoire managé est alloué. Si un petit objet managé alloue une grande quantité de mémoire non managée, le runtime prend en compte uniquement la mémoire managée et par conséquent sous-estime l’urgence de la planification du garbage collection. Le <xref:System.GC.AddMemoryPressure%2A> méthode informe l’exécution de cette sollicitation supplémentaire sur la mémoire système et le <xref:System.GC.RemoveMemoryPressure%2A> méthode informe le runtime que la pression supplémentaire a été publiée.  
  
 Dans le modèle d’utilisation la plus simple, un objet managé alloue la mémoire non managée dans le constructeur et la libère dans la `Dispose` ou `Finalize` (méthode). Appelez le <xref:System.GC.AddMemoryPressure%2A> méthode après avoir alloué la mémoire non managée et appelez le <xref:System.GC.RemoveMemoryPressure%2A> méthode après l’avoir libéré.  
  
 Dans les scénarios plus complexes, où l’allocation de mémoire non managée change substantiellement pendant la durée de vie de l’objet managé, vous pouvez appeler la <xref:System.GC.AddMemoryPressure%2A> et <xref:System.GC.RemoveMemoryPressure%2A> méthodes permettant de communiquer ces modifications incrémentielles à l’exécution.  
  
> [!CAUTION]
>  Vous devez vous assurer que vous supprimez la quantité exacte de pression que vous ajoutez. Ne parvient pas à le faire peut nuire aux performances du système dans les applications qui s’exécutent pendant de longues périodes de temps.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bytesAllocated" /> est inférieur ou égal à 0.  
  
- ou - 
Sur un ordinateur à 32 bits, <paramref name="bytesAllocated" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la manipulation de priorité de garbage collection. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet pour lequel un finaliseur doit être appelé.</param>
        <summary>Demande que le système appelle le finaliseur pour l'objet spécifié, pour lequel <see cref="M:System.GC.SuppressFinalize(System.Object)" /> a été précédemment appelé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.GC.ReRegisterForFinalize%2A> méthode ajoute la `obj` paramètre à la liste des objets qui demandent la finalisation avant que le garbage collector libère l’objet. Le `obj` paramètre doit être l’appelant de cette méthode.  
  
 Appel de la <xref:System.GC.ReRegisterForFinalize%2A> méthode ne garantit pas que le garbage collector appellera le finaliseur d’un objet.  
  
 Par défaut, tous les objets qui implémentent les finaliseurs sont ajoutés à la liste des objets qui nécessitent une finalisation ; Toutefois, un objet peut déjà avoir été finalisé ou avoir désactivé la finalisation en appelant le <xref:System.GC.SuppressFinalize%2A> (méthode).  
  
 Un finaliseur peut utiliser cette méthode pour se réactiver ou réactiver un objet qu’il référence.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser la méthode ReRegisterForFinalize pour finaliser un objet une deuxième fois après le garbage collection.  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet dont le finaliseur ne doit pas être exécuté.</param>
        <summary>Demande que le Common Language Runtime n'appelle pas le finaliseur pour l'objet spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode définit un bit dans l’en-tête de l’objet de `obj`, dont le runtime vérifie lors de l’appel de finaliseurs. Un finaliseur, qui est représenté par la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> méthode, est utilisée pour libérer les ressources non managées avant un objet est une opération de garbage collection. Si `obj` n’a pas d’un finaliseur, l’appel à la <xref:System.GC.SuppressFinalize%2A> méthode n’a aucun effet.  
  
 Objets qui implémentent le <xref:System.IDisposable> interface peut appeler cette méthode à partir de l’objet <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> mise en œuvre pour empêcher le garbage collector d’appeler <xref:System.Object.Finalize%2A?displayProperty=nameWithType> sur un objet qui ne l’impose pas. En règle générale, cela permet d’empêcher le finaliseur de libérer des ressources non managées qui ont déjà été libérées par la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implémentation.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.GC.SuppressFinalize%2A> méthode dans une classe de ressources pour empêcher un garbage collection redondant d’être appelée. L’exemple utilise le [dispose, modèle](~/docs/standard/design-guidelines/dispose-pattern.md) pour libérer à la fois les ressources managées (autrement dit, des objets qui implémentent <xref:System.IDisposable>) et les ressources non managées.  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
        <related type="Article" href="https://msdn.microsoft.com/library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb">Dispose, modèle</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tente d’interdire le garbage collection pendant l’exécution d’un chemin d’accès critique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Vous ne pouvez pas imbriquer des appels à la <xref:System.GC.TryStartNoGCRegion%2A> (méthode) et vous devez appeler uniquement la <xref:System.GC.EndNoGCRegion%2A> méthode si le runtime est actuellement en mode de latence sans région GC. En d’autres termes, vous ne devez pas appeler <xref:System.GC.TryStartNoGCRegion%2A> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <xref:System.GC.EndNoGCRegion%2A> réussisse parce que le premier appel à <xref:System.GC.TryStartNoGCRegion%2A> a réussi.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">Quantité de mémoire en octets à allouer sans déclencher un garbage collection. Elle doit être inférieure ou égale à la taille d'un segment éphémère. Pour plus d’informations sur la taille d’un segment éphémère, consultez la section « Segments et générations éphémères » dans l’article [Notions de base du garbage collection](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <summary>Tente d'interdire le garbage collection pendant l'exécution d'un chemin d'accès critique si une quantité de mémoire spécifiée est disponible.</summary>
        <returns>
          <see langword="true" /> si le runtime a pu valider la quantité de mémoire requise et que le garbage collector peut entrer en mode de latence sans région GC ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> méthode tente de placer le garbage collector dans aucun mode de latence de région GC, qui n’autorise pas le garbage collection pendant une application exécute une zone critique de code.  Si le runtime ne parvient pas initialement allouer la quantité de mémoire demandée, le garbage collector effectue une garbage collection de blocage en essayant de libérer la mémoire supplémentaire. Le garbage collector passe le mode de latence sans région GC s’il est en mesure d’allouer la quantité de mémoire, ce qui est dans ce cas 2 réellement requise * `totalSize` octets (il tente d’allouer `totalSize` octets pour le tas de petits objets et `totalSize` octets pour le tas d’objets volumineux).  
  
 `totalSize` doit être suffisamment grand pour gérer toutes les allocations de mémoire qui se produisent dans le chemin critique. Cela inclut les allocations par l’application, ainsi que les allocations par le runtime sur le nom de l’application.  
  
> [!IMPORTANT]
>  Vous ne pouvez pas imbriquer des appels à la <xref:System.GC.TryStartNoGCRegion%2A> (méthode) et vous devez appeler uniquement la <xref:System.GC.EndNoGCRegion%2A> méthode si le runtime est actuellement en mode de latence sans région GC. En d’autres termes, vous ne devez pas appeler <xref:System.GC.TryStartNoGCRegion%2A> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <xref:System.GC.EndNoGCRegion%2A> réussisse parce que le premier appel à <xref:System.GC.TryStartNoGCRegion%2A> a réussi.  
  
 Vous quittez le mode sans région GC latence en appelant le <xref:System.GC.EndNoGCRegion%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> dépasse la taille du segment éphémère.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus est déjà en mode de latence sans région GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Notions de base du garbage collection</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Modes de latence</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">Quantité de mémoire en octets à allouer sans déclencher un garbage collection. Elle doit être inférieure ou égale à la taille d'un segment éphémère. Pour plus d’informations sur la taille d’un segment éphémère, consultez la section « Segments et générations éphémères » dans l’article [Notions de base du garbage collection](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="disallowFullBlockingGC">
          <see langword="true" /> pour omettre un garbage collection de blocage complet si le garbage collector ne parvient pas initialement à allouer <paramref name="totalSize" /> octets ; sinon, <see langword="false" />.</param>
        <summary>Tente d'interdire le garbage collection pendant l'exécution d'un chemin d'accès critique si une quantité de mémoire spécifiée est disponible, et contrôle si le garbage collector effectue un garbage collection de blocage complet si la mémoire initialement disponible est insuffisante.</summary>
        <returns>
          <see langword="true" /> si le runtime a pu valider la quantité de mémoire requise et que le garbage collector peut entrer en mode de latence sans région GC ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> méthode tente de placer le garbage collector dans aucun mode de latence de région GC, qui n’autorise pas le garbage collection pendant une application exécute une zone critique de code.  Si le runtime ne parvient pas initialement allouer la quantité de mémoire demandée et la `disallowFullBlockingGC` argument est `false`, le garbage collector effectue une garbage collection de blocage en essayant de libérer de la mémoire supplémentaire ; sinon, l’allocation échoue et la méthode retourne `false`. Le garbage collector passe le mode de latence sans région GC s’il est en mesure d’allouer la quantité de mémoire, ce qui est dans ce cas 2 réellement requise * `totalSize` (il tente d’allouer `totalSize` pour le tas de petits objets et `totalSize` pour l’objet volumineux segment de mémoire).  
  
 `totalSize` doit être suffisamment grand pour gérer toutes les allocations de mémoire qui se produisent dans le chemin critique. Cela inclut les allocations par l’application, ainsi que les allocations par le runtime sur le nom de l’application.  
  
 Paramètre `disallowFullBlockingGC` à `true` pour empêcher un garbage de blocage complet collection s’il n’est pas suffisamment de mémoire initialement disponible est particulièrement utile dans les scénarios d’équilibrage de charge : un système peut appeler cette méthode et signaler lui-même comme prêt à accepter les demandes si elle retourne `true`, et l’équilibrage de charge rediriger les demandes vers d’autres systèmes si elle retourne `false`. Il peut ensuite faire une garbage collection de blocage quand il ne gère pas les demandes en appelant le <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> (méthode).  
  
> [!IMPORTANT]
>  Vous ne pouvez pas imbriquer des appels à la <xref:System.GC.TryStartNoGCRegion%2A> (méthode) et vous devez appeler uniquement la <xref:System.GC.EndNoGCRegion%2A> méthode si le runtime est actuellement en mode de latence sans région GC. En d’autres termes, vous ne devez pas appeler <xref:System.GC.TryStartNoGCRegion%2A> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <xref:System.GC.EndNoGCRegion%2A> réussisse parce que le premier appel à <xref:System.GC.TryStartNoGCRegion%2A> a réussi.  
  
 Vous quittez le mode sans région GC latence en appelant le <xref:System.GC.EndNoGCRegion%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> dépasse la taille du segment éphémère.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus est déjà en mode de latence sans région GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Notions de base du garbage collection</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Modes de latence</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">Quantité de mémoire en octets à allouer sans déclencher un garbage collection. <paramref name="totalSize" /> –<paramref name="lohSize" /> doit être inférieure ou égale à la taille d'un segment éphémère. Pour plus d’informations sur la taille d’un segment éphémère, consultez la section « Segments et générations éphémères » dans l’article [Notions de base du garbage collection](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="lohSize">Nombre d'octets dans <paramref name="totalSize" /> à utiliser pour les allocations de tas d'objets volumineux (LOH).</param>
        <summary>Tente d'interdire le garbage collection pendant l'exécution d'un chemin d'accès critique si une quantité de mémoire spécifiée est disponible pour le tas d'objets volumineux et le tas de petits objets.</summary>
        <returns>
          <see langword="true" /> si le runtime a pu valider la quantité de mémoire requise et que le garbage collector peut entrer en mode de latence sans région GC ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> méthode tente de placer le garbage collector dans aucun mode de latence de région GC, qui n’autorise pas le garbage collection pendant une application exécute une zone critique de code.  Si le runtime ne parvient pas initialement allouer la quantité de mémoire demandée, le garbage collector effectue une garbage collection de blocage en essayant de libérer la mémoire supplémentaire. Le garbage collector passe le mode de latence sans région GC s’il est en mesure d’allouer `lohSize` pour le LOH et `totalSize` – `lohSize` pour le tas de petits objets (SOH).  
  
 `lohSize` doit être suffisamment grand pour gérer toutes les allocations de mémoire qui se produisent dans le chemin critique pour le LOH, et `totalSize` – `lohSize` doit être suffisamment grand pour gérer toutes les allocations de mémoire qui se produisent dans le chemin critique pour la déclaration d’intégrité. Cela inclut les allocations par l’application, ainsi que les allocations par le runtime sur le nom de l’application.  
  
> [!IMPORTANT]
>  Vous ne pouvez pas imbriquer des appels à la <xref:System.GC.TryStartNoGCRegion%2A> (méthode) et vous devez appeler uniquement la <xref:System.GC.EndNoGCRegion%2A> méthode si le runtime est actuellement en mode de latence sans région GC. En d’autres termes, vous ne devez pas appeler <xref:System.GC.TryStartNoGCRegion%2A> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <xref:System.GC.EndNoGCRegion%2A> réussisse parce que le premier appel à <xref:System.GC.TryStartNoGCRegion%2A> a réussi.  
  
 Vous quittez le mode sans région GC latence en appelant le <xref:System.GC.EndNoGCRegion%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> – <paramref name="lohSize" /> dépasse la taille du segment éphémère.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus est déjà en mode de latence sans région GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Notions de base du garbage collection</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Modes de latence</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">Quantité de mémoire en octets à allouer sans déclencher un garbage collection. <paramref name="totalSize" /> –<paramref name="lohSize" /> doit être inférieure ou égale à la taille d'un segment éphémère. Pour plus d’informations sur la taille d’un segment éphémère, consultez la section « Segments et générations éphémères » dans l’article [Notions de base du garbage collection](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="lohSize">Nombre d'octets dans <paramref name="totalSize" /> à utiliser pour les allocations de tas d'objets volumineux (LOH).</param>
        <param name="disallowFullBlockingGC">
          <see langword="true" /> pour omettre un garbage collection de blocage complet si le garbage collector ne parvient pas initialement à allouer la mémoire spécifiée sur le tas de petits objets (SOH) et le tas d'objets volumineux (LOH) ; sinon, <see langword="false" />.</param>
        <summary>Tente de suspendre le garbage collection pendant l'exécution d'un chemin d'accès critique si une quantité de mémoire suffisante spécifiée est disponible pour le tas d'objets volumineux et le tas de petits objets, et contrôle si le garbage collector effectue un garbage collection de blocage complet si la mémoire initialement disponible est insuffisante.</summary>
        <returns>
          <see langword="true" /> si le runtime a pu valider la quantité de mémoire requise et que le garbage collector peut entrer en mode de latence sans région GC ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> méthode tente de placer le garbage collector dans aucun mode de latence de région GC, qui n’autorise pas le garbage collection pendant une application exécute une zone critique de code.  Si le runtime ne parvient pas initialement allouer la quantité de mémoire demandée et la `disallowFullBlockingGC` argument est `false`, le garbage collector effectue une garbage collection de blocage en essayant de libérer de la mémoire supplémentaire ; sinon, l’allocation échoue et la méthode retourne `false`. Le garbage collector passe le mode de latence sans région GC s’il est en mesure d’allouer `lohSize` pour le LOH et `totalSize` – `lohSize` pour le tas de petits objets (SOH).  
  
 `lohSize` doit être suffisamment grand pour gérer toutes les allocations de mémoire qui se produisent dans le chemin critique pour le LOH, et `totalSize` – `lohSize` doit être suffisamment grand pour gérer toutes les allocations de mémoire qui se produisent dans le chemin critique pour la déclaration d’intégrité. Cela inclut les allocations par l’application, ainsi que les allocations par le runtime sur le nom de l’application.  
  
 Paramètre `disallowFullBlockingGC` à `true` pour empêcher un garbage de blocage complet collection s’il n’est pas suffisamment de mémoire initialement disponible est particulièrement utile dans les scénarios d’équilibrage de charge : un système peut appeler cette méthode et signaler lui-même comme prêt à accepter les demandes si elle retourne `true`, et l’équilibrage de charge rediriger les demandes vers d’autres systèmes si elle retourne `false`. Il peut ensuite faire une garbage collection de blocage quand il ne gère pas les demandes en appelant le <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> (méthode).  
  
> [!IMPORTANT]
>  Vous ne pouvez pas imbriquer des appels à la <xref:System.GC.TryStartNoGCRegion%2A> (méthode) et vous devez appeler uniquement la <xref:System.GC.EndNoGCRegion%2A> méthode si le runtime est actuellement en mode de latence sans région GC. En d’autres termes, vous ne devez pas appeler <xref:System.GC.TryStartNoGCRegion%2A> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <xref:System.GC.EndNoGCRegion%2A> réussisse parce que le premier appel à <xref:System.GC.TryStartNoGCRegion%2A> a réussi.  
  
 Vous quittez le mode sans région GC latence en appelant le <xref:System.GC.EndNoGCRegion%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> – <paramref name="lohSize" /> dépasse la taille du segment éphémère.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus est déjà en mode de latence sans région GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Notions de base du garbage collection</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Modes de latence</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne l’état d’une notification inscrite pour déterminer si un garbage collection de blocage complet par le Common Language Runtime est imminent.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne l’état d’une notification inscrite pour déterminer si un garbage collection de blocage complet par le Common Language Runtime est imminent.</summary>
        <returns>État de la notification de garbage collection inscrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.GCNotificationStatus> énumération retournée par cette méthode pour déterminer l’état de la notification de garbage collection actuelle qui a été inscrite à l’aide de la <xref:System.GC.RegisterForFullGCNotification%2A> (méthode). Vous pouvez également utiliser le <xref:System.GC.WaitForFullGCComplete%2A> méthode pour déterminer si la garbage collection complet est terminé.  
  
 Lorsque l’énumération retourne <xref:System.GCNotificationStatus.Succeeded>, vous pouvez effectuer des tâches telles que des objets supplémentaires empêchant d’allouées et induire vous-même une collection avec la <xref:System.GC.Collect%2A> (méthode). Notez que la notification ne garantit pas qu’une garbage collection complet se produira, uniquement qui conditions ont atteint le seuil auquel un garbage collection complet se produise.  
  
 Cette méthode attend indéfiniment une notification de garbage collection doit être obtenu. Si vous souhaitez spécifier un délai d’attente pour la méthode à retourner si la notification ne peut pas être obtenue, utilisez le <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> surcharge de méthode. Si vous appelez cette méthode sans spécifier un délai d’attente, vous pouvez appeler la <xref:System.GC.CancelFullGCNotification%2A> méthode si vous attendez plus longtemps que préféré.  
  
 Vous devez suivre cette méthode avec un appel à la <xref:System.GC.WaitForFullGCComplete%2A> méthode pour vous assurer que vous avez eu une garbage collection complet. L’appel de cette méthode seule donne des résultats indéterminés.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser cette méthode pour déterminer si une opération garbage collection de blocage complète est proche. Chaque fois que l’état de la notification est <xref:System.GCNotificationStatus.Succeeded>, la méthode utilisateur `OnFullGCApproachNotify` est appelée pour effectuer des actions en réponse à la collection. Cet exemple de code fait partie d’un exemple plus complet fourni pour [Notifications de Garbage Collection](~/docs/standard/garbage-collection/notifications.md) rubrique.  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Notifications de garbage collection</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Temps à attendre avant qu'un état de notification puisse être obtenu. Spécifiez -1 pour attendre indéfiniment.</param>
        <summary>Retourne, dans le délai d’attente spécifié, l’état d’une notification inscrite pour déterminer si un garbage collection de blocage complet par le Common Language Runtime est imminent.</summary>
        <returns>État de la notification de garbage collection inscrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.GCNotificationStatus> énumération retournée par cette méthode pour déterminer l’état de la notification de garbage collection actuelle qui a été inscrite à l’aide de la <xref:System.GC.RegisterForFullGCNotification%2A> (méthode). Vous pouvez également utiliser le <xref:System.GC.WaitForFullGCComplete%2A> méthode pour déterminer si la garbage collection complet est terminé.  
  
 Notez que cette méthode retourne immédiatement chaque fois qu’un état de notification de garbage collection est obtenu, quelle que soit la valeur spécifiée par `millisecondsTimeout`. Si un état de notification de garbage collection n’est pas obtenu avant `millisecondsTimeout` heures, cette méthode retourne <xref:System.GCNotificationStatus.NotApplicable>.  
  
 Lorsque l’énumération retourne <xref:System.GCNotificationStatus.Succeeded>, vous pouvez effectuer des tâches telles que des objets supplémentaires empêchant d’allouées et induire vous-même une collection avec la <xref:System.GC.Collect%2A> (méthode). Notez que la notification ne garantit pas qu’une garbage collection complet se produira, uniquement qui conditions ont atteint le seuil auquel un garbage collection complet se produise.  
  
 Vous pouvez appeler la <xref:System.GC.CancelFullGCNotification%2A> méthode lorsque vous ne pouvez pas attendre la période de délai d’attente.  
  
 Vous devez suivre cette méthode avec un appel à la <xref:System.GC.WaitForFullGCComplete%2A> méthode pour vous assurer que vous avez eu une garbage collection complet. L’appel de cette méthode seule donne des résultats indéterminés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> doit être non négatif ou inférieur ou égal à <see cref="F:System.Int32.MaxValue" /> ou -1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Notifications de garbage collection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne l’état d’une notification inscrite pour déterminer si un garbage collection de blocage complet par le Common Language Runtime est terminé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne l’état d’une notification inscrite pour déterminer si un garbage collection de blocage complet par le Common Language Runtime est terminé.</summary>
        <returns>État de la notification de garbage collection inscrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.GCNotificationStatus> énumération retournée par cette méthode pour déterminer l’état de la notification de garbage collection actuelle qui a été inscrite à l’aide de la <xref:System.GC.RegisterForFullGCNotification%2A> (méthode). Vous pouvez également utiliser le <xref:System.GC.WaitForFullGCApproach%2A> méthode pour déterminer si une garbage collection complet est imminente.  
  
 Lorsque l’énumération retourne <xref:System.GCNotificationStatus.Succeeded>, vous pouvez effectuer des tâches telles que la reprise du travail et obtenir le nombre de collection avec le <xref:System.GC.CollectionCount%2A> propriété.  
  
 Cette méthode attend indéfiniment une notification de garbage collection doit être obtenu. Si vous souhaitez spécifier un délai d’attente pour la méthode à retourner si la notification ne peut pas être obtenue, utilisez le <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> surcharge de méthode. Si vous appelez cette méthode sans spécifier un délai d’attente, vous pouvez appeler la <xref:System.GC.CancelFullGCNotification%2A> méthode si vous attendez plus longtemps que préféré.  
  
 Cet appel de méthode doit être précédé d’un appel à la <xref:System.GC.WaitForFullGCApproach%2A> méthode pour vous assurer que vous avez eu une garbage collection complet. L’appel de cette méthode seule peut produire des résultats indéterminés.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser cette méthode pour déterminer si une garbage collection complet est terminé. Chaque fois que l’état de la notification est <xref:System.GCNotificationStatus.Succeeded>, la méthode utilisateur `OnFullGCCompletedNotify` est appelée pour effectuer des actions en réponse à la collection terminée. Cet exemple de code fait partie d’un exemple plus complet fourni pour [Notifications de Garbage Collection](~/docs/standard/garbage-collection/notifications.md) rubrique.  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Notifications de garbage collection</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Temps à attendre avant qu'un état de notification puisse être obtenu. Spécifiez -1 pour attendre indéfiniment.</param>
        <summary>Retourne, dans le délai d’attente spécifié, l’état d’une notification inscrite pour déterminer si un garbage de collection de blocage complet par le Common Language Runtime est terminé.</summary>
        <returns>État de la notification de garbage collection inscrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.GCNotificationStatus> énumération retournée par cette méthode pour déterminer l’état de la notification de garbage collection actuelle qui a été inscrite à l’aide de la <xref:System.GC.RegisterForFullGCNotification%2A> (méthode). Vous pouvez également utiliser le <xref:System.GC.WaitForFullGCApproach%2A> méthode pour déterminer si une garbage collection complet est imminente.  
  
 Notez que cette méthode retourne immédiatement chaque fois qu’un état de notification de garbage collection est obtenu, quelle que soit la valeur spécifiée par `millisecondsTimeout`. Si un état de notification de garbage collection n’est pas obtenu avant `millisecondsTimeout` heures, cette méthode retourne <xref:System.GCNotificationStatus.NotApplicable>.  
  
 Lorsque l’énumération retourne <xref:System.GCNotificationStatus.Succeeded>, vous pouvez effectuer des tâches telles que la reprise du travail et obtenir le nombre de collection avec le <xref:System.GC.CollectionCount%2A> propriété.  
  
 Vous pouvez appeler la <xref:System.GC.CancelFullGCNotification%2A> méthode lorsque vous ne pouvez pas attendre la période de délai d’attente.  
  
 Cet appel de méthode doit être précédé d’un appel à la <xref:System.GC.WaitForFullGCApproach%2A> méthode pour vous assurer que vous avez eu une garbage collection complet. L’appel de cette méthode seule peut produire des résultats indéterminés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="millisecondsTimeout" /> doit être non négatif ou inférieur ou égal à <see cref="F:System.Int32.MaxValue" /> ou -1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Notifications de garbage collection</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Suspend le thread actif jusqu'à ce que le thread traitant la file d'attente des finaliseurs ait vidé cette file d'attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le garbage collector recherche les objets qui peuvent être récupérées, il vérifie chaque objet pour déterminer les exigences de la finalisation de l’objet. Si un objet implémente un finaliseur et n’a pas désactivé la finalisation en appelant <xref:System.GC.SuppressFinalize%2A>, l’objet est placé dans une liste d’objets qui sont marquées comme prêtes pour la finalisation. Le garbage collector appelle la <xref:System.Object.Finalize%2A> méthodes pour les objets dans cette liste et supprime les entrées dans la liste. Cette méthode se bloque jusqu'à ce que tous les finaliseurs s’exécutaient jusqu'à la fin.  
  
 Le thread sur lequel les finaliseurs sont exécutés n’est pas spécifié, il n’existe aucune garantie que cette méthode se termine. Cependant, ce thread peut être interrompu par un autre thread pendant le <xref:System.GC.WaitForPendingFinalizers%2A> méthode est en cours. Par exemple, vous pouvez démarrer un autre thread qui attend pendant une période de temps, puis interrompt ce thread si ce thread est toujours suspendu.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.GC.WaitForPendingFinalizers%2A> méthode pour interrompre le thread actuel jusqu'à la fin de la finalisation de tous les objets collectés.  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>