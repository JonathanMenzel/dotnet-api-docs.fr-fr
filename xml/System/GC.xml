<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="GC.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5a32cca487ba8110051f97ff67e6a71e25b17a046.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a32cca487ba8110051f97ff67e6a71e25b17a046</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Controls the system garbage collector, a service that automatically reclaims unused memory.</source>
          <target state="translated">Contrôle le garbage collector du système, un service qui récupère automatiquement la mémoire inutilisée.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector is a common language runtime component that controls the allocation and release of managed memory.</source>
          <target state="translated">Le garbage collector est un composant du common language runtime qui contrôle l’allocation et la libération de mémoire managée.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.</source>
          <target state="translated">Les méthodes de cette classe influencent lorsque le garbage collection est effectué sur un objet lorsque les ressources allouées par un objet sont libérées.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</source>
          <target state="translated">Propriétés de cette classe fournissent des informations sur la quantité totale de mémoire disponible dans le système et la catégorie d’âge ou la génération, de mémoire allouée à un objet.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector tracks and reclaims objects allocated in managed memory.</source>
          <target state="translated">Le garbage collector effectue le suivi et libère des objets alloués dans la mémoire managée.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.</source>
          <target state="translated">Périodiquement, le garbage collector effectue le garbage collection pour récupérer la mémoire allouée aux objets pour lesquels il n’existe aucune référence valide.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.</source>
          <target state="translated">Le garbage collection se produit automatiquement quand une demande de mémoire ne peuvent pas être satisfaite à l’aide de la mémoire disponible.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Alternatively, an application can force garbage collection using the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">Une application peut également forcer le garbage collection à l’aide du <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Garbage collection consists of the following steps:</source>
          <target state="translated">Le garbage collection se compose des étapes suivantes :</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector searches for managed objects that are referenced in managed code.</source>
          <target state="translated">Le garbage collector recherche les objets managés qui sont référencés dans le code managé.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector tries to finalize objects that are not referenced.</source>
          <target state="translated">Le garbage collector essaie de finaliser les objets qui ne sont pas référencées.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector frees objects that are not referenced and reclaims their memory.</source>
          <target state="translated">Le garbage collector libère les objets qui ne sont pas référencés et récupère leur mémoire.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>This topic includes the following sections:</source>
          <target state="translated">Cette rubrique comporte les sections suivantes :</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source><bpt id="p1">[</bpt>The garbage collector and unmanaged resources<ept id="p1">](#unmanaged)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Le garbage collector et les ressources non managées<ept id="p1">](#unmanaged)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source><bpt id="p1">[</bpt>Object aging and generations<ept id="p1">](#generations)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Chronologie de l’objet et les générations<ept id="p1">](#generations)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source><bpt id="p1">[</bpt>Disallowing garbage collection<ept id="p1">](#NoGCRegion)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Interdire le garbage collection<ept id="p1">](#NoGCRegion)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector and unmanaged resources</source>
          <target state="translated">Le garbage collector et les ressources non managées</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.</source>
          <target state="translated">Au cours d’une collection, le garbage collector ne libère pas un objet s’il trouve une ou plusieurs références à l’objet dans le code managé.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.</source>
          <target state="translated">Toutefois, le garbage collector ne reconnaît pas les références à un objet à partir de code non managé et peut libérer des objets qui sont utilisés exclusivement dans du code non managé, sauf si l’interdisent explicitement de le faire.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> méthode fournit un mécanisme qui empêche le garbage collector de collecter des objets qui sont en cours d’utilisation dans le code non managé.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.</source>
          <target state="translated">À l’exception des allocations de mémoire managée, les implémentations du garbage collector ne conservent pas les informations sur les ressources détenues par un objet, telles que les handles de fichiers ou des connexions de base de données.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</source>
          <target state="translated">Lorsqu’un type utilise des ressources non managées doivent être libérées avant que les instances du type sont libérés, le type peut implémenter un finaliseur.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In most cases, finalizers are implemented by overriding the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <ph id="ph2">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Dans la plupart des cas, les finaliseurs sont implémentés en substituant la <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> méthode ; Toutefois, les types écrits en c# ou C++ implémentent des destructeurs que les compilateurs transforment en une substitution de <ph id="ph2">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.</source>
          <target state="translated">Dans la plupart des cas, si un objet a un finaliseur, le garbage collector l’appelle avant la libération de l’objet.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>However, the garbage collector is not required to call finalizers in all situations; for example, the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method explicitly prevents an object's finalizer from being called.</source>
          <target state="translated">Toutefois, le garbage collector n’est pas nécessaire d’appeler les finaliseurs dans toutes les situations ; par exemple, le <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> méthode empêche explicitement le finaliseur d’un objet d’être appelée.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</source>
          <target state="translated">En outre, le garbage collector n’est pas requis pour utiliser un thread spécifique pour finaliser les objets et garantit l’ordre dans lequel les finaliseurs sont appelés pour les objets qui se référencent mutuellement, mais sont disponibles pour le garbage collection.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In scenarios where resources must be released at a specific time, classes can implement the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface, which contains the <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> method that performs resource management and cleanup tasks.</source>
          <target state="translated">Dans les scénarios où les ressources doivent être libérées à un moment donné, les classes peuvent implémenter la <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface, qui contient le <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> méthode qui effectue les tâches de gestion et de nettoyage des ressources.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Classes that implement <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.</source>
          <target state="translated">Classes qui implémentent <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> doit spécifier, dans le cadre de leur contrat, si et quand les consommateurs de classe appellent la méthode pour nettoyer l’objet.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector does not, by default, call the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method; however, implementations of the <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method can call methods in the <ph id="ph3">&lt;xref:System.GC&gt;</ph> class to customize the finalization behavior of the garbage collector.</source>
          <target state="translated">Le garbage collector ne pas, par défaut, appelez le <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> (méthode) ; Toutefois, les implémentations de la <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> méthode peut appeler des méthodes dans la <ph id="ph3">&lt;xref:System.GC&gt;</ph> classe pour personnaliser le comportement de finalisation du garbage collector.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>For more information on object finalization and the dispose pattern, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la finalisation de l’objet et le modèle de suppression, consultez <bpt id="p1">[</bpt>de nettoyage des ressources non managées<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Object aging and generations</source>
          <target state="translated">Chronologie de l’objet et les générations</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector in the common language runtime supports object aging using generations.</source>
          <target state="translated">Le garbage collector dans le common language runtime prend en charge le vieillissement des objets à l’aide de générations.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>A generation is a unit of measure of the relative age of objects in memory.</source>
          <target state="translated">Une génération est une unité de mesure de l’âge relatif des objets en mémoire.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The generation number, or age, of an object indicates the generation to which an object belongs.</source>
          <target state="translated">Le numéro de génération, ou âge, d’un objet indique la génération à laquelle appartient un objet.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.</source>
          <target state="translated">Objets créés plus récemment font partie des générations plus récente et ont des numéros de génération inférieurs à passer des objets créés précédemment dans la vie de l’application.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Objects in the most recent generation are in generation 0.</source>
          <target state="translated">Les objets dans la génération la plus récente sont dans la génération 0.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.</source>
          <target state="translated">Cette implémentation du garbage collector prend en charge trois générations d’objets, les générations 0, 1 et 2.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum generation number supported by the system.</source>
          <target state="translated">Vous pouvez récupérer la valeur de la <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> propriété pour déterminer le nombre maximal de générations prises en charge par le système.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</source>
          <target state="translated">Vieillissement des objets permet aux applications cibler le garbage collection sur un ensemble spécifique de générations au lieu de demander au garbage collector d’évaluer toutes les générations.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Overloads of the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method that include a <ph id="ph2">`generation`</ph> parameter allow you to specify the oldest generation to be garbage collected.</source>
          <target state="translated">Les surcharges de la <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> méthode qui incluent un <ph id="ph2">`generation`</ph> paramètre permet de spécifier la génération la plus ancienne pour l’opération garbage collection.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Disallowing garbage collection</source>
          <target state="translated">Interdire le garbage collection</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, le garbage collector prend en charge un mode sans région GC latence qui peut être utilisé pendant l’exécution de chemins d’accès critiques dans laquelle les garbage collection peut nuire aux performances de l’application.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.</source>
          <target state="translated">Le mode sans région GC latence nécessite que vous spécifiez une quantité de mémoire pouvant être allouée par le garbage collector sans interférence.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.</source>
          <target state="translated">Si le runtime peut allouer cette mémoire, le runtime n’effectuera pas une opération garbage collection pendant l’exécution de code dans le chemin d’accès critique.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You define the beginning of the critical path of the no GC region by calling one of the overloads of the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>.</source>
          <target state="translated">Vous définissez le début du chemin d’accès critique de la région de GC aucune en appelant une des surcharges de la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You specify the end of its critical path by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">Vous spécifiez à la fin de son chemin d’accès critique en appelant le <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">Vous ne pouvez pas imbriquer des appels à la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> (méthode) et vous devez appeler uniquement la <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> méthode si le runtime est actuellement en mode de latence sans région GC.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">En d’autres termes, vous ne devez pas appeler <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> réussisse parce que le premier appel à <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> a réussi.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console.</source>
          <target state="translated">L’exemple suivant utilise plusieurs méthodes GC pour obtenir des informations de mémoire sur un bloc d’objets inutilisés et de génération et l’imprimer à la console.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The unused objects are then collected, and the resulting memory totals are displayed.</source>
          <target state="translated">Les objets inutilisés sont ensuite rassemblés et les totaux de mémoire résultants sont affichés.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>The incremental amount of unmanaged memory that has been allocated.</source>
          <target state="translated">Quantité incrémentielle de mémoire non managée qui a été allouée.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</source>
          <target state="translated">Informe l’exécution d’une allocation volumineuse de mémoire non managée qui doit être prise en considération lors de la planification du garbage collection.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</source>
          <target state="translated">Déterminer le moment de planifier le garbage collection, le runtime prend en compte la quantité de mémoire managée est alloué.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</source>
          <target state="translated">Si un petit objet managé alloue une grande quantité de mémoire non managée, le runtime prend en compte uniquement la mémoire managée et en conséquence sous-estime l’urgence de la planification du garbage collection.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method informs the runtime of this additional pressure on system memory.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> méthode informe l’exécution de cette sollicitation supplémentaire sur la mémoire système.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the <ph id="ph1">`Dispose`</ph> or <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">Dans le modèle d’utilisation la plus simple, un objet managé alloue la mémoire non managée dans le constructeur et mises à jour dans le <ph id="ph1">`Dispose`</ph> ou <ph id="ph2">`Finalize`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method after allocating the unmanaged memory, and call the <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method after releasing it.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> méthode après avoir alloué la mémoire non managée et appelez le <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> méthode après l’avoir libéré.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> methods to communicate these incremental changes to the runtime.</source>
          <target state="translated">Dans les scénarios plus complexes, où l’allocation de mémoire non managée change substantiellement pendant la durée de vie de l’objet managé, vous pouvez appeler la <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> méthodes permettant de communiquer ces modifications incrémentielles à l’exécution.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>You must ensure that you remove exactly the amount of pressure you add.</source>
          <target state="translated">Vous devez vous assurer que vous supprimez la quantité exacte de pression que vous ajoutez.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</source>
          <target state="translated">Sinon, peut nuire aux performances du système dans les applications qui s’exécutent pendant de longues périodes de temps.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is less than or equal to 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> est inférieur ou égal à 0.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>On a 32-bit computer, <ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is larger than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Sur un ordinateur à 32 bits, <ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> est supérieur à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>for the ability to call unmanaged code when manipulating garbage-collection priority.</source>
          <target state="translated">pour avoir la possibilité d’appeler du code non managé lors de la manipulation de priorité du garbage collection.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.GC.CancelFullGCNotification">
          <source>Cancels the registration of a garbage collection notification.</source>
          <target state="translated">Annule l’inscription de la notification de garbage collection.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This method cancels a garbage collection notification that was registered by using the <ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">Cette méthode annule une notification de garbage collection qui a été inscrite à l’aide de la <ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">Il est inutile d’appeler cette méthode avant de définir les valeurs de paramètre de seuil dans les appels suivants à la <ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>The following example cancels a garbage collection registration.</source>
          <target state="translated">L’exemple suivant annule une inscription de garbage collection.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This example is part of a larger example provided for the <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">Cet exemple fait partie d’un exemple plus complet fourni pour le <bpt id="p1">[</bpt>Notifications de Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> rubrique.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.GC.CancelFullGCNotification">
          <source>This member is not available when concurrent garbage collection is enabled.</source>
          <target state="translated">Ce membre n’est pas disponible quand le garbage collection simultané est activé.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.GC.CancelFullGCNotification">
          <source>See the <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>gcConcurrent<ph id="ph2">&amp;gt;</ph><ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)</ept> runtime setting for information about how to disable concurrent garbage collection.</source>
          <target state="translated">Pour plus d’informations sur la désactivation d’une opération garbage collection simultanée, consultez le paramètre d’exécution <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>gcConcurrent<ph id="ph2">&amp;gt;</ph><ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)</ept>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">pour la confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Forces garbage collection.</source>
          <target state="translated">Force un garbage collection.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.GC.Collect">
          <source>Forces an immediate garbage collection of all generations.</source>
          <target state="translated">Force un garbage collection immédiat sur toutes les générations.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>Use this method to try to reclaim all memory that is inaccessible.</source>
          <target state="translated">Utilisez cette méthode pour tenter de récupérer la mémoire qui n’est pas accessible.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>It performs a blocking garbage collection of all generations.</source>
          <target state="translated">Il effectue une garbage collection de blocage de toutes les générations.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.</source>
          <target state="translated">Tous les objets, indépendamment de la durée pendant laquelle ils ont été dans la mémoire, sont considérés comme pour la collection ; Toutefois, les objets qui sont référencés dans le code managé ne sont pas collectés.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>Use this method to force the system to try to reclaim the maximum amount of available memory.</source>
          <target state="translated">Utilisez cette méthode pour forcer le système à tenter de récupérer la quantité maximale de mémoire disponible.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, you can compact the large object heap (LOH) by setting the <ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property to <ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> before calling the <ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph> method, as the following example illustrates.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, vous pouvez compacter le tas d’objets volumineux (LOH) en définissant le <ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> propriété <ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> avant d’appeler le <ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph> méthode, comme l’exemple suivant illustre.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to perform a collection on all generations of memory.</source>
          <target state="translated">L’exemple suivant montre comment utiliser la <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> méthode pour exécuter une collecte sur toutes les générations de mémoire.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>The code generates a number of unused objects, and then calls the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to clean them from memory.</source>
          <target state="translated">Le code génère un nombre d’objets inutilisés, puis appelle la <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> méthode pour les supprimer de la mémoire.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">Numéro de la génération la plus ancienne devant faire l'objet d'un garbage collection.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32)">
          <source>Forces an immediate garbage collection from generation 0 through a specified generation.</source>
          <target state="translated">Force un garbage collection immédiat de la génération 0 jusqu'à une génération spécifiée.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>Use this method to try to reclaim memory that is inaccessible.</source>
          <target state="translated">Utilisez cette méthode pour tenter de récupérer la mémoire qui n’est pas accessible.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</source>
          <target state="translated">Toutefois, à l’aide de cette méthode ne garantit pas que la mémoire inaccessible dans la génération spécifiée est libérée.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.</source>
          <target state="translated">Si le vieillissement de l’objet est implémenté, le garbage collector ne collecte pas les objets avec un numéro de génération qui est supérieur à la génération spécifiée.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</source>
          <target state="translated">Si la chronologie de l’objet n’est pas implémentée, le garbage collector considère que tous les objets pendant le garbage collection.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum valid value of the <ph id="ph2">`generation`</ph> parameter.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> propriété pour déterminer la valeur maximale de la <ph id="ph2">`generation`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</source>
          <target state="translated">Pour que le garbage collector considère tous les objets, quelle que soit leur génération, utilisez la version de cette méthode qui ne prend aucun paramètre.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>To have the garbage collector reclaim objects based on a <ph id="ph1">&lt;xref:System.GCCollectionMode&gt;</ph> setting, use the <ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Pour que le garbage collector récupère les objets selon un <ph id="ph1">&lt;xref:System.GCCollectionMode&gt;</ph> , utilisez le <ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to perform a collection on individual layers of memory.</source>
          <target state="translated">L’exemple suivant montre comment utiliser la <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> méthode pour effectuer un regroupement sur des couches individuelles de mémoire.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>The code generates a number of unused objects, and then calls the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to clean them from memory.</source>
          <target state="translated">Le code génère un nombre d’objets inutilisés, puis appelle la <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> méthode pour les supprimer de la mémoire.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> n'est pas valide.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">Numéro de la génération la plus ancienne devant faire l'objet d'un garbage collection.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>An enumeration value that specifies whether the garbage collection is forced (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) or optimized (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</source>
          <target state="translated">Valeur d'énumération qui spécifie si le garbage collection est forcé (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) ou optimisé (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> value.</source>
          <target state="translated">Force un garbage collection de la génération 0 jusqu'à une génération spécifiée, à une heure indiquée par une valeur <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Use the <ph id="ph1">`mode`</ph> parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.</source>
          <target state="translated">Utilisez le <ph id="ph1">`mode`</ph> pour spécifier si le garbage collection doit avoir lieu immédiatement ou uniquement si l’heure est optimale pour récupérer des objets.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</source>
          <target state="translated">À l’aide de cette méthode ne garantit pas que la mémoire inaccessible dans la génération spécifiée est libérée.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>To adjust the intrusiveness of garbage collection during critical periods in your application, set the <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LatencyMode%2A&gt;</ph> property.</source>
          <target state="translated">Pour ajuster le niveau d’intrusion du garbage collection pendant des périodes critiques dans votre application, définissez la <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LatencyMode%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>The garbage collector does not collect objects with a generation number higher than specified by the <ph id="ph1">`generation`</ph> parameter.</source>
          <target state="translated">Le garbage collector ne collecte pas les objets avec un numéro de génération supérieur à celui spécifié par le <ph id="ph1">`generation`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Use the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum valid value of <ph id="ph2">`generation`</ph>.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> propriété pour déterminer la valeur valide maximale de <ph id="ph2">`generation`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</source>
          <target state="translated">Pour que le garbage collector considère tous les objets, quelle que soit leur génération, utilisez la version de cette méthode qui ne prend aucun paramètre.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>To have the garbage collector reclaim objects up to a specified generation of objects, use the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Pour que le garbage collector récupère des objets jusqu'à une génération d’objets spécifiée, utilisez la <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>When you specify the maximum generation, all objects are collected.</source>
          <target state="translated">Lorsque vous spécifiez la génération maximale, tous les objets sont collectés.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>The following example forces a garbage collection for generation 2 objects with the <ph id="ph1">&lt;xref:System.GCCollectionMode.Optimized&gt;</ph> setting.</source>
          <target state="translated">L’exemple suivant force un garbage collection pour les objets de génération 2 avec le <ph id="ph1">&lt;xref:System.GCCollectionMode.Optimized&gt;</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> n'est pas valide.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> ne fait pas partie des valeurs <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">Numéro de la génération la plus ancienne devant faire l'objet d'un garbage collection.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>An enumeration value that specifies whether the garbage collection is forced (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) or optimized (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</source>
          <target state="translated">Valeur d'énumération qui spécifie si le garbage collection est forcé (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) ou optimisé (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a blocking garbage collection; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a background garbage collection where possible.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour effectuer un garbage collection de blocage ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour effectuer un garbage collection d'arrière-plan, si possible.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> value, with a value specifying whether the collection should be blocking.</source>
          <target state="translated">Force un garbage collection de la génération 0 jusqu'à une génération spécifiée, à une heure indiquée par une valeur <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph>, avec une valeur indiquant si le garbage collection doit effectuer le blocage.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The following table summarizes the interaction of the <ph id="ph1">`mode`</ph> and <ph id="ph2">`blocking`</ph> parameters:</source>
          <target state="translated">Le tableau suivant résume l’interaction de le <ph id="ph1">`mode`</ph> et <ph id="ph2">`blocking`</ph> paramètres :</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">`blocking`</ph> is <ph id="ph2">`true`</ph></source>
          <target state="translated"><ph id="ph1">`blocking`</ph> a la valeur <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">`blocking`</ph> is <ph id="ph2">`false`</ph></source>
          <target state="translated"><ph id="ph1">`blocking`</ph> a la valeur <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.GCCollectionMode.Forced&gt;</ph> or <ph id="ph2">&lt;xref:System.GCCollectionMode.Default&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GCCollectionMode.Forced&gt;</ph> ou <ph id="ph2">&lt;xref:System.GCCollectionMode.Default&gt;</ph></target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A blocking collection is performed as soon as possible.</source>
          <target state="translated">Une collection de blocage est exécutée dès que possible.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is in progress and <ph id="ph1">`generation`</ph> is 0 or 1, the <ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method immediately triggers a blocking collection and returns when the collection is finished.</source>
          <target state="translated">Si une collection d’arrière-plan est en cours et <ph id="ph1">`generation`</ph> est 0 ou 1, le <ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> méthode déclenche une collection de blocage immédiatement et retourne la fin de la collection.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is in progress and <ph id="ph1">`generation`</ph> is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</source>
          <target state="translated">Si une collection d’arrière-plan est en cours et <ph id="ph1">`generation`</ph> est 2, la méthode attend la collection d’arrière-plan est terminée, déclenche une collection de génération 2 blocage et renvoie.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A collection is performed as soon as possible.</source>
          <target state="translated">Une collection est exécutée dès que possible.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> demande une collection d'arrière-plan, mais cela n'est pas garanti ; selon les cas, une collection bloquante peut toujours être exécutée.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is already in progress, the method returns immediately.</source>
          <target state="translated">Si une collection d’arrière-plan est déjà en cours, la méthode retourne immédiatement une valeur.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A blocking collection may be performed, depending on the state of the garbage collector and the <ph id="ph1">`generation`</ph> parameter.</source>
          <target state="translated">Une collecte bloquante peut être exécutée, selon l'état du récupérateur de mémoire et du paramètre <ph id="ph1">`generation`</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The garbage collector tries to provide optimal performance.</source>
          <target state="translated">Le Garbage collector tente de fournir des performances optimales.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A collection may be performed, depending on the state of the garbage collector.</source>
          <target state="translated">Une collection de blocage peut être effectuée, en fonction de l’état du Garbage collector.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> demande une collection d'arrière-plan, mais cela n'est pas garanti ; selon les cas, une collection bloquante peut toujours être exécutée.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The garbage collector tries to provide optimal performance.</source>
          <target state="translated">Le Garbage collector tente de fournir des performances optimales.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is already in progress, the method returns immediately.</source>
          <target state="translated">Si une collection d’arrière-plan est déjà en cours, la méthode retourne immédiatement une valeur.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a call to the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property to <ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> before calling the <ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">Si un appel à la <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> méthode effectue une garbage collection de blocage, vous pouvez également compacter le tas d’objets volumineux en définissant le <ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> propriété <ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> avant d’appeler le <ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> n'est pas valide.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> ne fait pas partie des valeurs <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">Numéro de la génération la plus ancienne devant faire l'objet d'un garbage collection.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>An enumeration value that specifies whether the garbage collection is forced (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) or optimized (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</source>
          <target state="translated">Valeur d'énumération qui spécifie si le garbage collection est forcé (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) ou optimisé (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a blocking garbage collection; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a background garbage collection where possible.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour effectuer un garbage collection de blocage ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour effectuer un garbage collection d'arrière-plan, si possible.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to compact the small object heap; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to sweep only.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour compacter le tas de petits objets. <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour effectuer un balayage uniquement.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> value, with values that specify whether the collection should be blocking and compacting.</source>
          <target state="translated">Force un garbage collection de la génération 0 jusqu'à une génération spécifiée, à une heure indiquée par une valeur <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph>, avec des valeurs indiquant si le garbage collection doit effectuer le blocage et le compactage.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`blocking`</ph> is <ph id="ph2">`false`</ph>, the GC decides whether to perform a background or a blocking garbage collection.</source>
          <target state="translated">Si <ph id="ph1">`blocking`</ph> est <ph id="ph2">`false`</ph>, le garbage collector décide s’il faut effectuer un arrière-plan ou un blocage de garbage collection.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`compacting`</ph> is <ph id="ph2">`true`</ph>, it performs a blocking garbage collection.</source>
          <target state="translated">Si <ph id="ph1">`compacting`</ph> est <ph id="ph2">`true`</ph>, il effectue une garbage collection de blocage.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`compacting`</ph> is <ph id="ph2">`true`</ph>, the runtime compacts the small object heap (SOH).</source>
          <target state="translated">Si <ph id="ph1">`compacting`</ph> est <ph id="ph2">`true`</ph>, le runtime compacte le tas de petits objets (SOH).</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>The large object heap (LOH) is not compacted unless the <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property is set to <ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Le tas d’objets volumineux (LOH) n’est pas compacté, sauf si le <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> est définie sur <ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Note that this includes all blocking garbage collections, not just full blocking garbage collections.</source>
          <target state="translated">Notez que cela inclut tous les garbage collections de blocage, pas simplement tous les garbage collections bloquants.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>You can call the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.</source>
          <target state="translated">Vous pouvez appeler la <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> méthode afin de réduire le tas managé pour la plus petite possible de taille, comme l’illustre le fragment de code suivant.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Specifying <ph id="ph1">`true`</ph> for the <ph id="ph2">`compacting`</ph> argument guarantees a compacting, full blocking garbage collection.</source>
          <target state="translated">Spécification de <ph id="ph1">`true`</ph> pour la <ph id="ph2">`compacting`</ph> argument garantit une compactage, complète garbage collection de blocage.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Setting the <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property to <ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> ensures that both the LOH and SOH are compacted.</source>
          <target state="translated">Définition de la <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> propriété <ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> garantit que le LOH et la déclaration d’intégrité sont compactées.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>The generation of objects for which the garbage collection count is to be determined.</source>
          <target state="translated">Génération d'objets pour lesquels le compteur de garbage collection doit être déterminé.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>Returns the number of times garbage collection has occurred for the specified generation of objects.</source>
          <target state="translated">Retourne le nombre de fois que le garbage collection s’est produit pour la génération d’objets spécifiée.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>The number of times garbage collection has occurred for the specified generation since the process was started.</source>
          <target state="translated">Nombre de fois où le garbage collection s’est produit pour la génération spécifiée, depuis que le processus a été démarré.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>If you implement your own resource management, you might need to force garbage collection periodically by calling the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">Si vous implémentez votre propre gestion des ressources, vous devrez peut-être forcer le garbage collection périodiquement en appelant le <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.</source>
          <target state="translated">Comme il s’agit d’une opération coûteuse, vous pouvez améliorer les performances en ignorant l’appel lorsqu’un garbage collection s’est produite récemment.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>Save the value returned by <ph id="ph1">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> immediately after calling <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph>.</source>
          <target state="translated">Enregistrez la valeur retournée par <ph id="ph1">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> immédiatement après l’appel <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>The next time you need to call <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>, compare the current value returned by <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> to the saved value.</source>
          <target state="translated">La prochaine fois que vous avez besoin d’appeler <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>, comparez la valeur actuelle retournée par <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> à la valeur enregistrée.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>If the two values are equal, no collection has occurred in the interim and it is reasonable to call <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> again.</source>
          <target state="translated">Si les deux valeurs sont égales, aucune collection ne s’est produit dans l’intervalle et il est raisonnable d’appeler <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> à nouveau.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>Ends the no GC region latency mode.</source>
          <target state="translated">Termine le mode de latence sans région GC.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> if the garbage collector is not in no GC region latency mode.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> méthode lève une exception une <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> si le garbage collector n’est pas en mode de latence sans région GC.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>This occurs under any of the following conditions:</source>
          <target state="translated">Cela se produit si l’une des conditions suivantes :</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method was not called previously.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> (méthode) n’a pas été appelée précédemment.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The call to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method returned <ph id="ph2">`false`</ph>.</source>
          <target state="translated">L’appel à la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> méthode retournée <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The call to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method threw an exception.</source>
          <target state="translated">L’appel à la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> méthode a levé une exception.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>You can prevent an exception for any of these reasons by using code such as the following:</source>
          <target state="translated">Vous pouvez éviter qu’une exception pour une des raisons suivantes à l’aide de code semblable au suivant :</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>The garbage collector is not in no GC region latency mode.</source>
          <target state="translated">Le garbage collector n’est pas en mode de latence sans région GC.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>The no GC region latency mode was ended previously because a garbage collection was induced.</source>
          <target state="translated">Le mode de latence sans région GC a été interrompu précédemment, car un garbage collection a été induit.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>A memory allocation exceeded the amount specified in the call to the <ph id="ph1">&lt;see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /&gt;</ph> method.</source>
          <target state="translated">Une allocation de mémoire a dépassé la quantité spécifiée dans l’appel à la méthode <ph id="ph1">&lt;see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Returns the current generation number of an object.</source>
          <target state="translated">Retourne le numéro de la génération actuelle d'un objet.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The object that generation information is retrieved for.</source>
          <target state="translated">Objet pour lequel les informations de génération sont récupérées.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.Object)">
          <source>Returns the current generation number of the specified object.</source>
          <target state="translated">Retourne le numéro de la génération actuelle de l'objet spécifié.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The current generation number of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated">Numéro de génération actuelle de <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>Use this method to determine the age of an object, and then use that information with the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to force the garbage collector to collect objects in the same generation.</source>
          <target state="translated">Utilisez cette méthode pour déterminer la durée de vie d’un objet et ensuite utiliser ces informations avec la <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> méthode pour forcer le garbage collector pour collecter des objets dans la même génération.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</source>
          <target state="translated">Par exemple, utilisez cette méthode lorsque vous avez un ensemble d’objets qui sont créés en tant que groupe et qui deviennent inaccessibles en même temps.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph> method to determine the age of an object.</source>
          <target state="translated">L’exemple suivant montre comment utiliser la <ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph> méthode pour déterminer la durée de vie d’un objet.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.</source>
          <target state="translated">L’exemple effectue ensuite les opérations garbage collection pour nettoyer la mémoire et de comparer les versions antérieures et de valider les totaux de mémoire dans la console.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>A <ph id="ph1">&lt;see cref="T:System.WeakReference" /&gt;</ph> that refers to the target object whose generation number is to be determined.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.WeakReference" /&gt;</ph> qui fait référence à l'objet cible dont le numéro de génération doit être déterminé.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>Returns the current generation number of the target of a specified weak reference.</source>
          <target state="translated">Retourne le numéro de la génération actuelle de la cible d'une référence faible spécifiée.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>The current generation number of the target of <ph id="ph1">&lt;paramref name="wo" /&gt;</ph>.</source>
          <target state="translated">Numéro de génération actuelle de la cible de <ph id="ph1">&lt;paramref name="wo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph> method to determine the age of a weak reference object.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph> méthode pour déterminer la durée de vie d’un objet de référence faible.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>Garbage collection has already been performed on <ph id="ph1">&lt;paramref name="wo" /&gt;</ph>.</source>
          <target state="translated">Le garbage collection a déjà été exécuté sur <ph id="ph1">&lt;paramref name="wo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour indiquer que cette méthode peut attendre le garbage collection avant de retourner une réponse ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>Retrieves the number of bytes currently thought to be allocated.</source>
          <target state="translated">Récupère le nombre d'octets qu'il est actuellement prévu d'allouer.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</source>
          <target state="translated">Un paramètre indique si cette méthode peut attendre une courte période de temps avant de retourner une réponse, pour permettre au système d'effectuer un garbage collection et de finaliser les objets.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>A number that is the best available approximation of the number of bytes currently allocated in managed memory.</source>
          <target state="translated">Nombre correspondant à la meilleure approximation possible du nombre d'octets actuellement alloués dans la mémoire managée.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>If the <ph id="ph1">`forceFullCollection`</ph> parameter is <ph id="ph2">`true`</ph>, this method waits a short interval before returning while the system collects garbage and finalizes objects.</source>
          <target state="translated">Si le <ph id="ph1">`forceFullCollection`</ph> paramètre est <ph id="ph2">`true`</ph>, cette méthode attend une courte période avant de retourner pendant que le système de garbage collection et finalise les objets.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.</source>
          <target state="translated">La durée de l’intervalle est une limite spécifiée en interne déterminée par le nombre de garbage collection cycles est terminée et que la modification de la quantité de mémoire récupérée entre les cycles.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>The garbage collector does not guarantee that all inaccessible memory is collected.</source>
          <target state="translated">Le garbage collector ne garantit pas que la mémoire inaccessible est collectée.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.GetTotalMemory%2A&gt;</ph> method to get and display the number of bytes currently allocated in managed memory.</source>
          <target state="translated">L’exemple suivant montre comment utiliser la <ph id="ph1">&lt;xref:System.GC.GetTotalMemory%2A&gt;</ph> méthode pour obtenir et afficher le nombre d’octets actuellement alloués dans la mémoire managée.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The object to reference.</source>
          <target state="translated">Objet à référencer.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.GC.KeepAlive(System.Object)">
          <source>References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</source>
          <target state="translated">Référence l’objet spécifié, ce qui le rend inéligible pour le garbage collection du début de la routine actuelle jusqu’au point où cette méthode est appelée.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The purpose of the <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.</source>
          <target state="translated">L’objectif de la <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> méthode consiste à vérifier l’existence d’une référence à un objet qui risque d’être récupéré prématurément par le garbage collector.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.</source>
          <target state="translated">Est d’un scénario courant où cela peut se produire lorsqu’il n’existe aucune référence à l’objet dans le code managé ou les données, mais l’objet est en cours d’utilisation dans le code non managé, telles que les API Win32, des DLL non managées, ou les méthodes à l’aide de COM.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>This method references the <ph id="ph1">`obj`</ph> parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.</source>
          <target state="translated">Cette méthode fait référence à la <ph id="ph1">`obj`</ph> paramètre, rendant cet objet inéligible pour le garbage collection à partir du début de la routine au point de données, dans l’ordre d’exécution, où cette méthode est appelée.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>Code this method at the end, not the beginning, of the range of instructions where <ph id="ph1">`obj`</ph> must be available.</source>
          <target state="translated">Cette méthode à la fin, et non au début de la plage d’instructions de code où <ph id="ph1">`obj`</ph> doit être disponible.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> méthode n’effectue aucune opération et ne produit aucun effet autre que l’extension de la durée de vie de l’objet passé en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The following code example creates an object at the beginning of its <ph id="ph1">`Main`</ph> method and does not refer to the object again until the end, when the <ph id="ph2">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method is called.</source>
          <target state="translated">L’exemple de code suivant crée un objet au début de son <ph id="ph1">`Main`</ph> méthode et ne fait pas référence à l’objet jusqu'à la fin, lorsque la <ph id="ph2">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The object persists for the 30-second duration of the <ph id="ph1">`Main`</ph> method, despite calls to the <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> methods.</source>
          <target state="translated">L’objet est persistant pendant la durée de 30 secondes de la <ph id="ph1">`Main`</ph> (méthode), en dépit d’appels à la <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> et <ph id="ph3">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="P:System.GC.MaxGeneration">
          <source>Gets the maximum number of generations that the system currently supports.</source>
          <target state="translated">Obtient le nombre maximal de générations actuellement pris en charge par le système.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>A value that ranges from zero to the maximum number of supported generations.</source>
          <target state="translated">Valeur comprise entre zéro et le nombre maximal de générations prises en charge.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.</source>
          <target state="translated">Le numéro de génération, ou âge, d’un objet est une mesure relative définie par l’implémentation de durée de vie d’un objet.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property.</source>
          <target state="translated">Les objets plus récemment créés sont dans la génération 0 et les objets les plus anciens sont dans une génération inférieure ou égale à la génération retournée par la <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.</source>
          <target state="translated">Le garbage collector considère que la mémoire la plus récente est plus susceptible d’être éligibles pour le garbage collection que la mémoire plus anciens.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property value can grow over time.</source>
          <target state="translated">Par conséquent, le garbage collector améliore ses performances en ajustant les numéros de génération chaque fois qu’il récupère la mémoire, et le <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> valeur de propriété peut augmenter au fil du temps.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>If object aging is implemented, the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property returns the maximum generation number used by the system; otherwise, this property returns zero.</source>
          <target state="translated">Si la chronologie de l’objet est implémentée, le <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> propriété retourne le nombre maximal de générations utilisé par le système ; sinon, cette propriété retourne zéro.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The following example demonstrates how to use the MaxGeneration property to display the largest generation number currently in use.</source>
          <target state="translated">L’exemple suivant montre comment utiliser la propriété MaxGeneration pour afficher le plus grand nombre de génération actuellement en cours d’utilisation.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>For this implementation, the value returned by the <ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph> property is guaranteed to remain constant for the lifetime of an executing application.</source>
          <target state="translated">Pour cette implémentation, la valeur retournée par la <ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph> propriété reste constante pour la durée de vie d’une application en cours d’exécution est garantie.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>Use the <ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph> property to determine the maximum value you can specify when calling the <ph id="ph2">&lt;see cref="M:System.GC.Collect(System.Int32)" /&gt;</ph> method that takes a generation parameter.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph> propriété pour déterminer la valeur maximale que vous pouvez spécifier lors de l’appel du <ph id="ph2">&lt;see cref="M:System.GC.Collect(System.Int32)" /&gt;</ph> méthode qui accepte un paramètre de génération.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</source>
          <target state="translated">Nombre entre 1 et 99 qui spécifie le moment auquel la notification doit être émise selon les objets alloués dans la génération 2.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</source>
          <target state="translated">Nombre entre 1 et 99 qui spécifie le moment auquel la notification doit être émise selon les objets alloués dans le tas d'objets volumineux.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</source>
          <target state="translated">Spécifie qu’une notification de garbage collection doit être émise quand les conditions sont favorables à un garbage collection complet et quand celui-ci est terminé.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For each generation, the garbage collector sets a threshold for allocations into that generation.</source>
          <target state="translated">Pour chaque génération, le garbage collector définit un seuil pour les allocations de cette génération.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.</source>
          <target state="translated">Lorsque la taille des allocations dépasse ce seuil, un garbage collection est déclenché sur cette génération.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For example, if generation 2’s threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.</source>
          <target state="translated">Pour exemple, si le seuil de génération 2 est de 20 Mo (ce qui signifie que 20 Mo survit à des collections de génération 1 est promue dans la génération 2) et plus de 20 Mo a survécu à la génération 1 et qu’il est invité à entrer dans la génération 2, le garbage collection suivant va être tenté. en tant que collection de génération 2.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).</source>
          <target state="translated">De même, si le tas d’objets volumineux 's (LOH) seuil est de 20 Mo et que votre application a allouée plus de 20 Mo d’objets volumineux, le garbage collection suivant sera tenté également comme une collection de génération 2 (puisque le LOH est collecté uniquement dans les garbage collections de génération 2).</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`maxGenerationThreshold`</ph> and <ph id="ph2">`largeObjectHeapThreshold`</ph> thresholds control how much in advance you are notified before a full garbage collection occurs.</source>
          <target state="translated">Le <ph id="ph1">`maxGenerationThreshold`</ph> et <ph id="ph2">`largeObjectHeapThreshold`</ph> seuils contrôlent combien à l’avance vous êtes averti avant un garbage collection complet.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.</source>
          <target state="translated">Plus le seuil, plus les allocations qui peuvent se produire entre la notification et le prochain garbage collection complet.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method) when conditions are still favorable.</source>
          <target state="translated">Si vous avez des situations dans lesquelles une garbage collection complet par le common language runtime peut gêner les performances de votre application, vous pouvez demander à être averti lorsque l’exécution est sur le point d’effectuer un garbage collection complet et le contrecarrer par induire vous-même une collection (à l’aide de la <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> méthode) lorsque les conditions sont toujours favorables.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:</source>
          <target state="translated">En plus de la modification de la garbage collection vous-même, notification GC complète est utile dans les scénarios suivants :</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).</source>
          <target state="translated">Vous surveillez pour l’approche de garbage collection complet et, lorsque vous êtes informé qu’une approche, vous réduisez la taille des données en temps réel (par exemple, en libérant des entrées de cache).</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>As a result, when the garbage collection occurs, it is able to reclaim more memory.</source>
          <target state="translated">Par conséquent, lorsque le garbage collection se produit, il est en mesure de libérer plus de mémoire.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>You monitor for the completion of a full garbage collection so that you can collect some statistics.</source>
          <target state="translated">Vous surveillez l’achèvement d’un garbage collection complet afin que vous pouvez collecter des statistiques.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.</source>
          <target state="translated">Par exemple, vous souhaiterez mesurer la taille du segment de mémoire à l’achèvement de GC afin que vous connaissez la taille des données en direct.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>(After a full GC, the heap is at its smallest size.)</source>
          <target state="translated">(Après un GC complet, le segment de mémoire est à sa taille plus petite).</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For more information about what represents a full garbage collection, see <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur ce que représente un garbage collection complet, consultez <bpt id="p1">[</bpt>Notifications de Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.</source>
          <target state="translated">Lorsque vous inscrivez pour une notification de garbage collection, vous pouvez être averti quand un garbage collection complet approche et lorsqu’elle est effectuée.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This pattern resembles how the operating system monitors for low memory notifications.</source>
          <target state="translated">Ce modèle est similaire à la manière dont le système d’exploitation analyse pour les notifications de mémoire insuffisante.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>Use the following guidelines for specifying the <ph id="ph1">`maxGenerationThreshold`</ph> and <ph id="ph2">`largeObjectHeapThreshold`</ph> parameters:</source>
          <target state="translated">Suivez les indications ci-dessous pour spécifier le <ph id="ph1">`maxGenerationThreshold`</ph> et <ph id="ph2">`largeObjectHeapThreshold`</ph> paramètres :</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.</source>
          <target state="translated">Plus la valeur de seuil, les allocations plus seront produit entre la notification et le garbage collection complet.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>A larger threshold value provides more opportunities for the runtime to check for an approaching collection.</source>
          <target state="translated">Une valeur de seuil élevée fournit davantage d’occasions de l’exécution pour vérifier imminence d’une collection.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This increases the likelihood that you will be notified.</source>
          <target state="translated">Cela augmente la probabilité que vous êtes averti.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.</source>
          <target state="translated">Toutefois, vous ne devez pas définir le seuil trop élevé, car entraîne une allocations plus avant que le runtime déclenche la collection suivante.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.</source>
          <target state="translated">Lorsque vous induisez une collection vous-même la notification à l’aide d’une valeur de seuil élevée, moins d’objets sont libérés qu’aurait être récupéré par la collection suivante.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.</source>
          <target state="translated">Plus la valeur de seuil, moins les allocations entre la notification et le garbage collection complet.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification.</source>
          <target state="translated">L’exemple suivant montre comment inscrire une notification de garbage collection et démarrer un thread pour surveiller l’état de la notification de garbage collection.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This code example is part of a larger example provided for <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">Cet exemple de code fait partie d’un exemple plus complet fourni pour <bpt id="p1">[</bpt>Notifications de Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> rubrique.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maxGenerationThreshold" /&gt;</ph> or <ph id="ph2">&lt;paramref name="largeObjectHeapThreshold" /&gt;</ph> is not between 1 and 99.</source>
          <target state="translated">Ni <ph id="ph1">&lt;paramref name="maxGenerationThreshold" /&gt;</ph> ni <ph id="ph2">&lt;paramref name="largeObjectHeapThreshold" /&gt;</ph> n’est compris entre 1 et 99.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">pour la confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>The amount of unmanaged memory that has been released.</source>
          <target state="translated">Quantité de mémoire non managée qui a été libérée.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</source>
          <target state="translated">Informe l’exécution que la mémoire non managée a été libérée et n’a plus besoin d’être prise en compte lors de la planification du garbage collection.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</source>
          <target state="translated">Déterminer le moment de planifier le garbage collection, le runtime prend en compte la quantité de mémoire managée est alloué.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</source>
          <target state="translated">Si un petit objet managé alloue une grande quantité de mémoire non managée, le runtime prend en compte uniquement la mémoire managée et en conséquence sous-estime l’urgence de la planification du garbage collection.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method informs the runtime of this additional pressure on system memory, and the <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method informs the runtime that the additional pressure has been released.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> méthode informe l’exécution de cette sollicitation supplémentaire sur la mémoire système et le <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> méthode informe l’exécution que la pression supplémentaire a été libérée.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the <ph id="ph1">`Dispose`</ph> or <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">Dans le modèle d’utilisation la plus simple, un objet managé alloue la mémoire non managée dans le constructeur et mises à jour dans le <ph id="ph1">`Dispose`</ph> ou <ph id="ph2">`Finalize`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method after allocating the unmanaged memory, and call the <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method after releasing it.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> méthode après avoir alloué la mémoire non managée et appelez le <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> méthode après l’avoir libéré.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> methods to communicate these incremental changes to the runtime.</source>
          <target state="translated">Dans les scénarios plus complexes, où l’allocation de mémoire non managée change substantiellement pendant la durée de vie de l’objet managé, vous pouvez appeler la <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> méthodes permettant de communiquer ces modifications incrémentielles à l’exécution.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>You must ensure that you remove exactly the amount of pressure you add.</source>
          <target state="translated">Vous devez vous assurer que vous supprimez la quantité exacte de pression que vous ajoutez.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</source>
          <target state="translated">Sinon, peut nuire aux performances du système dans les applications qui s’exécutent pendant de longues périodes de temps.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is less than or equal to 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> est inférieur ou égal à 0.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>On a 32-bit computer, <ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is larger than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Sur un ordinateur à 32 bits, <ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> est supérieur à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>for the ability to call unmanaged code when manipulating garbage-collection priority.</source>
          <target state="translated">pour avoir la possibilité d’appeler du code non managé lors de la manipulation de priorité du garbage collection.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The object that a finalizer must be called for.</source>
          <target state="translated">Objet pour lequel un finaliseur doit être appelé.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>Requests that the system call the finalizer for the specified object for which <ph id="ph1">&lt;see cref="M:System.GC.SuppressFinalize(System.Object)" /&gt;</ph> has previously been called.</source>
          <target state="translated">Demande que le système appelle le finaliseur pour l'objet spécifié, pour lequel <ph id="ph1">&lt;see cref="M:System.GC.SuppressFinalize(System.Object)" /&gt;</ph> a été précédemment appelé.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> method adds the <ph id="ph2">`obj`</ph> parameter to the list of objects that request finalization before the garbage collector frees the object.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> méthode ajoute la <ph id="ph2">`obj`</ph> paramètre à la liste des objets qui demandent à être finalisés avant que le garbage collector libère l’objet.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The <ph id="ph1">`obj`</ph> parameter must be the caller of this method.</source>
          <target state="translated">Le <ph id="ph1">`obj`</ph> le paramètre doit être l’appelant de cette méthode.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> method does not guarantee that the garbage collector will call an object's finalizer.</source>
          <target state="translated">Appel de la <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> méthode ne garantit pas que le garbage collector appellera le finaliseur d’un objet.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method.</source>
          <target state="translated">Par défaut, tous les objets qui implémentent des finaliseurs sont ajoutés à la liste des objets qui nécessitent une finalisation ; Toutefois, un objet peut déjà avoir été finalisé ou avoir désactivé la finalisation en appelant le <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>A finalizer can use this method to resurrect itself or an object that it references.</source>
          <target state="translated">Un finaliseur peut utiliser cette méthode pour se réactiver ou réactiver un objet qu’il référence.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The following example demonstrates how to use the ReRegisterForFinalize method to finalize an object a second time after garbage collection.</source>
          <target state="translated">L’exemple suivant montre comment utiliser la méthode ReRegisterForFinalize pour finaliser l’objet d’un deuxième temps après le garbage collection.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>The object whose finalizer must not be executed.</source>
          <target state="translated">Objet dont le finaliseur ne doit pas être exécuté.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>Requests that the common language runtime not call the finalizer for the specified object.</source>
          <target state="translated">Demande que le Common Language Runtime n'appelle pas le finaliseur pour l'objet spécifié.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>This method sets a bit in the object header of <ph id="ph1">`obj`</ph>, which the runtime checks when calling finalizers.</source>
          <target state="translated">Cette méthode définit un bit dans l’en-tête de l’objet de <ph id="ph1">`obj`</ph>, ce qui le runtime vérifie lors de l’appel de finaliseurs.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>A finalizer, which is represented by the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method, is used to release unmanaged resources before an object is garbage-collected.</source>
          <target state="translated">Un finaliseur, ce qui est représenté par le <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> (méthode), est utilisée pour libérer les ressources non managées avant un objet par le garbage collector.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>If <ph id="ph1">`obj`</ph> does not have a finalizer, the call to the <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method has no effect.</source>
          <target state="translated">Si <ph id="ph1">`obj`</ph> n’a pas d’un finaliseur, l’appel à la <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> méthode n’a aucun effet.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>Objects that implement the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface can call this method from the object's <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation to prevent the garbage collector from calling <ph id="ph3">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> on an object that does not require it.</source>
          <target state="translated">Les objets qui implémentent la <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface peut appeler cette méthode à partir de l’objet <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> mise en œuvre pour empêcher le garbage collector d’appeler <ph id="ph3">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> sur un objet qui ne l’impose pas.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">En règle générale, cela empêche le finaliseur de libérer des ressources non managées qui ont déjà été libérées par la <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implémentation.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method in a resource class to prevent a redundant garbage collection from being called.</source>
          <target state="translated">L’exemple suivant montre comment utiliser la <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> méthode dans une classe de ressource pour empêcher un garbage collection redondant à partir de l’appel.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>The example uses the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> to free both managed resources (that is, objects that implement <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>) and unmanaged resources.</source>
          <target state="translated">L’exemple utilise le <bpt id="p1">[</bpt>modèle de suppression<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> pour libérer à la fois les ressources managées (autrement dit, les objets qui implémentent <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>) et les ressources non managées.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Attempts to disallow garbage collection during the execution of a critical path.</source>
          <target state="translated">Tente d’interdire le garbage collection pendant l’exécution d’un chemin d’accès critique.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">Vous ne pouvez pas imbriquer des appels à la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> (méthode) et vous devez appeler uniquement la <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> méthode si le runtime est actuellement en mode de latence sans région GC.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">En d’autres termes, vous ne devez pas appeler <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> réussisse parce que le premier appel à <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> a réussi.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">Quantité de mémoire en octets à allouer sans déclencher un garbage collection.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>It must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated">Elle doit être inférieure ou égale à la taille d'un segment éphémère.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>For information on the size of an ephemeral segement, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">Pour plus d’informations sur la taille d’un segment éphémère, consultez la section « Segments et générations éphémères » dans l’article <bpt id="p1">[</bpt>Notions de base du garbage collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</source>
          <target state="translated">Tente d'interdire le garbage collection pendant l'exécution d'un chemin d'accès critique si une quantité de mémoire spécifiée est disponible.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le runtime a pu valider la quantité de mémoire requise et que le garbage collector peut entrer en mode de latence sans région GC ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%29&gt;</ph> méthode tente de placer le garbage collector dans aucun mode de latence de région dans le catalogue global, qui n’autorise pas le garbage collection pendant une application exécute une région de code critique.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</source>
          <target state="translated">Si le runtime ne parvient pas initialement allouer la quantité de mémoire demandée, le garbage collector effectue une garbage collection de blocage afin de libérer de la mémoire.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * <ph id="ph1">`totalSize`</ph> bytes (it attempts to allocate <ph id="ph2">`totalSize`</ph> bytes for the small object heap and <ph id="ph3">`totalSize`</ph> bytes for the large object heap).</source>
          <target state="translated">Le garbage collector entre le mode de latence sans région GC s’il n’est en mesure d’allouer la quantité de mémoire, ce qui dans ce cas est réellement 2 requise * <ph id="ph1">`totalSize`</ph> octets (il tente d’allouer <ph id="ph2">`totalSize`</ph> octets pour le tas de petits objets et <ph id="ph3">`totalSize`</ph> octets pour le tas d’objets volumineux).</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source><ph id="ph1">`totalSize`</ph> must be large enough to handle all memory allocations that occur in the critical path.</source>
          <target state="translated"><ph id="ph1">`totalSize`</ph> doit être suffisamment grande pour gérer toutes les allocations de mémoire qui se produisent dans le chemin d’accès critique.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">Cela inclut les allocations effectuées par l’application, ainsi que les allocations que le runtime effectue sur le nom de l’application.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">Vous ne pouvez pas imbriquer des appels à la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> (méthode) et vous devez appeler uniquement la <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> méthode si le runtime est actuellement en mode de latence sans région GC.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">En d’autres termes, vous ne devez pas appeler <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> réussisse parce que le premier appel à <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> a réussi.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">Vous quittez le mode sans région GC latence en appelant le <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> dépasse la taille du segment éphémère.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">Le processus est déjà en mode de latence sans région GC.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">Quantité de mémoire en octets à allouer sans déclencher un garbage collection.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>It must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated">Elle doit être inférieure ou égale à la taille d'un segment éphémère.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>For information on the size of an ephemeral segement, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">Pour plus d’informations sur la taille d’un segment éphémère, consultez la section « Segments et générations éphémères » dans l’article <bpt id="p1">[</bpt>Notions de base du garbage collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> bytes; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour omettre un garbage collection de blocage total si le récupérateur de mémoire ne parvient pas initialement à allouer <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> octets ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</source>
          <target state="translated">Tente d'interdire le garbage collection pendant l'exécution d'un chemin d'accès critique si une quantité de mémoire spécifiée est disponible, et contrôle si le garbage collector effectue un garbage collection de blocage complet si la mémoire initialement disponible est insuffisante.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le runtime a pu valider la quantité de mémoire requise et que le garbage collector peut entrer en mode de latence sans région GC ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29&gt;</ph> méthode tente de placer le garbage collector dans aucun mode de latence de région dans le catalogue global, qui n’autorise pas le garbage collection pendant une application exécute une région de code critique.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>If the runtime is unable to initially allocate the requested amount of memory and the <ph id="ph1">`disallowFullBlockingGC`</ph> argument is <ph id="ph2">`false`</ph>, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Si le runtime ne parvient pas initialement allouer la quantité de mémoire demandée et le <ph id="ph1">`disallowFullBlockingGC`</ph> argument est <ph id="ph2">`false`</ph>, le garbage collector effectue une garbage collection de blocage en essayant de libérer de la mémoire ; sinon, l’allocation échoue et la méthode retourne <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * <ph id="ph1">`totalSize`</ph> (it attempts to allocate <ph id="ph2">`totalSize`</ph> for the small object heap and <ph id="ph3">`totalSize`</ph> for the large object heap).</source>
          <target state="translated">Le garbage collector entre le mode de latence sans région GC s’il n’est en mesure d’allouer la quantité de mémoire, ce qui dans ce cas est réellement 2 requise * <ph id="ph1">`totalSize`</ph> (il tente d’allouer <ph id="ph2">`totalSize`</ph> pour le tas de petits objets et <ph id="ph3">`totalSize`</ph> pour le tas d’objets volumineux).</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">`totalSize`</ph> must be large enough to handle all memory allocations that occur in the critical path.</source>
          <target state="translated"><ph id="ph1">`totalSize`</ph> doit être suffisamment grande pour gérer toutes les allocations de mémoire qui se produisent dans le chemin d’accès critique.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">Cela inclut les allocations effectuées par l’application, ainsi que les allocations que le runtime effectue sur le nom de l’application.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>Setting <ph id="ph1">`disallowFullBlockingGC`</ph> to <ph id="ph2">`true`</ph> to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns <ph id="ph3">`true`</ph>, and have the load balancer redirect requests to other systems if it returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Paramètre <ph id="ph1">`disallowFullBlockingGC`</ph> à <ph id="ph2">`true`</ph> pour empêcher un garbage de blocage complet collection si l’objet n’est pas assez de mémoire initialement disponible est particulièrement utile dans les scénarios d’équilibrage de charge : un système peut appeler cette méthode et déclarer non prêt à accepter les demandes si elle retourne <ph id="ph3">`true`</ph>, et l’équilibrage de charge rediriger les demandes vers d’autres systèmes si elle retourne <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>It can then do a full blocking garbage collection when it's not handling requests by calling the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">Il peut ensuite exécuter une garbage collection de blocage quand il ne gère pas les demandes en appelant le <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">Vous ne pouvez pas imbriquer des appels à la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> (méthode) et vous devez appeler uniquement la <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> méthode si le runtime est actuellement en mode de latence sans région GC.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">En d’autres termes, vous ne devez pas appeler <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> réussisse parce que le premier appel à <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> a réussi.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">Vous quittez le mode sans région GC latence en appelant le <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> dépasse la taille du segment éphémère.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">Le processus est déjà en mode de latence sans région GC.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">Quantité de mémoire en octets à allouer sans déclencher un garbage collection.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> –<bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> – <bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> doit être inférieure ou égale à la taille d’un segment éphémère.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>For information on the size of an ephemeral segement, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">Pour plus d’informations sur la taille d’un segment éphémère, consultez la section « Segments et générations éphémères » dans l’article <bpt id="p1">[</bpt>Notions de base du garbage collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The number of bytes in <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> to use for large object heap (LOH) allocations.</source>
          <target state="translated">Nombre d’octets dans <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> à utiliser pour les allocations de tas d’objets volumineux (LOH).</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</source>
          <target state="translated">Tente d'interdire le garbage collection pendant l'exécution d'un chemin d'accès critique si une quantité de mémoire spécifiée est disponible pour le tas d'objets volumineux et le tas de petits objets.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le runtime a pu valider la quantité de mémoire requise et que le garbage collector peut entrer en mode de latence sans région GC ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29&gt;</ph> méthode tente de placer le garbage collector dans aucun mode de latence de région dans le catalogue global, qui n’autorise pas le garbage collection pendant une application exécute une région de code critique.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</source>
          <target state="translated">Si le runtime ne parvient pas initialement allouer la quantité de mémoire demandée, le garbage collector effectue une garbage collection de blocage afin de libérer de la mémoire.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate <ph id="ph1">`lohSize`</ph> for the LOH and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> for the small object heap (SOH).</source>
          <target state="translated">Le garbage collector entre le mode de latence sans région GC s’il n’est en mesure d’allouer <ph id="ph1">`lohSize`</ph> pour le LOH et <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> pour le tas de petits objets (SOH).</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><ph id="ph1">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the LOH, and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the SOH.</source>
          <target state="translated"><ph id="ph1">`lohSize`</ph> doit être suffisamment grande pour gérer toutes les allocations de mémoire qui se produisent dans le chemin d’accès critique pour le LOH, et <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> doit être suffisamment grande pour gérer toutes les allocations de mémoire qui se produisent dans le chemin d’accès critique pour la déclaration d’intégrité.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">Cela inclut les allocations effectuées par l’application, ainsi que les allocations que le runtime effectue sur le nom de l’application.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">Vous ne pouvez pas imbriquer des appels à la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> (méthode) et vous devez appeler uniquement la <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> méthode si le runtime est actuellement en mode de latence sans région GC.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">En d’autres termes, vous ne devez pas appeler <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> réussisse parce que le premier appel à <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> a réussi.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">Vous quittez le mode sans région GC latence en appelant le <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> dépasse la taille du segment éphémère.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">Le processus est déjà en mode de latence sans région GC.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">Quantité de mémoire en octets à allouer sans déclencher un garbage collection.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> –<bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> – <bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> doit être inférieure ou égale à la taille d’un segment éphémère.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>For information on the size of an ephemeral segement, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">Pour plus d’informations sur la taille d’un segment éphémère, consultez la section « Segments et générations éphémères » dans l’article <bpt id="p1">[</bpt>Notions de base du garbage collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The number of bytes in <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> to use for large object heap (LOH) allocations.</source>
          <target state="translated">Nombre d’octets dans <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> à utiliser pour les allocations de tas d’objets volumineux (LOH).</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour omettre un garbage collection de blocage complet si le garbage collector ne parvient pas initialement à allouer la mémoire spécifiée sur le tas de petits objets (SOH) et le tas d'objets volumineux (LOH) ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</source>
          <target state="translated">Tente de suspendre le garbage collection pendant l'exécution d'un chemin d'accès critique si une quantité de mémoire suffisante spécifiée est disponible pour le tas d'objets volumineux et le tas de petits objets, et contrôle si le garbage collector effectue un garbage collection de blocage complet si la mémoire initialement disponible est insuffisante.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le runtime a pu valider la quantité de mémoire requise et que le garbage collector peut entrer en mode de latence sans région GC ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29&gt;</ph> méthode tente de placer le garbage collector dans aucun mode de latence de région dans le catalogue global, qui n’autorise pas le garbage collection pendant une application exécute une région de code critique.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>If the runtime is unable to initially allocate the requested amount of memory and the <ph id="ph1">`disallowFullBlockingGC`</ph> argument is <ph id="ph2">`false`</ph>, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Si le runtime ne parvient pas initialement allouer la quantité de mémoire demandée et le <ph id="ph1">`disallowFullBlockingGC`</ph> argument est <ph id="ph2">`false`</ph>, le garbage collector effectue une garbage collection de blocage en essayant de libérer de la mémoire ; sinon, l’allocation échoue et la méthode retourne <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate <ph id="ph1">`lohSize`</ph> for the LOH and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> for the small object heap (SOH).</source>
          <target state="translated">Le garbage collector entre le mode de latence sans région GC s’il n’est en mesure d’allouer <ph id="ph1">`lohSize`</ph> pour le LOH et <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> pour le tas de petits objets (SOH).</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the LOH, and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the SOH.</source>
          <target state="translated"><ph id="ph1">`lohSize`</ph> doit être suffisamment grande pour gérer toutes les allocations de mémoire qui se produisent dans le chemin d’accès critique pour le LOH, et <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> doit être suffisamment grande pour gérer toutes les allocations de mémoire qui se produisent dans le chemin d’accès critique pour la déclaration d’intégrité.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">Cela inclut les allocations effectuées par l’application, ainsi que les allocations que le runtime effectue sur le nom de l’application.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>Setting <ph id="ph1">`disallowFullBlockingGC`</ph> to <ph id="ph2">`true`</ph> to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns <ph id="ph3">`true`</ph>, and have the load balancer redirect requests to other systems if it returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Paramètre <ph id="ph1">`disallowFullBlockingGC`</ph> à <ph id="ph2">`true`</ph> pour empêcher un garbage de blocage complet collection si l’objet n’est pas assez de mémoire initialement disponible est particulièrement utile dans les scénarios d’équilibrage de charge : un système peut appeler cette méthode et déclarer non prêt à accepter les demandes si elle retourne <ph id="ph3">`true`</ph>, et l’équilibrage de charge rediriger les demandes vers d’autres systèmes si elle retourne <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>It can then do a full blocking garbage collection when it's not handling requests by calling the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">Il peut ensuite exécuter une garbage collection de blocage quand il ne gère pas les demandes en appelant le <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">Vous ne pouvez pas imbriquer des appels à la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> (méthode) et vous devez appeler uniquement la <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> méthode si le runtime est actuellement en mode de latence sans région GC.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">En d’autres termes, vous ne devez pas appeler <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> plusieurs fois (après le premier appel de méthode, les appels suivants ne réussissent pas), et vous ne devriez pas les appels à <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> réussisse parce que le premier appel à <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> a réussi.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">Vous quittez le mode sans région GC latence en appelant le <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> dépasse la taille du segment éphémère.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">Le processus est déjà en mode de latence sans région GC.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</source>
          <target state="translated">Retourne l’état d’une notification inscrite pour déterminer si un garbage collection de blocage complet par le Common Language Runtime est imminent.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</source>
          <target state="translated">Retourne l’état d’une notification inscrite pour déterminer si un garbage collection de blocage complet par le Common Language Runtime est imminent.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">État de la notification de garbage collection inscrite.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> énumération retournée par cette méthode pour déterminer l’état de la notification de garbage collection en cours qui a été inscrite à l’aide de la <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to determine whether the full garbage collection has completed.</source>
          <target state="translated">Vous pouvez également utiliser le <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> méthode pour déterminer si le garbage collection complet est terminé.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">Lorsque l’énumération retourne <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, vous pouvez effectuer des tâches telles qu’empêcher des objets supplémentaires qui est alloué et induire une collection avec le <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</source>
          <target state="translated">Notez que la notification ne garantit pas qu’un garbage collection complet se produit, qu’en conditions ont atteint le seuil auquel un garbage collection complet se produise.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This method waits indefinitely for a garbage collection notification to be obtained.</source>
          <target state="translated">Cette méthode attend indéfiniment pour une notification de garbage collection doit être obtenu.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Si vous souhaitez spécifier un délai d’attente pour la méthode à retourner si la notification ne peut pas être obtenue, utilisez le <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>If you call this method without specifying a time-out, you can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method if you are waiting longer than preferred.</source>
          <target state="translated">Si vous appelez cette méthode sans spécifier un délai d’attente, vous pouvez appeler la <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> méthode si vous attendez plus de préférence.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>You should follow this method with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">Vous devez suivre cette méthode avec un appel à la <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> méthode pour vous assurer que vous avez obtenu un garbage collection complet.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Calling this method alone causes indeterminate results.</source>
          <target state="translated">L’appel de cette méthode seule donne des résultats indéterminés.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching.</source>
          <target state="translated">L’exemple suivant montre comment utiliser cette méthode pour déterminer si un garbage collection de blocage complet est proche.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Whenever the status of the notification is <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, the user method <ph id="ph2">`OnFullGCApproachNotify`</ph> is called to perform actions in response to the approaching collection.</source>
          <target state="translated">Chaque fois que l’état de la notification est <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, la méthode <ph id="ph2">`OnFullGCApproachNotify`</ph> est appelée pour effectuer des actions en réponse à la collection.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This code example is part of a larger example provided for <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">Cet exemple de code fait partie d’un exemple plus complet fourni pour <bpt id="p1">[</bpt>Notifications de Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> rubrique.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">pour la confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>The length of time to wait before a notification status can be obtained.</source>
          <target state="translated">Temps à attendre avant qu'un état de notification puisse être obtenu.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Specify -1 to wait indefinitely.</source>
          <target state="translated">Spécifiez -1 pour attendre indéfiniment.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</source>
          <target state="translated">Retourne, dans le délai d’attente spécifié, l’état d’une notification inscrite pour déterminer si un garbage collection de blocage complet par le Common Language Runtime est imminent.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">État de la notification de garbage collection inscrite.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> énumération retournée par cette méthode pour déterminer l’état de la notification de garbage collection en cours qui a été inscrite à l’aide de la <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to determine whether the full garbage collection has completed.</source>
          <target state="translated">Vous pouvez également utiliser le <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> méthode pour déterminer si le garbage collection complet est terminé.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by <ph id="ph1">`millisecondsTimeout`</ph>.</source>
          <target state="translated">Notez que cette méthode retourne immédiatement chaque fois qu’un état de notification de garbage collection est obtenu, quelle que soit la valeur spécifiée par <ph id="ph1">`millisecondsTimeout`</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>If a garbage collection notification status is not obtained before <ph id="ph1">`millisecondsTimeout`</ph> times out, this method returns <ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>.</source>
          <target state="translated">Si un état de notification de garbage collection n’est pas obtenu avant <ph id="ph1">`millisecondsTimeout`</ph> heures, cette méthode retourne <ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">Lorsque l’énumération retourne <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, vous pouvez effectuer des tâches telles qu’empêcher des objets supplémentaires qui est alloué et induire une collection avec le <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</source>
          <target state="translated">Notez que la notification ne garantit pas qu’un garbage collection complet se produit, qu’en conditions ont atteint le seuil auquel un garbage collection complet se produise.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>You can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method when you cannot wait for the time-out period to elapse.</source>
          <target state="translated">Vous pouvez appeler la <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> méthode lorsque vous ne pouvez pas attendre la période de délai d’attente.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>You should follow this method with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">Vous devez suivre cette méthode avec un appel à la <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> méthode pour vous assurer que vous avez obtenu un garbage collection complet.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Calling this method alone causes indeterminate results.</source>
          <target state="translated">L’appel de cette méthode seule donne des résultats indéterminés.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> must be either non-negative or less than or equal to <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> or -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> doit être non négatif ou inférieur ou égal à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> ou -1.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">pour la confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</source>
          <target state="translated">Retourne l’état d’une notification inscrite pour déterminer si un garbage collection de blocage complet par le Common Language Runtime est terminé.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</source>
          <target state="translated">Retourne l’état d’une notification inscrite pour déterminer si un garbage collection de blocage complet par le Common Language Runtime est terminé.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">État de la notification de garbage collection inscrite.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> énumération retournée par cette méthode pour déterminer l’état de la notification de garbage collection en cours qui a été inscrite à l’aide de la <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to determine whether a full garbage collection is imminent.</source>
          <target state="translated">Vous pouvez également utiliser le <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> méthode pour déterminer si un garbage collection complet est imminent.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as resuming work and obtaining a collection count with the <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> property.</source>
          <target state="translated">Lorsque l’énumération retourne <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, vous pouvez effectuer des tâches telles que la reprise du travail et obtenir le nombre de collection avec le <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This method waits indefinitely for a garbage collection notification to be obtained.</source>
          <target state="translated">Cette méthode attend indéfiniment pour une notification de garbage collection doit être obtenu.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Si vous souhaitez spécifier un délai d’attente pour la méthode à retourner si la notification ne peut pas être obtenue, utilisez le <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>If you call this method without specifying a time-out, you can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method if you are waiting longer than preferred.</source>
          <target state="translated">Si vous appelez cette méthode sans spécifier un délai d’attente, vous pouvez appeler la <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> méthode si vous attendez plus de préférence.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This method call should be preceded with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">Cet appel de méthode doit être précédé d’un appel à la <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> méthode pour vous assurer que vous avez obtenu un garbage collection complet.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>Calling this method alone can produce indeterminate results.</source>
          <target state="translated">L’appel de cette méthode seule peut produire des résultats indéterminés.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>The following example shows how to use this method to determine whether a full garbage collection has completed.</source>
          <target state="translated">L’exemple suivant montre comment utiliser cette méthode pour déterminer si un garbage collection complet est terminé.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>Whenever the status of the notification is <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, the user method <ph id="ph2">`OnFullGCCompletedNotify`</ph> is called to perform actions in response to the completed collection.</source>
          <target state="translated">Chaque fois que l’état de la notification est <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, la méthode <ph id="ph2">`OnFullGCCompletedNotify`</ph> est appelée pour effectuer des actions en réponse à la collection terminée.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This code example is part of a larger example provided for <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">Cet exemple de code fait partie d’un exemple plus complet fourni pour <bpt id="p1">[</bpt>Notifications de Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> rubrique.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">pour la confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>The length of time to wait before a notification status can be obtained.</source>
          <target state="translated">Temps à attendre avant qu'un état de notification puisse être obtenu.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Specify -1 to wait indefinitely.</source>
          <target state="translated">Spécifiez -1 pour attendre indéfiniment.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</source>
          <target state="translated">Retourne, dans le délai d’attente spécifié, l’état d’une notification inscrite pour déterminer si un garbage de collection de blocage complet par le Common Language Runtime est terminé.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">État de la notification de garbage collection inscrite.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> énumération retournée par cette méthode pour déterminer l’état de la notification de garbage collection en cours qui a été inscrite à l’aide de la <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to determine whether a full garbage collection is imminent.</source>
          <target state="translated">Vous pouvez également utiliser le <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> méthode pour déterminer si un garbage collection complet est imminent.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by <ph id="ph1">`millisecondsTimeout`</ph>.</source>
          <target state="translated">Notez que cette méthode retourne immédiatement chaque fois qu’un état de notification de garbage collection est obtenu, quelle que soit la valeur spécifiée par <ph id="ph1">`millisecondsTimeout`</ph>.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>If a garbage collection notification status is not obtained before <ph id="ph1">`millisecondsTimeout`</ph> times out, this method returns <ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>.</source>
          <target state="translated">Si un état de notification de garbage collection n’est pas obtenu avant <ph id="ph1">`millisecondsTimeout`</ph> heures, cette méthode retourne <ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as resuming work and obtaining a collection count with the <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> property.</source>
          <target state="translated">Lorsque l’énumération retourne <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, vous pouvez effectuer des tâches telles que la reprise du travail et obtenir le nombre de collection avec le <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>You can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method when you cannot wait for the time-out period to elapse.</source>
          <target state="translated">Vous pouvez appeler la <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> méthode lorsque vous ne pouvez pas attendre la période de délai d’attente.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>This method call should be preceded with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">Cet appel de méthode doit être précédé d’un appel à la <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> méthode pour vous assurer que vous avez obtenu un garbage collection complet.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Calling this method alone can produce indeterminate results.</source>
          <target state="translated">L’appel de cette méthode seule peut produire des résultats indéterminés.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> must be either non-negative or less than or equal to <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> or -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> doit être non négatif ou inférieur ou égal à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> ou -1.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">pour la confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForPendingFinalizers">
          <source>Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</source>
          <target state="translated">Suspend le thread actif jusqu'à ce que le thread traitant la file d'attente des finaliseurs ait vidé cette file d'attente.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.</source>
          <target state="translated">Lorsque le garbage collector détecte les objets qui peuvent être récupérés, il vérifie chaque objet pour déterminer les besoins de la finalisation de l’objet.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>If an object implements a finalizer and has not disabled finalization by calling <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>, the object is placed in a list of objects that are marked as ready for finalization.</source>
          <target state="translated">Si un objet implémente un finaliseur et n’a pas désactivé la finalisation en appelant <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>, l’objet est placé dans une liste d’objets qui sont marquées comme prêtes pour la finalisation.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>The garbage collector calls the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> methods for the objects in this list and removes the entries from the list.</source>
          <target state="translated">Le garbage collector appelle la <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> méthodes pour les objets dans cette liste et supprime les entrées dans la liste.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>This method blocks until all finalizers have run to completion.</source>
          <target state="translated">Cette méthode s’interrompt jusqu'à ce que tous les finaliseurs ont exécutées jusqu'à la fin.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.</source>
          <target state="translated">Le thread sur lequel les finaliseurs sont exécutés n’est pas spécifié, il n’existe aucune garantie que cette méthode se termine.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>However, this thread can be interrupted by another thread while the <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> method is in progress.</source>
          <target state="translated">Toutefois, ce thread peut être interrompu par un autre thread lors de la <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> méthode est en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</source>
          <target state="translated">Par exemple, vous pouvez démarrer un autre thread qui attend pendant une période de temps, puis interrompt ce thread si ce thread est toujours suspendu.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> method to suspend the current thread until finalization of all the collected objects is complete.</source>
          <target state="translated">L’exemple suivant montre comment utiliser la <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> méthode pour interrompre le thread actuel jusqu'à la fin de la finalisation de tous les objets collectés.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>