<Type Name="Tuple&lt;T1,T2,T3,T4,T5,T6,T7,TRest&gt;" FullName="System.Tuple&lt;T1,T2,T3,T4,T5,T6,T7,TRest&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="745c7af1e21364803819f362fcf2ef3ecb0a0421" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39766485" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Tuple&lt;T1,T2,T3,T4,T5,T6,T7,TRest&gt; : IComparable, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Tuple`8&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt; extends System.Object implements class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.IComparable" />
  <TypeSignature Language="DocId" Value="T:System.Tuple`8" />
  <TypeSignature Language="VB.NET" Value="Public Class Tuple(Of T1, T2, T3, T4, T5, T6, T7, TRest)&#xA;Implements IComparable, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename TRest&gt;&#xA;public ref class Tuple : IComparable, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt; = class&#xA;    interface IStructuralEquatable&#xA;    interface IStructuralComparable&#xA;    interface IComparable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T1" />
    <TypeParameter Name="T2" />
    <TypeParameter Name="T3" />
    <TypeParameter Name="T4" />
    <TypeParameter Name="T5" />
    <TypeParameter Name="T6" />
    <TypeParameter Name="T7" />
    <TypeParameter Name="TRest" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="T1">Type du premier composant du tuple.</typeparam>
    <typeparam name="T2">Type du second composant du tuple.</typeparam>
    <typeparam name="T3">Type du troisième composant du tuple.</typeparam>
    <typeparam name="T4">Type du quatrième composant du tuple.</typeparam>
    <typeparam name="T5">Type du cinquième composant du tuple.</typeparam>
    <typeparam name="T6">Type du sixième composant du tuple.</typeparam>
    <typeparam name="T7">Type du septième composant du tuple.</typeparam>
    <typeparam name="TRest">Tout objet <see langword="Tuple" /> générique qui définit les types des composants restants du tuple.</typeparam>
    <summary>Représente un *n*-tuple, où *n* est supérieur ou égal à 8.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un tuple est une structure de données qui a un nombre spécifique et une séquence de valeurs. Le <xref:System.Tuple%608> classe représente un *n*- tuple qui a huit composants ou plus.  
  
 Vous pouvez instancier un <xref:System.Tuple%608> objet avec exactement huit composants en appelant la méthode statique <xref:System.Tuple.Create%2A?displayProperty=nameWithType> (méthode). L’exemple suivant crée un 8-tuple (octuple) qui contient les nombres premiers inférieurs à 20. Notez qu’il utilise l’inférence de type pour déterminer le type de chaque composant.  
  
 [!code-csharp[System.Tuple.Create#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/createntuple.cs#17)]
 [!code-vb[System.Tuple.Create#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/createntuple.vb#17)]  
  
 Vous pouvez également instancier un objet n-tuple avec huit ou plus de composants en appelant le <xref:System.Tuple%608.%23ctor%2A> constructeur. L’exemple suivant utilise le <xref:System.Tuple%608.%23ctor%2A> constructeur pour créer un tuple de 8 est équivalent au tuple créés dans l’exemple précédent.  
  
 [!code-csharp[System.Tuple\`8.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.class/cs/octuple1.cs#1)]
 [!code-vb[System.Tuple\`8.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.class/vb/octuple1.vb#1)]  
  
> [!NOTE]
>  Pour créer un tuple de n avec neuf composants ou plus, vous devez appeler la <xref:System.Tuple%608.%23ctor%2A> constructeur. Les méthodes de fabrique statiques de la <xref:System.Tuple> classe ne prennent pas en charge la création de `Tuple` objets avec plus de huit composants.  
  
 Pour instancier un tuple de n qui a huit composants ou plus avec le <xref:System.Tuple%608.%23ctor%2A> constructeur, vous fournissez un générique `Tuple` de l’objet en tant que le `rest` paramètre pour définir le huitième via *n*composants du tuple. Par l’imbrication générique `Tuple` objets de cette façon, vous pouvez créer un tuple qui n’a aucune limitation pratique sur le nombre de ses composants.  
  
 L’exemple suivant crée un tuple de 17 qui contient les données de population pour la ville de Détroit, Michigan, pour chaque recensement national de 1860 à 2000. Le premier composant du tuple est le nom de ville. Le deuxième composant est la date de début de la série de données, et le troisième composant est la population à la date de début. Chaque composant suivant fournit la population à des intervalles de dix ans. Le 17-tuple est créé par l’imbrication un <xref:System.Tuple%603> de l’objet à l’intérieur d’un <xref:System.Tuple%608> objet. (Qui est, le <xref:System.Tuple%603> objet est fourni comme valeur de la `rest` paramètre dans le <xref:System.Tuple%608> constructeur de classe.) Cela <xref:System.Tuple%608> objet, à son tour, est imbriqué dans externe <xref:System.Tuple%608> objet. (Qui est, le <xref:System.Tuple%608> objet est fourni comme valeur de la `rest` paramètre dans la liste externe <xref:System.Tuple%608> constructeur de classe de l’objet.)  
  
 [!code-csharp[System.Tuple.Create#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/example.cs#19)]
 [!code-vb[System.Tuple.Create#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/example.vb#19)]  
  
 Vous pouvez récupérer la valeur de sept premiers composants du tuple à l’aide en lecture seule <xref:System.Tuple%607.Item1%2A>, <xref:System.Tuple%607.Item2%2A>, <xref:System.Tuple%607.Item3%2A>, <xref:System.Tuple%607.Item4%2A>, <xref:System.Tuple%607.Item5%2A>, <xref:System.Tuple%607.Item6%2A>, et <xref:System.Tuple%607.Item7%2A> propriétés de l’instance. Tous les autres composants sont imbriqués et peuvent être récupérées à partir de la <xref:System.Tuple%608.Rest%2A> propriété. Dans l’exemple précédent, le <xref:System.Tuple%608.Item1%2A> via <xref:System.Tuple%608.Item7%2A> propriétés extraient le premier composants 1 à 7 du tuple. Le composants 8 à 14 sont contenus dans le tuple qui est imbriqué au deuxième niveau et sont représentées par le `Rest.Item1` via `Rest.Item7` propriétés. Les composants 15 à 17 sont contenus dans le tuple qui est imbriqué au troisième niveau et sont représentés par le `Rest.Rest.Item1` si `Rest.Rest.Item3` propriétés.  
  
 Tuples sont fréquemment utilisées dans quatre façons différentes :  
  
-   Pour représenter un jeu unique de données. Par exemple, un tuple peut représenter un enregistrement de base de données, et ses composants peuvent représenter des champs individuels de l’enregistrement.  
  
-   Pour fournir un accès facile aux et manipulation d’un jeu de données.  
  
-   Pour retourner plusieurs valeurs à partir d’une méthode sans utiliser de `out` paramètres (en c#) ou `ByRef` paramètres (Visual Basic). Par exemple, l’exemple précédent retourne ses statistiques calculées, avec le nom de ville, dans un <xref:System.Tuple%607> objet.  
  
-   Pour passer les valeurs multiples dans une méthode via un paramètre unique. Par exemple, le <xref:System.Threading.Thread.Start%28System.Object%29?displayProperty=nameWithType> méthode possède un paramètre unique qui vous permet de fournir une valeur à la méthode que le thread exécute au démarrage. Si vous fournissez un <xref:System.Tuple%607> de l’objet en tant qu’argument de méthode, vous pouvez fournir la routine de démarrage du thread avec sept éléments de données.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Tuple" />
    <altmember cref="T:System.Tuple`1" />
    <altmember cref="T:System.Tuple`2" />
    <altmember cref="T:System.Tuple`3" />
    <altmember cref="T:System.Tuple`4" />
    <altmember cref="T:System.Tuple`5" />
    <altmember cref="T:System.Tuple`6" />
    <altmember cref="T:System.Tuple`7" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Tuple (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T1 item1, !T2 item2, !T3 item3, !T4 item4, !T5 item5, !T6 item6, !T7 item7, !TRest rest) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (item1 As T1, item2 As T2, item3 As T3, item4 As T4, item5 As T5, item6 As T6, item7 As T7, rest As TRest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);" />
      <MemberSignature Language="F#" Value="new Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt; : 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'Rest -&gt; Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;" Usage="new System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt; (item1, item2, item3, item4, item5, item6, item7, rest)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
        <Parameter Name="item4" Type="T4" />
        <Parameter Name="item5" Type="T5" />
        <Parameter Name="item6" Type="T6" />
        <Parameter Name="item7" Type="T7" />
        <Parameter Name="rest" Type="TRest" />
      </Parameters>
      <Docs>
        <param name="item1">Valeur du premier composant du tuple.</param>
        <param name="item2">Valeur du second composant du tuple.</param>
        <param name="item3">Valeur du troisième composant du tuple.</param>
        <param name="item4">Valeur du quatrième composant du tuple.</param>
        <param name="item5">Valeur du cinquième composant du tuple.</param>
        <param name="item6">Valeur du sixième composant du tuple.</param>
        <param name="item7">Valeur du septième composant du tuple.</param>
        <param name="rest">Tout objet <see langword="Tuple" /> générique qui contient les valeurs des composants restants du tuple.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Tuple`8" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez également utiliser la méthode statique <xref:System.Tuple.Create%2A?displayProperty=nameWithType> méthode pour instancier un objet de 8-tuple (octuple) sans devoir spécifier explicitement les types de ses composants. L’exemple suivant utilise la <xref:System.Tuple.Create%2A?displayProperty=nameWithType> méthode pour instancier un objet de 8-tuple qui contient les nombres premiers inférieurs à 20.  
  
 [!code-csharp[System.Tuple.Create#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/createntuple.cs#17)]
 [!code-vb[System.Tuple.Create#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/createntuple.vb#17)]  
  
 Cela équivaut à l’appel suivant à la <xref:System.Tuple%607.%23ctor%2A> constructeur de classe.  
  
 [!code-csharp[System.Tuple\`8.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.class/cs/octuple1.cs#1)]
 [!code-vb[System.Tuple\`8.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.class/vb/octuple1.vb#1)]  
  
 Toutefois, la méthode statique <xref:System.Tuple.Create%2A?displayProperty=nameWithType> méthode ne peut pas être utilisée pour créer un objet de tuple avec plus de huit composants.  
  
 Lorsque vous utilisez le <xref:System.Tuple%608.%23ctor%2A> constructeur pour créer un tuple de n avec huit composants ou plus, vous utilisez le `rest` paramètre pour créer un tuple de n imbriqué qui a un à sept composants. À l’aide de niveaux d’imbrication successives, vous pouvez créer un tuple de n qui a un nombre presque illimité de composants. Par exemple, pour créer un tuple de 25, vous instanciez un <xref:System.Tuple%608> objet avec trois niveaux d’imbrication, comme suit :  
  
-   Le plus externe <xref:System.Tuple%608> objet contient les composants 1 à 7. Son <xref:System.Tuple%608.Rest%2A> propriété fournit l’accès à un <xref:System.Tuple%608> objet au premier niveau d’imbrication.  
  
-   Le plus externe <xref:System.Tuple%608> objet contient le composants 8 à 14 et sa <xref:System.Tuple%608.Rest%2A> propriété fournit l’accès à un <xref:System.Tuple%608> objet au deuxième niveau d’imbrication.  
  
-   Le <xref:System.Tuple%608> objet au deuxième niveau d’imbrication contient le composants 15 à vingt et unième et son <xref:System.Tuple%608.Rest%2A> propriété fournit l’accès à un <xref:System.Tuple%604> objet au troisième niveau d’imbrication.  
  
-   Le tuple le plus profond est un <xref:System.Tuple%604> objet qui contient les composants de vingt-cinq à vingt secondes.  
  
   
  
## Examples  
 L’exemple suivant crée un tuple de 17 qui contient les données de population pour la ville de Détroit, Michigan, pour chaque recensement de 1860 à 2000. Le premier composant du tuple est le nom de ville. Le deuxième composant est la date de début de la série de données, et le troisième composant est la population à la date de début. Chaque composant suivant fournit la population à des intervalles de dix ans. L’exemple utilise deux couches d’imbrication pour créer le tuple de 17 : il définit un 7-tuple dont les composants contiennent les données de la population pour 1860 à 1900, un tuple de 7 imbriquée qui contient les données démographiques pour 1910 via 1970 et interne imbriquée à 3 tuples qui contient des données démographiques pour 1980 à 2000.  
  
 [!code-csharp[System.Tuple.Create#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/example.cs#19)]
 [!code-vb[System.Tuple.Create#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/example.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rest" /> n'est pas un objet <see langword="Tuple" /> générique.</exception>
        <altmember cref="M:System.Tuple.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="tuple.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à comparer avec cette instance.</param>
        <summary>Retourne une valeur qui indique si l'objet <see cref="T:System.Tuple`8" /> actuel est égal à un objet spécifié.</summary>
        <returns>
          <see langword="true" /> si l'instance actuelle est égale à l'objet spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `obj` paramètre est considéré comme égal à l’instance actuelle s’il répond à toutes les conditions suivantes :  
  
-   Il s’agit une <xref:System.Tuple%608> objet.  
  
-   Il a le même nombre total de composants sont des mêmes types que l’instance actuelle.  
  
-   Ses composants (y compris ses composants imbriqués) sont égales à celles de l’instance actuelle. L’égalité est déterminée par le comparateur d’égalité par défaut pour chaque composant.  
  
   
  
## Examples  
 L’exemple suivant définit cinq <xref:System.Tuple%608> objets qui contiennent des nombres premiers. Il compare ensuite le premier objet comportant chacun des objets restants. Comme le montre la sortie, seule la première et la dernière <xref:System.Tuple%608> objets sont égaux, parce qu’ils ont un nombre identique de composants avec des valeurs identiques.  
  
 [!code-csharp[System.Tuple\`8.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.equals/cs/equals1.cs#1)]
 [!code-vb[System.Tuple\`8.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="tuple.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Calcule le code de hachage pour l'objet <see cref="T:System.Tuple`8" /> actuel.</summary>
        <returns>Code de hachage d'un entier signé 32 bits.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item1">
      <MemberSignature Language="C#" Value="public T1 Item1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T1 Item1" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item1" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item1 As T1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T1 Item1 { T1 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item1 : 'T1" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T1</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du premier composant de l'objet <see cref="T:System.Tuple`8" /> actif.</summary>
        <value>Valeur du premier composant de l'objet <see cref="T:System.Tuple`8" /> actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez déterminer dynamiquement le type de la <xref:System.Tuple%608.Item1%2A> composant de deux manières :  
  
-   En appelant le `GetType` méthode sur la valeur retournée par la <xref:System.Tuple%608.Item1%2A> propriété.  
  
-   En récupérant le <xref:System.Type> objet qui représente le <xref:System.Tuple%608> de l’objet et en extrayant le premier élément du tableau retourné par son <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant crée un objet de 17-tuple qui contient les données de population pour la ville de Détroit, Michigan, de 1860 à 2000. Le premier composant du tuple-17 est le nom de ville. L’exemple utilise le <xref:System.Tuple%608.Item1%2A> propriété à afficher le nom de ville dans l’en-tête du tableau avant d’afficher les données de population.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item2">
      <MemberSignature Language="C#" Value="public T2 Item2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T2 Item2" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item2" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item2 As T2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T2 Item2 { T2 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item2 : 'T2" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T2</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du deuxième composant de l'objet <see cref="T:System.Tuple`8" /> actif.</summary>
        <value>Valeur du deuxième composant de l'objet <see cref="T:System.Tuple`8" /> actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez déterminer dynamiquement le type de la <xref:System.Tuple%608.Item2%2A> composant de deux manières :  
  
-   En appelant le `GetType` méthode sur la valeur retournée par la <xref:System.Tuple%608.Item2%2A> propriété.  
  
-   En récupérant le <xref:System.Type> objet qui représente le <xref:System.Tuple%608> de l’objet et en extrayant le deuxième élément du tableau retourné par son <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant crée un objet de 17-tuple qui contient les données de population pour la ville de Détroit, Michigan, de 1860 à 2000. Le deuxième composant du tuple-17 est la première année de la série de données. L’exemple affecte la valeur de la <xref:System.Tuple%608.Item2%2A> propriété à une variable, puis utilise cette variable pour représenter l’année dont les données sont affichées.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item3">
      <MemberSignature Language="C#" Value="public T3 Item3 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T3 Item3" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item3" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item3 As T3" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T3 Item3 { T3 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item3 : 'T3" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item3" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T3</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du troisième composant de l'objet <see cref="T:System.Tuple`8" /> actif.</summary>
        <value>Valeur du troisième composant de l'objet <see cref="T:System.Tuple`8" /> actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez déterminer dynamiquement le type de la <xref:System.Tuple%608.Item3%2A> composant de deux manières :  
  
-   En appelant le `GetType` méthode sur la valeur retournée par la <xref:System.Tuple%608.Item3%2A> propriété.  
  
-   En récupérant le <xref:System.Type> objet qui représente le <xref:System.Tuple%608> de l’objet et en extrayant le troisième élément du tableau retourné par son <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant crée un objet de 17-tuple qui contient les données de population pour la ville de Détroit, Michigan, de 1860 à 2000. Le troisième composant du tuple-17 est la population en 1860. L’exemple utilise le <xref:System.Tuple%608.Item3%2A> propriété pour afficher la valeur de population et calculer le taux de changement de population entre 1860 et 1870 annuel.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item4">
      <MemberSignature Language="C#" Value="public T4 Item4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T4 Item4" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item4" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item4 As T4" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T4 Item4 { T4 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item4 : 'T4" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T4</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du quatrième composant de l'objet <see cref="T:System.Tuple`8" /> actif.</summary>
        <value>Valeur du quatrième composant de l'objet <see cref="T:System.Tuple`8" /> actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez déterminer dynamiquement le type de la <xref:System.Tuple%608.Item4%2A> composant de deux manières :  
  
-   En appelant le `GetType` méthode sur la valeur retournée par la <xref:System.Tuple%608.Item4%2A> propriété.  
  
-   En récupérant le <xref:System.Type> objet qui représente le <xref:System.Tuple%608> de l’objet et en extrayant le quatrième élément du tableau retourné par son <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant crée un objet de 17-tuple qui contient les données de population pour la ville de Détroit, Michigan, de 1860 à 2000. Le quatrième composant du tuple-17 est la population en 1870. L’exemple utilise le <xref:System.Tuple%608.Item4%2A> propriété pour afficher la valeur de population et calculer le taux de changement de population entre 1870 et 1880 annuel.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item5">
      <MemberSignature Language="C#" Value="public T5 Item5 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T5 Item5" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item5 As T5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T5 Item5 { T5 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item5 : 'T5" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item5" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T5</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du cinquième composant de l'objet <see cref="T:System.Tuple`8" /> actif.</summary>
        <value>Valeur du cinquième composant de l'objet <see cref="T:System.Tuple`8" /> actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez déterminer dynamiquement le type de la <xref:System.Tuple%608.Item5%2A> composant de deux manières :  
  
-   En appelant le `GetType` méthode sur la valeur retournée par la <xref:System.Tuple%608.Item5%2A> propriété.  
  
-   En récupérant le <xref:System.Type> objet qui représente le <xref:System.Tuple%608> de l’objet et en extrayant le cinquième élément du tableau retourné par son <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant crée un objet de 17-tuple qui contient les données de population pour la ville de Détroit, Michigan, de 1860 à 2000. Le cinquième composant du tuple-17 est la population en 1880. L’exemple utilise le <xref:System.Tuple%608.Item5%2A> propriété pour afficher la valeur de population et calculer le taux de changement de population entre 1880 et 1890 annuel.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item6">
      <MemberSignature Language="C#" Value="public T6 Item6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T6 Item6" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item6" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item6 As T6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T6 Item6 { T6 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item6 : 'T6" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T6</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du sixième composant de l'objet <see cref="T:System.Tuple`8" /> actif.</summary>
        <value>Valeur du sixième composant de l'objet <see cref="T:System.Tuple`8" /> actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez déterminer dynamiquement le type de la <xref:System.Tuple%608.Item6%2A> composant de deux manières :  
  
-   En appelant le `GetType` méthode sur la valeur retournée par la <xref:System.Tuple%608.Item6%2A> propriété.  
  
-   En récupérant le <xref:System.Type> objet qui représente le <xref:System.Tuple%608> de l’objet et en extrayant le sixième élément du tableau retourné par son <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant crée un objet de 17-tuple qui contient les données de population pour la ville de Détroit, Michigan, de 1860 à 2000. Le sixième composant du tuple-17 est la population en 1890. L’exemple utilise le <xref:System.Tuple%608.Item6%2A> propriété pour afficher la valeur de population et calculer le taux de changement de population entre 1890 et 1900 annuel.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item7">
      <MemberSignature Language="C#" Value="public T7 Item7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T7 Item7" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item7" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item7 As T7" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T7 Item7 { T7 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item7 : 'T7" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T7</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du septième composant de l'objet <see cref="T:System.Tuple`8" /> actif.</summary>
        <value>Valeur du septième composant de l'objet <see cref="T:System.Tuple`8" /> actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez déterminer dynamiquement le type de la <xref:System.Tuple%608.Item7%2A> composant de deux manières :  
  
-   En appelant le `GetType` méthode sur la valeur retournée par la <xref:System.Tuple%608.Item7%2A> propriété.  
  
-   En récupérant le <xref:System.Type> objet qui représente le <xref:System.Tuple%608> de l’objet et en extrayant le septième élément du tableau retourné par son <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant crée un objet de 17-tuple qui contient les données de population pour la ville de Détroit, Michigan, de 1860 à 2000. Le septième composant du tuple-17 est la population en 1900. L’exemple utilise le <xref:System.Tuple%608.Item7%2A> propriété pour afficher la valeur de population et calculer le taux de changement de population entre 1900 et 1910 annuel.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rest">
      <MemberSignature Language="C#" Value="public TRest Rest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TRest Rest" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Rest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rest As TRest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TRest Rest { TRest get(); };" />
      <MemberSignature Language="F#" Value="member this.Rest : 'Rest" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Rest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TRest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les composants restants de l'objet <see cref="T:System.Tuple`8" /> actif.</summary>
        <value>Valeur des composants restants de l'objet <see cref="T:System.Tuple`8" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Tuple%608.Rest%2A> propriété retourne une liste imbriquée `Tuple` objet qui autorise l’accès aux huitième cependant *n*composants du tuple. En fonction du nombre total de composants dans le tuple, les valeurs du huitième au quatorzième composants peuvent être récupérées à partir de la commande imbriquée `Tuple` l’objet <xref:System.Tuple%608.Item1%2A> via <xref:System.Tuple%608.Item7%2A> propriétés. Vous pouvez ensuite utiliser le <xref:System.Tuple%608.Rest%2A> propriété imbriquée <xref:System.Tuple%608> objet à récupérer le `Tuple` objet au niveau d’imbrication suivant.  
  
 Vous pouvez déterminer dynamiquement le nombre de composants dans une liste imbriquée `Tuple` objet qui est retourné par la <xref:System.Tuple%608.Rest%2A> propriété en extrayant le chiffre de son nom de type. L'exemple suivant illustre cette situation.  
  
 [!code-vb[System.Tuple\`8.Item1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/rest.vb#2)]  
  
   
  
## Examples  
 L’exemple suivant crée un objet de 17-tuple qui contient les données de population pour la ville de Détroit, Michigan, de 1860 à 2000. Le septième composant du tuple-17 est la population en 1900. L’exemple utilise le <xref:System.Tuple%608.Rest%2A> propriété pour récupérer les valeurs du huitième au quatorzième composants et il utilise le <xref:System.Tuple%608.Rest%2A> propriété d’imbriqué <xref:System.Tuple%608> objet pour récupérer les valeurs des composants restants.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">Objet à comparer à l'instance actuelle.</param>
        <param name="comparer">Un objet qui fournit des règles personnalisées pour la comparaison.</param>
        <summary>Compare l'objet <see cref="T:System.Tuple`8" /> actif à un objet spécifié à l'aide d'un comparateur spécifié et retourne un entier qui indique si l'objet actif précède, suit ou se trouve à la même position que l'objet spécifié dans l'ordre de tri.</summary>
        <returns>Entier signé qui indique la position relative de cette instance et de <paramref name="other" /> dans l’ordre de tri, comme indiqué dans le tableau suivant.  
  
 <list type="table"><listheader><term> Valeur  </term><description> Description  </description></listheader><item><term> Entier négatif  </term><description> Cette instance précède <paramref name="other" />.  </description></item><item><term> Zéro  </term><description> Cette instance et <paramref name="other" /> ont la même position dans l’ordre de tri.  </description></item><item><term> Entier positif  </term><description> Cette instance suit <paramref name="other" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Tuple%608> est castée en interface <xref:System.Collections.IStructuralComparable>.  
  
 Cette méthode vous permet de définir des comparaisons personnalisées de <xref:System.Tuple%608> objets. Par exemple, vous pouvez utiliser cette méthode à la commande <xref:System.Tuple%608> objets basés sur la valeur d’un composant spécifique.  
  
 Bien que cette méthode peut être appelée directement, elle est généralement appelée par tri à la collection de méthodes qui incluent <xref:System.Collections.IComparer> paramètres pour classer les membres d’une collection. Par exemple, elle est appelée par le <xref:System.Array.Sort%28System.Array%2CSystem.Collections.IComparer%29?displayProperty=nameWithType> (méthode) et le <xref:System.Collections.SortedList.Add%2A> méthode d’un <xref:System.Collections.SortedList> objet est instancié à l’aide de la <xref:System.Collections.SortedList.%23ctor%28System.Collections.IComparer%29?displayProperty=nameWithType> constructeur.  
  
> [!CAUTION]
>  Le <xref:System.Tuple%608.System%23Collections%23IStructuralComparable%23CompareTo%2A> méthode est conçue pour une utilisation dans les opérations de tri. Elle ne doit pas être utilisée lors de l’objectif principal d’une comparaison consiste à déterminer si deux objets sont égaux. Pour déterminer si deux objets sont égales, appelez le <xref:System.Tuple%608.System%23Collections%23IStructuralEquatable%23Equals%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant crée un tableau de <xref:System.Tuple%608> objets qui contient les données démographiques pour quatre des villes américaines de 1940 à 2000. Premier composant de l’octuple est le nom de ville. Les six composants restants représentent la population à des intervalles de 10 ans de 1940 à 2000.  
  
 Le `PopulationComparer` classe fournit un <xref:System.Collections.IComparer> implémentation qui autorise le tableau d’octuples à être trié par l’un de ses composants. Deux valeurs sont fournies à la `PopulationComparer` classe dans son constructeur : la position du composant qui définit l’ordre de tri, et un <xref:System.Boolean> valeur qui indique si les objets de tuple doivent être triés dans l’ordre croissant ou décroissant.  
  
 L’exemple puis affiche les éléments dans le tableau dans un ordre aléatoire, les trie par le troisième composant (population en 1950) et les affiche, puis les trie par le huitième composant (population en 2000) et les affiche.  
  
 [!code-csharp[System.Tuple\`8.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.compareto/cs/compareto2.cs#2)]
 [!code-vb[System.Tuple\`8.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.compareto/vb/compareto2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="other" /> n’est pas un objet <see cref="T:System.Tuple`8" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">Objet à comparer avec cette instance.</param>
        <param name="comparer">Un objet qui définit la méthode à utiliser pour évaluer si les deux objets sont égaux.</param>
        <summary>Retourne une valeur qui indique si l'objet <see cref="T:System.Tuple`8" /> actif est égal à un objet spécifié selon une méthode de comparaison spécifiée.</summary>
        <returns>
          <see langword="true" /> si l'instance actuelle est égale à l'objet spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Tuple%608> est castée en interface <xref:System.Collections.IStructuralEquatable>.  
  
 Le <xref:System.Collections.IEqualityComparer.Equals%2A?displayProperty=nameWithType> implémentation est appelée uniquement si `other` n’est pas `null`, et si elle peut être casté (en c#) ou converti (en Visual Basic) en un <xref:System.Tuple%608> objet qui a le même nombre total de composants (y compris ceux imbriqués `Tuple` objets) des mêmes types que l’instance actuelle. Le <xref:System.Tuple%608.System%23Collections%23IStructuralEquatable%23Equals%28System.Object%2CSystem.Collections.IEqualityComparer%29> passe en premier (méthode) le <xref:System.Tuple%608.Item1%2A> les valeurs de la <xref:System.Tuple%608> objets à comparer à la <xref:System.Collections.IEqualityComparer.Equals%2A?displayProperty=nameWithType> implémentation. Si cet appel de méthode retourne `true`, la méthode est appelée à nouveau et passée le <xref:System.Tuple%608.Item2%2A> les valeurs des deux <xref:System.Tuple%608> objets. Ce processus se poursuit jusqu'à ce que l’appel de méthode retourne `false` lorsqu’il compare une paire spécifique de valeurs, ou les deux <xref:System.Tuple%608.Rest%2A> valeurs sont passées à la méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Objet dont la méthode <see cref="M:System.Collections.IEqualityComparer.GetHashCode(System.Object)" /> calcule le code de hachage de l'objet <see cref="T:System.Tuple`8" /> actuel.</param>
        <summary>Calcule le code de hachage pour l'objet <see cref="T:System.Tuple`8" /> actif à l'aide d'une méthode de calcul spécifiée.</summary>
        <returns>Code de hachage d'un entier signé 32 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Tuple%608> est castée en interface <xref:System.Collections.IStructuralEquatable>.  
  
 La méthode encapsule simplement un appel à la `comparer` l’objet <xref:System.Collections.IEqualityComparer.GetHashCode%2A?displayProperty=nameWithType> implémentation.  
  
 L’algorithme utilisé pour calculer le code de hachage doit retourner le même code de hachage pour deux <xref:System.Tuple%608> les objets qui sont considérées comme égales.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à comparer à l'instance actuelle.</param>
        <summary>Compare l’objet <see cref="T:System.Tuple`8" /> actuel à un objet spécifié et renvoie un entier qui indique si l’objet actuel est avant, après ou à la même position que l’objet spécifié dans l’ordre de tri.</summary>
        <returns>Entier signé qui indique la position relative de cette instance et de <paramref name="obj" /> dans l’ordre de tri, comme indiqué dans le tableau suivant.  
  
 <list type="table"><listheader><term> Valeur  </term><description> Description  </description></listheader><item><term> Entier négatif  </term><description> Cette instance précède <paramref name="obj" />.  </description></item><item><term> Zéro  </term><description> Cette instance et <paramref name="obj" /> ont la même position dans l’ordre de tri.  </description></item><item><term> Entier positif  </term><description> Cette instance suit <paramref name="obj" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Tuple%608> est castée en interface <xref:System.IComparable>.  
  
 Cette méthode fournit le <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> implémentation pour la <xref:System.Tuple%608> classe. Bien que la méthode peut être appelée directement, elle est généralement appelée par les surcharges par défaut de tri à la collection de méthodes, telles que <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> et <xref:System.Collections.SortedList.Add%2A?displayProperty=nameWithType>, pour classer les membres d’une collection.  
  
> [!CAUTION]
>  Le <xref:System.Tuple%608.System%23IComparable%23CompareTo%2A> méthode est conçue pour une utilisation dans les opérations de tri. Elle ne doit pas être utilisée lors de l’objectif principal d’une comparaison consiste à déterminer si deux objets sont égaux. Pour déterminer si deux objets sont égales, appelez le <xref:System.Tuple%608.Equals%28System.Object%29?displayProperty=nameWithType> (méthode).  
  
 Cette méthode utilise le comparateur d’objet par défaut pour comparer chaque composant.  
  
   
  
## Examples  
 L’exemple suivant crée un tableau d’octuples dont les composants sont des entiers qui contiennent une plage de nombres premiers. L’exemple affiche les éléments du tableau en ordre non trié, trie le tableau, puis affiche le tableau dans un ordre trié. La sortie montre que le tableau a été trié par <xref:System.Tuple%608.Item1%2A>, ou le premier composant du tuple. Notez que l’exemple n’appelle pas directement la <xref:System.Tuple%608.System%23IComparable%23CompareTo%28System.Object%29> (méthode). Cette méthode est appelée implicitement par la <xref:System.Array.Sort%28System.Array%29> méthode pour chaque élément du tableau.  
  
 [!code-csharp[System.Tuple\`8.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.compareto/cs/compareto1.cs#1)]
 [!code-vb[System.Tuple\`8.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.compareto/vb/compareto1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> n’est pas un objet <see cref="T:System.Tuple`8" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.CompilerServices.ITuple.Item">
      <MemberSignature Language="C#" Value="object System.Runtime.CompilerServices.ITuple.Item[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Runtime.CompilerServices.ITuple.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.System#Runtime#CompilerServices#ITuple#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Item(index As Integer) As Object Implements ITuple.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Runtime::CompilerServices::ITuple::Item[int] { System::Object ^ get(int index); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.CompilerServices.ITuple.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.CompilerServices.ITuple.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de l’élément <see langword="Tuple" /> spécifié. <c>index</c> peut être compris entre 0 pour <see langword="Item1" /> et un de moins que le nombre d’éléments dans <see langword="Tuple" />.</param>
        <summary>Obtient la valeur de l’élément <see langword="Tuple" /> spécifié.</summary>
        <value>Valeur de l’élément <see langword="Tuple" /> à la position spécifiée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Tuple%608.System%23Runtime%23CompilerServices%23ITuple%23Item%2A?displayProperty=nameWithType> propriété est une implémentation d’interface explicite. Pour l’appeler, vous devez effectuer un cast ou convertir le <xref:System.Tuple%608> de l’objet à un <xref:System.Runtime.CompilerServices.ITuple> objet d’interface.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> est inférieur à 0.  
  
- ou - 
 <paramref name="index" /> est supérieur ou égal à <see cref="P:System.Tuple`8.System#Runtime#CompilerServices#ITuple#Length" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.CompilerServices.ITuple.Length">
      <MemberSignature Language="C#" Value="int System.Runtime.CompilerServices.ITuple.Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Runtime.CompilerServices.ITuple.Length" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.System#Runtime#CompilerServices#ITuple#Length" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Length As Integer Implements ITuple.Length" />
      <MemberSignature Language="C++ CLI" Value="property int System::Runtime::CompilerServices::ITuple::Length { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.CompilerServices.ITuple.Length" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.CompilerServices.ITuple.Length</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d’éléments dans <see langword="Tuple" />.</summary>
        <value>Nombre d'éléments dans <see langword="Tuple" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Tuple%608.System%23Runtime%23CompilerServices%23ITuple%23Length%2A> propriété est une implémentation d’interface explicite. Pour l’appeler, vous devez effectuer un cast ou convertir le <xref:System.Tuple%608> type à un <xref:System.Runtime.CompilerServices.ITuple> objet d’interface.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="tuple.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une chaîne qui représente la valeur de cette instance <see cref="T:System.Tuple`8" />.</summary>
        <returns>Représentation sous forme de chaîne de cet objet <see cref="T:System.Tuple`8" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chaîne retournée par cette méthode prend la forme (*Item1*, *Item2*, *Item3*, *Item4*, `Item5, Item6, Item7`, * Item8*...), où *Item1*, *Item2*, *Item3*, *Item4*, *Item5*, *Item6*, et *Item7* représentent les valeurs de la <xref:System.Tuple%608.Item1%2A>, <xref:System.Tuple%608.Item2%2A>, <xref:System.Tuple%608.Item3%2A>, <xref:System.Tuple%608.Item4%2A>, <xref:System.Tuple%608.Item5%2A>, <xref:System.Tuple%608.Item6%2A>, et <xref:System.Tuple%608.Item7%2A> propriétés. *Item8* représente la valeur de la <xref:System.Tuple%608> l’objet `Next.Item1` propriété. Suivez la valeur de tous les autres composants imbriqués *Item8*. Si une des valeurs de propriété est `null`, il est représenté en tant que <xref:System.String.Empty?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant crée un tuple de 17 qui contient les données de population pour la ville de Détroit, Michigan, de 1860 à 1900. Il utilise ensuite la <xref:System.Tuple%608.ToString%2A> méthode pour afficher les données du tuple.  
  
 [!code-csharp[System.Tuple\`8.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Tuple\`8.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>