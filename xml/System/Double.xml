<Type Name="Double" FullName="System.Double">
  <Metadata><Meta Name="ms.openlocfilehash" Value="68d00a88edf625115173a91bf65a493d47e5a8f1" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56403939" /></Metadata><TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IConvertible, IEquatable(Of Double), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un nombre à virgule flottante double précision.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Double> type de valeur représente un nombre de 64 bits double précision avec des valeurs comprises entre moins 1, 79769313486232E308 et plus 1, 79769313486232E308, ainsi que le zéro positif ou négatif, <xref:System.Double.PositiveInfinity>, <xref:System.Double.NegativeInfinity>et pas un nombre (<xref:System.Double.NaN>). Il est destiné à représenter les valeurs que sont extrêmement volumineux (par exemple, les distances entre les planètes ou galaxies) ou extrêmement petit (la masse moléculaire de substance en kilogrammes) et qui sont souvent imprécises (par exemple la distance entre la terre et un autre système solaire), le <xref:System.Double> type est conforme à la IEC 60559 : 1989 (IEEE 754) standard pour l’arithmétique à virgule flottante binaire.  
  
 Cette rubrique contient les sections suivantes :  
  
-   [Précision et une représentation à virgule flottante](#Precision)  
  
-   [Test d’égalité](#Equality)  
  
-   [Exceptions et les valeurs à virgule flottante](#Exceptions)  
  
-   [Conversions de types et la structure Double](#Conversions)  
  
-   [Fonctionnalités à virgule flottante](#Functionality)  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Précision et une représentation à virgule flottante  
 Le <xref:System.Double> type de données stocke les valeurs à virgule flottante double précision dans un format binaire 64 bits, comme indiqué dans le tableau suivant :  
  
|Élément|Bits|  
|----------|----------|  
|Mantisse|0-51|  
|Exposant|52-62|  
|Connexion (0 = positif, 1 = négatif)|63|  
  
 Tout comme les fractions décimales ne peut pas représenter précisément certaines valeurs fractionnaires (par exemple 1/3 ou <xref:System.Math.PI?displayProperty=nameWithType>), fractions binaires sont ne peut pas représenter certaines valeurs fractionnaires. Par exemple, 1/10, qui est représentée précisément par.1 comme une fraction décimale, est représenté par.001100110011 sous forme de fraction binaire, avec le modèle « 0011 » extensible à l’infini. Dans ce cas, la valeur à virgule flottante fournit une représentation imprécise du nombre qu’il représente. Effectuer des opérations de mathématiques supplémentaires sur la valeur à virgule flottante d’origine souvent a tendance à augmenter son manque de précision. Par exemple, si l'on compare le résultat de la multiplication.1 par 10 et ajout de.1 à.1 neuf fois, nous voir cet ajout, car il a impliqué huit davantage d’opérations, a produit le résultat moins précis. Notez que cette disparité est visible uniquement si les deux, nous affichons <xref:System.Double> valeurs à l’aide de « R » [chaîne de format numérique standard](~/docs/standard/base-types/standard-numeric-format-strings.md), qui si nécessaire affiche tous les 17 chiffres de précision pris en charge par le <xref:System.Double> type.  
  
 [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 Étant donné que des nombres ne peut pas être représentées exactement comme valeurs binaires fractionnaires, nombres à virgule flottante peuvent uniquement des nombres réels approximatives.  
  
 Tous les nombres à virgule flottante ont également un nombre limité de chiffres significatifs, lequel détermine également la façon dont une valeur à virgule flottante s’apparentent précisément un nombre réel.   Un <xref:System.Double> valeur a jusqu'à 15 chiffres décimaux de précision, bien qu’un maximum de 17 chiffres soit maintenu en interne. Cela signifie que certaines opérations à virgule flottante n’ont peut-être pas la précision pour modifier flottante valeur de point. L'exemple suivant illustre cette situation. Définit une valeur à virgule flottante très volumineuse, elle ajoute ensuite le produit de <xref:System.Double.Epsilon?displayProperty=nameWithType> et trillion celui à celui-ci. Le produit, cependant, est trop petit pour modifier la valeur à virgule flottante d’origine. Son chiffre le moins significatif est millièmes, tandis que le chiffre le plus significatif dans le produit est 10<sup>-309</sup>.  
  
 [!code-csharp[System.Double.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 La précision limitée d’un nombre à virgule flottante a plusieurs conséquences :  
  
-   Deux nombres à virgule flottante qui apparaissent égaux pour une précision particulière ne peuvent pas considérés comme égaux, car leurs chiffres les moins significatifs sont différents. Dans l’exemple suivant, une série de nombres sont additionnés, et leur total est comparée avec leur total attendu. Bien que les deux valeurs semblent être identiques, un appel à la `Equals` méthode indique qu’ils ne sont pas.  
  
     [!code-csharp[System.Double.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     Si vous modifiez les éléments de format dans le <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> instruction à partir de `{0}` et `{1}` à `{0:R}` et `{1:R}` pour afficher tous les chiffres significatifs des deux <xref:System.Double> valeurs, il est clair que les deux valeurs sont inégales, car d’une perte de précision pendant les opérations d’addition. Dans ce cas, le problème peut être résolu en appelant le <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> méthode pour arrondir le <xref:System.Double> valeurs à la précision de votre choix avant d’effectuer la comparaison.  
  
-   Une opération mathématique ou de comparaison qui utilise un nombre à virgule flottante peut ne pas donne le même résultat si un nombre décimal est utilisé, étant donné que le nombre à virgule flottante binaire ne peut pas égal au nombre décimal. Un exemple précédent illustre cela en affichant le résultat de la multiplication.1 par 10 et ajoutant fois.1.  
  
     Lorsque la précision dans les opérations numériques avec les valeurs fractionnaires est importante, vous pouvez utiliser la <xref:System.Decimal> plutôt que <xref:System.Double> type. Lors de la précision dans les opérations numériques avec des valeurs intégrales au-delà de la plage de la <xref:System.Int64> ou <xref:System.UInt64> types est important, utilisez le <xref:System.Numerics.BigInteger> type.  
  
-   Une valeur ne peut pas effectuer un aller-retour si un nombre à virgule flottante est impliqué. Une valeur est dite d’aller-retour si une opération convertit un nombre à virgule flottante d’origine vers un autre formulaire, l’opération inverse retransforme la forme convertie en un nombre à virgule flottante, et le nombre à virgule flottante final n’est pas égal à la version d’origine nombre à virgule flottante. L’aller-retour peut échouer car un ou plusieurs chiffres les moins significatifs sont perdus ou modifiés dans une conversion. Dans l’exemple suivant, trois <xref:System.Double> valeurs sont converties en chaînes et enregistrés dans un fichier. Comme le montre la sortie, toutefois, même si les valeurs semblent identiques, les valeurs restaurés ne valent pas les valeurs d’origine.  
  
     [!code-csharp[System.Double.Structure#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     Dans ce cas, les valeurs peuvent être l’aller-retour avec succès à l’aide de la « G17 » [chaîne de format numérique standard](~/docs/standard/base-types/standard-numeric-format-strings.md) pour conserver la précision de <xref:System.Double> valeurs, comme le montre l’exemple suivant.  
  
     [!code-csharp[System.Double.Structure#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  

   > [!IMPORTANT]
   >  Lorsqu’il est utilisé avec un <xref:System.Double> valeur, le spécificateur de format « R » dans certains cas ne peut pas effectuer un aller-retour avec la valeur d’origine. Pour vous assurer que <xref:System.Double> valeurs aller-retour, utiliser le spécificateur de format « G17 ».

-   <xref:System.Single> les valeurs ont moins de précision que <xref:System.Double> valeurs. Un <xref:System.Single> valeur est convertie en un équivalent apparemment <xref:System.Double> souvent n’est pas égale la <xref:System.Double> valeur en raison des différences de précision. Dans l’exemple suivant, le résultat des opérations de division identique est assigné à un <xref:System.Double> et un <xref:System.Single> valeur. Après le <xref:System.Single> valeur est convertie en un <xref:System.Double>, une comparaison des deux valeurs montre qu’ils sont inégaux.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Pour éviter ce problème, utilisez le <xref:System.Double> à la place de la <xref:System.Single> type de données, ou utilisez le <xref:System.Math.Round%2A> méthode afin que les deux valeurs ont la même précision.  
  
 En outre, le résultat des opérations arithmétiques et d’assignation avec <xref:System.Double> valeurs peuvent différer légèrement par la plateforme en raison de la perte de précision de la <xref:System.Double> type. Par exemple, le résultat de l’affectation d’un littéral <xref:System.Double> valeur peut être différente dans les versions 32 bits et 64 bits de .NET Framework. L’exemple suivant illustre cette différence lorsque le littéral de valeur - 4.42330604244772E-305 et une variable dont la valeur est - 4.42330604244772E-305 sont assignées à un <xref:System.Double> variable. Notez que le résultat de la <xref:System.Double.Parse%28System.String%29> méthode dans ce cas ne souffre pas d’une perte de précision.  
  
 [!code-csharp[System.Double.Class.Precision#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Test d’égalité  
 Pour être considérées comme égales, deux <xref:System.Double> valeurs doivent représenter des valeurs identiques. Toutefois, en raison de différences de précision entre les valeurs, ou en raison d’une perte de précision par une ou les deux valeurs, les valeurs à virgule flottante sont censés être identiques souvent s’avérer accentuées en raison de différences dans leurs chiffres les moins significatifs. Par conséquent, les appels à la <xref:System.Double.Equals%2A> méthode pour déterminer si deux valeurs sont égales, ou des appels à la <xref:System.Double.CompareTo%2A> méthode pour déterminer la relation entre deux <xref:System.Double> valeurs, souvent donner des résultats inattendus. Ceci est évident dans l’exemple suivant, où deux égal apparemment <xref:System.Double> valeurs semblent pour être inégaux, car le premier a 15 chiffres de précision, alors que la seconde a 17.  
  
 [!code-csharp[System.Double.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 Les valeurs calculées qui suivent des chemins de code différents, et qui sont manipulées de différentes façons, souvent s’avérer inégaux. Dans l’exemple suivant, un <xref:System.Double> valeur est mis au carré, et ensuite la racine carrée est calculée pour restaurer la valeur d’origine. Une seconde <xref:System.Double> est multipliée par 3.51 et carré avant la racine carrée du résultat est divisée par 3.51 pour restaurer la valeur d’origine. Bien que les deux valeurs semblent identiques, un appel à la <xref:System.Double.Equals%28System.Double%29> méthode indique qu’ils ne sont pas égaux. À l’aide de la chaîne de format standard « R » pour renvoyer une chaîne de résultat qui affiche tous les chiffres significatifs de chaque valeur Double montre que la deuxième valeur est.0000000000001 inférieure à la première.  
  
 [!code-csharp[System.Double.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 Dans les cas où une perte de précision est susceptible d’affecter le résultat d’une comparaison, vous pouvez adopter une des méthodes suivantes pour appeler le <xref:System.Double.Equals%2A> ou <xref:System.Double.CompareTo%2A> méthode :  
  
-   Appelez le <xref:System.Math.Round%2A?displayProperty=nameWithType> pour s’assurer que les deux valeurs ont la même précision. L’exemple suivant modifie un exemple précédent pour utiliser cette approche, afin que les deux valeurs fractionnaires sont équivalentes.  
  
     [!code-csharp[System.Double.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     Notez, cependant, que le problème de précision s’applique toujours à l’arrondi des valeurs du milieu. Pour plus d'informations, voir la méthode <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Tester l’égalité approximative au lieu de l’égalité. Cela nécessite que vous définissez soit absolu montant par lequel les deux valeurs peuvent différer mais toujours être égal ou que vous définissez une quantité relative par lequel la plus petite valeur peut différer de la plus grande valeur.  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=nameWithType> est parfois utilisé comme mesure absolue de la distance entre deux <xref:System.Double> lors du test d’égalité des valeurs.  Toutefois, <xref:System.Double.Epsilon?displayProperty=nameWithType> mesure la plus petite valeur possible qui peut être ajoutée à ou soustraite, un <xref:System.Double> dont la valeur est égale à zéro. Pour la plupart des positif et négatif <xref:System.Double> valeurs, la valeur de <xref:System.Double.Epsilon?displayProperty=nameWithType> est trop petite pour être détecté. Par conséquent, à l’exception des valeurs qui sont égales à zéro, nous déconseillons son utilisation dans les tests d’égalité.  
  
     L’exemple suivant utilise cette dernière approche pour définir un `IsApproximatelyEqual` méthode qui teste la différence relative entre les deux valeurs. Il compare également le résultat d’appels à la `IsApproximatelyEqual` (méthode) et le <xref:System.Double.Equals%28System.Double%29> (méthode).  
  
     [!code-csharp[System.Double.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Exceptions et les valeurs à virgule flottante  
 Contrairement aux opérations avec des types intégraux, qui lèvent des exceptions en cas de dépassement de capacité ou des opérations illégales telles que la division par zéro, opérations avec des valeurs à virgule flottante ne lèvent pas d’exceptions. Au lieu de cela, dans des situations exceptionnelles, le résultat d’une opération à virgule flottante est zéro, l’infini positif, infini négatif ou une valeur non numérique (NaN) :  
  
-   Si le résultat d’une opération à virgule flottante est trop petit pour le format de destination, le résultat est zéro. Cela peut se produire lorsque deux très petits nombres sont multipliés, comme le montre l’exemple suivant.  
  
     [!code-csharp[System.Double.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   Si la grandeur du résultat d’une opération à virgule flottante dépasse la plage du format de destination, le résultat de l’opération est <xref:System.Double.PositiveInfinity> ou <xref:System.Double.NegativeInfinity>, selon le cas pour le signe du résultat. Le résultat d’une opération qui dépassent <xref:System.Double.MaxValue?displayProperty=nameWithType> est <xref:System.Double.PositiveInfinity>et le résultat d’une opération qui dépassent <xref:System.Double.MinValue?displayProperty=nameWithType> est <xref:System.Double.NegativeInfinity>, comme illustré dans l’exemple suivant.  
  
     [!code-csharp[System.Double.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity> entraîne également à partir d’une division par zéro avec un dividende positif, et <xref:System.Double.NegativeInfinity> provient d’une division par zéro avec un dividende négatif.  
  
-   Si une opération à virgule flottante n’est pas valide, le résultat de l’opération est <xref:System.Double.NaN>. Par exemple, <xref:System.Double.NaN> entraîne des opérations suivantes :  
  
    -   Division par zéro avec un dividende égale à zéro. Notez que les autres cas de division par zéro entraînent soit <xref:System.Double.PositiveInfinity> ou <xref:System.Double.NegativeInfinity>.  
  
-   Toute opération à virgule flottante avec une entrée non valide. Par exemple, l’appel la <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> méthode avec une valeur négative est retournée <xref:System.Double.NaN>, comme le fait appel le <xref:System.Math.Acos%2A?displayProperty=nameWithType> méthode avec une valeur qui est supérieure à 1 ou inférieure à 1 négatif.  
  
-   Toute opération avec un argument dont la valeur est <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
<a name="Conversions"></a>   
## <a name="type-conversions-and-the-double-structure"></a>Conversions de types et la structure Double  
 Le <xref:System.Double> structure ne définit pas d’opérateur de conversion explicite ou implicite ; au lieu de cela, les conversions sont implémentées par le compilateur.  
  
 La conversion de la valeur de n’importe quel type numérique primitif à un <xref:System.Double> est une conversion étendue et par conséquent ne nécessitent pas un opérateur de cast explicite ou lors de l’appel à une méthode de conversion, sauf si un compilateur exige explicitement. Par exemple, le compilateur c# nécessite un opérateur de cast pour les conversions entre <xref:System.Decimal> à <xref:System.Double>, contrairement au compilateur Visual Basic. L’exemple suivant convertit la valeur minimale ou maximale d’autres types numériques primitifs à un <xref:System.Double>.  
  
 [!code-csharp[System.Double.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 En outre, le <xref:System.Single> valeurs <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, et <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> convertir à <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, et <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectivement.  
  
 Notez que la conversion de la valeur de certains types numériques à une <xref:System.Double> valeur peut impliquer une perte de précision. Comme l’illustre l’exemple, une perte de précision est possible lors de la conversion <xref:System.Decimal>, <xref:System.Int64>, <xref:System.Single>, et <xref:System.UInt64> valeurs <xref:System.Double> valeurs.  
  
 La conversion d’un <xref:System.Double> à une valeur d’un autre type de données numérique primitif est une conversion restrictive et nécessite un opérateur de conversion (en c#), une méthode de conversion (en Visual Basic) ou un appel à un <xref:System.Convert> (méthode). Les valeurs en dehors de la plage du type de données cible, qui sont définies par le type de cible `MinValue` et `MaxValue` se comportent des propriétés, comme indiqué dans le tableau suivant.  
  
|Type cible|Résultat|  
|-----------------|------------|  
|N’importe quel type intégral|Un <xref:System.OverflowException> exception si la conversion se produit dans un contexte vérifié.<br /><br /> Si la conversion se produit dans un contexte non vérifié (la valeur par défaut en c#), l’opération de conversion réussit mais déborde de la valeur.|  
|<xref:System.Decimal>|Exception <xref:System.OverflowException>.|  
|<xref:System.Single>|<xref:System.Single.NegativeInfinity?displayProperty=nameWithType> pour les valeurs négatives.<br /><br /> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> pour les valeurs positives.|  
  
 En outre, <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, et <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> lever un <xref:System.OverflowException> pour les conversions en entiers dans un contexte vérifié, mais ces dépassement des valeurs lorsque convertis en entiers dans un contexte non vérifié. Pour les conversions <xref:System.Decimal>, elles lèvent toujours un <xref:System.OverflowException>. Pour les conversions <xref:System.Single>, ils convertis vers <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, et <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectivement.  
  
 Notez qu’une perte de précision peut-être provenir de la conversion d’un <xref:System.Double> valeur à un autre type numérique. Dans le cas de conversion non intégrales <xref:System.Double> valeurs, comme le montre la sortie de l’exemple, la partie fractionnaire est perdue lorsque la <xref:System.Double> valeur est arrondie (comme dans Visual Basic) ou tronqué (comme dans c#). Pour les conversions <xref:System.Decimal> et <xref:System.Single> valeurs, le <xref:System.Double> valeur ne peut pas avoir une représentation précise dans le type de données cible.  
  
 L’exemple suivant convertit un nombre de <xref:System.Double> valeurs à plusieurs autres types numériques. Les conversions se produisent dans un contexte vérifié dans Visual Basic (la valeur par défaut) et en c# (raison de la [vérifiée](~/docs/csharp/language-reference/keywords/checked.md) mot clé). La sortie de l’exemple montre le résultat pour les conversions a été archivé à la fois un contexte non vérifié. Vous pouvez effectuer des conversions dans un contexte non vérifié dans Visual Basic en compilant avec le `/removeintchecks+` commutateur de compilateur et en c# en commentant la `checked` instruction.  
  
 [!code-csharp[System.Double.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 Pour plus d’informations sur la conversion des types numériques, consultez [Conversion de Type dans le .NET Framework](~/docs/standard/base-types/type-conversion.md) et [tableaux de Conversion de Type](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Fonctionnalités à virgule flottante  
 Le <xref:System.Double> structure et les types associés fournissent des méthodes pour effectuer des opérations dans les domaines suivants :  
  
-   **Comparaison de valeurs**. Vous pouvez appeler la <xref:System.Double.Equals%2A> méthode pour déterminer si deux <xref:System.Double> valeurs sont égales, ou le <xref:System.Double.CompareTo%2A> méthode pour déterminer la relation entre deux valeurs.  
  
     Le <xref:System.Double> prend également en charge un ensemble complet d’opérateurs de comparaison. Par exemple, vous pouvez tester l’égalité ou d’inégalité ou déterminer si une valeur est supérieure ou égale à un autre. Si l’un des opérandes est de type numérique autre qu’un <xref:System.Double>, il est converti en un <xref:System.Double> avant d’effectuer la comparaison.  
  
    > [!WARNING]
    >  En raison de différences de précision, deux <xref:System.Double> les valeurs que vous attendez d’être égal peuvent s’avérer pour être inégaux, ce qui affecte le résultat de la comparaison. Consultez le [test d’égalité](#Equality) section pour plus d’informations sur la comparaison de deux <xref:System.Double> valeurs.  
  
     Vous pouvez également appeler le <xref:System.Double.IsNaN%2A>, <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, et <xref:System.Double.IsNegativeInfinity%2A> méthodes pour tester ces valeurs spéciales.  
  
-   **Opérations mathématiques**. Les opérations arithmétiques courantes, telles que l’addition, soustraction, multiplication et division, sont implémentées par les compilateurs de langage et les instructions de langage CIL (Common Intermediate), plutôt que par <xref:System.Double> méthodes. Si un des opérandes d’une opération mathématique est un type numérique autre qu’un <xref:System.Double>, il est converti en un <xref:System.Double> avant d’effectuer l’opération. Le résultat de l’opération est également un <xref:System.Double> valeur.  
  
     Autres opérations mathématiques peuvent être effectuées en appelant `static` (`Shared` en Visual Basic) méthodes dans la <xref:System.Math?displayProperty=nameWithType> classe. Il inclut des méthodes supplémentaires couramment utilisés pour les opérations arithmétiques (tels que <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, et <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), géométrie (tel que <xref:System.Math.Cos%2A?displayProperty=nameWithType> et <xref:System.Math.Sin%2A?displayProperty=nameWithType>) et de calcul (comme <xref:System.Math.Log%2A?displayProperty=nameWithType>).  
  
     Vous pouvez également manipuler les bits individuels d’un <xref:System.Double> valeur. Le <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> méthode conserve un <xref:System.Double> modèle de valeur de bit dans un entier 64 bits. Le <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=nameWithType> méthode retourne son modèle de bits dans un tableau d’octets.  
  
-   **Arrondi**. Arrondi est souvent utilisé comme une technique permettant de réduire l’impact des différences entre les valeurs provoquées par des problèmes de représentation à virgule flottante et de précision. Vous pouvez arrondir un <xref:System.Double> valeur en appelant le <xref:System.Math.Round%2A?displayProperty=nameWithType> (méthode).  
  
-   **Mise en forme**. Vous pouvez convertir un <xref:System.Double> valeur à sa représentation sous forme de chaîne en appelant le <xref:System.Double.ToString%2A> méthode ou à l’aide de la fonctionnalité de mise en forme composite. Pour plus d’informations sur la façon dont les chaînes de format contrôlent la représentation sous forme de chaîne de valeurs à virgule flottante, consultez le [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md) rubriques.  
  
-   **Analyse de chaînes**. Vous pouvez convertir la représentation sous forme de chaîne d’une valeur à virgule flottante en une <xref:System.Double> valeur en appelant le <xref:System.Double.Parse%2A> ou <xref:System.Double.TryParse%2A> (méthode). Si l’opération d’analyse échoue, le <xref:System.Double.Parse%2A> méthode lève une exception, tandis que le <xref:System.Double.TryParse%2A> retourne de la méthode `false`.  
  
-   **Conversion de type**. Le <xref:System.Double> structure fournit une implémentation d’interface explicite pour le <xref:System.IConvertible> interface, qui prend en charge la conversion entre les deux types de données .NET Framework standards. Les compilateurs de langage prennent également en charge la conversion implicite des valeurs de tous les autres types numériques standards pour <xref:System.Double> valeurs. Conversion d’une valeur de n’importe quel type numérique standard à un <xref:System.Double> est une conversion étendue et ne nécessite pas de l’utilisateur d’une méthode de conversion ou opérateur cast,  
  
     Toutefois, la conversion de <xref:System.Int64> et <xref:System.Single> valeurs peuvent entraîner une perte de précision. Le tableau suivant répertorie les différences de précision pour chacun de ces types :  
  
    |Type|Précision maximale|Précision interne|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|19 chiffres décimaux|19 chiffres décimaux|  
    |<xref:System.Single>|7 chiffres décimaux|9 chiffres décimaux|  
  
     Le problème de précision affecte plus fréquemment <xref:System.Single> les valeurs sont converties en <xref:System.Double> valeurs. Dans l’exemple suivant, deux valeurs produites par des opérations de division identiques sont inégaux, car une des valeurs est une valeur à virgule flottante simple précision convertie en un <xref:System.Double>.  
  
     [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de <xref:System.Double>:  
  
 [!code-cpp[Double Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tous les membres de ce type sont thread-safe. Les membres qui semblent modifier l’état de l’instance retournent en fait une nouvelle instance initialisée avec la nouvelle valeur. Comme avec tout autre type, la lecture et écriture à une variable partagée qui contient une instance de ce type doivent être protégées par un verrou pour garantir la sécurité des threads.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Single" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">Exemple : utilitaire de mise en forme .NET Framework 4</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compare cette instance à un objet spécifié ou un objet <see cref="T:System.Double" /> et retourne un entier qui indique si la valeur de cette instance est inférieure, égale ou supérieure à la valeur de l'objet spécifié ou de l'objet <see cref="T:System.Double" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(double value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : double -&gt; int&#xA;override this.CompareTo : double -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Nombre à virgule flottante double précision à comparer.</param>
        <summary>Compare cette instance à un nombre à virgule flottante double précision spécifié et retourne un entier qui indique si la valeur de cette instance est inférieure, égale ou supérieure à celle du nombre à virgule flottante double précision spécifié.</summary>
        <returns>Nombre signé indiquant les valeurs relatives de cette instance et <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valeur de retour 
 </term><description> Description  
 </description></listheader><item><term> Inférieure à zéro 
 </term><description> Cette instance est inférieure à <paramref name="value" />.  
  
ou 
Cette instance n'est pas un nombre (<see cref="F:System.Double.NaN" />) et <paramref name="value" /> est un nombre.  
  
 </description></item><item><term> Zéro 
 </term><description> Cette instance est égale à <paramref name="value" />.  
  
ou 
Cette instance et <paramref name="value" /> sont tous deux des non-nombres (<see cref="F:System.Double.NaN" />), <see cref="F:System.Double.PositiveInfinity" /> ou <see cref="F:System.Double.NegativeInfinity" />.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description> Cette instance est supérieure à <paramref name="value" />.  
  
ou 
Cette instance est un nombre et <paramref name="value" /> n'est pas un nombre (<see cref="F:System.Double.NaN" />).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les valeurs doivent être identiques pour être considérées comme égales. En particulier lorsque les valeurs à virgule flottante dépendent de plusieurs opérations mathématiques, il est courant de perte de précision et de leurs valeurs être quasiment identique à l’exception de leurs chiffres les moins significatifs. Pour cette raison, la valeur de retour de la <xref:System.Double.CompareTo%2A> méthode peut parfois sembler surprenante. Par exemple, la multiplication par une valeur particulière, suivie de division par la même valeur doit produire la valeur d’origine. Dans l’exemple suivant, toutefois, la valeur calculée s’avère pour être supérieure à la valeur d’origine. Affichage de tous les chiffres significatifs des deux valeurs à l’aide de « R » [chaîne de format numérique standard](~/docs/standard/base-types/standard-numeric-format-strings.md) indique que la valeur calculée diffère de la valeur d’origine dans ses chiffres les moins significatifs. Pour plus d’informations sur la gestion des ces comparaisons, consultez la section Notes de la <xref:System.Double.Equals%28System.Double%29> (méthode).  
  
 [!code-csharp[System.Double.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Double.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb#1)]  
  
 Cette méthode implémente la <xref:System.IComparable%601?displayProperty=nameWithType> interface et effectue légèrement meilleures que le <xref:System.Double.CompareTo%2A?displayProperty=nameWithType> (méthode), car il n’a pas à convertir le `value` paramètre à un objet.  
  
 Notez que, même si un objet dont la valeur est <xref:System.Double.NaN> n’est pas considéré comme égal à un autre objet dont la valeur est <xref:System.Double.NaN> (y compris à lui-même), le <xref:System.IComparable%601> interface requiert que `A.CompareTo(A)` retournent la valeur zéro.  
  
## <a name="widening-conversions"></a>conversions étendues  
 Selon votre langage de programmation, il est parfois possible au code un <xref:System.Double.CompareTo%2A> méthode où le type de paramètre comporte moins de bits (est plus restreint) que le type d’instance. Cela est possible, car certains langages de programmation effectuent une conversion étendue implicite qui représente le paramètre en tant que type avec autant de bits que l’instance.  
  
 Par exemple, supposons que le type d’instance est <xref:System.Double> et le type de paramètre est <xref:System.Int32>. Le compilateur Microsoft c# génère des instructions pour représenter la valeur du paramètre comme un <xref:System.Double> de l’objet, puis génère un <xref:System.Double.CompareTo%28System.Double%29?displayProperty=nameWithType> méthode qui compare les valeurs de l’instance et la représentation étendue du paramètre.  
  
 Consultez la documentation de votre langage de programmation pour déterminer si son compilateur effectue des conversions étendues implicites des types numériques. Pour plus d’informations, consultez le [tableaux de Conversion de Type](~/docs/standard/base-types/conversion-tables.md) rubrique.  
  
## <a name="precision-in-comparisons"></a>Précision dans les comparaisons  
 La précision des nombres à virgule flottante au-delà de la précision documentée est spécifique à l’implémentation et la version du .NET Framework. Par conséquent, une comparaison de deux nombres particuliers peut changer entre les versions du .NET Framework, car la précision de la représentation interne des nombres peut changer.  
  
   
  
## Examples  
 L’exemple de code suivant montre des versions génériques et de la <xref:System.Double.CompareTo%2A> méthode pour plusieurs types valeur et référence.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objet à comparer ou <see langword="null" />.</param>
        <summary>Compare cette instance à un objet spécifié et retourne un entier qui indique si la valeur de cette instance est inférieure, égale ou supérieure à la valeur de l'objet spécifié.</summary>
        <returns>Nombre signé indiquant les valeurs relatives de cette instance et <paramref name="value" />.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Description  
 </description></listheader><item><term> Entier négatif 
 </term><description> Cette instance est inférieure à <paramref name="value" />.  
  
ou 
Cette instance n'est pas un nombre (<see cref="F:System.Double.NaN" />) et <paramref name="value" /> est un nombre.  
  
 </description></item><item><term> Zéro 
 </term><description> Cette instance est égale à <paramref name="value" />.  
  
ou 
Cette instance et <paramref name="value" /> sont tous deux <see langword="Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> ou <see cref="F:System.Double.NegativeInfinity" />.</description></item><item><term> Entier positif 
 </term><description> Cette instance est supérieure à <paramref name="value" />.  
  
ou 
Cette instance est un nombre et <paramref name="value" /> n'est pas un nombre (<see cref="F:System.Double.NaN" />).  
  
ou 
 <paramref name="value" /> est <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `value` paramètre doit être `null` ou une instance de `Double`; sinon, une exception est levée. N’importe quelle instance de <xref:System.Double>, quelle que soit sa valeur, est considéré comme supérieur `null`.  
  
 Les valeurs doivent être identiques pour être considérées comme égales. En particulier lorsque les valeurs à virgule flottante dépendent de plusieurs opérations mathématiques, il est courant de perte de précision et de leurs valeurs être quasiment identique à l’exception de leurs chiffres les moins significatifs. Pour cette raison, la valeur de retour de la <xref:System.Double.CompareTo%2A> méthode peut parfois sembler surprenante. Par exemple, la multiplication par une valeur particulière, suivie de division par la même valeur doit produire la valeur d’origine. Dans l’exemple suivant, toutefois, la valeur calculée s’avère pour être supérieure à la valeur d’origine. Affichage de tous les chiffres significatifs des deux valeurs à l’aide de « R » [chaîne de format numérique standard](~/docs/standard/base-types/standard-numeric-format-strings.md) indique que la valeur calculée diffère de la valeur d’origine dans ses chiffres les moins significatifs. Pour plus d’informations sur la gestion des ces comparaisons, consultez la section Notes de la <xref:System.Double.Equals%28System.Double%29> (méthode).  
  
 [!code-csharp[System.Double.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Double.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb#2)]  
  
 Cette méthode est implémentée pour prendre en charge la <xref:System.IComparable> interface. Notez que, même si un <xref:System.Double.NaN> n’est pas considéré comme égal à un autre <xref:System.Double.NaN> (y compris à lui-même), le <xref:System.IComparable> interface requiert que `A.CompareTo(A)` retournent la valeur zéro.  
  
## <a name="precision-in-comparisons"></a>Précision dans les comparaisons  
 La précision des nombres à virgule flottante au-delà de la précision documentée est spécifique à l’implémentation et la version du .NET Framework. Par conséquent, une comparaison de deux nombres particuliers peut changer entre les versions du .NET Framework, car la précision de la représentation interne des nombres peut changer.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de `CompareTo` dans le contexte de `Double`.  
  
 [!code-cpp[System.Double#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> n’est pas un <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Double  = 4.94065645841247E-324" />
      <MemberSignature Language="C++ CLI" Value="public: double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : double" Usage="System.double.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>Représente la valeur <see cref="T:System.Double" /> positive la plus petite qui est supérieure à zéro. Ce champ est constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de la <xref:System.Double.Epsilon> propriété reflète la positive la plus petite <xref:System.Double> qui est significative dans les opérations numériques ou les comparaisons lorsque la valeur de la <xref:System.Double> instance est égale à zéro. Par exemple, le code suivant montre que zéro et <xref:System.Double.Epsilon> sont considérés comme des valeurs inégales, alors que zéro et la moitié de la valeur de <xref:System.Double.Epsilon> sont considérées comme égales.  
  
 [!code-csharp[System.Double.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Double.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb#5)]  
  
 Plus précisément, flottante point format se compose d’une connexion, une mantisse 52 bits ou mantisse et un exposant de 11 bits. Comme le montre l’exemple suivant, zéro a un exposant de -1022 et une mantisse de 0. <xref:System.Double.Epsilon> a un exposant de -1022 et une mantisse de 1. Cela signifie que <xref:System.Double.Epsilon> est la positive la plus petite <xref:System.Double> valeur supérieure à zéro et représente la plus petite valeur possible et le plus petit incrément possible pour un <xref:System.Double> dont exposant est 1022.  
  
 [!code-csharp[System.Double.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Double.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb#6)]  
  
 Toutefois, le <xref:System.Double.Epsilon> propriété n’est pas une mesure générale de précision de la <xref:System.Double> tapez ; elle s’applique uniquement aux <xref:System.Double> instances qui ont une valeur égale à zéro ou un exposant de -1022.  
  
> [!NOTE]
>  La valeur de la <xref:System.Double.Epsilon> propriété n’est pas équivalente à epsilon d’ordinateur, qui représente la limite supérieure de l’erreur relative en raison de l’arrondi dans l’arithmétique à virgule flottante.  
  
 La valeur de cette constante est 4, 94065645841247E-324.  
  
 Deux nombres à virgule flottante apparemment équivalentes peuvent ne pas être considérés comme égaux en raison de différences dans leurs chiffres les moins significatifs. Par exemple, l’expression c# `(double)1/3 == (double)0.33333`, ne vérifie l’égalité, car l’opération de division sur le côté gauche présente la précision maximale alors que la constante sur le côté droit est uniquement pour les chiffres spécifiés. Si vous créez un algorithme personnalisé qui détermine si deux nombres à virgule flottante peuvent être considérés comme égaux, nous ne recommandons pas que vous basez votre algorithme sur la valeur de la <xref:System.Double.Epsilon> pour établir la marge absolue acceptable de différence pour (constante) les deux valeurs devant être considérées comme égales.  (En règle générale, cette marge de différence est plusieurs fois supérieure à <xref:System.Double.Epsilon>.) Pour plus d’informations sur la comparaison des deux valeurs à virgule flottante double précision, consultez <xref:System.Double> et <xref:System.Double.Equals%28System.Double%29>.  
  
## <a name="platform-notes"></a>Notes de la plateforme  
 Sur les systèmes ARM, la valeur de la <xref:System.Double.Epsilon> constante étant trop petite pour être détecté, ce qui équivaut à zéro. Vous pouvez définir une valeur de remplacement epsilon égale à 2.2250738585072014E-308 à la place.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une valeur indiquant si deux instances de <see cref="T:System.Double" /> représentent la même valeur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(double obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : double -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="obj">Objet <see cref="T:System.Double" /> à comparer à cette instance.</param>
        <summary>Retourne une valeur indiquant si cette instance et un objet <see cref="T:System.Double" /> spécifié représentent la même valeur.</summary>
        <returns><see langword="true" /> si <paramref name="obj" /> est égal à cette instance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode implémente la <xref:System.IEquatable%601?displayProperty=nameWithType> interface et effectue légèrement meilleures que <xref:System.Double.Equals%2A> , car il n’a pas à convertir le `obj` paramètre à un objet.  
  
## <a name="widening-conversions"></a>conversions étendues  
 Selon votre langage de programmation, il est parfois possible au code un <xref:System.Double.Equals%2A> méthode où le type de paramètre comporte moins de bits (est plus restreint) que le type d’instance. Cela est possible, car certains langages de programmation effectuent une conversion étendue implicite qui représente le paramètre en tant que type avec autant de bits que l’instance.  
  
 Par exemple, supposons que le type d’instance est <xref:System.Double> et le type de paramètre est <xref:System.Int32>. Le compilateur Microsoft c# génère des instructions pour représenter la valeur du paramètre comme un <xref:System.Double> de l’objet, puis génère un <xref:System.Double.Equals%28System.Double%29?displayProperty=nameWithType> méthode qui compare les valeurs de l’instance et la représentation étendue du paramètre.  
  
 Consultez la documentation de votre langage de programmation pour déterminer si son compilateur effectue des conversions étendues implicites des types numériques. Pour plus d’informations, consultez le [tableaux de Conversion de Type](~/docs/standard/base-types/conversion-tables.md) rubrique.  
  
## <a name="precision-in-comparisons"></a>Précision dans les comparaisons  
 Le <xref:System.Double.Equals%2A> méthode doit être utilisée avec précaution, car deux valeurs apparemment équivalentes peuvent être différentes en raison de la précision différente de deux valeurs. L’exemple suivant indique que le <xref:System.Double> valeur.333333 et le <xref:System.Double> valeur retournée en divisant 1 par 3 ne sont pas égales.  
  
 [!code-csharp[System.Double.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#1)]
 [!code-vb[System.Double.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#1)]  
  
 Au lieu de la comparaison d’égalité, une technique consiste à définir une marge acceptable de différence entre deux valeurs (tel que. % 001 d’une des valeurs). Si la valeur absolue de la différence entre les deux valeurs est inférieure ou égale à cette marge, la différence est susceptible d’être en raison des différences de précision et, par conséquent, les valeurs sont susceptibles d’être égal. L’exemple suivant utilise cette technique pour comparer.33333 et 1/3, les deux <xref:System.Double> valeurs qui peuvent pour être inégaux l’exemple de code précédent. Dans ce cas, les valeurs sont égales.  
  
 [!code-csharp[System.Double.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#2)]
 [!code-vb[System.Double.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#2)]  
  
> [!NOTE]
>  Étant donné que <xref:System.Double.Epsilon> définit l’expression minimum d’une valeur positive dont la plage est proche de zéro, la marge de différence entre deux valeurs semblables doit être supérieure à <xref:System.Double.Epsilon>. En règle générale, il est beaucoup plus important que <xref:System.Double.Epsilon>. Pour cette raison, nous vous recommandons de ne pas utiliser <xref:System.Double.Epsilon> lors de la comparaison <xref:System.Double> valeurs sont égales.  
  
 Une deuxième technique implique la comparaison de la différence entre deux nombres à virgule flottante avec une valeur absolue. Si la différence est inférieure ou égale à cette valeur absolue, les nombres sont égaux. Si elle est supérieure, les nombres ne sont pas égaux. Une solution consiste à sélectionner arbitrairement une valeur absolue. Cela peut être problématique, toutefois, car une marge acceptable de différence dépend de l’ampleur de la <xref:System.Double> valeurs. Une alternative tire parti d’une fonctionnalité de conception du format à virgule flottante : La différence entre la représentation de type entier de deux valeurs à virgule flottante indique le nombre de valeurs à virgule flottante possibles qui les sépare. Par exemple, la différence entre 0.0 et <xref:System.Double.Epsilon> est 1, parce que <xref:System.Double.Epsilon> est la plus petite valeur représentable lorsque vous travaillez avec un <xref:System.Double> dont la valeur est égale à zéro. L’exemple suivant utilise cette technique pour comparer.33333 et 1/3, qui sont les deux <xref:System.Double> valeurs que l’exemple de code précédent avec le <xref:System.Double.Equals%28System.Double%29> méthode trouvée accentuées. Notez que l’exemple utilise le <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> méthode pour convertir une valeur à virgule flottante double précision en sa représentation sous forme d’entier.  
  
 [!code-csharp[System.Double.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Double.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb#1)]  
  
 La précision des nombres à virgule flottante au-delà de la précision documentée est spécifique à l’implémentation et la version du .NET Framework. Par conséquent, une comparaison de deux nombres particuliers peut changer entre les versions du .NET Framework, car la précision de la représentation interne des nombres peut changer.  
  
 Si deux <xref:System.Double.NaN?displayProperty=nameWithType> les valeurs sont testées pour l’égalité en appelant le <xref:System.Double.Equals%2A> (méthode), la méthode retourne `true`. Toutefois, si deux <xref:System.Double.NaN> retourne de l’opérateur d’égalité, les valeurs sont testées à l’aide de l’opérateur d’égalité, `false`. Lorsque vous souhaitez déterminer si la valeur d’un <xref:System.Double> n’est pas un nombre (NaN), une alternative consiste à appeler le <xref:System.Double.IsNaN%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Résolution de surcharge du compilateur peut-être représenter une différence apparente dans le comportement des deux <see cref="M:System.Double.Equals(System.Object)" /> surcharges de méthode. Si une conversion implicite entre le <paramref name="obj" /> argument et un <see cref="T:System.Double" /> est défini et l’argument n’est pas typé comme un <see cref="T:System.Object" />, compilateurs peuvent effectuer une conversion implicite et l’appel de la <see cref="M:System.Double.Equals(System.Double)" /> (méthode). Sinon, elles appellent la <see cref="M:System.Double.Equals(System.Object)" /> (méthode), qui retourne toujours <see langword="false" /> si son <paramref name="obj" /> argument n’est pas un <see cref="T:System.Double" /> valeur. L’exemple suivant illustre la différence de comportement entre les surcharges de deux méthode. Dans le cas de tous les types numériques primitifs à l’exception de <see cref="T:System.Decimal" /> et en c#, la première comparaison retourne <see langword="true" /> , car le compilateur effectue automatiquement une conversion étendue et appelle le <see cref="M:System.Double.Equals(System.Double)" /> (méthode), tandis que la deuxième comparaison Retourne <see langword="false" /> , car le compilateur appelle le <see cref="M:System.Double.Equals(System.Object)" /> (méthode).  
  
[!code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [!code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Double.Equals(System.Object)" />
        <altmember cref="Overload:System.Double.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à comparer à cette instance.</param>
        <summary>Retourne une valeur indiquant si cette instance équivaut à un objet spécifié.</summary>
        <returns><see langword="true" /> si <paramref name="obj" /> est une instance de <see cref="T:System.Double" /> et est égal à la valeur de cette instance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Double.Equals%2A> méthode doit être utilisée avec précaution, car deux valeurs apparemment équivalentes peuvent être différentes en raison de la précision différente de deux valeurs. L’exemple suivant indique que le <xref:System.Double> valeur.3333 et <xref:System.Double> retournée en divisant 1 par 3 ne sont pas égales.  
  
 [!code-csharp[System.Double.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#3)]
 [!code-vb[System.Double.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#3)]  
  
 Des alternatives à appeler le <xref:System.Double.Equals%2A> (méthode), consultez la documentation de la <xref:System.Double.Equals%28System.Double%29> de surcharge.  
  
> [!NOTE]
>  Étant donné que <xref:System.Double.Epsilon> définit l’expression minimum d’une valeur positive dont la plage est proche de zéro, la marge de différence entre deux valeurs semblables doit être supérieure à <xref:System.Double.Epsilon>. En règle générale, il est beaucoup plus important que <xref:System.Double.Epsilon>.  
  
 La précision des nombres à virgule flottante au-delà de la précision documentée est spécifique à l’implémentation et la version du .NET Framework. Par conséquent, une comparaison de deux nombres particuliers peut changer entre les versions du .NET Framework, car la précision de la représentation interne des nombres peut changer.  
  
 Si deux <xref:System.Double.NaN?displayProperty=nameWithType> les valeurs sont testées pour l’égalité en appelant le <xref:System.Double.Equals%2A> (méthode), la méthode retourne `true`. Toutefois, si deux <xref:System.Double.NaN> retourne de l’opérateur d’égalité, les valeurs sont testées à l’aide de l’opérateur d’égalité, `false`. Lorsque vous souhaitez déterminer si la valeur d’un <xref:System.Double> n’est pas un nombre (NaN), une alternative consiste à appeler le <xref:System.Double.IsNaN%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Résolution de surcharge du compilateur peut-être représenter une différence apparente dans le comportement des deux <see cref="M:System.Double.Equals(System.Object)" /> surcharges de méthode. Si une conversion implicite entre le <paramref name="obj" /> argument et un <see cref="T:System.Double" /> est défini et l’argument n’est pas typé comme un <see cref="T:System.Object" />, compilateurs peuvent effectuer une conversion implicite et l’appel de la <see cref="M:System.Double.Equals(System.Double)" /> (méthode). Sinon, elles appellent la <see cref="M:System.Double.Equals(System.Object)" /> (méthode), qui retourne toujours <see langword="false" /> si son <paramref name="obj" /> argument n’est pas un <see cref="T:System.Double" /> valeur. L’exemple suivant illustre la différence de comportement entre les surcharges de deux méthode. Dans le cas de tous les types numériques primitifs à l’exception de <see cref="T:System.Decimal" /> et en c#, la première comparaison retourne <see langword="true" /> , car le compilateur effectue automatiquement une conversion étendue et appelle le <see cref="M:System.Double.Equals(System.Double)" /> (méthode), tandis que la deuxième comparaison Retourne <see langword="false" /> , car le compilateur appelle le <see cref="M:System.Double.Equals(System.Object)" /> (méthode).  
  
[!code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [!code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Double.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="double.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage de cette instance.</summary>
        <returns>Code de hachage d'un entier signé 32 bits.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="double.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le <see cref="T:System.TypeCode" /> du type valeur <see cref="T:System.Double" />.</summary>
        <returns>Constante énumérée, <see cref="F:System.TypeCode.Double" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsFinite(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(double d);" />
      <MemberSignature Language="F#" Value="static member IsFinite : double -&gt; bool" Usage="System.double.IsFinite d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : double -&gt; bool" Usage="System.double.IsInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Nombre à virgule flottante double précision.</param>
        <summary>Retourne une valeur indiquant si le nombre spécifié a pour valeur l'infini négatif ou positif.</summary>
        <returns><see langword="true" /> si <paramref name="d" /> a la valeur <see cref="F:System.Double.PositiveInfinity" /> ou <see cref="F:System.Double.NegativeInfinity" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les opérations à virgule flottante retournent <xref:System.Double.PositiveInfinity> ou <xref:System.Double.NegativeInfinity> pour signaler une condition de dépassement de capacité.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de <xref:System.Double.IsInfinity%2A>:  
  
 [!code-cpp[System.Double#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(double d);" />
      <MemberSignature Language="F#" Value="static member IsNaN : double -&gt; bool" Usage="System.double.IsNaN d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Nombre à virgule flottante double précision.</param>
        <summary>Retourne une valeur qui indique si la valeur spécifiée n'est pas un nombre (<see cref="F:System.Double.NaN" />).</summary>
        <returns><see langword="true" /> si <paramref name="d" /> a la valeur <see cref="F:System.Double.NaN" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les opérations à virgule flottante retournent <xref:System.Double.NaN> pour signaler que le résultat de l’opération est non défini. Par exemple, la division de 0,0 par 0,0 entraîne <xref:System.Double.NaN>.  
  
> [!NOTE]
>  <xref:System.Double.IsNaN%2A> Retourne `false` si un <xref:System.Double> valeur est soit <xref:System.Double.PositiveInfinity> ou <xref:System.Double.NegativeInfinity>. Pour tester ces valeurs, utilisez le <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, et <xref:System.Double.IsNegativeInfinity%2A> méthodes.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de <xref:System.Double.IsNaN%2A>:  
  
 [!code-cpp[System.Double#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Double.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegative(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegative : double -&gt; bool" Usage="System.double.IsNegative d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : double -&gt; bool" Usage="System.double.IsNegativeInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Nombre à virgule flottante double précision.</param>
        <summary>Retourne une valeur indiquant si le nombre spécifié est équivalent à l'infini négatif.</summary>
        <returns><see langword="true" /> si <paramref name="d" /> a la valeur <see cref="F:System.Double.NegativeInfinity" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les opérations à virgule flottante retournent <xref:System.Double.NegativeInfinity> pour signaler une condition de dépassement de capacité.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de <xref:System.Double.IsNegativeInfinity%2A>:  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsNormal : double -&gt; bool" Usage="System.double.IsNormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : double -&gt; bool" Usage="System.double.IsPositiveInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Nombre à virgule flottante double précision.</param>
        <summary>Retourne une valeur indiquant si le nombre spécifié est équivalent à l'infini positif.</summary>
        <returns><see langword="true" /> si <paramref name="d" /> a la valeur <see cref="F:System.Double.PositiveInfinity" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les opérations à virgule flottante retournent <xref:System.Double.PositiveInfinity> pour signaler une condition de dépassement de capacité.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de <xref:System.Double.IsPositiveInfinity%2A>:  
  
 [!code-cpp[System.Double#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsSubnormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : double -&gt; bool" Usage="System.double.IsSubnormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Double  = 1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : double" Usage="System.double.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Représente la plus grande valeur possible d'un <see cref="T:System.Double" />. Ce champ est constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette constante est positive 1.7976931348623157E + 308.  
  
 Le résultat d’une opération qui dépasse <xref:System.Double.MaxValue?displayProperty=nameWithType> est <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. Dans l’exemple suivant, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> entraîne des opérations d’addition, la multiplication et une puissance lorsque le résultat dépasse <xref:System.Double.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Double.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de <xref:System.Double.MaxValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Double  = -1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : double" Usage="System.double.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Représente la plus petite valeur possible de <see cref="T:System.Double" />. Ce champ est constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette constante est négative 1.7976931348623157E + 308.  
  
 Le résultat d’une opération qui est inférieur à <xref:System.Double.MinValue?displayProperty=nameWithType> est <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Dans l’exemple suivant, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> résulte de la soustraction et multiplication des opérations lorsque le résultat est inférieur à <xref:System.Double.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Double.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de <xref:System.Double.MinValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Double  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: double NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : double" Usage="System.double.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Représente une valeur qui n'est pas un nombre (<see langword="NaN" />). Ce champ est constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une méthode ou un opérateur retourne <xref:System.Double.NaN> lorsque le résultat d’une opération est indéfini. Par exemple, le résultat de la division de zéro par zéro est <xref:System.Double.NaN>, comme illustré dans l’exemple suivant. (Mais notez que la division d’un nombre différent de zéro par zéro retourne <xref:System.Double.PositiveInfinity> ou <xref:System.Double.NegativeInfinity>, selon le signe du diviseur.)  
  
 [!code-csharp[System.Double.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#1)]
 [!code-vb[System.Double.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#1)]  
  
 En outre, un appel de méthode avec un <xref:System.Double.NaN> valeur ou une opération sur un <xref:System.Double.NaN> retourne la valeur <xref:System.Double.NaN>, comme illustré dans l’exemple suivant.  
  
 [!code-csharp[System.Double.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#2)]
 [!code-vb[System.Double.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#2)]  
  
 Utilisez le <xref:System.Double.IsNaN%2A> méthode pour déterminer si une valeur n’est pas un nombre. Le <xref:System.Double.op_Equality%2A> opérateur considère deux <xref:System.Double.NaN> valeurs japonaises entre eux. En règle générale, <xref:System.Double> opérateurs ne peuvent pas être utilisés pour comparer <xref:System.Double.NaN?displayProperty=nameWithType> avec d’autres <xref:System.Double> valeurs, bien que les méthodes de comparaison (tels que <xref:System.Double.Equals%2A> et <xref:System.Double.CompareTo%2A>) peut. L’exemple suivant illustre la différence de comportement entre les <xref:System.Double> les méthodes et les opérateurs de comparaison.  
  
 [!code-csharp[System.Double.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs#4)]
 [!code-vb[System.Double.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb#4)]  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de <xref:System.Double.NaN> :  
  
 [!code-cpp[System.Double#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#7)]
 [!code-csharp[System.Double#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#7)]
 [!code-vb[System.Double#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNaN(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Double  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : double" Usage="System.double.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Représente l'infini négatif. Ce champ est constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette constante est le résultat de la division d’un nombre négatif par zéro.  
  
 Cette constante est retournée quand le résultat d’une opération est inférieur à <xref:System.Double.MinValue>.  
  
 Utilisez <xref:System.Double.IsNegativeInfinity%2A> pour déterminer si une valeur correspond à l’infini négatif.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de <xref:System.Double.NegativeInfinity>:  
  
 [!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : double * double -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si deux valeurs <see cref="T:System.Double" /> spécifiées sont égales.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> et <paramref name="right" /> sont égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Double.op_Equality%2A> méthode définit l’opérateur d’égalité pour <xref:System.Double> valeurs.  
  
 Si deux <xref:System.Double.NaN?displayProperty=nameWithType> les valeurs sont testées pour l’égalité à l’aide de l’opérateur d’égalité, le résultat est `false`; deux <xref:System.Double.NaN?displayProperty=nameWithType> valeurs ne sont pas considérées comme égales. Si elles sont testées pour l’égalité en appelant le <xref:System.Double.Equals%2A> (méthode), le résultat est `true`.  Lorsque vous souhaitez déterminer si la valeur d’un <xref:System.Double> n’est pas un nombre (NaN), une alternative consiste à appeler le <xref:System.Double.IsNaN%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : double * double -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Double" /> spécifique est supérieure à une autre valeur <see cref="T:System.Double" /> spécifique.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> est supérieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Double.op_GreaterThan%2A> méthode définit l’opération de la plus grande-que l’opérateur pour <xref:System.Double> valeurs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : double * double -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Double" /> spécifique est supérieure ou égale à une autre valeur <see cref="T:System.Double" /> spécifique.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> est supérieur ou égal à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Double.op_GreaterThanOrEqual%2A> méthode définit l’opération de l’opérateur supérieur ou égal pour <xref:System.Double> valeurs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : double * double -&gt; bool" Usage="System.double.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si deux valeurs <see cref="T:System.Double" /> spécifiées sont différentes.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> et <paramref name="right" /> ne sont pas égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Double.op_Inequality%2A> méthode définit l’opérateur d’inégalité pour <xref:System.Double> valeurs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : double * double -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Double" /> spécifique est inférieure à une autre valeur <see cref="T:System.Double" /> spécifique.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> est inférieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Double.op_LessThan%2A> méthode définit l’opération d’inférieur-que l’opérateur pour <xref:System.Double> valeurs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : double * double -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Double" /> spécifique est inférieure ou égale à une autre valeur <see cref="T:System.Double" /> spécifique.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> est inférieur ou égal à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Double.op_LessThanOrEqual%2A> méthode définit l’opération de l’opérateur inférieur ou égal pour <xref:System.Double> valeurs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit la représentation sous forme de chaîne d'un nombre en nombre à virgule flottante double précision équivalent.</summary>
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; double" Usage="System.double.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne contenant un nombre à convertir.</param>
        <summary>Convertit la représentation sous forme de chaîne d'un nombre en nombre à virgule flottante double précision équivalent.</summary>
        <returns>Nombre à virgule flottante double précision équivalant à la valeur numérique ou au symbole spécifié dans <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `s` paramètre peut contenir de la culture actuelle <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>, ou une chaîne au format :  
  
 [*ws*] [*connexion*] [*chiffres intégraux*[*,*]]*chiffres intégraux*[*.* [*chiffres fractionnaires*]] [E [*connexion*]*chiffres exponentiels*] [*ws*]  
  
 Les éléments entre crochets ([ et ]) sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Une série de caractères d’espace blanc.|  
|*sign*|Un symbole négatif (-) ou un signe positif (+) de symboles. Uniquement un signe de début peut être utilisé.|  
|*integral-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie entière du nombre. Les exécutions de *chiffres intégraux* peuvent être partitionnées par un symbole de séparateur de groupes. Par exemple, dans certaines cultures une virgule (,) sépare les groupes de milliers. Le *chiffres intégraux* élément peut être absent si la chaîne contient le *chiffres fractionnaires* élément.|  
|,|Des milliers spécifiques à la culture des symboles de séparateur.|  
|.|Un symbole décimal spécifique à la culture.|  
|*fractional-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie fractionnaire du nombre.|  
|E|Le « e » ou un caractère « E », ce qui indique que la valeur est représentée dans la notation exponentielle (scientifique).|  
|*exponential-digits*|Une série de chiffres allant de 0 à 9 qui spécifie un exposant.|  
  
 Le `s` paramètre est interprété en utilisant une combinaison de la <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> et <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> indicateurs. Cela signifie que les espaces blancs et des milliers les séparateurs sont autorisés, par exemple, tandis que les symboles monétaires ne sont pas. Pour un contrôle précis sur le style des éléments sont autorisés dans `s` pour l’opération d’analyse réussisse, appelez le <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> ou <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 Le `s` paramètre est interprété en utilisant les informations de mise en forme dans un <xref:System.Globalization.NumberFormatInfo> objet initialisé pour la culture du thread actuel. Pour plus d'informations, consultez <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Pour analyser une chaîne en utilisant les informations de mise en forme d’une autre culture, appelez le <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> ou <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 En règle générale, si vous passez le <xref:System.Double.Parse%2A?displayProperty=nameWithType> méthode une chaîne qui est créé en appelant le <xref:System.Double.ToString%2A?displayProperty=nameWithType> (méthode), la version d’origine <xref:System.Double> valeur est retournée. Toutefois, en raison d’une perte de précision, les valeurs peut-être pas égales. En outre, une tentative d’analyser la représentation sous forme de chaîne du <xref:System.Double.MinValue> ou <xref:System.Double.MaxValue> lève un <xref:System.OverflowException>, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Si un séparateur est rencontré dans le `s` paramètre pendant une opération d’analyse et la devise ou un nombre décimal et des séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur. Pour plus d’informations sur les séparateurs, consultez <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, et <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode <xref:System.Double.Parse%28System.String%29>.  
  
 [!code-cpp[Double Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#5)]
 [!code-csharp[Double Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#5)]
 [!code-vb[Double Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> ne représente pas un nombre dans un format valide.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> représente un nombre qui est inférieur à <see cref="F:System.Double.MinValue" /> ou supérieur à <see cref="F:System.Double.MaxValue" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="M:System.Double.TryParse(System.String,System.Double@)" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analyse de chaînes numériques dans .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; double" Usage="System.double.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne contenant un nombre à convertir.</param>
        <param name="style">Combinaison d'opérations de bit des valeurs d'énumération qui indiquent les éléments de style qui peuvent être présents dans <paramref name="s" />. Une valeur typique à spécifier est une combinaison de <see cref="F:System.Globalization.NumberStyles.Float" /> combinée avec <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Convertit la représentation sous forme de chaîne d'un nombre dans un style spécifié en nombre à virgule flottante double précision équivalent.</summary>
        <returns>Nombre à virgule flottante double précision équivalant à la valeur numérique ou au symbole spécifié dans <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `style` paramètre définit les éléments de style (tels que des espaces blancs, des milliers séparateurs et les symboles monétaires) qui sont autorisés dans les `s` paramètre pour l’opération d’analyse. Il doit être une combinaison d’indicateurs de bits de le <xref:System.Globalization.NumberStyles> énumération. Ce qui suit <xref:System.Globalization.NumberStyles> membres ne sont pas pris en charge :  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Le `s` paramètre peut contenir de la culture actuelle <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, ou <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>. Selon la valeur de `style`, il peut également prendre la forme :  
  
 [*ws*][*$*][*sign*][*integral-digits*[*,*]]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 Les éléments entre crochets ([ et ]) sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Une série de caractères d’espace blanc. Espace blanc peut apparaître au début de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> indicateur et il peuvent apparaître à la fin de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> indicateur.|  
|$|Un symbole monétaire spécifique à la culture. Sa position dans la chaîne est définie par le <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> et <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propriétés de la culture actuelle. Symbole de devise de la culture actuelle peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> indicateur.|  
|*sign*|Un symbole négatif (-) ou un signe positif (+) de symboles. Le signe peut apparaître au début de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> indicateur et il peuvent apparaître à la fin de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> indicateur. Parenthèses peuvent être utilisées dans `s` pour indiquer une valeur négative si `style` inclut le <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> indicateur.|  
|*integral-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie entière du nombre. Le *chiffres intégraux* élément peut être absent si la chaîne contient le *chiffres fractionnaires* élément.|  
|,|Un séparateur de groupe spécifique à la culture. Symbole de séparateur de groupe de la culture actuelle peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> indicateur|  
|.|Un symbole décimal spécifique à la culture. Symbole de virgule décimale de la culture actuelle peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> indicateur.|  
|*fractional-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie fractionnaire du nombre. Les chiffres fractionnaires peuvent apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> indicateur.|  
|E|Le « e » ou un caractère « E », ce qui indique que la valeur est représentée dans la notation exponentielle (scientifique). Le `s` paramètre peut représenter un nombre en notation exponentielle si `style` inclut le <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> indicateur.|  
|*exponential-digits*|Une série de chiffres allant de 0 à 9 qui spécifie un exposant.|  
  
> [!NOTE]
> Les caractères (U + 0000) NUL fin `s` sont ignorés par l’opération d’analyse, quelle que soit la valeur de la `style` argument.

 Une chaîne contenant uniquement des chiffres (qui correspond à la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) toujours analysée avec succès. Les autres <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> membres contrôlent des éléments qui peuvent être présents, mais ne sont pas requis pour être présents dans la chaîne d’entrée. Le tableau suivant indique comment chaque <xref:System.Globalization.NumberStyles> indicateurs affectent les éléments qui peuvent être présents dans `s`.  
  
|Valeur NumberStyles|Éléments autorisés dans `s` en plus des chiffres|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Le *chiffres intégraux* élément uniquement.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|La virgule décimale (*.*) et *chiffres fractionnaires* éléments.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Le « e » ou un caractère « E », ce qui indique la notation exponentielle. Cet indicateur en lui-même prend en charge les valeurs sous la forme *chiffres*E*chiffres*; autres indicateurs sont nécessaires pour analyser correctement les chaînes avec des éléments tels que les signes positifs ou négatifs et des symboles de séparateur décimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Le *ws* élément au début de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Le *ws* élément à la fin de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Le *connexion* élément au début de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Le *connexion* élément à la fin de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Le *connexion* élément sous la forme de parenthèses entourant la valeur numérique.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Les milliers élément séparateur (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Élément de devise ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Tous les éléments. Toutefois, `s` ne peut pas représenter un nombre hexadécimal ou un nombre en notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Float>|Le *ws* élément au début ou à la fin de `s`, *connexion* au début de `s`et le symbole de virgule décimale (.). Le `s` paramètre peut également utiliser la notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Number>|Le `ws`, `sign`, des milliers séparateur (,) et les éléments de la virgule décimale (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Tous les éléments. Toutefois, `s` ne peut pas représenter un nombre hexadécimal.|  
  
 Le `s` paramètre est analysé en utilisant les informations de mise en forme dans un <xref:System.Globalization.NumberFormatInfo> objet initialisé pour la culture système actuelle. Pour plus d'informations, consultez <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>.  
  
 En règle générale, si vous passez le <xref:System.Double.Parse%2A?displayProperty=nameWithType> méthode une chaîne qui est créé en appelant le <xref:System.Double.ToString%2A?displayProperty=nameWithType> (méthode), la version d’origine <xref:System.Double> valeur est retournée. Toutefois, en raison d’une perte de précision, les valeurs peut-être pas égales. En outre, une tentative d’analyser la représentation sous forme de chaîne du <xref:System.Double.MinValue> ou <xref:System.Double.MaxValue> lève un <xref:System.OverflowException>, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Si un séparateur est rencontré dans le `s` paramètre pendant une opération d’analyse et la devise ou un nombre décimal et des séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur. Pour plus d’informations sur les séparateurs, consultez <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, et <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> méthode pour analyser les représentations sous forme de chaîne de <xref:System.Double> des valeurs en utilisant la culture en-US.  
  
 [!code-csharp[System.Double.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs#1)]
 [!code-vb[System.Double.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> ne représente pas un nombre dans un format valide.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> représente un nombre qui est inférieur à <see cref="F:System.Double.MinValue" /> ou supérieur à <see cref="F:System.Double.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> n’est pas une valeur <see cref="T:System.Globalization.NumberStyles" />.  
  
ou 
 <paramref name="style" /> inclut la valeur <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analyse de chaînes numériques dans .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; double" Usage="System.double.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne contenant un nombre à convertir.</param>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture sur <paramref name="s" />.</param>
        <summary>Convertit la représentation sous forme de chaîne d'un nombre dans un format propre à la culture spécifié en nombre à virgule flottante double précision équivalent.</summary>
        <returns>Nombre à virgule flottante double précision équivalant à la valeur numérique ou au symbole spécifié dans <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de la <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> méthode est généralement utilisée pour convertir du texte qui peut être mis en forme de différentes façons pour un <xref:System.Double> valeur. Par exemple, il peut être utilisé pour convertir le texte entré par un utilisateur dans une zone de texte HTML en valeur numérique.  
  
 Le `s` paramètre est interprété en utilisant une combinaison de la <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> et <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> indicateurs. Le `s` paramètre peut contenir <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, ou <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> pour la culture spécifiée par `provider`, ou il peut contenir une chaîne sous la forme :  
  
 [*ws*][*sign*]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 Éléments facultatifs sont encadrés par des crochets ([et]). Les éléments qui contiennent le terme « chiffres » se composent d’une série de caractères numériques comprises entre 0 et 9.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Une série de caractères d’espace blanc.|  
|*sign*|Un symbole négatif (-) ou un signe positif (+) de symboles.|  
|*integral-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie entière du nombre. Les exécutions de *chiffres intégraux* peuvent être partitionnées par un symbole de séparateur de groupes. Par exemple, dans certaines cultures une virgule (,) sépare les groupes de milliers. Le *chiffres intégraux* élément peut être absent si la chaîne contient le *chiffres fractionnaires* élément.|  
|.|Un symbole décimal spécifique à la culture.|  
|*fractional-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie fractionnaire du nombre.|  
|E|Le « e » ou un caractère « E », ce qui indique que la valeur est représentée dans la notation exponentielle (scientifique).|  
|*exponential-digits*|Une série de chiffres allant de 0 à 9 qui spécifie un exposant.|  
  
 Pour plus d’informations sur les formats numériques, consultez le [mise en forme des Types](~/docs/standard/base-types/formatting-types.md) rubrique.  
  
 Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation dont <xref:System.IFormatProvider.GetFormat%2A> méthode retourne un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations spécifiques à la culture utilisées pour interpréter le format de `s`. En règle générale, il est un <xref:System.Globalization.NumberFormatInfo> ou <xref:System.Globalization.CultureInfo> objet. Si `provider` est `null` ou un <xref:System.Globalization.NumberFormatInfo> ne peut pas être obtenu, les informations de mise en forme pour la culture système actuelle est utilisée.  
  
 En règle générale, si vous passez le <xref:System.Double.Parse%2A?displayProperty=nameWithType> méthode une chaîne qui est créé en appelant le <xref:System.Double.ToString%2A?displayProperty=nameWithType> (méthode), la version d’origine <xref:System.Double> valeur est retournée. Toutefois, en raison d’une perte de précision, les valeurs peut-être pas égales. En outre, une tentative d’analyser la représentation sous forme de chaîne du <xref:System.Double.MinValue> ou <xref:System.Double.MaxValue> lève un <xref:System.OverflowException>, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Si un séparateur est rencontré dans le `s` paramètre pendant une opération d’analyse et la devise ou un nombre décimal et des séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur. Pour plus d’informations sur les séparateurs, consultez <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, et <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L’exemple suivant est le bouton sur le Gestionnaire d’événements d’un formulaire Web. Il utilise le tableau retourné par la <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> propriété afin de déterminer les paramètres régionaux de l’utilisateur. Il instancie ensuite un <xref:System.Globalization.CultureInfo> objet qui correspond à ces paramètres régionaux. Le <xref:System.Globalization.NumberFormatInfo> objet appartient à celle <xref:System.Globalization.CultureInfo> objet est ensuite passé à la <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> d’entrée de méthode pour convertir l’utilisateur à un <xref:System.Double> valeur.  
  
 [!code-csharp[ParseMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> ne représente pas un nombre dans un format valide.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> représente un nombre qui est inférieur à <see cref="F:System.Double.MinValue" /> ou supérieur à <see cref="F:System.Double.MaxValue" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analyse de chaînes numériques dans .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Double" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne contenant un nombre à convertir.</param>
        <param name="style">Combinaison d'opérations de bit des valeurs d'énumération qui indiquent les éléments de style qui peuvent être présents dans <paramref name="s" />. Une valeur typique à spécifier est <see cref="F:System.Globalization.NumberStyles.Float" /> combinée avec <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture sur <paramref name="s" />.</param>
        <summary>Convertit la représentation sous forme de chaîne d'un nombre dans un style et un format propre à la culture spécifiés en nombre à virgule flottante double précision équivalent.</summary>
        <returns>Nombre à virgule flottante double précision équivalant à la valeur numérique ou au symbole spécifié dans <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `style` paramètre définit les éléments de style (tels que des espaces blancs, des milliers séparateurs et les symboles monétaires) qui sont autorisés dans les `s` paramètre pour l’opération d’analyse. Il doit être une combinaison d’indicateurs de bits de le <xref:System.Globalization.NumberStyles> énumération. Ce qui suit <xref:System.Globalization.NumberStyles> membres ne sont pas pris en charge :  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Le `s` paramètre peut contenir <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, ou <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> pour la culture spécifiée par `provider`. Selon la valeur de `style`, il peut également prendre la forme :  
  
 [*ws*] [*$*] [*sign*][*integral-digits*,]*integral-digits*[.[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 Éléments encadrés par des crochets ([et]) sont facultatives. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Une série de caractères d’espace blanc. Espace blanc peut apparaître au début de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> indicateur et il peuvent apparaître à la fin de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> indicateur.|  
|$|Un symbole monétaire spécifique à la culture. Sa position dans la chaîne est définie par le <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> et <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propriétés de la culture actuelle. Symbole de devise de la culture actuelle peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> indicateur.|  
|*sign*|Un symbole négatif (-) ou un signe positif (+) de symboles. Le signe peut apparaître au début de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> indicateur et il peuvent apparaître à la fin de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> indicateur. Parenthèses peuvent être utilisées dans `s` pour indiquer une valeur négative si `style` inclut le <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> indicateur.|  
|*integral-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie entière du nombre. Le *chiffres intégraux* élément peut être absent si la chaîne contient le *chiffres fractionnaires* élément.|  
|,|Un séparateur de groupe spécifique à la culture. Symbole de séparateur de groupe de la culture actuelle peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> indicateur|  
|.|Un symbole décimal spécifique à la culture. Symbole de virgule décimale de la culture actuelle peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> indicateur.|  
|*fractional-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie fractionnaire du nombre. Les chiffres fractionnaires peuvent apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> indicateur.|  
|E|Le « e » ou un caractère « E », ce qui indique que la valeur est représentée dans la notation exponentielle (scientifique). Le `s` paramètre peut représenter un nombre en notation exponentielle si `style` inclut le <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> indicateur.|  
|*exponential-digits*|Une série de chiffres allant de 0 à 9 qui spécifie un exposant.|  
  
> [!NOTE]
> Les caractères (U + 0000) NUL fin `s` sont ignorés par l’opération d’analyse, quelle que soit la valeur de la `style` argument.

 Une chaîne contenant uniquement des chiffres (qui correspond à la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) toujours analysée avec succès. Les autres <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> membres contrôlent des éléments qui peuvent être présents, mais ne sont pas requis pour être présents dans la chaîne d’entrée. Le tableau suivant indique comment chaque <xref:System.Globalization.NumberStyles> indicateurs affectent les éléments qui peuvent être présents dans `s`.  
  
|Valeur NumberStyles|Éléments autorisés dans `s` en plus des chiffres|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Le *chiffres intégraux* élément uniquement.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|La virgule décimale (*.*) et *chiffres fractionnaires* éléments.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Le « e » ou un caractère « E », ce qui indique la notation exponentielle. Cet indicateur en lui-même prend en charge les valeurs sous la forme *chiffres*E*chiffres*; autres indicateurs sont nécessaires pour analyser correctement les chaînes avec des éléments tels que les signes positifs ou négatifs et des symboles de séparateur décimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Le *ws* élément au début de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Le *ws* élément à la fin de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Le *connexion* élément au début de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Le *connexion* élément à la fin de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Le *connexion* élément sous la forme de parenthèses entourant la valeur numérique.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Les milliers élément séparateur (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Élément de devise ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Tous les éléments. Toutefois, `s` ne peut pas représenter un nombre hexadécimal ou un nombre en notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Float>|Le *ws* élément au début ou à la fin de `s`, *connexion* au début de `s`et le symbole de virgule décimale (.). Le `s` paramètre peut également utiliser la notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Number>|Le `ws`, `sign`, des milliers séparateur (,) et les éléments de la virgule décimale (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Tous les éléments. Toutefois, `s` ne peut pas représenter un nombre hexadécimal.|  
  
 Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation dont <xref:System.IFormatProvider.GetFormat%2A> méthode retourne un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations spécifiques à la culture utilisées pour interpréter le format de `s`. En règle générale, il est un <xref:System.Globalization.NumberFormatInfo> ou <xref:System.Globalization.CultureInfo> objet. Si `provider` est `null` ou un <xref:System.Globalization.NumberFormatInfo> ne peut pas être obtenu, les informations de mise en forme pour la culture système actuelle est utilisée.  
  
 En règle générale, si vous passez le <xref:System.Double.Parse%2A?displayProperty=nameWithType> méthode une chaîne qui est créé en appelant le <xref:System.Double.ToString%2A?displayProperty=nameWithType> (méthode), la version d’origine <xref:System.Double> valeur est retournée. Toutefois, en raison d’une perte de précision, les valeurs peut-être pas égales. En outre, une tentative d’analyser la représentation sous forme de chaîne du <xref:System.Double.MinValue> ou <xref:System.Double.MaxValue> lève un <xref:System.OverflowException>, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Si un séparateur est rencontré dans le `s` paramètre pendant une opération d’analyse et la devise ou un nombre décimal et des séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur. Pour plus d’informations sur les séparateurs, consultez <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, et <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> méthode pour attribuer plusieurs représentations sous forme de chaîne de valeurs de température pour un `Temperature` objet.  
  
 [!code-csharp[System.Double.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs#2)]
 [!code-vb[System.Double.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> ne représente pas une valeur numérique.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> n’est pas une valeur <see cref="T:System.Globalization.NumberStyles" />.  
  
ou 
 <paramref name="style" /> est la valeur <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> représente un nombre qui est inférieur à <see cref="F:System.Double.MinValue" /> ou supérieur à <see cref="F:System.Double.MaxValue" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analyse de chaînes numériques dans .NET</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Double  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : double" Usage="System.double.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Représente l'infini positif. Ce champ est constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette constante est le résultat de la division d’un nombre positif par zéro.  
  
 Cette constante est retournée quand le résultat d’une opération est supérieur à <xref:System.Double.MaxValue>.  
  
 Utilisez <xref:System.Double.IsPositiveInfinity%2A> pour déterminer si une valeur correspond à l’infini positif.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de <xref:System.Double.PositiveInfinity>:  
  
 [!code-cpp[System.Double#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#10)]
 [!code-csharp[System.Double#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#10)]
 [!code-vb[System.Double#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns><see langword="true" /> si la valeur de l'instance actuelle est différente de zéro ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Double> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Double> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToByte%28System.Double%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Cette conversion n'est pas prise en charge. Toute tentative d'utilisation de cette méthode lève une <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Cette conversion n'est pas prise en charge. Aucune valeur n'est retournée.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Dans tous les cas.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Cette conversion n'est pas prise en charge. Toute tentative d'utilisation de cette méthode lève une <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Cette conversion n'est pas prise en charge. Aucune valeur n'est retournée.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Dans tous les cas.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Double> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Double> est castée en interface <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Double> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToInt16%28System.Double%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Double> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Double> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToInt64%28System.Double%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Double> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToSByte%28System.Double%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.Single" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Double> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToSingle%28System.Double%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Type dans lequel convertir cette valeur <see cref="T:System.Double" />.</param>
        <param name="provider">Implémentation de <see cref="T:System.IFormatProvider" /> qui fournit des informations propres à la culture sur le format de la valeur retournée.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Double> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le `static` (`Shared` en Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Double> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Double> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Double> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit la valeur numérique de cette instance en sa représentation équivalente sous forme de chaîne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="double.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convertit la valeur numérique de cette instance en sa représentation équivalente sous forme de chaîne.</summary>
        <returns>Représentation sous forme de chaîne de la valeur de cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Double.ToString> méthode formats un <xref:System.Double> valeur dans la valeur par défaut (« G » ou général), format de la culture actuelle. Si vous souhaitez spécifier un autre format, la précision ou la culture, utilisez les autres surcharges de la <xref:System.Double.ToString%2A> méthode, comme suit :  
  
|Pour utiliser le format|Pour la culture|Utilisez la surcharge|  
|-------------------|-----------------|----------------------|  
|Format par défaut (« G »)|Une culture spécifique|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Un format spécifique ou précision|Culture par défaut (actuelle)|<xref:System.Double.ToString%28System.String%29>|  
|Un format spécifique ou précision|Une culture spécifique|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 La valeur de retour peut être <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, ou une chaîne au format :  
  
 [signe] chiffres intégraux [. [chiffres fractionnaires]] [e [signe] chiffres exponentiels]  
  
 Éléments facultatifs sont encadrés par des crochets ([et]). Les éléments qui contiennent le terme « chiffres » se composent d’une série de caractères numériques comprises entre 0 et 9. Les éléments répertoriés dans le tableau suivant sont pris en charge.  
  
|Élément|Description |  
|-------------|-----------------|  
|*sign*|Un signe négatif ou le symbole du signe positif.|  
|*integral-digits*|Une série de chiffres spécifiant la partie entière du nombre. Chiffres intégraux peuvent être absents s’il existe des chiffres fractionnaires.|  
|'*.*'|Un symbole décimal spécifique à la culture.|  
|*fractional-digits*|Une série de chiffres spécifiant la partie fractionnaire du nombre.|  
|'*e*'|Un caractère minuscule « e », indiquant la notation exponentielle (scientifique).|  
|*exponential-digits*|Une série de chiffres spécifiant un exposant.|  
  
 Sont des exemples de la valeur de retour « 100 », «-123 456 789 », « 123.45e + 6 », « 500 », « 3,1416 », « 600 », « -0,123 », et «-Infinity ».  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques de mise en forme suivantes :  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 L’exemple suivant utilise la valeur par défaut <xref:System.Double.ToString?displayProperty=nameWithType> méthode pour afficher les représentations sous forme de chaîne d’un nombre de <xref:System.Double> valeurs.  
  
 [!code-csharp[System.Double.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Double.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#1)]  
  
 L’exemple suivant illustre l’utilisation de <xref:System.Double.ToString%2A>.  
  
 [!code-cpp[System.Double#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="double.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Convertit la valeur numérique de cette instance en sa représentation sous forme de chaîne équivalente à l'aide des informations de format spécifiques à la culture donnée.</summary>
        <returns>Représentation sous forme de chaîne de la valeur de cette instance, comme indiqué par <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Double.ToString%28System.IFormatProvider%29> méthode formats un <xref:System.Double> valeur de format d’une culture spécifiée dans la valeur par défaut (« G » ou général). Si vous souhaitez spécifier un autre format ou la culture, utilisez les autres surcharges de la <xref:System.Double.ToString%2A> méthode, comme suit :  
  
|Pour utiliser le format|Pour la culture|Utilisez la surcharge|  
|-------------------|-----------------|----------------------|  
|Format par défaut (« G »)|Par défaut (actuel)|<xref:System.Double.ToString>|  
|Un format spécifique ou précision|Culture par défaut (actuelle)|<xref:System.Double.ToString%28System.String%29>|  
|Un format spécifique ou précision|Une culture spécifique|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 La valeur de retour peut être <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, ou une chaîne au format :  
  
 [signe] chiffres intégraux [. [chiffres fractionnaires]] [e [signe] chiffres exponentiels]  
  
 Éléments facultatifs sont encadrés par des crochets ([et]). Les éléments qui contiennent le terme « chiffres » se composent d’une série de caractères numériques comprises entre 0 et 9. Les éléments répertoriés dans le tableau suivant sont pris en charge.  
  
|Élément|Description |  
|-------------|-----------------|  
|*sign*|Un signe négatif ou le symbole du signe positif.|  
|*integral-digits*|Une série de chiffres spécifiant la partie entière du nombre. Chiffres intégraux peuvent être absents s’il existe des chiffres fractionnaires.|  
|'*.*'|Un symbole décimal spécifique à la culture.|  
|*fractional-digits*|Une série de chiffres spécifiant la partie fractionnaire du nombre.|  
|'*e*'|Un caractère minuscule « e », indiquant la notation exponentielle (scientifique).|  
|*exponential-digits*|Une série de chiffres spécifiant un exposant.|  
  
 Sont des exemples de la valeur de retour « 100 », «-123 456 789 », « 123.45e + 6 », « 500 », « 3,1416 », « 600 », « -0,123 », et «-Infinity ».  
  
 Cette instance est mise en forme avec le spécificateur de format numérique général (« G »).  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques de mise en forme suivantes :  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
 Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation dont <xref:System.IFormatProvider.GetFormat%2A> méthode retourne un <xref:System.Globalization.NumberFormatInfo> objet. En règle générale, `provider` est un <xref:System.Globalization.CultureInfo> objet ou un <xref:System.Globalization.NumberFormatInfo> objet. Le `provider` paramètre fournit des informations spécifiques à la culture utilisées dans la mise en forme. Si `provider` est `null`, la valeur de retour est mise en forme le <xref:System.Globalization.NumberFormatInfo> objet pour la culture actuelle.  
  
   
  
## Examples  
 L’exemple suivant affiche la représentation sous forme de chaîne de deux <xref:System.Double> des valeurs en utilisant <xref:System.Globalization.CultureInfo> objets qui représentent plusieurs cultures différentes.  
  
 [!code-csharp[System.Double.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#2)]
 [!code-vb[System.Double.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#2)]  
  
 L’exemple suivant illustre l’utilisation de <xref:System.Double.ToString%2A>, avec un <xref:System.String> et un <xref:System.IFormatProvider> en tant que paramètres.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="double.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format numérique.</param>
        <summary>Convertit la valeur numérique de cette instance en sa représentation sous forme de chaîne équivalente en utilisant le format spécifié.</summary>
        <returns>Représentation sous forme de chaîne de la valeur de cette instance, comme indiqué par <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Double.ToString%28System.String%29> méthode formats un <xref:System.Double> valeur dans un format spécifié en utilisant les conventions de la culture actuelle. Si vous souhaitez spécifier un autre format ou la culture, utilisez les autres surcharges de la <xref:System.Double.ToString%2A> méthode, comme suit :  
  
|Pour utiliser le format|Pour la culture|Utilisez la surcharge|  
|-------------------|-----------------|----------------------|  
|Format par défaut (« G »)|Culture par défaut (actuelle)|<xref:System.Double.ToString>|  
|Format par défaut (« G »)|Une culture spécifique|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Un format spécifique ou précision|Une culture spécifique|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 La valeur de retour peut être <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, ou la représentation sous forme de chaîne d’un nombre, tel que spécifié par `format`.  
  
 Le `format` paramètre peut être n’importe quel spécificateur de format numérique standard valide à l’exception de D et X, ainsi que n’importe quelle combinaison de spécificateurs de format numériques personnalisés. Si `format` est `null` ou une chaîne vide, la valeur de retour est mis en forme avec le spécificateur de format numérique général (« G »).  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques de mise en forme suivantes :  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
 Par défaut, la valeur de retour contient uniquement 15 chiffres de précision bien qu’un maximum de 17 chiffres soit maintenu en interne. Si la valeur de cette instance est supérieure à 15 chiffres, <xref:System.Double.ToString%2A> retourne <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> ou <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> au lieu du nombre attendu. Si vous avez besoin de plus de précision, spécifiez `format` avec la spécification de format « G17 », qui retourne toujours 17 chiffres de précision, ou « R », qui retourne 15 chiffres si le nombre peut être représenté avec cette précision ou 17 chiffres si le nombre peut être uniquement représentés avec précision maximale.  
  
   
  
## Examples  
 L’exemple suivant définit une valeur numérique et formats en tant que valeur monétaire en utilisant la chaîne de format numérique standard « C » et en tant que valeur numérique à trois décimales en utilisant la chaîne de format numérique standard « N ». Les chaînes de résultat sont mis en forme en utilisant les conventions de la culture en-US. Pour plus d’informations sur les chaînes de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Double.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 L’exemple suivant affiche plusieurs <xref:System.Double> des valeurs en utilisant les spécificateurs de format numérique standard pris en charge avec trois chaînes de format numériques personnalisées. Une de ces chaînes de format personnalisées illustre comment remplir un <xref:System.Single> valeur avec des zéros non significatifs. En outre, l’exemple utilise le spécificateur de précision avec chaque spécificateur de format standard à l’exception de « R ». Les valeurs de la plage de spécificateurs de précision de 0 à 3. Pour convertir les valeurs numériques en chaînes, l’exemple utilise les conventions de mise en forme de la culture en-US.  
  
 [!code-cpp[System.Double.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> n'est pas valide.</exception>
        <block subset="none" type="usage"><para>Dans certains cas, les valeurs <see cref="T:System.Double" /> mises en forme avec la chaîne de format numérique standard "R" ne font pas un aller-retour correct si elles sont compilées avec les commutateurs <see langword="/platform:x64" /> ou <see langword="/platform:anycpu" />, et exécutées sur des systèmes 64 bits. Pour contourner ce problème, vous pouvez mettre en forme les valeurs <see cref="T:System.Double" /> en utilisant la chaîne de format numérique standard "G17". L'exemple suivant utilise la chaîne de format "R" avec une valeur <see cref="T:System.Double" /> qui ne fait pas un aller-retour correct, et il utilise également la chaîne de format "G17" pour effectuer un aller-retour correct avec la valeur d'origine.  
  
[!code-csharp[System.Double.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex2.cs#6)] [!code-vb[System.Double.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex2.vb#6)]</para></block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Chaînes de format numériques standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Chaînes de format numériques personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Comment : remplir un nombre avec des zéros non significatifs</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="double.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format numérique.</param>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Convertit la valeur numérique de cette instance en sa représentation sous forme de chaîne équivalente à l'aide du format spécifié et des informations de format spécifiques à la culture.</summary>
        <returns>Représentation sous forme de chaîne de la valeur de cette instance, telle que spécifiée par <paramref name="format" /> et <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> méthode formats un <xref:System.Double> valeur dans un format spécifié d’une culture spécifiée. Si vous souhaitez spécifier un autre format ou la culture, utilisez les autres surcharges de la <xref:System.Double.ToString%2A> méthode, comme suit :  
  
|Pour utiliser le format|Pour la culture|Utilisez la surcharge|  
|-------------------|-----------------|----------------------|  
|Format par défaut (« G »)|Culture par défaut (actuelle)|<xref:System.Double.ToString>|  
|Format par défaut (« G »)|Une culture spécifique|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Un format spécifique ou précision|Culture par défaut (actuelle)|<xref:System.Double.ToString%28System.String%29>|  
  
 La valeur de retour peut être <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, ou la représentation sous forme de chaîne d’un nombre, tel que spécifié par `format`.  
  
 Le `format` paramètre peut être n’importe quel spécificateur de format numérique standard valide à l’exception de D et X, ainsi que n’importe quelle combinaison de spécificateurs de format numériques personnalisés. Si `format` est `null` ou une chaîne vide, la valeur de retour pour cette instance est formatée avec le spécificateur de format numérique général (« G »).  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques de mise en forme suivantes :  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
 Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation dont <xref:System.IFormatProvider.GetFormat%2A> méthode retourne un <xref:System.Globalization.NumberFormatInfo> objet. En règle générale, `provider` est un <xref:System.Globalization.CultureInfo> objet ou un <xref:System.Globalization.NumberFormatInfo> objet. Le `provider` paramètre fournit des informations spécifiques à la culture utilisées dans la mise en forme. Si `provider` est `null`, la valeur de retour est mise en forme le <xref:System.Globalization.NumberFormatInfo> objet pour la culture actuelle.  
  
 Par défaut, la valeur de retour contient uniquement 15 chiffres de précision bien qu’un maximum de 17 chiffres soit maintenu en interne. Si la valeur de cette instance est supérieure à 15 chiffres, <xref:System.Double.ToString%2A> retourne <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> ou <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> au lieu du nombre attendu. Si vous avez besoin de plus de précision, spécifiez `format` avec la spécification de format « G17 », qui retourne toujours 17 chiffres de précision, ou « R », qui retourne 15 chiffres si le nombre peut être représenté avec cette précision ou 17 chiffres si le nombre peut être uniquement représentés avec précision maximale.  
  
   
  
## Examples  
 L’exemple suivant affiche un <xref:System.Double> valeur à l’aide de chacun des spécificateurs de format numérique standard pris en charge pour plusieurs cultures différentes.  
  
 [!code-cpp[System.Double.ToString#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp#4)]
 [!code-csharp[System.Double.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Double.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#4)]  
  
 L’exemple suivant illustre l’utilisation de <xref:System.Double.ToString%2A>, avec un <xref:System.String> et un <xref:System.IFormatProvider> en tant que paramètres.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Dans certains cas, les valeurs <see cref="T:System.Double" /> mises en forme avec la chaîne de format numérique standard "R" ne font pas un aller-retour correct si elles sont compilées avec les commutateurs <see langword="/platform:x64" /> ou <see langword="/platform:anycpu" />, et exécutées sur des systèmes 64 bits. Pour contourner ce problème, vous pouvez mettre en forme les valeurs <see cref="T:System.Double" /> en utilisant la chaîne de format numérique standard "G17". L'exemple suivant utilise la chaîne de format "R" avec une valeur <see cref="T:System.Double" /> qui ne fait pas un aller-retour correct, et il utilise également la chaîne de format "G17" pour effectuer un aller-retour correct avec la valeur d'origine.  
  
[!code-csharp[System.Double.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex1.cs#5)] [!code-vb[System.Double.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex1.vb#5)]</para></block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Chaînes de format numériques standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Chaînes de format numériques personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Comment : remplir un nombre avec des zéros non significatifs</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">Exemple : utilitaire de mise en forme .NET Framework 4</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="double.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit la représentation sous forme de chaîne d'un nombre en nombre à virgule flottante double précision équivalent. Une valeur de retour indique si la conversion a réussi ou a échoué.</summary>
        <altmember cref="Overload:System.Double.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne contenant un nombre à convertir.</param>
        <param name="result">Quand cette méthode est retournée, contient le nombre à virgule flottante double précision équivalent au paramètre <paramref name="s" /> si la conversion a réussi, ou zéro si elle a échoué. La conversion échoue si le paramètre <paramref name="s" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />, n'est pas un nombre dans un format valide ou représente un nombre inférieur à <see cref="F:System.Double.MinValue" /> ou supérieur à <see cref="F:System.Double.MaxValue" />. Ce paramètre est passé non initialisé ; toute valeur fournie initialement dans <paramref name="result" /> sera remplacée.</param>
        <summary>Convertit la représentation sous forme de chaîne d'un nombre en nombre à virgule flottante double précision équivalent. Une valeur de retour indique si la conversion a réussi ou a échoué.</summary>
        <returns><see langword="true" /> si la conversion de <paramref name="s" /> est réussie ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge diffère la <xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType> méthode en retournant une valeur booléenne qui indique si l’opération d’analyse a réussi au lieu de retourner la valeur numérique analysée. Il élimine la nécessité d’utiliser la gestion des exceptions pour tester un <xref:System.FormatException> dans le cas où `s` n’est pas valide et ne peut pas être analysée avec succès.  
  
 Le `s` paramètre peut contenir de la culture actuelle <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> (la comparaison de chaînes respecte la casse), ou une chaîne au format :  
  
 [ws] [connexion] [chiffres intégraux,] chiffres intégraux [. [chiffres fractionnaires]] [e [signe] chiffres exponentiels] [ws]  
  
 Les éléments entre crochets sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Une série de caractères d’espace blanc.|  
|*sign*|Un signe négatif ou le symbole du signe positif.|  
|*integral-digits*|Une série de caractères numériques comprises entre 0 et 9 qui spécifie la partie entière du nombre. Chiffres intégraux peuvent être absents s’il existe des chiffres fractionnaires.|  
|*,*|Un symbole de séparateur de groupe spécifique à la culture.|  
|*.*|Un symbole décimal spécifique à la culture.|  
|*fractional-digits*|Une série de caractères numériques comprises entre 0 et 9 qui spécifie la partie fractionnaire du nombre.|  
|*E*|Un majuscule ou minuscule caractère « e », qui indique la notation exponentielle (scientifique).|  
|*exponential-digits*|Une série de caractères numériques comprises entre 0 et 9 qui spécifie un exposant.|  
  
 Pour plus d’informations sur les formats numériques, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
 Le `s` paramètre est interprété en utilisant une combinaison de la <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> et <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> indicateurs. Cela signifie que les espaces blancs et des milliers les séparateurs sont autorisés, mais les symboles monétaires ne sont pas. Pour définir explicitement les éléments (tels que les symboles monétaires, des milliers, séparateurs et l’espace blanc) qui peuvent être présents dans `s`, utiliser le <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> surcharge de méthode.  
  
 Le `s` paramètre est analysé en utilisant les informations de mise en forme dans un <xref:System.Globalization.NumberFormatInfo> objet initialisé pour la culture système actuelle. Pour plus d'informations, consultez <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Pour analyser une chaîne en utilisant les informations de mise en forme d’une autre culture spécifiée, utilisez la <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> surcharge de méthode.  
  
 En règle générale, si vous passez le <xref:System.Double.TryParse%2A?displayProperty=nameWithType> méthode une chaîne qui est créé en appelant le <xref:System.Double.ToString%2A?displayProperty=nameWithType> (méthode), la version d’origine <xref:System.Double> valeur est retournée. Toutefois, en raison d’une perte de précision, les valeurs peut-être pas égales. En outre, une tentative d’analyser la représentation sous forme de chaîne du <xref:System.Double.MinValue> ou <xref:System.Double.MaxValue> lève un <xref:System.OverflowException>, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Si un séparateur est rencontré dans le `s` paramètre pendant une opération d’analyse et les séparateurs décimaux et de groupe sont les mêmes, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un séparateur de groupes. Pour plus d’informations sur les séparateurs, consultez <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, et <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> méthode pour convertir les représentations sous forme de chaîne de valeurs numériques à <xref:System.Double> valeurs. Il suppose qu’en-US est la culture actuelle.  
  
 [!code-csharp[System.Double.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs#1)]
 [!code-vb[System.Double.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analyse de chaînes numériques dans .NET</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">Exemple : utilitaire de mise en forme .NET Framework 4</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne contenant un nombre à convertir.</param>
        <param name="style">Combinaison d'opérations au niveau du bit de valeurs <see cref="T:System.Globalization.NumberStyles" /> indiquant le format autorisé de <paramref name="s" />. Une valeur typique à spécifier est <see cref="F:System.Globalization.NumberStyles.Float" /> combinée avec <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider"><see cref="T:System.IFormatProvider" /> qui fournit des informations de format propres à la culture concernant <paramref name="s" />.</param>
        <param name="result">Quand cette méthode est retournée, contient un nombre à virgule flottante double précision équivalent à la valeur numérique ou au symbole contenu dans <paramref name="s" /> si la conversion a réussi, ou zéro si elle a échoué. La conversion échoue si le paramètre <paramref name="s" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />, n'est pas dans un format conforme à <paramref name="style" />, représente un nombre inférieur à <see cref="F:System.SByte.MinValue" /> ou supérieur à <see cref="F:System.SByte.MaxValue" />, ou encore si <paramref name="style" /> n'est pas une combinaison valide de constantes énumérées <see cref="T:System.Globalization.NumberStyles" />. Ce paramètre est passé non initialisé ; toute valeur fournie initialement dans <paramref name="result" /> sera remplacée.</param>
        <summary>Convertit la représentation sous forme de chaîne d'un nombre dans un style et un format propre à la culture spécifiés en nombre à virgule flottante double précision équivalent. Une valeur de retour indique si la conversion a réussi ou a échoué.</summary>
        <returns><see langword="true" /> si la conversion de <paramref name="s" /> est réussie ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Double.TryParse%2A> méthode est comparable à la <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> (méthode), mais cette méthode ne lève pas d’exception si la conversion échoue. Si la conversion réussit, la valeur de retour est `true` et `result` paramètre est défini sur le résultat de la conversion. Si la conversion échoue, la valeur de retour est `false` et `result` paramètre est défini sur zéro. Cela élimine la nécessité d’utiliser la gestion des exceptions pour tester un <xref:System.FormatException> dans le cas où `s` n’est pas valide et ne peut pas être analysée avec succès.  
  
 Le `style` paramètre définit le format autorisé de le `s` paramètre pour l’opération d’analyse. Il doit être une combinaison d’indicateurs de bits de le <xref:System.Globalization.NumberStyles> énumération. Ce qui suit <xref:System.Globalization.NumberStyles> membres ne sont pas pris en charge :  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 Le `s` paramètre peut contenir <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, ou <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> pour la culture indiquée par `provider`. En outre, selon la valeur de `style`, le `s` paramètre peut inclure les éléments suivants :  
  
 [ws] [$] [connexion] [chiffres intégraux,] chiffres intégraux [.chiffres fractionnaires] [e [signe] chiffres exponentiels] [ws]  
  
 Les éléments entre crochets ([ et ]) sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Espace blanc facultatif. Espace blanc peut apparaître au début de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> indicateur. Elle peut apparaître à la fin de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> indicateur.|  
|*$*|Un symbole monétaire spécifique à la culture. Sa position dans la chaîne est définie par le <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> ou <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propriétés de la <xref:System.Globalization.NumberFormatInfo> objet retourné par la <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> méthode de le `provider` paramètre. Le symbole monétaire peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> indicateur.|  
|*sign*|Un signe facultatif. Le signe peut apparaître au début de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> indicateur et il peuvent apparaître à la fin de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> indicateur. Parenthèses peuvent être utilisées dans `s` pour indiquer une valeur négative si `style` inclut le <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> indicateur.|  
|*integral-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie entière du nombre. Chiffres intégraux peuvent être absents s’il existe des chiffres fractionnaires.|  
|*,*|Des milliers spécifiques à la culture des symboles de séparateur. Plusieurs milliers de la culture actuelle symbole séparateur peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> indicateur.|  
|*.*|Un symbole décimal spécifique à la culture. Symbole de virgule décimale de la culture actuelle peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> indicateur.|  
|*fractional-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie fractionnaire du nombre. Les chiffres fractionnaires peuvent apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> indicateur.|  
|*e*|Le caractère e ou E, qui indique que `s` peut représenter un nombre en notation exponentielle. Le `s` paramètre peut représenter un nombre en notation exponentielle si le style inclut le <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> indicateur.|  
|*exponential-digits*|Une série de chiffres allant de 0 à 9 qui spécifie un exposant.|  
  
> [!NOTE]
> Les caractères (U + 0000) NUL fin `s` sont ignorés par l’opération d’analyse, quelle que soit la valeur de la `style` argument.

 Une chaîne contenant uniquement des chiffres (qui correspond à la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) toujours analysée avec succès. Les autres <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> membres contrôlent des éléments qui peuvent être, mais ne doivent pas être présents dans la chaîne d’entrée. Le tableau suivant indique comment chaque <xref:System.Globalization.NumberStyles> indicateurs affectent les éléments qui peuvent être présents dans `s`.  
  
|Valeur NumberStyles|Éléments autorisés dans s en plus des chiffres|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Le *chiffres intégraux* élément uniquement.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|L’élément de langage *.* et *chiffres fractionnaires* éléments.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Le `s` paramètre peut également utiliser la notation exponentielle. Cet indicateur en lui-même prend en charge les valeurs sous la forme *chiffres intégraux*E*chiffres exponentiels*; autres indicateurs sont nécessaires pour analyser correctement les chaînes en notation exponentielle avec des éléments tels que signes positifs ou négatifs et des symboles de séparateur décimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Le *ws* élément au début de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Le *ws* élément à la fin de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Le *connexion* élément au début de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Le *connexion* élément à la fin de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Le *connexion* élément sous la forme de parenthèses entourant la valeur numérique.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Le *,* élément.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Le *$* élément.|  
|<xref:System.Globalization.NumberStyles.Currency>|Tout le monde. Le `s` paramètre ne peut pas représenter un nombre hexadécimal ou un nombre en notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Float>|Le *ws* élément au début ou à la fin de `s`, *connexion* au début de `s`et le *.* symbole. Le `s` paramètre peut également utiliser la notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Number>|Le `ws`, `sign`, des milliers séparateur (*,),* et séparateur décimal (*.*) éléments.|  
|<xref:System.Globalization.NumberStyles.Any>|Tous les styles, à l’exception `s` ne peut pas représenter un nombre hexadécimal.|  
  
 Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation, comme un <xref:System.Globalization.NumberFormatInfo> ou <xref:System.Globalization.CultureInfo> objet. Le `provider` paramètre fournit des informations spécifiques à la culture utilisées dans l’analyse. Si `provider` est `null` ou un <xref:System.Globalization.NumberFormatInfo> objet ne peut pas être obtenu, les informations de format pour la culture actuelle sont utilisées.  
  
 La conversion échoue si le `s` paramètre est `null` ou non une valeur numérique, la `provider` ne génère pas de paramètre un <xref:System.Globalization.NumberFormatInfo> objet, ou le `style` paramètre n’est pas une combinaison d’indicateurs de bits de le <xref:System.Globalization.NumberStyles> énumération.  
  
 En règle générale, si vous passez le <xref:System.Double.TryParse%2A?displayProperty=nameWithType> méthode une chaîne qui est créé en appelant le <xref:System.Double.ToString%2A?displayProperty=nameWithType> (méthode), la version d’origine <xref:System.Double> valeur est retournée. Toutefois, en raison d’une perte de précision, les valeurs peut-être pas égales. En outre, une tentative d’analyser la représentation sous forme de chaîne du <xref:System.Double.MinValue> ou <xref:System.Double.MaxValue> lève un <xref:System.OverflowException>, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Si un séparateur est rencontré dans le `s` paramètre pendant une opération d’analyse et la devise ou un nombre décimal et des séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur. Pour plus d’informations sur les séparateurs, consultez <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, et <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> méthode pour analyser la représentation sous forme de chaîne de nombres qui ont un style particulier et sont formatés en utilisant les conventions d’une culture particulière.  
  
 [!code-csharp[System.Double.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Double.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> n’est pas une valeur <see cref="T:System.Globalization.NumberStyles" />.  
  
ou 
 <paramref name="style" /> inclut la valeur <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analyse de chaînes numériques dans .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>