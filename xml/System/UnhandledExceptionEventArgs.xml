<Type Name="UnhandledExceptionEventArgs" FullName="System.UnhandledExceptionEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9811531194d62fd50310ad6baf15b7e5d3024df0" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37727020" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UnhandledExceptionEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnhandledExceptionEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.UnhandledExceptionEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class UnhandledExceptionEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnhandledExceptionEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type UnhandledExceptionEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit des données pour l'événement déclenché en cas d'exception non gérée dans un domaine d'application.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UnhandledExceptionEventArgs> fournit l’accès à l’objet exception et un indicateur indiquant si le common language runtime se termine. Le <xref:System.UnhandledExceptionEventArgs> est un des paramètres passés à <xref:System.UnhandledExceptionEventHandler> pour le <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> événement.  
  
 Pour plus d’informations sur les délégués de gestionnaire d’événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="E:System.AppDomain.UnhandledException" />
    <altmember cref="T:System.UnhandledExceptionEventHandler" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnhandledExceptionEventArgs (object exception, bool isTerminating);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object exception, bool isTerminating) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UnhandledExceptionEventArgs.#ctor(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (exception As Object, isTerminating As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnhandledExceptionEventArgs(System::Object ^ exception, bool isTerminating);" />
      <MemberSignature Language="F#" Value="new UnhandledExceptionEventArgs : obj * bool -&gt; UnhandledExceptionEventArgs" Usage="new System.UnhandledExceptionEventArgs (exception, isTerminating)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="exception" Type="System.Object" />
        <Parameter Name="isTerminating" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="exception">Exception non gérée.</param>
        <param name="isTerminating">
          <see langword="true" /> si le runtime se termine ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.UnhandledExceptionEventArgs" /> avec l'objet exception et un indicateur de fin Common Language Runtime.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptionObject">
      <MemberSignature Language="C#" Value="public object ExceptionObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ExceptionObject" />
      <MemberSignature Language="DocId" Value="P:System.UnhandledExceptionEventArgs.ExceptionObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExceptionObject As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ExceptionObject { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExceptionObject : obj" Usage="System.UnhandledExceptionEventArgs.ExceptionObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet exception non géré.</summary>
        <value>Objet exception non géré.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne un objet de type <xref:System.Object> au lieu d’un dérivé <xref:System.Exception>. Bien que le Common Language Specification nécessite que tous les types d’exceptions dérivent de <xref:System.Exception>, il est possible pour les méthodes de lever des exceptions avec des objets non dérivés de <xref:System.Exception>. Vous pouvez effectuer les opérations suivantes pour travailler avec cette exception :  
  
-   Appliquer le <xref:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute> attribut avec un <xref:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute.WrapNonExceptionThrows%2A?displayProperty=nameWithType> valeur `true` à l’assembly qui contient le Gestionnaire d’événements. Cela inclut toutes les exceptions non dérivées de la <xref:System.Exception> classe dans un <xref:System.Runtime.CompilerServices.RuntimeWrappedException> objet. Vous pouvez sans risque un cast (en c#) ou convertir (en Visual Basic), l’objet retourné par cette propriété pour un <xref:System.Exception> de l’objet et récupérer l’objet exception d’origine à partir de la <xref:System.Runtime.CompilerServices.RuntimeWrappedException.WrappedException%2A?displayProperty=nameWithType> propriété. Notez que certains compilateurs, tels que les compilateurs c# et Visual Basic, appliquent automatiquement cet attribut.  
  
-   Effectuer un cast de l’objet retourné par cette propriété pour un <xref:System.Exception> objet.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.AppDomain.UnhandledException> événement. Il définit un gestionnaire d’événements, `MyHandler`, qui est appelé chaque fois qu’une exception non gérée est levée dans le domaine d’application par défaut. Ensuite, elle génère deux exceptions. La première est gérée par un **try/catch** bloc. La seconde n’est pas gérée et appelle le `MyHandle` routine avant que l’application se termine.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute" />
        <altmember cref="T:System.Runtime.CompilerServices.RuntimeWrappedException" />
      </Docs>
    </Member>
    <Member MemberName="IsTerminating">
      <MemberSignature Language="C#" Value="public bool IsTerminating { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTerminating" />
      <MemberSignature Language="DocId" Value="P:System.UnhandledExceptionEventArgs.IsTerminating" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTerminating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTerminating { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTerminating : bool" Usage="System.UnhandledExceptionEventArgs.IsTerminating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si le Common Language Runtime se termine.</summary>
        <value>
          <see langword="true" /> si le runtime se termine ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À compter de .NET Framework version 2.0, cette propriété retourne `true` pour la plupart des exceptions non gérées, sauf si un indicateur de compatibilité d’application est utilisé pour rétablir le comportement des versions 1.0 et 1.1. La raison est que plus les exceptions non gérées dans les threads, y compris les threads du pool, sont autorisées à poursuivre naturellement, ce qui entraîne généralement l’arrêt de l’application. Pour plus d’informations, notamment une liste de cas dans lequel le runtime ne se termine pas, consultez [Exceptions dans les Threads managés](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
## <a name="version-information"></a>Informations sur la version  
 Ce qui suit s’applique pour les versions 1.0 et 1.1 du .NET Framework : cette propriété retourne `true` quand une exception est reçue dans, mais pas gérée par un thread d’application principal. Cette propriété retourne également `true` si un thread non managé exécute le code managé et reçoit une exception non gérée. Enfin, cette propriété retourne `false` pour les threads du pool et les threads managés créés par une application, car les versions 1.0 et 1.1 interceptent des exceptions non gérées dans de tels threads et les ignorent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>