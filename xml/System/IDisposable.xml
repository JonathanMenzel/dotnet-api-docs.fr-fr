<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="IDisposable.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac50f129b9e6cc6b4ce4a818f23df9a72208cdccc21.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0f129b9e6cc6b4ce4a818f23df9a72208cdccc21</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IDisposable">
          <source>Provides a mechanism for releasing unmanaged resources.</source>
          <target state="translated">Fournit un mécanisme pour libérer des ressources non gérées.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>The primary use of this interface is to release unmanaged resources.</source>
          <target state="translated">La principale utilisation de cette interface est de libérer les ressources non managées.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>The garbage collector automatically releases the memory allocated to a managed object when that object is no longer used.</source>
          <target state="translated">Le garbage collector libère automatiquement la mémoire allouée à un objet managé lorsque cet objet n’est plus utilisé.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>However, it is not possible to predict when garbage collection will occur.</source>
          <target state="translated">Toutefois, il n’est pas possible de prédire quand le garbage collection se produit.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>Furthermore, the garbage collector has no knowledge of unmanaged resources such as window handles, or open files and streams.</source>
          <target state="translated">En outre, le garbage collector n’a aucune connaissance des ressources non managées, telles que les handles de fenêtre, ou ouvrir des fichiers et des flux de données.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>Use the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method of this interface to explicitly release unmanaged resources in conjunction with the garbage collector.</source>
          <target state="translated">Utilisez la <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> méthode de cette interface pour libérer explicitement les ressources non managées en association avec le garbage collector.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>The consumer of an object can call this method when the object is no longer needed.</source>
          <target state="translated">Le consommateur d’un objet peut appeler cette méthode lorsque l’objet n’est plus nécessaire.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>It is a breaking change to add the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface to an existing class.</source>
          <target state="translated">Il s’agit d’une modification avec rupture pour ajouter le <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface à une classe existante.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>Because pre-existing consumers of your type cannot call <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>, you cannot be certain that unmanaged resources held by your type will be released.</source>
          <target state="translated">Étant donné que les consommateurs existants de votre type ne peut pas appeler <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>, vous n’êtes pas certain que les ressources non managées détenues par votre type seront libérés.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>Because the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation is called by the consumer of a type when the resources owned by an instance are no longer needed, you should either wrap the managed object in a <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> (the recommended alternative), or you should override <ph id="ph3">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> to free unmanaged resources in the event that the consumer forgets to call <ph id="ph4">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>.</source>
          <target state="translated">Étant donné que la <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implémentation est appelée par le consommateur d’un type lorsque les ressources détenues par une instance ne sont plus nécessaires, vous devez encapsuler soit l’objet managé dans un <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> (l’alternative recommandée), ou vous devez substituer <ph id="ph3">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>pour libérer les ressources non managées dans le cas où le consommateur oublie d’appeler <ph id="ph4">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>In the .NET Framework, the C++ compiler supports deterministic disposal of resources and does not allow direct implementation of the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">Dans le .NET Framework, le compilateur C++ prend en charge la suppression déterministe de ressources et n’autorise pas l’implémentation directe de la <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>For a detailed discussion about how this interface and the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method are used, see the <bpt id="p1">[</bpt>Garbage Collection<ept id="p1">](http://msdn.microsoft.com/library/22b6cb97-0c80-4eeb-a2cf-5ed7655e37f9)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept> topics.</source>
          <target state="translated">Pour plus d’informations sur la façon de cette interface et la <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> méthode sont utilisées, consultez la <bpt id="p1">[</bpt>Garbage Collection<ept id="p1">](http://msdn.microsoft.com/library/22b6cb97-0c80-4eeb-a2cf-5ed7655e37f9)</ept> et <bpt id="p2">[</bpt>implémentant une méthode de suppression<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept> rubriques.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>Using an object that implements IDisposable</source>
          <target state="translated">À l’aide d’un objet qui implémente IDisposable</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>If your app simply uses an object that implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface, you should call the object's <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation when you are finished using it.</source>
          <target state="translated">Si votre application utilise simplement un objet qui implémente le <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface, vous devez appeler l’objet <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implémentation lorsque vous avez fini de l’utiliser.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>Depending on your programming language, you can do this in one of two ways:</source>
          <target state="translated">Selon votre langage de programmation, vous pouvez faire de deux manières :</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>By using a language construct such as the <ph id="ph1">`using`</ph> statement in C# and Visual Basic.</source>
          <target state="translated">En utilisant un langage de construction tels que le <ph id="ph1">`using`</ph> instruction en c# et Visual Basic.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>By wrapping the call to the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`finally`</ph> block.</source>
          <target state="translated">En encapsulant l’appel à la <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> mise en œuvre dans un <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`finally`</ph> bloc.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>Documentation for types that implement <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> note that fact and include a reminder to call its <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implementation.</source>
          <target state="translated">Documentation pour les types qui implémentent <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> Notez que les et inclure un rappel à appeler son <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implémentation.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>The C# and Visual Basic Using statement</source>
          <target state="translated">L’instruction c# et Visual Basic à l’aide</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>If your language supports a construct such as the <bpt id="p1">[</bpt>using<ept id="p1">](~/docs/csharp/language-reference/keywords/using.md)</ept> statement in C# and the <bpt id="p2">[</bpt>Using<ept id="p2">](~/docs/visual-basic/language-reference/statements/using-statement.md)</ept> statement in Visual Basic, you can use it instead of explicitly calling <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> yourself.</source>
          <target state="translated">Si votre langage prend en charge une construction tels que le <bpt id="p1">[</bpt>à l’aide de<ept id="p1">](~/docs/csharp/language-reference/keywords/using.md)</ept> instruction en c# et la <bpt id="p2">[</bpt>Using<ept id="p2">](~/docs/visual-basic/language-reference/statements/using-statement.md)</ept> instruction en Visual Basic, vous pouvez l’utiliser au lieu d’appeler explicitement <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> vous-même.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>The following example uses this approach in defining a <ph id="ph1">`WordCount`</ph> class that preserves information about a file and the number of words in it.</source>
          <target state="translated">L’exemple suivant utilise cette approche dans la définition d’un <ph id="ph1">`WordCount`</ph> classe qui conserve les informations sur un fichier et le nombre de mots qu’il contient.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>The <ph id="ph1">`using`</ph> statement is actually a syntactic convenience.</source>
          <target state="translated">La <ph id="ph1">`using`</ph> instruction est réellement une commodité syntaxique.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>At compile time, the language compiler implements the intermediate language (IL) for a <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`finally`</ph> block.</source>
          <target state="translated">Au moment de la compilation, le compilateur de langage implémente le langage intermédiaire (IL) pour un <ph id="ph1">`try`</ph> <ph id="ph2">/</ph> <ph id="ph3">`finally`</ph> bloc.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>For more information about the <ph id="ph1">`using`</ph> statement, see the <bpt id="p1">[</bpt>Using Statement<ept id="p1">](~/docs/visual-basic/language-reference/statements/using-statement.md)</ept> or <bpt id="p2">[</bpt>using Statement<ept id="p2">](~/docs/csharp/language-reference/keywords/using-statement.md)</ept> topics.</source>
          <target state="translated">Pour plus d’informations sur la <ph id="ph1">`using`</ph> instruction, consultez la <bpt id="p1">[</bpt>à l’aide de l’instruction<ept id="p1">](~/docs/visual-basic/language-reference/statements/using-statement.md)</ept> ou <bpt id="p2">[</bpt>à l’aide d’instruction<ept id="p2">](~/docs/csharp/language-reference/keywords/using-statement.md)</ept> rubriques.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>The Try/Finally block</source>
          <target state="translated">Le bloc Try/Finally</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>If your programming language does not support a construct like the <ph id="ph1">`using`</ph> statement in C# or Visual Basic, or if you prefer not to use it, you can call the <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation from the <ph id="ph3">`finally`</ph> block of a <ph id="ph4">`try`</ph><ph id="ph5">/</ph><ph id="ph6">`finally`</ph> statement.</source>
          <target state="translated">Si votre langage de programmation ne prend pas en charge une construction comme le <ph id="ph1">`using`</ph> instruction en c# ou Visual Basic, ou si vous préférez ne pas l’utiliser, vous pouvez appeler la <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implémentation à partir de la <ph id="ph3">`finally`</ph> bloquer d’un <ph id="ph4">`try`</ph> <ph id="ph5">/</ph> <ph id="ph6">`finally`</ph> instruction.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>The following example replaces the <ph id="ph1">`using`</ph> block in the previous example with a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`finally`</ph> block.</source>
          <target state="translated">L’exemple suivant remplace le <ph id="ph1">`using`</ph> bloquer dans l’exemple précédent, avec un <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`finally`</ph> bloc.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>For more information about the <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`finally`</ph> pattern, see <bpt id="p1">[</bpt>Try...Catch...Finally Statement<ept id="p1">](~/docs/visual-basic/language-reference/statements/try-catch-finally-statement.md)</ept>, <bpt id="p2">[</bpt>try-finally<ept id="p2">](~/docs/csharp/language-reference/keywords/try-finally.md)</ept>, or <bpt id="p3">[</bpt>try-finally Statement<ept id="p3">](http://msdn.microsoft.com/library/514400c1-c322-4bf3-9e48-3047240b8a82)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la <ph id="ph1">`try`</ph> <ph id="ph2">/</ph> <ph id="ph3">`finally`</ph> de modèle, consultez <bpt id="p1">[</bpt>essayez... Catch... Instruction finally<ept id="p1">](~/docs/visual-basic/language-reference/statements/try-catch-finally-statement.md)</ept>, <bpt id="p2">[</bpt>try-finally<ept id="p2">](~/docs/csharp/language-reference/keywords/try-finally.md)</ept>, ou <bpt id="p3">[</bpt>try-finally, instruction<ept id="p3">](http://msdn.microsoft.com/library/514400c1-c322-4bf3-9e48-3047240b8a82)</ept>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>Implementing IDisposable</source>
          <target state="translated">Implémentation de IDisposable</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>You should implement <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> only if your type uses unmanaged resources directly.</source>
          <target state="translated">Vous devez implémenter <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> uniquement si votre type utilise directement les ressources non managées.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>The consumers of your type can call your <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation to free resources when the instance is no longer needed.</source>
          <target state="translated">Les consommateurs de votre type peuvent appeler votre <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implémentation de libérer des ressources lors de l’instance n’est plus nécessaire.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>To handle cases in which they fail to call <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>, you should either use a class derived from <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> to wrap the unmanaged resources, or you should override the <ph id="ph3">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method for a reference type.</source>
          <target state="translated">Pour gérer les cas dans lesquels ils échouent à appeler <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>, vous devez utiliser une classe dérivée de <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> pour encapsuler les ressources non managées, ou vous devez substituer la <ph id="ph3">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> méthode pour un type référence.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>In either case, you use the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method to perform whatever cleanup is necessary after using the unmanaged resources, such as freeing, releasing, or resetting the unmanaged resources.</source>
          <target state="translated">Dans les deux cas, vous utilisez la <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> méthode pour effectuer le nettoyage est nécessaire après l’utilisation de ressources non managées, telles que la libération ou à la redéfinition des ressources non managées.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>If you are defining a base class that uses unmanaged resources and that either has, or is likely to have, subclasses that should be disposed, you should implement the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> method and provide a second overload of <ph id="ph2">`Dispose`</ph>, as discussed in the next section.</source>
          <target state="translated">Si vous définissez une classe de base qui utilise des ressources non managées et qui a, ou est susceptible d’avoir les sous-classes doivent être supprimés, vous devez implémenter la <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> méthode et fournir une deuxième surcharge de <ph id="ph2">`Dispose`</ph>, comme indiqué dans la prochaine section.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>IDisposable and the inheritance hierarchy</source>
          <target state="translated">IDisposable et la hiérarchie d’héritage</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>A base class with subclasses that should be disposable must implement <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> as follows.</source>
          <target state="translated">Classe de base avec les sous-classes doivent être supprimables doit implémenter <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> comme suit.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>You should use this pattern whenever you implement <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> on any type that isn't <ph id="ph2">`sealed`</ph> (<ph id="ph3">`NotInheritable`</ph> in Visual Basic).</source>
          <target state="translated">Vous devez utiliser ce modèle chaque fois que vous implémentez <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> sur n’importe quel type qui n’est pas <ph id="ph2">`sealed`</ph> (<ph id="ph3">`NotInheritable`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>It should provide one public, non-virtual <ph id="ph1">&lt;xref:System.IDisposable.Dispose&gt;</ph> method and a protected virtual <ph id="ph2">`Dispose(Boolean disposing)`</ph> method.</source>
          <target state="translated">Il doit fournir un, non virtuelle publique <ph id="ph1">&lt;xref:System.IDisposable.Dispose&gt;</ph> (méthode) et un document protégé virtuel <ph id="ph2">`Dispose(Boolean disposing)`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>The <ph id="ph1">&lt;xref:System.IDisposable.Dispose&gt;</ph> method must call <ph id="ph2">`Dispose(true)`</ph> and should suppress finalization for performance.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IDisposable.Dispose&gt;</ph> méthode doit appeler <ph id="ph2">`Dispose(true)`</ph> et doit supprimer la finalisation de performances.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>The base type should not include any finalizers.</source>
          <target state="translated">Le type de base ne doit pas inclure de finaliseurs.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>The following code fragment reflects the dispose pattern for base classes.</source>
          <target state="translated">Le fragment de code suivant indique le modèle de suppression pour les classes de base.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>It assumes that your type does not override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Il part du principe que votre type ne remplace pas le <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>If you do override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method, your class should implement the following pattern.</source>
          <target state="translated">Si vous ne substituez pas la <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> (méthode), votre classe doit implémenter le modèle suivant.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>Subclasses should implement the disposable pattern as follows:</source>
          <target state="translated">Les sous-classes doivent implémenter le modèle supprimable comme suit :</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>They must override <ph id="ph1">`Dispose(Boolean)`</ph> and call the base class <ph id="ph2">`Dispose(Boolean)`</ph> implementation.</source>
          <target state="translated">Elles doivent substituer <ph id="ph1">`Dispose(Boolean)`</ph> et appeler l'implémentation <ph id="ph2">`Dispose(Boolean)`</ph> de la classe de base.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>They can provide a finalizer if needed.</source>
          <target state="translated">Elles peuvent fournir un finaliseur, si nécessaire.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>The finalizer must call <ph id="ph1">`Dispose(false)`</ph>.</source>
          <target state="translated">Le finaliseur doit appeler <ph id="ph1">`Dispose(false)`</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>Note that derived classes do not themselves implement the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface and do not include a parameterless <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">Notez que les classes dérivées n’eux-mêmes implémentent pas la <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface et n’incluez pas un sans paramètre <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>They only override the base class <ph id="ph1">`Dispose(Boolean)`</ph> method.</source>
          <target state="translated">Ils ne peuvent remplacer la classe de base <ph id="ph1">`Dispose(Boolean)`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>The following code fragment reflects the dispose pattern for derived classes.</source>
          <target state="translated">Le fragment de code suivant indique le modèle de suppression pour les classes dérivées.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>It assumes that your type does not override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Il part du principe que votre type ne remplace pas le <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IDisposable">
          <source>The following example demonstrates how to create a resource class that implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">L’exemple suivant montre comment créer une classe de ressource qui implémente le <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IDisposable.Dispose">
          <source>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</source>
          <target state="translated">Exécute les tâches définies par l’application associées à la libération ou à la redéfinition des ressources non managées.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>Use this method to close or release unmanaged resources such as files, streams, and handles held by an instance of the class that implements this interface.</source>
          <target state="translated">Utilisez cette méthode pour fermer ou libérer les ressources non managées, telles que des fichiers, flux de données et les handles détenus par une instance de la classe qui implémente cette interface.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>By convention, this method is used for all tasks associated with freeing resources held by an object, or preparing an object for reuse.</source>
          <target state="translated">Par convention, cette méthode est utilisée pour toutes les tâches associées à la libération des ressources détenues par un objet, ou de la préparation d’un objet pour une réutilisation.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>If you are using a class that implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface, you should call its <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implementation when you are finished using the class.</source>
          <target state="translated">Si vous utilisez une classe qui implémente le <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface, vous devez appeler sa <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implémentation lorsque vous avez terminé à l’aide de la classe.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>For more information, see the "Using an object that implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> topic.</source>
          <target state="translated">Pour plus d’informations, consultez la section « Utilisation d’un objet qui implémente IDisposable » dans la <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> rubrique.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>When implementing this method, ensure that all held resources are freed by propagating the call through the containment hierarchy.</source>
          <target state="translated">Lorsque vous implémentez cette méthode, assurez-vous que toutes les ressources détenues soient libérées par l’appel dans la hiérarchie de relation contenant-contenu.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>For example, if an object A allocates an object B, and object B allocates an object C, then A's <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implementation must call <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> on B, which must in turn call <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> on C.</source>
          <target state="translated">Par exemple, si un objet A alloue un objet B, et l’objet B alloue un objet C, alors <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implémentation doit appeler <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> sur B, qui doit appeler ensuite <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> sur C.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>The C++ compiler supports deterministic disposal of resources and does not allow direct implementation of the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">Le compilateur C++ prend en charge la suppression déterministe de ressources et n’autorise pas l’implémentation directe de la <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>An object must also call the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method of its base class if the base class implements <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph>.</source>
          <target state="translated">Un objet doit également appeler le <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> méthode de sa classe de base si la classe de base implémente <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>For more information about implementing <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> on a base class and its subclasses, see the "IDisposable and the inheritance hierarchy" section in the <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> topic.</source>
          <target state="translated">Pour plus d’informations sur l’implémentation de <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> sur une classe de base et de ses sous-classes, consultez la section « IDisposable et la hiérarchie d’héritage » dans la <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> rubrique.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>If an object's <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method is called more than once, the object must ignore all calls after the first one.</source>
          <target state="translated">Si un objet <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> est appelée plusieurs fois, l’objet doit ignorer tous les appels après le premier.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>The object must not throw an exception if its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method is called multiple times.</source>
          <target state="translated">L’objet ne doit pas lever une exception si son <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> méthode est appelée plusieurs fois.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>Instance methods other than <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> can throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> when resources are already disposed.</source>
          <target state="translated">Méthodes d’instance autres que <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> peut lever une <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> lorsque les ressources sont déjà supprimées.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>Users might expect a resource type to use a particular convention to denote an allocated state versus a freed state.</source>
          <target state="translated">Les utilisateurs peuvent attendre d’un type de ressource à utiliser une convention particulière pour dénoter un état alloué par rapport à un état libéré.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>An example of this is stream classes, which are traditionally thought of as open or closed.</source>
          <target state="translated">Un exemple est les classes de flux de données, qui sont traditionnellement considérés comme ouvert ou fermés.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>The implementer of a class that has such a convention might choose to implement a public method with a customized name, such as <ph id="ph1">`Close`</ph>, that calls the <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">L’implémenteur d’une classe qui a une telle convention peut choisir d’implémenter une méthode publique avec un nom personnalisé, tel que <ph id="ph1">`Close`</ph>, qui appelle la <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>Because the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method must be called explicitly, there is always a danger that the unmanaged resources will not be released, because the consumer of an object fails to call its <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">Étant donné que la <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> méthode doit être appelée explicitement, il existe toujours un danger les ressources non managées ne sera pas publié, car le consommateur d’un objet ne parvient pas à appeler son <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>There are two ways to avoid this:</source>
          <target state="translated">Il existe deux façons d’éviter ce problème :</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>Wrap the managed resource in an object derived from <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Retour à la ligne la ressource managée dans un objet dérivé de <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>Your <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implementation then calls the <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method of the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph> instances.</source>
          <target state="translated">Votre <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implémentation appelle alors la <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> méthode de la <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph> instances.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>For more information, see "The SafeHandle alternative" section in the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> topic.</source>
          <target state="translated">Pour plus d’informations, consultez la section « L’alternative de SafeHandle » dans la <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> rubrique.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>Implement a finalizer to free resources when <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> is not called.</source>
          <target state="translated">Implémenter un finaliseur pour libérer des ressources lorsque <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> n’est pas appelée.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>By default, the garbage collector automatically calls an object's finalizer before reclaiming its memory.</source>
          <target state="translated">Par défaut, le garbage collector appelle automatiquement le finaliseur d’un objet avant de libérer sa mémoire.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>However, if the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method has been called, it is typically unnecessary for the garbage collector to call the disposed object's finalizer.</source>
          <target state="translated">Toutefois, si le <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> méthode a été appelée, il est généralement inutile que le garbage collector d’appeler le finaliseur de l’objet supprimé.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>To prevent automatic finalization, <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implementations can call the <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour éviter la Finalisation automatique, <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implémentations peuvent appeler le <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>When you use an object that accesses unmanaged resources, such as a <ph id="ph1">&lt;xref:System.IO.StreamWriter&gt;</ph>, a good practice is to create the instance with a <ph id="ph2">`using`</ph> statement.</source>
          <target state="translated">Lorsque vous utilisez un objet qui accède à des ressources non managées, comme un <ph id="ph1">&lt;xref:System.IO.StreamWriter&gt;</ph>, la meilleure pratique consiste à créer l’instance avec un <ph id="ph2">`using`</ph> instruction.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>The <ph id="ph1">`using`</ph> statement automatically closes the stream and calls <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> on the object when the code that is using it has completed.</source>
          <target state="translated">Le <ph id="ph1">`using`</ph> instruction ferme automatiquement le flux de données et les appels <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> sur l’objet lorsque le code qui l’utilise est terminé.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>For an example, see the <ph id="ph1">&lt;xref:System.IO.StreamWriter&gt;</ph> class.</source>
          <target state="translated">Pour obtenir un exemple, consultez la <ph id="ph1">&lt;xref:System.IO.StreamWriter&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IDisposable.Dispose">
          <source>The following example shows how you can implement the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant montre comment vous pouvez implémenter la <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> (méthode).</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>