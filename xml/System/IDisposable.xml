<Type Name="IDisposable" FullName="System.IDisposable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1e6b408b88af2e3e5027106be9c33751cc9e19c3" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34452198" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IDisposable" />
  <TypeSignature Language="VB.NET" Value="Public Interface IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit un mécanisme pour libérer des ressources non gérées.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La principale utilisation de cette interface est de libérer les ressources non managées. Le garbage collector libère automatiquement la mémoire allouée à un objet managé lorsque cet objet n’est plus utilisé. Toutefois, il n’est pas possible de prédire quand le garbage collection se produit. En outre, le garbage collector n’a aucune connaissance des ressources non managées, telles que les handles de fenêtre, ou ouvrir des fichiers et des flux de données.  
  
 Utilisez la <xref:System.IDisposable.Dispose%2A> méthode de cette interface pour libérer explicitement les ressources non managées en association avec le garbage collector. Le consommateur d’un objet peut appeler cette méthode lorsque l’objet n’est plus nécessaire.  
  
> [!WARNING]
>  Il s’agit d’une modification avec rupture pour ajouter le <xref:System.IDisposable> interface à une classe existante. Étant donné que les consommateurs existants de votre type ne peut pas appeler <xref:System.IDisposable.Dispose%2A>, vous n’êtes pas certain que les ressources non managées détenues par votre type seront libérés.  
  
 Étant donné que la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implémentation est appelée par le consommateur d’un type lorsque les ressources détenues par une instance ne sont plus nécessaires, vous devez encapsuler soit l’objet managé dans un <xref:System.Runtime.InteropServices.SafeHandle> (l’alternative recommandée), ou vous devez substituer <xref:System.Object.Finalize%2A?displayProperty=nameWithType>pour libérer les ressources non managées dans le cas où le consommateur oublie d’appeler <xref:System.IDisposable.Dispose%2A>.  
  
> [!IMPORTANT]
>  Dans le .NET Framework, le compilateur C++ prend en charge la suppression déterministe de ressources et n’autorise pas l’implémentation directe de la <xref:System.IDisposable.Dispose%2A> (méthode).  
  
 Pour plus d’informations sur la façon de cette interface et la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> méthode sont utilisées, consultez la [Garbage Collection](~/docs/standard/garbage-collection/index.md) et [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md) rubriques.  
  
## <a name="using-an-object-that-implements-idisposable"></a>À l’aide d’un objet qui implémente IDisposable  
 Si votre application utilise simplement un objet qui implémente le <xref:System.IDisposable> interface, vous devez appeler l’objet <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implémentation lorsque vous avez fini de l’utiliser. Selon votre langage de programmation, vous pouvez faire de deux manières :  
  
-   En utilisant un langage de construction tels que le `using` instruction en c# et Visual Basic.  
  
-   En encapsulant l’appel à la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> mise en œuvre dans un `try` / `finally` bloc.  
  
> [!NOTE]
>  Documentation pour les types qui implémentent <xref:System.IDisposable> Notez que les et inclure un rappel à appeler son <xref:System.IDisposable.Dispose%2A> implémentation.  
  
<a name="Using"></a>   
### <a name="the-c-and-visual-basic-using-statement"></a>L’instruction c# et Visual Basic à l’aide  
 Si votre langage prend en charge une construction tels que le [à l’aide de](~/docs/csharp/language-reference/keywords/using.md) instruction en c# et la [Using](~/docs/visual-basic/language-reference/statements/using-statement.md) instruction en Visual Basic, vous pouvez l’utiliser au lieu d’appeler explicitement <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> vous-même. L’exemple suivant utilise cette approche dans la définition d’un `WordCount` classe qui conserve les informations sur un fichier et le nombre de mots qu’il contient.  
  
 [!code-csharp[System.IDisposable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling1.cs#1)]
 [!code-vb[System.IDisposable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling1.vb#1)]  
  
 La `using` instruction est réellement une commodité syntaxique. Au moment de la compilation, le compilateur de langage implémente le langage intermédiaire (IL) pour un `try` / `finally` bloc.  
  
 Pour plus d’informations sur la `using` instruction, consultez la [à l’aide de l’instruction](~/docs/visual-basic/language-reference/statements/using-statement.md) ou [à l’aide d’instruction](~/docs/csharp/language-reference/keywords/using-statement.md) rubriques.  
  
### <a name="the-tryfinally-block"></a>Le bloc Try/Finally  
 Si votre langage de programmation ne prend pas en charge une construction comme le `using` instruction en c# ou Visual Basic, ou si vous préférez ne pas l’utiliser, vous pouvez appeler la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implémentation à partir de la `finally` bloquer d’un `try` / `finally` instruction. L’exemple suivant remplace le `using` bloquer dans l’exemple précédent, avec un `try` / `finally` bloc.  
  
 [!code-csharp[System.IDisposable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling2.cs#2)]
 [!code-vb[System.IDisposable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling2.vb#2)]  
  
 Pour plus d’informations sur la `try` / `finally` de modèle, consultez [essayez... Catch... Instruction finally](~/docs/visual-basic/language-reference/statements/try-catch-finally-statement.md), [try-finally](~/docs/csharp/language-reference/keywords/try-finally.md), ou [try-finally, instruction](http://msdn.microsoft.com/library/514400c1-c322-4bf3-9e48-3047240b8a82).  
  
## <a name="implementing-idisposable"></a>Implémentation de IDisposable  
 Vous devez implémenter <xref:System.IDisposable> uniquement si votre type utilise directement les ressources non managées. Les consommateurs de votre type peuvent appeler votre <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implémentation de libérer des ressources lors de l’instance n’est plus nécessaire. Pour gérer les cas dans lesquels ils échouent à appeler <xref:System.IDisposable.Dispose%2A>, vous devez utiliser une classe dérivée de <xref:System.Runtime.InteropServices.SafeHandle> pour encapsuler les ressources non managées, ou vous devez substituer la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> méthode pour un type référence. Dans les deux cas, vous utilisez la <xref:System.IDisposable.Dispose%2A> méthode pour effectuer le nettoyage est nécessaire après l’utilisation de ressources non managées, telles que la libération ou à la redéfinition des ressources non managées.  
  
> [!IMPORTANT]
>  Si vous définissez une classe de base qui utilise des ressources non managées et qui a, ou est susceptible d’avoir les sous-classes doivent être supprimés, vous devez implémenter la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> méthode et fournir une deuxième surcharge de `Dispose`, comme indiqué dans la prochaine section.  
  
<a name="BaseClasses"></a>   
## <a name="idisposable-and-the-inheritance-hierarchy"></a>IDisposable et la hiérarchie d’héritage  
 Classe de base avec les sous-classes doivent être supprimables doit implémenter <xref:System.IDisposable> comme suit. Vous devez utiliser ce modèle chaque fois que vous implémentez <xref:System.IDisposable> sur n’importe quel type qui n’est pas `sealed` (`NotInheritable` en Visual Basic).  
  
-   Il doit fournir un, non virtuelle publique <xref:System.IDisposable.Dispose> (méthode) et un document protégé virtuel `Dispose(Boolean disposing)` (méthode).  
  
-   Le <xref:System.IDisposable.Dispose> méthode doit appeler `Dispose(true)` et doit supprimer la finalisation de performances.  
  
-   Le type de base ne doit pas inclure de finaliseurs.  
  
 Le fragment de code suivant indique le modèle de suppression pour les classes de base. Il part du principe que votre type ne remplace pas le <xref:System.Object.Finalize%2A?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.IDisposable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
 [!code-vb[System.IDisposable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  
  
 Si vous ne substituez pas la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> (méthode), votre classe doit implémenter le modèle suivant.  
  
 [!code-csharp[System.IDisposable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
 [!code-vb[System.IDisposable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  
  
 Les sous-classes doivent implémenter le modèle supprimable comme suit :  
  
-   Elles doivent substituer `Dispose(Boolean)` et appeler l'implémentation `Dispose(Boolean)` de la classe de base.  
  
-   Elles peuvent fournir un finaliseur, si nécessaire. Le finaliseur doit appeler `Dispose(false)`.  
  
 Notez que les classes dérivées n’eux-mêmes implémentent pas la <xref:System.IDisposable> interface et n’incluez pas un sans paramètre <xref:System.IDisposable.Dispose%2A> (méthode). Ils ne peuvent remplacer la classe de base `Dispose(Boolean)` (méthode).  
  
 Le fragment de code suivant indique le modèle de suppression pour les classes dérivées. Il part du principe que votre type ne remplace pas le <xref:System.Object.Finalize%2A?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.IDisposable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
 [!code-vb[System.IDisposable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une classe de ressource qui implémente le <xref:System.IDisposable> interface.  
  
 [!code-cpp[System.IDisposable.Dispose Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]
 [!code-csharp[System.IDisposable.Dispose Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]
 [!code-vb[System.IDisposable.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" />
  </Docs>
  <Members>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IDisposable.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Dispose();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exécute les tâches définies par l’application associées à la libération ou à la redéfinition des ressources non managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour fermer ou libérer les ressources non managées, telles que des fichiers, flux de données et les handles détenus par une instance de la classe qui implémente cette interface. Par convention, cette méthode est utilisée pour toutes les tâches associées à la libération des ressources détenues par un objet, ou de la préparation d’un objet pour une réutilisation.  
  
> [!WARNING]
>  Si vous utilisez une classe qui implémente le <xref:System.IDisposable> interface, vous devez appeler sa <xref:System.IDisposable.Dispose%2A> implémentation lorsque vous avez terminé à l’aide de la classe. Pour plus d’informations, consultez la section « Utilisation d’un objet qui implémente IDisposable » dans la <xref:System.IDisposable> rubrique.  
  
 Lorsque vous implémentez cette méthode, assurez-vous que toutes les ressources détenues soient libérées par l’appel dans la hiérarchie de relation contenant-contenu. Par exemple, si un objet A alloue un objet B, et l’objet B alloue un objet C, alors <xref:System.IDisposable.Dispose%2A> implémentation doit appeler <xref:System.IDisposable.Dispose%2A> sur B, qui doit appeler ensuite <xref:System.IDisposable.Dispose%2A> sur C.  
  
> [!IMPORTANT]
>  Le compilateur C++ prend en charge la suppression déterministe de ressources et n’autorise pas l’implémentation directe de la <xref:System.IDisposable.Dispose%2A> (méthode).  
  
 Un objet doit également appeler le <xref:System.IDisposable.Dispose%2A> méthode de sa classe de base si la classe de base implémente <xref:System.IDisposable>. Pour plus d’informations sur l’implémentation de <xref:System.IDisposable> sur une classe de base et de ses sous-classes, consultez la section « IDisposable et la hiérarchie d’héritage » dans la <xref:System.IDisposable> rubrique.  
  
 Si un objet <xref:System.IDisposable.Dispose%2A> est appelée plusieurs fois, l’objet doit ignorer tous les appels après le premier. L’objet ne doit pas lever une exception si son <xref:System.IDisposable.Dispose%2A> méthode est appelée plusieurs fois. Méthodes d’instance autres que <xref:System.IDisposable.Dispose%2A> peut lever une <xref:System.ObjectDisposedException> lorsque les ressources sont déjà supprimées.  
  
 Les utilisateurs peuvent attendre d’un type de ressource à utiliser une convention particulière pour dénoter un état alloué par rapport à un état libéré. Un exemple est les classes de flux de données, qui sont traditionnellement considérés comme ouvert ou fermés. L’implémenteur d’une classe qui a une telle convention peut choisir d’implémenter une méthode publique avec un nom personnalisé, tel que `Close`, qui appelle la <xref:System.IDisposable.Dispose%2A> (méthode).  
  
 Étant donné que la <xref:System.IDisposable.Dispose%2A> méthode doit être appelée explicitement, il existe toujours un danger les ressources non managées ne sera pas publié, car le consommateur d’un objet ne parvient pas à appeler son <xref:System.IDisposable.Dispose%2A> (méthode). Il existe deux façons d’éviter ce problème :  
  
-   Retour à la ligne la ressource managée dans un objet dérivé de <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>. Votre <xref:System.IDisposable.Dispose%2A> implémentation appelle alors la <xref:System.IDisposable.Dispose%2A> méthode de la <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> instances. Pour plus d’informations, consultez la section « L’alternative de SafeHandle » dans la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> rubrique.  
  
-   Implémenter un finaliseur pour libérer des ressources lorsque <xref:System.IDisposable.Dispose%2A> n’est pas appelée. Par défaut, le garbage collector appelle automatiquement le finaliseur d’un objet avant de libérer sa mémoire. Toutefois, si le <xref:System.IDisposable.Dispose%2A> méthode a été appelée, il est généralement inutile que le garbage collector d’appeler le finaliseur de l’objet supprimé. Pour éviter la Finalisation automatique, <xref:System.IDisposable.Dispose%2A> implémentations peuvent appeler le <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode).  
  
 Lorsque vous utilisez un objet qui accède à des ressources non managées, comme un <xref:System.IO.StreamWriter>, la meilleure pratique consiste à créer l’instance avec un `using` instruction. Le `using` instruction ferme automatiquement le flux de données et les appels <xref:System.IDisposable.Dispose%2A> sur l’objet lorsque le code qui l’utilise est terminé. Pour obtenir un exemple, consultez la <xref:System.IO.StreamWriter> classe.  
  
   
  
## Examples  
 L’exemple suivant montre comment vous pouvez implémenter la <xref:System.IDisposable.Dispose%2A> (méthode).  
  
 [!code-cpp[System.IDisposable.Dispose Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]
 [!code-csharp[System.IDisposable.Dispose Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]
 [!code-vb[System.IDisposable.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>