<Type Name="UriParser" FullName="System.UriParser">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="18211f47087f208e898b72272d14ecd78771eb8c" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30728533" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class UriParser" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract UriParser extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.UriParser" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class UriParser" />
  <TypeSignature Language="C++ CLI" Value="public ref class UriParser abstract" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Analyse un nouveau schéma URI. Il s'agit d'une classe abstraite.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe UriParser vous permet de créer des analyseurs pour de nouveaux modèles URI. Vous pouvez écrire ces analyseurs dans leur intégralité, ou les analyseurs peuvent être dérivées de schémas connus (HTTP, FTP et autres modèles basés sur les protocoles réseau). Si vous souhaitez créer un analyseur, héritent de <xref:System.GenericUriParser>. Si vous souhaitez créer un analyseur qui étend un schéma URI connu, héritent de <xref:System.FtpStyleUriParser>, <xref:System.HttpStyleUriParser>, <xref:System.FileStyleUriParser>, <xref:System.GopherStyleUriParser>, ou <xref:System.LdapStyleUriParser>.  
  
 Microsoft recommande fortement d’utiliser un analyseur livré avec .NET. Création de votre propre analyseur augmente la complexité de votre application et n’effectuera pas, ainsi que les analyseurs livrés.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UriParser ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriParser.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; UriParser();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Construit un analyseur URI par défaut.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetComponents">
      <MemberSignature Language="C#" Value="protected virtual string GetComponents (Uri uri, UriComponents components, UriFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetComponents(class System.Uri uri, valuetype System.UriComponents components, valuetype System.UriFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriParser.GetComponents(System.Uri,System.UriComponents,System.UriFormat)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetComponents(Uri ^ uri, UriComponents components, UriFormat format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="components" Type="System.UriComponents" />
        <Parameter Name="format" Type="System.UriFormat" />
      </Parameters>
      <Docs>
        <param name="uri">URI à analyser.</param>
        <param name="components">
          <see cref="T:System.UriComponents" /> à récupérer de <c>uri</c>.</param>
        <param name="format">L'une des valeurs <see cref="T:System.UriFormat" /> qui contrôlent la façon dont les caractères spéciaux sont placés dans une séquence d'échappement.</param>
        <summary>Obtient les composants d'un URI.</summary>
        <returns>Chaîne qui contient les composants.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.UriParser.GetComponents%2A> méthode pour déterminer la valeur de différentes parties de l’URI, telles que la <xref:System.UriComponents.Scheme>, <xref:System.UriComponents.Host>, ou <xref:System.UriComponents.Port>.  
  
 Les composants sont retournés dans l’ordre d’apparition dans l’URI. Par exemple, si <xref:System.UriComponents.Scheme> est spécifié, il apparaît en premier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="uriFormat" /> n'est pas valide.  
  
 \- ou -  
  
 <paramref name="uriComponents" /> n'est pas une combinaison de valeurs <see cref="T:System.UriComponents" /> valides.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="uri" /> nécessite une analyse commandée par l'utilisateur  
  
 \- ou -  
  
 <paramref name="uri" /> n’est pas un URI absolu. Il est impossible d'utiliser des URI relatifs avec cette méthode.</exception>
        <altmember cref="T:System.UriComponents" />
        <altmember cref="F:System.UriComponents.Host" />
        <altmember cref="F:System.UriComponents.Port" />
        <altmember cref="F:System.UriComponents.Scheme" />
        <altmember cref="T:System.UriFormat" />
        <altmember cref="M:System.UriParser.GetComponents(System.Uri,System.UriComponents,System.UriFormat)" />
      </Docs>
    </Member>
    <Member MemberName="InitializeAndValidate">
      <MemberSignature Language="C#" Value="protected virtual void InitializeAndValidate (Uri uri, out UriFormatException parsingError);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeAndValidate(class System.Uri uri, [out] class System.UriFormatException&amp; parsingError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriParser.InitializeAndValidate(System.Uri,System.UriFormatException@)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeAndValidate(Uri ^ uri, [Runtime::InteropServices::Out] UriFormatException ^ % parsingError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="parsingError" Type="System.UriFormatException&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="uri">T:System.Uri à valider.</param>
        <param name="parsingError">Erreurs de validation, le cas échéant.</param>
        <summary>Initialise l'état de l'analyseur et valide l'URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.UriParser.InitializeAndValidate%2A> méthode est appelée chaque fois qu’un <xref:System.Uri> est instancié.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBaseOf">
      <MemberSignature Language="C#" Value="protected virtual bool IsBaseOf (Uri baseUri, Uri relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsBaseOf(class System.Uri baseUri, class System.Uri relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriParser.IsBaseOf(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsBaseOf (baseUri As Uri, relativeUri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsBaseOf(Uri ^ baseUri, Uri ^ relativeUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseUri">URI de base.</param>
        <param name="relativeUri">URI à tester.</param>
        <summary>Détermine si <paramref name="baseUri" /> est un URI de base pour <paramref name="relativeUri" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="baseUri" /> est un URI de base pour <paramref name="relativeUri" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKnownScheme">
      <MemberSignature Language="C#" Value="public static bool IsKnownScheme (string schemeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKnownScheme(string schemeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriParser.IsKnownScheme(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsKnownScheme (schemeName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsKnownScheme(System::String ^ schemeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="schemeName">Nom du schéma à vérifier.</param>
        <summary>Indique si l'analyseur d'un schéma est enregistré.</summary>
        <returns>
          <see langword="true" /> si <paramref name="schemeName" /> a été enregistré ; sinon <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="schemeName" /> est null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="schemeName" /> n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedOriginalString">
      <MemberSignature Language="C#" Value="protected virtual bool IsWellFormedOriginalString (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsWellFormedOriginalString(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriParser.IsWellFormedOriginalString(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsWellFormedOriginalString(Uri ^ uri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">URI à vérifier.</param>
        <summary>Indique si un URI est de forme correcte.</summary>
        <returns>
          <see langword="true" /> si <paramref name="uri" /> a une forme correcte ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.UriParser.IsWellFormedOriginalString%2A> méthode retourne false si :  
  
-   La chaîne n’est pas correctement échappée la norme RFC 2396.  
  
-   La chaîne représente un URI absolu qui fait référence à un URI de fichier implicite.  
  
-   La chaîne représente un URI absolu auquel il manque une barre oblique avant le composant de chemin d’accès.  
  
-   La chaîne contient des barres obliques inverses sans séquence d’échappement, même si elles sont traitées comme des barres obliques.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNewUri">
      <MemberSignature Language="C#" Value="protected virtual UriParser OnNewUri ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.UriParser OnNewUri() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriParser.OnNewUri" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnNewUri () As UriParser" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual UriParser ^ OnNewUri();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriParser</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appelé par un constructeur <see cref="T:System.Uri" /> pour obtenir une instance <see cref="T:System.UriParser" /></summary>
        <returns>
          <see cref="T:System.UriParser" /> pour le <see cref="T:System.Uri" /> construit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne la même <xref:System.UriParser> instance. Vous devrez peut-être substituer cette méthode et retourner une autre <xref:System.UriParser> pour chaque appel si vous opérez dans un environnement multithread.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRegister">
      <MemberSignature Language="C#" Value="protected virtual void OnRegister (string schemeName, int defaultPort);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRegister(string schemeName, int32 defaultPort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriParser.OnRegister(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRegister (schemeName As String, defaultPort As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRegister(System::String ^ schemeName, int defaultPort);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
        <Parameter Name="defaultPort" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="schemeName">Schéma associé à ce <see cref="T:System.UriParser" />.</param>
        <param name="defaultPort">Numéro de port du schéma.</param>
        <summary>Appelé par Framework lorsqu'une méthode <see cref="T:System.UriParser" /> est enregistrée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static void Register (UriParser uriParser, string schemeName, int defaultPort);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Register(class System.UriParser uriParser, string schemeName, int32 defaultPort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriParser.Register(System.UriParser,System.String,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Register(UriParser ^ uriParser, System::String ^ schemeName, int defaultPort);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriParser" Type="System.UriParser" />
        <Parameter Name="schemeName" Type="System.String" />
        <Parameter Name="defaultPort" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="uriParser">Analyseur URI à enregistrer.</param>
        <param name="schemeName">Nom du schéma associé à cet analyseur.</param>
        <param name="defaultPort">Numéro de port par défaut pour le schéma spécifié.</param>
        <summary>Associe un schéma et un numéro de port à <see cref="T:System.UriParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `defaultPort` paramètre a la valeur -1, le <xref:System.UriParser.Register%2A> méthode n’inscrit aucune valeur par défaut pour le numéro de port.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Le paramètre <paramref name="uriParser" /> est null  
  
 \- ou -  
  
 Le paramètre <paramref name="schemeName" /> est null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Le paramètre <paramref name="schemeName" /> n'est pas valide.  
  
 \- ou -  
  
 Le paramètre <paramref name="defaultPort" /> n'est pas valide. Le paramètre <paramref name="defaultPort" /> est inférieur à -1 ou supérieur à 65 534.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resolve">
      <MemberSignature Language="C#" Value="protected virtual string Resolve (Uri baseUri, Uri relativeUri, out UriFormatException parsingError);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string Resolve(class System.Uri baseUri, class System.Uri relativeUri, [out] class System.UriFormatException&amp; parsingError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriParser.Resolve(System.Uri,System.Uri,System.UriFormatException@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Resolve (baseUri As Uri, relativeUri As Uri, ByRef parsingError As UriFormatException) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ Resolve(Uri ^ baseUri, Uri ^ relativeUri, [Runtime::InteropServices::Out] UriFormatException ^ % parsingError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
        <Parameter Name="parsingError" Type="System.UriFormatException&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">URI de base.</param>
        <param name="relativeUri">URI relatif.</param>
        <param name="parsingError">Erreurs pendant le processus de résolution, le cas échéant.</param>
        <summary>Appelé par les constructeurs <see cref="T:System.Uri" /> et <see cref="Overload:System.Uri.TryCreate" /> pour résoudre un URI relatif.</summary>
        <returns>Chaîne du <see cref="T:System.Uri" /> relatif résolu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri> constructeurs et <xref:System.Uri.TryCreate%2A?displayProperty=nameWithType> utiliser <xref:System.UriParser.Resolve%2A> pour construire un URI à partir de `baseUri` et `relativeUri`.  
  
 Si une analyse erreur se produit, la chaîne retournée pour relatif résolu <xref:System.Uri> a la valeur null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          Le paramètre <paramref name="baseUri" /> n'est pas un <see cref="T:System.Uri" />absolu  
  
 \- ou -  
  
 Le paramètre <paramref name="baseUri" /> requiert une analyse exécutée par l'utilisateur.</exception>
      </Docs>
    </Member>
  </Members>
</Type>