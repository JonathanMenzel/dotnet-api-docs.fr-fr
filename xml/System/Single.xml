<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Single.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5a55e5f4bf64067757cfd61da12a6070a0e3d5cb3.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a55e5f4bf64067757cfd61da12a6070a0e3d5cb3</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Single">
          <source>Represents a single-precision floating-point number.</source>
          <target state="translated">Représente un nombre à virgule flottante simple précision.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The <ph id="ph1">&lt;xref:System.Single&gt;</ph> value type represents a single-precision 32-bit number with values ranging from negative 3.402823e38 to positive 3.402823e38, as well as positive or negative zero, <ph id="ph2">&lt;xref:System.Single.PositiveInfinity&gt;</ph>, <ph id="ph3">&lt;xref:System.Single.NegativeInfinity&gt;</ph>, and not a number (<ph id="ph4">&lt;xref:System.Single.NaN&gt;</ph>).</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single&gt;</ph> type de valeur représente un nombre de 32 bits simple précision avec des valeurs comprises entre moins 3, 402823E38 et plus 3, 402823E38, ainsi que le zéro positif ou négatif, <ph id="ph2">&lt;xref:System.Single.PositiveInfinity&gt;</ph>, <ph id="ph3">&lt;xref:System.Single.NegativeInfinity&gt;</ph>et pas un nombre (<ph id="ph4">&lt;xref:System.Single.NaN&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>It is intended to represent values that are extremely large (such as distances between planets or galaxies) or extremely small (such as the molecular mass of a substance in kilograms) and that often are imprecise (such as the distance from earth to another solar system).</source>
          <target state="translated">Il est destiné à représenter des valeurs qui sont extrêmement volumineux (par exemple, les distances entre les planètes ou galaxies) ou très petite (par exemple, la masse moléculaire de substance dans kg) et qui sont souvent imprécises (par exemple la distance à partir de la terre à un autre système solaire ).</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The <ph id="ph1">&lt;xref:System.Single&gt;</ph> type complies with the IEC 60559:1989 (IEEE 754) standard for binary floating-point arithmetic.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single&gt;</ph> type est conforme à la IEC 60559 : 1989 (IEEE 754) standard pour les opérateurs d’arithmétique binaire à virgule flottante.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>This topic consists of the following sections:</source>
          <target state="translated">Cette rubrique contient les sections suivantes :</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><bpt id="p1">[</bpt>Floating-point representation and precision<ept id="p1">](#Precision)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Précision et une représentation à virgule flottante<ept id="p1">](#Precision)</ept></target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><bpt id="p1">[</bpt>Testing for equality<ept id="p1">](#Equality)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Test d’égalité<ept id="p1">](#Equality)</ept></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><bpt id="p1">[</bpt>Floating-point values and exceptions<ept id="p1">](#Exceptions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Exceptions et les valeurs à virgule flottante<ept id="p1">](#Exceptions)</ept></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><bpt id="p1">[</bpt>Type conversion and the Single structure<ept id="p1">](#Conversion)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Conversion de type et la structure unique<ept id="p1">](#Conversion)</ept></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><bpt id="p1">[</bpt>Floating-point functionality<ept id="p1">](#Functionality)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Fonctionnalité à virgule flottante<ept id="p1">](#Functionality)</ept></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><ph id="ph1">&lt;xref:System.Single?displayProperty=nameWithType&gt;</ph> provides methods to compare instances of this type, to convert the value of an instance to its string representation, and to convert the string representation of a number to an instance of this type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Single?displayProperty=nameWithType&gt;</ph> Fournit des méthodes permettant de comparer des instances de ce type, de convertir la valeur d’une instance en sa représentation sous forme de chaîne et de convertir la représentation sous forme de chaîne d’un nombre à une instance de ce type.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>For information about how format specification codes control the string representation of value types, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>, <bpt id="p2">[</bpt>Standard Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>, and <bpt id="p3">[</bpt>Custom Numeric Format Strings<ept id="p3">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur comment les codes de spécification de format contrôlent la représentation sous forme de chaîne des types valeur, consultez <bpt id="p1">[</bpt>mise en forme des Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>, <bpt id="p2">[</bpt>des chaînes de Format numériques Standard<ept id="p2">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>, et <bpt id="p3">[</bpt>numérique personnalisée Chaînes de format<ept id="p3">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Floating-point representation and precision</source>
          <target state="translated">Précision et une représentation à virgule flottante</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The <ph id="ph1">&lt;xref:System.Single&gt;</ph> data type stores single-precision floating-point values in a 32-bit binary format, as shown in the following table:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single&gt;</ph> type de données stocke les valeurs à virgule flottante simple précision dans un format binaire de 32 bits, comme indiqué dans le tableau suivant :</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Part</source>
          <target state="translated">Élément</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Bits</source>
          <target state="translated">Bits</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Significand or mantissa</source>
          <target state="translated">Mantisse ou mantisse</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>0-22</source>
          <target state="translated">0-22</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Exponent</source>
          <target state="translated">Exposant</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>23-30</source>
          <target state="translated">23-30</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Sign (0 = positive, 1 = negative)</source>
          <target state="translated">Signe (0 = positifs, 1 = négatif)</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>31</source>
          <target state="translated">31</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Just as decimal fractions are unable to precisely represent some fractional values (such as 1/3 or <ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>), binary fractions are unable to represent some fractional values.</source>
          <target state="translated">Tout comme les fractions décimales sont ne peut pas représenter précisément de certaines valeurs fractionnaires (tels que 1/3 ou <ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>), fractions binaires ne peuvent pas représenter des valeurs fractionnaires.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>For example, 2/10, which is represented precisely by .2 as a decimal fraction, is represented by .0011111001001100 as a binary fraction, with the pattern "1100" repeating to infinity.</source>
          <target state="translated">Par exemple, 2/10, qui est représentée avec précision par.2 comme une fraction décimale, est représenté par.0011111001001100 sous forme de fraction binaire, avec le modèle « 1100 » extensible à l’infini.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>In this case, the floating-point value provides an imprecise representation of the number that it represents.</source>
          <target state="translated">Dans ce cas, la valeur à virgule flottante fournit une représentation imprécise du nombre qu’il représente.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Performing additional mathematical operations on the original floating-point value often increases its lack of precision.</source>
          <target state="translated">Exécution d’autres opérations mathématiques sur la valeur à virgule flottante d’origine souvent augmente son manque de précision.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>For example, if you compare the results of multiplying .3 by 10 and adding .3 to .3 nine times, you will see that addition produces the less precise result, because it involves eight more operations than multiplication.</source>
          <target state="translated">Par exemple, si vous comparez les résultats de la multiplication.3 par 10 et ajoutez.3 à.3 neuf fois, vous verrez cet ajout produit le résultat moins précis, car elle implique des huit davantage d’opérations de multiplication.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Note that this disparity is apparent only if you display the two <ph id="ph1">&lt;xref:System.Single&gt;</ph> values by using the "R" <bpt id="p1">[</bpt>standard numeric format string<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>, which, if necessary, displays all 9 digits of precision supported by the <ph id="ph2">&lt;xref:System.Single&gt;</ph> type.</source>
          <target state="translated">Notez que cette disparité est visible uniquement si vous affichez les deux <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeurs à l’aide de « R » <bpt id="p1">[</bpt>chaîne de format numérique standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>, qui, si nécessaire, affiche toutes les 9 chiffres de précision pris en charge par le <ph id="ph2">&lt;xref:System.Single&gt;</ph> type.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Because some numbers cannot be represented exactly as fractional binary values, floating-point numbers can only approximate real numbers.</source>
          <target state="translated">Étant donné que des nombres ne peut pas être représentés exactement comme des valeurs binaires fractions de seconde, des nombres à virgule flottante peuvent uniquement des nombres réels approximatives.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>All floating-point numbers have a limited number of significant digits, which also determines how accurately a floating-point value approximates a real number.</source>
          <target state="translated">Tous les nombres à virgule flottante ont un nombre limité de chiffres significatifs, qui détermine également la façon dont une valeur à virgule flottante s’apparentent précisément un nombre réel.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>A <ph id="ph1">&lt;xref:System.Single&gt;</ph> value has up to 7 decimal digits of precision, although a maximum of 9 digits is maintained internally.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur a jusqu'à 7 chiffres décimaux de précision, bien qu’un maximum de 9 chiffres est géré en interne.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>This means that some floating-point operations may lack the precision to change a floating-point value.</source>
          <target state="translated">Cela signifie que certaines opérations à virgule flottante n’ont peut-être pas la précision pour modifier une valeur à virgule flottante.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The following example defines a large single-precision floating-point value, and then adds the product of <ph id="ph1">&lt;xref:System.Single.Epsilon?displayProperty=nameWithType&gt;</ph> and one quadrillion to it.</source>
          <target state="translated">L’exemple suivant définit une valeur à virgule flottante simple précision élevée, puis ajoute le produit de <ph id="ph1">&lt;xref:System.Single.Epsilon?displayProperty=nameWithType&gt;</ph> et quadrillion d’un à celui-ci.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>However, the product is too small to modify the original floating-point value.</source>
          <target state="translated">Toutefois, le produit est trop petit pour modifier la valeur à virgule flottante d’origine.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Its least significant digit is thousandths, whereas the most significant digit in the product is 1<bpt id="p1">&lt;sup&gt;</bpt>-312<ept id="p1">&lt;/sup&gt;</ept>.</source>
          <target state="translated">Son chiffre le moins significatif est millièmes, tandis que le chiffre le plus significatif dans le produit est 1<bpt id="p1">&lt;sup&gt;</bpt>valeur -312<ept id="p1">&lt;/sup&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The limited precision of a floating-point number has several consequences:</source>
          <target state="translated">La précision limitée d’un nombre à virgule flottante a plusieurs conséquences :</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Two floating-point numbers that appear equal for a particular precision might not compare equal because their least significant digits are different.</source>
          <target state="translated">Deux nombres à virgule flottante qui apparaissent égaux pour une précision particulière ne peuvent pas considérés comme égaux parce que leurs chiffres les moins significatifs sont différents.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>In the following example, a series of numbers are added together, and their total is compared with their expected total.</source>
          <target state="translated">Dans l’exemple suivant, une série de nombres sont additionnés et leur total est comparé à leur total attendu.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Although the two values appear to be the same, a call to the <ph id="ph1">`Equals`</ph> method indicates that they are not.</source>
          <target state="translated">Bien que les deux valeurs semblent être identiques, un appel à la <ph id="ph1">`Equals`</ph> méthode indique qu’ils ne sont pas.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>If you change the format items in the <ph id="ph1">&lt;xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> statement from <ph id="ph2">`{0}`</ph> and <ph id="ph3">`{1}`</ph> to <ph id="ph4">`{0:R}`</ph> and <ph id="ph5">`{1:R}`</ph> to display all significant digits of the two <ph id="ph6">&lt;xref:System.Single&gt;</ph> values, it is clear that the two values are unequal because of a loss of precision during the addition operations.</source>
          <target state="translated">Si vous modifiez les éléments de format dans le <ph id="ph1">&lt;xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> instruction à partir de <ph id="ph2">`{0}`</ph> et <ph id="ph3">`{1}`</ph> à <ph id="ph4">`{0:R}`</ph> et <ph id="ph5">`{1:R}`</ph> pour afficher tous les chiffres significatifs des deux <ph id="ph6">&lt;xref:System.Single&gt;</ph> valeurs, il est clair que les deux valeurs sont inégales, car d’une perte de précision pendant les opérations d’addition.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>In this case, the issue can be resolved by calling the <ph id="ph1">&lt;xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to round the <ph id="ph2">&lt;xref:System.Single&gt;</ph> values to the desired precision before performing the comparison.</source>
          <target state="translated">Dans ce cas, le problème peut être résolu en appelant le <ph id="ph1">&lt;xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> méthode pour arrondir le <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeurs à la précision souhaitée avant d’effectuer la comparaison.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>A mathematical or comparison operation that uses a floating-point number might not yield the same result if a decimal number is used, because the binary floating-point number might not equal the decimal number.</source>
          <target state="translated">Une opération mathématique ou de comparaison qui utilise un nombre à virgule flottante peut ne pas donne le même résultat si un nombre décimal est utilisé, car le nombre à virgule flottante binaire ne peut pas égal au nombre décimal.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>A previous example illustrated this by displaying the result of multiplying .3 by 10 and adding .3 to .3 nine times.</source>
          <target state="translated">Un exemple précédent illustre cela en affichant le résultat de la multiplication.3 par 10 et en ajoutant.3 à.3 neuf fois.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>When accuracy in numeric operations with fractional values is important, use the <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> type instead of the <ph id="ph2">&lt;xref:System.Single&gt;</ph> type.</source>
          <target state="translated">Lorsque la précision dans les opérations numériques avec les valeurs fractionnaires est importante, utilisez la <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> de type au lieu du <ph id="ph2">&lt;xref:System.Single&gt;</ph> type.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>When accuracy in numeric operations with integral values beyond the range of the <ph id="ph1">&lt;xref:System.Int64&gt;</ph> or <ph id="ph2">&lt;xref:System.UInt64&gt;</ph> types is important, use the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> type.</source>
          <target state="translated">Lors de la précision dans les opérations numériques avec des valeurs intégrales au-delà de la plage de la <ph id="ph1">&lt;xref:System.Int64&gt;</ph> ou <ph id="ph2">&lt;xref:System.UInt64&gt;</ph> types est important, utilisez le <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> type.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>A value might not round-trip if a floating-point number is involved.</source>
          <target state="translated">Une valeur ne peut pas effectuer un aller-retour si un nombre à virgule flottante est impliqué.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>A value is said to round-trip if an operation converts an original floating-point number to another form, an inverse operation transforms the converted form back to a floating-point number, and the final floating-point number is equal to the original floating-point number.</source>
          <target state="translated">Une valeur est dite d’aller-retour si une opération convertit un nombre à virgule flottante d’origine dans un autre format, l’opération inverse retransforme la forme convertie en nombre à virgule flottante et le nombre à virgule flottante final est égal à celle d’origine nombre à virgule flottante.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The round trip might fail because one or more least significant digits are lost or changed in a conversion.</source>
          <target state="translated">L’aller-retour peut échouer, car un ou plusieurs chiffres les moins significatifs sont perdus ou ont changé dans une conversion.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>In the following example, three <ph id="ph1">&lt;xref:System.Single&gt;</ph> values are converted to strings and saved in a file.</source>
          <target state="translated">Dans l’exemple suivant, trois <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeurs sont converties en chaînes et enregistrés dans un fichier.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>As the output shows, although the values appear to be identical, the restored values are not equal to the original values.</source>
          <target state="translated">Comme le montre la sortie, bien que les valeurs semblent identiques, les valeurs de restaurée ne sont pas égales aux valeurs d’origine.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>In this case, the values can be successfully round-tripped by using the "G9" <bpt id="p1">[</bpt>standard numeric format string<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> to preserve the full precision of <ph id="ph1">&lt;xref:System.Single&gt;</ph> values, as the following example shows.</source>
          <target state="translated">Dans ce cas, les valeurs peuvent être le correctement un aller-retour à l’aide de la « G9 » <bpt id="p1">[</bpt>chaîne de format numérique standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> pour conserver la précision de <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeurs, comme le montre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><ph id="ph1">&lt;xref:System.Single&gt;</ph> values have less precision than <ph id="ph2">&lt;xref:System.Double&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Single&gt;</ph> les valeurs ont moins de précision que <ph id="ph2">&lt;xref:System.Double&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>A <ph id="ph1">&lt;xref:System.Single&gt;</ph> value that is converted to a seemingly equivalent <ph id="ph2">&lt;xref:System.Double&gt;</ph> often does not equal the <ph id="ph3">&lt;xref:System.Double&gt;</ph> value because of differences in precision.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur est convertie en un équivalent apparemment <ph id="ph2">&lt;xref:System.Double&gt;</ph> souvent n’est pas égale la <ph id="ph3">&lt;xref:System.Double&gt;</ph> valeur en raison de différences de précision.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>In the following example, the result of identical division operations is assigned to a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value and a <ph id="ph2">&lt;xref:System.Single&gt;</ph> value.</source>
          <target state="translated">Dans l’exemple suivant, le résultat des opérations de division identique est assigné à un <ph id="ph1">&lt;xref:System.Double&gt;</ph> valeur et un <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeur.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>After the <ph id="ph1">&lt;xref:System.Single&gt;</ph> value is cast to a <ph id="ph2">&lt;xref:System.Double&gt;</ph>, a comparison of the two values shows that they are unequal.</source>
          <target state="translated">Après le <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur est effectuée en une <ph id="ph2">&lt;xref:System.Double&gt;</ph>, une comparaison des deux valeurs indique qu’elles sont inégales.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>To avoid this problem, either use the <ph id="ph1">&lt;xref:System.Double&gt;</ph> data type in place of the <ph id="ph2">&lt;xref:System.Single&gt;</ph> data type, or use the <ph id="ph3">&lt;xref:System.Math.Round%2A&gt;</ph> method so that both values have the same precision.</source>
          <target state="translated">Pour éviter ce problème, utilisez le <ph id="ph1">&lt;xref:System.Double&gt;</ph> de type de données à la place de la <ph id="ph2">&lt;xref:System.Single&gt;</ph> type de données, ou utilisez le <ph id="ph3">&lt;xref:System.Math.Round%2A&gt;</ph> méthode afin que les deux valeurs ont la même précision.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Testing for equality</source>
          <target state="translated">Test d’égalité</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>To be considered equal, two <ph id="ph1">&lt;xref:System.Single&gt;</ph> values must represent identical values.</source>
          <target state="translated">Pour être considérées comme égales, deux <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeurs doivent représenter des valeurs identiques.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>However, because of differences in precision between values, or because of a loss of precision by one or both values, floating-point values that are expected to be identical often turn out to be unequal due to differences in their least significant digits.</source>
          <target state="translated">Toutefois, en raison de différences de précision entre les valeurs, ou en raison d’une perte de précision par une ou deux valeurs, les valeurs à virgule flottante qui doivent être identiques souvent activer japonaises en raison de différences dans leurs chiffres les moins significatifs.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>As a result, calls to the <ph id="ph1">&lt;xref:System.Single.Equals%2A&gt;</ph> method to determine whether two values are equal, or calls to the <ph id="ph2">&lt;xref:System.Single.CompareTo%2A&gt;</ph> method to determine the relationship between two <ph id="ph3">&lt;xref:System.Single&gt;</ph> values, often yield unexpected results.</source>
          <target state="translated">Par conséquent, les appels à la <ph id="ph1">&lt;xref:System.Single.Equals%2A&gt;</ph> méthode pour déterminer si deux valeurs sont égales ou les appels à la <ph id="ph2">&lt;xref:System.Single.CompareTo%2A&gt;</ph> méthode pour déterminer la relation entre deux <ph id="ph3">&lt;xref:System.Single&gt;</ph> valeurs, souvent provoquer des résultats inattendus.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>This is evident in the following example, where two apparently equal <ph id="ph1">&lt;xref:System.Single&gt;</ph> values turn out to be unequal, because the first value has 7 digits of precision, whereas the second value has 9.</source>
          <target state="translated">Ceci est évident dans l’exemple suivant, où deux égal apparemment <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeurs semblent pour être égaux, car la première valeur est 7 chiffres de précision, alors que la deuxième valeur est 9.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Calculated values that follow different code paths and that are manipulated in different ways often prove to be unequal.</source>
          <target state="translated">Les valeurs calculées qui suivent des chemins de code différents, et qui sont manipulés de différentes façons, souvent s’avérer inégaux.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>In the following example, one <ph id="ph1">&lt;xref:System.Single&gt;</ph> value is squared, and then the square root is calculated to restore the original value.</source>
          <target state="translated">Dans l’exemple suivant, un <ph id="ph1">&lt;xref:System.Single&gt;</ph> carrée de la valeur, puis la racine carrée est calculée pour restaurer la valeur d’origine.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>A second <ph id="ph1">&lt;xref:System.Single&gt;</ph> is multiplied by 3.51 and squared before the square root of the result is divided by 3.51 to restore the original value.</source>
          <target state="translated">Une seconde <ph id="ph1">&lt;xref:System.Single&gt;</ph> est multipliée par 3.51 et carré avant la racine carrée du résultat est divisée par 3.51 pour restaurer la valeur d’origine.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Although the two values appear to be identical, a call to the <ph id="ph1">&lt;xref:System.Single.Equals%28System.Single%29&gt;</ph> method indicates that they are not equal.</source>
          <target state="translated">Bien que les deux valeurs semblent identiques, un appel à la <ph id="ph1">&lt;xref:System.Single.Equals%28System.Single%29&gt;</ph> méthode indique qu’ils ne sont pas égaux.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Using the "G9" standard format string to return a result string that displays all the significant digits of each <ph id="ph1">&lt;xref:System.Single&gt;</ph> value shows that the second value is .0000000000001 less than the first.</source>
          <target state="translated">À l’aide de la chaîne de format standard « G9 » pour renvoyer une chaîne de résultat qui affiche tous les chiffres significatifs de chaque <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur indique que la deuxième valeur est.0000000000001 inférieure à la première.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>In cases where a loss of precision is likely to affect the result of a comparison, you can use the following techniques instead of calling the <ph id="ph1">&lt;xref:System.Single.Equals%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Single.CompareTo%2A&gt;</ph> method:</source>
          <target state="translated">Dans les cas où une perte de précision est susceptible d’affecter le résultat d’une comparaison, vous pouvez utiliser les techniques suivantes au lieu d’appeler le <ph id="ph1">&lt;xref:System.Single.Equals%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Single.CompareTo%2A&gt;</ph> méthode :</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Call the <ph id="ph1">&lt;xref:System.Math.Round%2A?displayProperty=nameWithType&gt;</ph> method to ensure that both values have the same precision.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Math.Round%2A?displayProperty=nameWithType&gt;</ph> pour s’assurer que les deux valeurs ont la même précision.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The following example modifies a previous example to use this approach so that two fractional values are equivalent.</source>
          <target state="translated">L’exemple suivant modifie un exemple précédent pour utiliser cette approche afin que les deux valeurs fractionnaires sont équivalents.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Note that the problem of precision still applies to rounding of midpoint values.</source>
          <target state="translated">Notez que le problème de précision s’applique toujours à l’arrondi des valeurs du milieu.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour plus d'informations, voir la méthode <ph id="ph1">&lt;xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Test for approximate equality instead of equality.</source>
          <target state="translated">Tester l’égalité approximative au lieu de l’égalité.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>This technique requires that you define either an absolute amount by which the two values can differ but still be equal, or that you define a relative amount by which the smaller value can diverge from the larger value.</source>
          <target state="translated">Cette technique requiert que vous définissez soit absolu montant par lequel les deux valeurs peuvent différer mais toujours être égal ou que vous définissez une quantité relative par lequel la plus petite valeur peut différer de la plus grande valeur.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><ph id="ph1">&lt;xref:System.Single.Epsilon?displayProperty=nameWithType&gt;</ph> is sometimes used as an absolute measure of the distance between two <ph id="ph2">&lt;xref:System.Single&gt;</ph> values when testing for equality.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Single.Epsilon?displayProperty=nameWithType&gt;</ph> est parfois utilisé en tant qu’une mesure absolue de la distance entre deux <ph id="ph2">&lt;xref:System.Single&gt;</ph> lors du test d’égalité des valeurs.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>However, <ph id="ph1">&lt;xref:System.Single.Epsilon?displayProperty=nameWithType&gt;</ph> measures the smallest possible value that can be added to, or subtracted from, a <ph id="ph2">&lt;xref:System.Single&gt;</ph> whose value is zero.</source>
          <target state="translated">Toutefois, <ph id="ph1">&lt;xref:System.Single.Epsilon?displayProperty=nameWithType&gt;</ph> mesure la plus petite valeur possible qui peut être ajoutée à ou soustrait de, un <ph id="ph2">&lt;xref:System.Single&gt;</ph> dont la valeur est égale à zéro.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>For most positive and negative <ph id="ph1">&lt;xref:System.Single&gt;</ph> values, the value of <ph id="ph2">&lt;xref:System.Single.Epsilon?displayProperty=nameWithType&gt;</ph> is too small to be detected.</source>
          <target state="translated">Pour la plupart des nombres positifs et négatifs <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeurs, la valeur de <ph id="ph2">&lt;xref:System.Single.Epsilon?displayProperty=nameWithType&gt;</ph> est trop petite pour être détecté.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Therefore, except for values that are zero, we do not recommend its use in tests for equality.</source>
          <target state="translated">Par conséquent, à l’exception des valeurs qui sont égales à zéro, nous déconseillons son utilisation dans les tests d’égalité.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The following example uses the latter approach to define an <ph id="ph1">`IsApproximatelyEqual`</ph> method that tests the relative difference between two values.</source>
          <target state="translated">L’exemple suivant utilise cette dernière approche pour définir un <ph id="ph1">`IsApproximatelyEqual`</ph> méthode qui teste la différence relative entre deux valeurs.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>It also contrasts the result of calls to the <ph id="ph1">`IsApproximatelyEqual`</ph> method and the <ph id="ph2">&lt;xref:System.Single.Equals%28System.Single%29&gt;</ph> method.</source>
          <target state="translated">Il compare également le résultat d’appels à la <ph id="ph1">`IsApproximatelyEqual`</ph> (méthode) et le <ph id="ph2">&lt;xref:System.Single.Equals%28System.Single%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Floating-point values and exceptions</source>
          <target state="translated">Exceptions et les valeurs à virgule flottante</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Operations with floating-point values do not throw exceptions, unlike operations with integral types, which throw exceptions in cases of illegal operations such as division by zero or overflow.</source>
          <target state="translated">Opérations avec des valeurs à virgule flottante ne lèvent pas d’exceptions, contrairement aux opérations avec des types intégraux, qui lèvent des exceptions dans le cas des opérations illégales telles que la division par zéro ou de dépassement de capacité.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Instead, in these situations, the result of a floating-point operation is zero, positive infinity, negative infinity, or not a number (NaN):</source>
          <target state="translated">Au lieu de cela, dans ce cas, le résultat d’une opération à virgule flottante est zéro, l’infini positif, l’infini négatif ou une valeur non numérique (NaN) :</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>If the result of a floating-point operation is too small for the destination format, the result is zero.</source>
          <target state="translated">Si le résultat d’une opération à virgule flottante est trop petit pour le format de destination, le résultat est zéro.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>This can occur when two very small floating-point numbers are multiplied, as the following example shows.</source>
          <target state="translated">Cela peut se produire lorsque deux nombres à virgule flottante très petites sont multipliés, comme le montre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>If the magnitude of the result of a floating-point operation exceeds the range of the destination format, the result of the operation is <ph id="ph1">&lt;xref:System.Single.PositiveInfinity&gt;</ph> or <ph id="ph2">&lt;xref:System.Single.NegativeInfinity&gt;</ph>, as appropriate for the sign of the result.</source>
          <target state="translated">Si la grandeur du résultat d’une opération à virgule flottante dépasse la plage du format de destination, le résultat de l’opération est <ph id="ph1">&lt;xref:System.Single.PositiveInfinity&gt;</ph> ou <ph id="ph2">&lt;xref:System.Single.NegativeInfinity&gt;</ph>, selon le cas pour le signe du résultat.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The result of an operation that overflows <ph id="ph1">&lt;xref:System.Single.MaxValue?displayProperty=nameWithType&gt;</ph> is <ph id="ph2">&lt;xref:System.Single.PositiveInfinity&gt;</ph>, and the result of an operation that overflows <ph id="ph3">&lt;xref:System.Single.MinValue?displayProperty=nameWithType&gt;</ph> is <ph id="ph4">&lt;xref:System.Single.NegativeInfinity&gt;</ph>, as the following example shows.</source>
          <target state="translated">Le résultat d’une opération qui déborde <ph id="ph1">&lt;xref:System.Single.MaxValue?displayProperty=nameWithType&gt;</ph> est <ph id="ph2">&lt;xref:System.Single.PositiveInfinity&gt;</ph>et le résultat d’une opération qui déborde <ph id="ph3">&lt;xref:System.Single.MinValue?displayProperty=nameWithType&gt;</ph> est <ph id="ph4">&lt;xref:System.Single.NegativeInfinity&gt;</ph>, comme le montre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><ph id="ph1">&lt;xref:System.Single.PositiveInfinity&gt;</ph> also results from a division by zero with a positive dividend, and <ph id="ph2">&lt;xref:System.Single.NegativeInfinity&gt;</ph> results from a division by zero with a negative dividend.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Single.PositiveInfinity&gt;</ph> également des résultats à partir d’une division par zéro avec un dividende positif, et <ph id="ph2">&lt;xref:System.Single.NegativeInfinity&gt;</ph> résultant d’une division par zéro avec un dividende négatif.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>If a floating-point operation is invalid, the result of the operation is <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph>.</source>
          <target state="translated">Si une opération en virgule flottante n’est pas valide, le résultat de l’opération est <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>For example, <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph> results from the following operations:</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph> des résultats des opérations suivantes :</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Division by zero with a dividend of zero.</source>
          <target state="translated">Division par zéro avec un dividende égale à zéro.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Note that other cases of division by zero result in either <ph id="ph1">&lt;xref:System.Single.PositiveInfinity&gt;</ph> or <ph id="ph2">&lt;xref:System.Single.NegativeInfinity&gt;</ph>.</source>
          <target state="translated">Notez que les autres cas de division par zéro résultat, que ce soit <ph id="ph1">&lt;xref:System.Single.PositiveInfinity&gt;</ph> ou <ph id="ph2">&lt;xref:System.Single.NegativeInfinity&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Any floating-point operation with invalid input.</source>
          <target state="translated">Toute opération à virgule flottante avec une entrée non valide.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>For example, attempting to find the square root of a negative value returns <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph>.</source>
          <target state="translated">Par exemple, la tentative de trouver la racine carrée d’une valeur négative retourne <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Any operation with an argument whose value is <ph id="ph1">&lt;xref:System.Single.NaN?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Toute opération avec un argument dont la valeur est <ph id="ph1">&lt;xref:System.Single.NaN?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Type conversions and the Single structure</source>
          <target state="translated">Conversions de type et la structure unique</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The <ph id="ph1">&lt;xref:System.Single&gt;</ph> structure does not define any explicit or implicit conversion operators; instead, conversions are implemented by the compiler.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single&gt;</ph> structure ne définit pas de tous les opérateurs de conversion explicite ou implicite ; au lieu de cela, les conversions sont implémentées par le compilateur.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The following table lists the possible conversions of a value of the other primitive numeric types to a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value, It also indicates whether the conversion is widening or narrowing and whether the resulting <ph id="ph2">&lt;xref:System.Single&gt;</ph> may have less precision than the original value.</source>
          <target state="translated">Le tableau suivant répertorie les conversions possibles d’une valeur pour les autres types numériques primitifs à un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur, il indique également si la conversion est restrictive ou étendue et si résultant <ph id="ph2">&lt;xref:System.Single&gt;</ph> peut avoir une précision inférieure à la valeur d’origine.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Conversion from</source>
          <target state="translated">Conversion de</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Widening/narrowing</source>
          <target state="translated">Étendues/restrictives</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Possible loss of precision</source>
          <target state="translated">Perte de précision</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Widening</source>
          <target state="translated">Widening</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>No</source>
          <target state="translated">Non</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Widening</source>
          <target state="translated">Widening</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Note that C# requires a cast operator.</source>
          <target state="translated">Notez que c# nécessite un opérateur de conversion.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Yes.</source>
          <target state="translated">Oui.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><ph id="ph1">&lt;xref:System.Decimal&gt;</ph> supports 29 decimal digits of precision; <ph id="ph2">&lt;xref:System.Single&gt;</ph> supports 9.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Decimal&gt;</ph> prend en charge de 29 chiffres décimaux de précision. <ph id="ph2">&lt;xref:System.Single&gt;</ph> prend en charge 9.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Narrowing; out-of-range values are converted to <ph id="ph1">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Restrictives ; out-of-range valeurs sont converties en <ph id="ph1">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph> ou <ph id="ph2">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Yes.</source>
          <target state="translated">Oui.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><ph id="ph1">&lt;xref:System.Double&gt;</ph> supports 17 decimal digits of precision; <ph id="ph2">&lt;xref:System.Single&gt;</ph> supports 9.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Double&gt;</ph> prend en charge de 17 chiffres décimaux de précision. <ph id="ph2">&lt;xref:System.Single&gt;</ph> prend en charge 9.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Widening</source>
          <target state="translated">Widening</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>No</source>
          <target state="translated">Non</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Widening</source>
          <target state="translated">Widening</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Yes.</source>
          <target state="translated">Oui.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><ph id="ph1">&lt;xref:System.Int32&gt;</ph> supports 10 decimal digits of precision; <ph id="ph2">&lt;xref:System.Single&gt;</ph> supports 9.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Int32&gt;</ph> prend en charge de 10 chiffres décimaux de précision. <ph id="ph2">&lt;xref:System.Single&gt;</ph> prend en charge 9.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Widening</source>
          <target state="translated">Widening</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Yes.</source>
          <target state="translated">Oui.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><ph id="ph1">&lt;xref:System.Int64&gt;</ph> supports 19 decimal digits of precision; <ph id="ph2">&lt;xref:System.Single&gt;</ph> supports 9.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Int64&gt;</ph> prend en charge de 19 chiffres décimaux de précision. <ph id="ph2">&lt;xref:System.Single&gt;</ph> prend en charge 9.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Widening</source>
          <target state="translated">Widening</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>No</source>
          <target state="translated">Non</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Widening</source>
          <target state="translated">Widening</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>No</source>
          <target state="translated">Non</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Widening</source>
          <target state="translated">Widening</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Yes.</source>
          <target state="translated">Oui.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><ph id="ph1">&lt;xref:System.UInt32&gt;</ph> supports 10 decimal digits of precision; <ph id="ph2">&lt;xref:System.Single&gt;</ph> supports 9.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.UInt32&gt;</ph> prend en charge de 10 chiffres décimaux de précision. <ph id="ph2">&lt;xref:System.Single&gt;</ph> prend en charge 9.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Widening</source>
          <target state="translated">Widening</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Yes.</source>
          <target state="translated">Oui.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><ph id="ph1">&lt;xref:System.Int64&gt;</ph> supports 20 decimal digits of precision; <ph id="ph2">&lt;xref:System.Single&gt;</ph> supports 9.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Int64&gt;</ph> prend en charge 20 chiffres décimaux de précision. <ph id="ph2">&lt;xref:System.Single&gt;</ph> prend en charge 9.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The following example converts the minimum or maximum value of other primitive numeric types to a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value.</source>
          <target state="translated">L’exemple suivant convertit la valeur minimale ou maximale d’autres types numériques primitifs à un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>In addition, the <ph id="ph1">&lt;xref:System.Double&gt;</ph> values <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph> covert to <ph id="ph5">&lt;xref:System.Single.NaN?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.Single.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, and <ph id="ph7">&lt;xref:System.Single.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, respectively.</source>
          <target state="translated">En outre, le <ph id="ph1">&lt;xref:System.Double&gt;</ph> valeurs <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, et <ph id="ph4">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph> cachées à <ph id="ph5">&lt;xref:System.Single.NaN?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.Single.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, et <ph id="ph7">&lt;xref:System.Single.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, respectivement.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Note that the conversion of the value of some numeric types to a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value can involve a loss of precision.</source>
          <target state="translated">Notez que la conversion de la valeur de certains types numériques à un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur peut entraîner une perte de précision.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>As the example illustrates, a loss of precision is possible when converting <ph id="ph1">&lt;xref:System.Decimal&gt;</ph>, <ph id="ph2">&lt;xref:System.Double&gt;</ph>, <ph id="ph3">&lt;xref:System.Int32&gt;</ph>, <ph id="ph4">&lt;xref:System.Int64&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt32&gt;</ph>, and <ph id="ph6">&lt;xref:System.UInt64&gt;</ph> values to <ph id="ph7">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">Comme l’illustre l’exemple, une perte de précision est possible lors de la conversion <ph id="ph1">&lt;xref:System.Decimal&gt;</ph>, <ph id="ph2">&lt;xref:System.Double&gt;</ph>, <ph id="ph3">&lt;xref:System.Int32&gt;</ph>, <ph id="ph4">&lt;xref:System.Int64&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt32&gt;</ph>, et <ph id="ph6">&lt;xref:System.UInt64&gt;</ph> valeurs <ph id="ph7">&lt;xref:System.Single&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The conversion of a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value to a <ph id="ph2">&lt;xref:System.Double&gt;</ph> is a widening conversion.</source>
          <target state="translated">La conversion d’un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur un <ph id="ph2">&lt;xref:System.Double&gt;</ph> est une conversion étendue.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The conversion may result in a loss of precision if the <ph id="ph1">&lt;xref:System.Double&gt;</ph> type does not have a precise representation for the <ph id="ph2">&lt;xref:System.Single&gt;</ph> value.</source>
          <target state="translated">La conversion peut entraîner une perte de précision si le <ph id="ph1">&lt;xref:System.Double&gt;</ph> type n’a pas de représentation précise pour le <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeur.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The conversion of a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value to a value of any primitive numeric data type other than a <ph id="ph2">&lt;xref:System.Double&gt;</ph> is a narrowing conversion and requires a cast operator (in C#) or a conversion method (in Visual Basic).</source>
          <target state="translated">La conversion d’un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur autre que pour une valeur de tout type numérique primitif un <ph id="ph2">&lt;xref:System.Double&gt;</ph> est une conversion restrictive et nécessite un opérateur de conversion (en c#) ou une méthode de conversion (en Visual Basic).</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Values that are outside the range of the target data type, which are defined by the target type's <ph id="ph1">`MinValue`</ph> and <ph id="ph2">`MaxValue`</ph> properties, behave as shown in the following table.</source>
          <target state="translated">Les valeurs sont en dehors de la plage du type de données cible, qui sont définies par le type de cible <ph id="ph1">`MinValue`</ph> et <ph id="ph2">`MaxValue`</ph> se comportent des propriétés, comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Target type</source>
          <target state="translated">Type cible</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Result</source>
          <target state="translated">Résultat</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Any integral type</source>
          <target state="translated">Tout type intégral</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>An <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> exception if the conversion occurs in a checked context.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> exception si la conversion se produit dans un contexte vérifié.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>If the conversion occurs in an unchecked context (the default in C#), the conversion operation succeeds but the value overflows.</source>
          <target state="translated">Si la conversion se produit dans un contexte non vérifié (la valeur par défaut en c#), l’opération de conversion réussit, mais la valeur dépasse.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>An <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> exception,</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> exception,</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>In addition, <ph id="ph1">&lt;xref:System.Single.NaN?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Single.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Single.NegativeInfinity?displayProperty=nameWithType&gt;</ph> throw an <ph id="ph4">&lt;xref:System.OverflowException&gt;</ph> for conversions to integers in a checked context, but these values overflow when converted to integers in an unchecked context.</source>
          <target state="translated">En outre, <ph id="ph1">&lt;xref:System.Single.NaN?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Single.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, et <ph id="ph3">&lt;xref:System.Single.NegativeInfinity?displayProperty=nameWithType&gt;</ph> lever un <ph id="ph4">&lt;xref:System.OverflowException&gt;</ph> pour les conversions de nombres entiers dans un contexte vérifié, mais ces dépassement des valeurs lorsque convertis en entiers dans un contexte non vérifié.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>For conversions to <ph id="ph1">&lt;xref:System.Decimal&gt;</ph>, they always throw an <ph id="ph2">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Pour les conversions <ph id="ph1">&lt;xref:System.Decimal&gt;</ph>, elles lèvent toujours un <ph id="ph2">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>For conversions to <ph id="ph1">&lt;xref:System.Double&gt;</ph>, they convert to <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, respectively.</source>
          <target state="translated">Pour les conversions <ph id="ph1">&lt;xref:System.Double&gt;</ph>, ils convertissent <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, et <ph id="ph4">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, respectivement.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Note that a loss of precision may result from converting a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value to another numeric type.</source>
          <target state="translated">Notez qu’une perte de précision peut entraîner de convertir un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur à un autre type numérique.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>In the case of converting non-integral <ph id="ph1">&lt;xref:System.Single&gt;</ph> values, as the output from the example shows, the fractional component is lost when the <ph id="ph2">&lt;xref:System.Single&gt;</ph> value is either rounded (as in Visual Basic) or truncated (as in C#).</source>
          <target state="translated">Dans le cas de conversion non intégral <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeurs, comme le montre la sortie de l’exemple, la partie fractionnaire est perdue lorsque le <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeur est arrondie (comme dans Visual Basic) ou tronqué (comme dans c#).</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>For conversions to <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> and <ph id="ph2">&lt;xref:System.Double&gt;</ph> values, the <ph id="ph3">&lt;xref:System.Single&gt;</ph> value may not have a precise representation in the target data type.</source>
          <target state="translated">Pour les conversions <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> et <ph id="ph2">&lt;xref:System.Double&gt;</ph> valeurs, le <ph id="ph3">&lt;xref:System.Single&gt;</ph> valeur ne peut pas avoir de représentation précise dans le type de données cible.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The following example converts a number of <ph id="ph1">&lt;xref:System.Single&gt;</ph> values to several other numeric types.</source>
          <target state="translated">L’exemple suivant convertit un nombre de <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeurs à plusieurs autres types numériques.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The conversions occur in a checked context in Visual Basic (the default) and in C# (because of the <bpt id="p1">[</bpt>checked<ept id="p1">](~/docs/csharp/language-reference/keywords/checked.md)</ept> keyword).</source>
          <target state="translated">Les conversions se produisent dans un contexte vérifié en Visual Basic (la valeur par défaut) et en c# (raison de la <bpt id="p1">[</bpt>vérifiée<ept id="p1">](~/docs/csharp/language-reference/keywords/checked.md)</ept> mot clé).</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The output from the example shows the result for conversions in both a checked an unchecked context.</source>
          <target state="translated">La sortie de l’exemple montre le résultat des conversions a été archivé à la fois un contexte non vérifié.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>You can perform conversions in an unchecked context in Visual Basic by compiling with the <ph id="ph1">`/removeintchecks+`</ph> compiler switch and in C# by commenting out the <ph id="ph2">`checked`</ph> statement.</source>
          <target state="translated">Vous pouvez effectuer des conversions dans un contexte unchecked en Visual Basic en compilant avec le <ph id="ph1">`/removeintchecks+`</ph> commutateur de compilateur et en c#, en supprimant la <ph id="ph2">`checked`</ph> instruction.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>For more information on the conversion of numeric types, see <bpt id="p1">[</bpt>Type Conversion in the .NET Framework<ept id="p1">](~/docs/standard/base-types/type-conversion.md)</ept> and <bpt id="p2">[</bpt>Type Conversion Tables<ept id="p2">](~/docs/standard/base-types/conversion-tables.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la conversion des types numériques, consultez <bpt id="p1">[</bpt>Conversion de Type dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/type-conversion.md)</ept> et <bpt id="p2">[</bpt>tableaux de Conversion de Type<ept id="p2">](~/docs/standard/base-types/conversion-tables.md)</ept>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Floating-point functionality</source>
          <target state="translated">Fonctionnalité à virgule flottante</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The <ph id="ph1">&lt;xref:System.Single&gt;</ph> structure and related types provide methods to perform the following categories of operations:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single&gt;</ph> structure et les types associés fournissent des méthodes pour effectuer les catégories suivantes d’opérations :</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><bpt id="p1">**</bpt>Comparison of values<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Comparaison de valeurs<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>You can call the <ph id="ph1">&lt;xref:System.Single.Equals%2A&gt;</ph> method to determine whether two <ph id="ph2">&lt;xref:System.Single&gt;</ph> values are equal, or the <ph id="ph3">&lt;xref:System.Single.CompareTo%2A&gt;</ph> method to determine the relationship between two values.</source>
          <target state="translated">Vous pouvez appeler la <ph id="ph1">&lt;xref:System.Single.Equals%2A&gt;</ph> méthode pour déterminer si deux <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeurs sont égales, ou le <ph id="ph3">&lt;xref:System.Single.CompareTo%2A&gt;</ph> méthode pour déterminer la relation entre deux valeurs.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The <ph id="ph1">&lt;xref:System.Single&gt;</ph> structure also supports a complete set of comparison operators.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single&gt;</ph> prend également en charge un jeu complet d’opérateurs de comparaison.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>For example, you can test for equality or inequality, or determine whether one value is greater than or equal to another value.</source>
          <target state="translated">Par exemple, vous pouvez tester l’égalité ou d’inégalité, ou déterminer si une valeur est supérieure ou égale à une autre valeur.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>If one of the operands is a <ph id="ph1">&lt;xref:System.Double&gt;</ph>, the <ph id="ph2">&lt;xref:System.Single&gt;</ph> value is converted to a <ph id="ph3">&lt;xref:System.Double&gt;</ph> before performing the comparison.</source>
          <target state="translated">Si l’un des opérandes est une <ph id="ph1">&lt;xref:System.Double&gt;</ph>, le <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeur est convertie en un <ph id="ph3">&lt;xref:System.Double&gt;</ph> avant d’effectuer la comparaison.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>If one of the operands is an integral type, it is converted to a <ph id="ph1">&lt;xref:System.Single&gt;</ph> before performing the comparison.</source>
          <target state="translated">Si l’un des opérandes est un type intégral, il est converti en un <ph id="ph1">&lt;xref:System.Single&gt;</ph> avant d’effectuer la comparaison.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Although these are widening conversions, they may involve a loss of precision.</source>
          <target state="translated">Bien que ceux-ci sont des conversions étendues, elles peuvent impliquer une perte de précision.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Because of differences in precision, two <ph id="ph1">&lt;xref:System.Single&gt;</ph> values that you expect to be equal may turn out to be unequal, which affects the result of the comparison.</source>
          <target state="translated">En raison de différences de précision, deux <ph id="ph1">&lt;xref:System.Single&gt;</ph> les valeurs que vous pensez être égal peuvent s’avérer pour être égaux, ce qui affecte le résultat de la comparaison.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>See the <bpt id="p1">[</bpt>Testing for equality<ept id="p1">](#Equality)</ept> section for more information about comparing two <ph id="ph1">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">Consultez le <bpt id="p1">[</bpt>test d’égalité<ept id="p1">](#Equality)</ept> section pour plus d’informations sur la comparaison de deux <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>You can also call the <ph id="ph1">&lt;xref:System.Single.IsNaN%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Single.IsInfinity%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Single.IsPositiveInfinity%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Single.IsNegativeInfinity%2A&gt;</ph> methods to test for these special values.</source>
          <target state="translated">Vous pouvez également appeler le <ph id="ph1">&lt;xref:System.Single.IsNaN%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Single.IsInfinity%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Single.IsPositiveInfinity%2A&gt;</ph>, et <ph id="ph4">&lt;xref:System.Single.IsNegativeInfinity%2A&gt;</ph> méthodes pour tester ces valeurs spéciales.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><bpt id="p1">**</bpt>Mathematical operations<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Opérations mathématiques<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Common arithmetic operations such as addition, subtraction, multiplication, and division are implemented by language compilers and Common Intermediate Language (CIL) instructions rather than by <ph id="ph1">&lt;xref:System.Single&gt;</ph> methods.</source>
          <target state="translated">Les opérations arithmétiques courantes telles que l’addition, soustraction, multiplication et division sont implémentées par les compilateurs de langage et les instructions du langage CIL (Common Intermediate) plutôt que par <ph id="ph1">&lt;xref:System.Single&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>If the other operand in a mathematical operation is a <ph id="ph1">&lt;xref:System.Double&gt;</ph>, the <ph id="ph2">&lt;xref:System.Single&gt;</ph> is converted to a <ph id="ph3">&lt;xref:System.Double&gt;</ph> before performing the operation, and the result of the operation is also a <ph id="ph4">&lt;xref:System.Double&gt;</ph> value.</source>
          <target state="translated">Si l’autre opérande dans une opération mathématique est un <ph id="ph1">&lt;xref:System.Double&gt;</ph>, le <ph id="ph2">&lt;xref:System.Single&gt;</ph> est converti en un <ph id="ph3">&lt;xref:System.Double&gt;</ph> avant d’effectuer l’opération et le résultat de l’opération est également un <ph id="ph4">&lt;xref:System.Double&gt;</ph> valeur.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>If the other operand is an integral type, it is converted to a <ph id="ph1">&lt;xref:System.Single&gt;</ph> before performing the operation, and the result of the operation is also a <ph id="ph2">&lt;xref:System.Single&gt;</ph> value.</source>
          <target state="translated">Si l’autre opérande est un type intégral, il est converti en un <ph id="ph1">&lt;xref:System.Single&gt;</ph> avant d’effectuer l’opération et le résultat de l’opération est également un <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeur.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>You can perform other mathematical operations by calling <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) methods in the <ph id="ph3">&lt;xref:System.Math?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">Vous pouvez effectuer d’autres opérations mathématiques en appelant <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> en Visual Basic) les méthodes dans la <ph id="ph3">&lt;xref:System.Math?displayProperty=nameWithType&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>These include additional methods commonly used for arithmetic (such as <ph id="ph1">&lt;xref:System.Math.Abs%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Math.Sign%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Math.Sqrt%2A?displayProperty=nameWithType&gt;</ph>), geometry (such as <ph id="ph4">&lt;xref:System.Math.Cos%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Math.Sin%2A?displayProperty=nameWithType&gt;</ph>), and calculus (such as <ph id="ph6">&lt;xref:System.Math.Log%2A?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Parmi d’autres méthodes couramment utilisées pour les opérations arithmétiques (tels que <ph id="ph1">&lt;xref:System.Math.Abs%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Math.Sign%2A?displayProperty=nameWithType&gt;</ph>, et <ph id="ph3">&lt;xref:System.Math.Sqrt%2A?displayProperty=nameWithType&gt;</ph>), géométrie (tel que <ph id="ph4">&lt;xref:System.Math.Cos%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph5">&lt;xref:System.Math.Sin%2A?displayProperty=nameWithType&gt;</ph>) et le calcul (tels que <ph id="ph6">&lt;xref:System.Math.Log%2A?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>In all cases, the <ph id="ph1">&lt;xref:System.Single&gt;</ph> value is converted to a <ph id="ph2">&lt;xref:System.Double&gt;</ph>.</source>
          <target state="translated">Dans tous les cas, le <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur est convertie en un <ph id="ph2">&lt;xref:System.Double&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>You can also manipulate the individual bits in a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value.</source>
          <target state="translated">Vous pouvez également manipuler les bits individuels d’un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The <ph id="ph1">&lt;xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType&gt;</ph> method returns its bit pattern in a byte array.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType&gt;</ph> méthode retourne son modèle de bits dans un tableau d’octets.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>By passing that byte array to the <ph id="ph1">&lt;xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType&gt;</ph> method, you can also preserve the <ph id="ph2">&lt;xref:System.Single&gt;</ph> value's bit pattern in a 32-bit integer.</source>
          <target state="translated">En passant ce tableau d’octets à la <ph id="ph1">&lt;xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType&gt;</ph> (méthode), vous pouvez également conserver la <ph id="ph2">&lt;xref:System.Single&gt;</ph> modèle de valeur de bit dans un entier 32 bits.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><bpt id="p1">**</bpt>Rounding<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Arrondi<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Rounding is often used as a technique for reducing the impact of differences between values caused by problems of floating-point representation and precision.</source>
          <target state="translated">Arrondi est souvent utilisé comme une technique permettant de réduire l’impact des différences entre les valeurs provoquées par les problèmes de représentation à virgule flottante et de précision.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>You can round a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value by calling the <ph id="ph2">&lt;xref:System.Math.Round%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Vous pouvez arrondir un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur en appelant le <ph id="ph2">&lt;xref:System.Math.Round%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>However, note  that the <ph id="ph1">&lt;xref:System.Single&gt;</ph> value is converted to a <ph id="ph2">&lt;xref:System.Double&gt;</ph> before the method is called, and the conversion can involve a loss of precision.</source>
          <target state="translated">Toutefois, notez que le <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur est convertie en un <ph id="ph2">&lt;xref:System.Double&gt;</ph> avant de la méthode est appelée, la conversion peut impliquer une perte de précision.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><bpt id="p1">**</bpt>Formatting<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Mise en forme<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>You can convert a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value to its string representation by calling the <ph id="ph2">&lt;xref:System.Single.ToString%2A&gt;</ph> method or by using the <bpt id="p1">[</bpt>composite formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> feature.</source>
          <target state="translated">Vous pouvez convertir un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur à sa représentation sous forme de chaîne en appelant le <ph id="ph2">&lt;xref:System.Single.ToString%2A&gt;</ph> méthode ou à l’aide de la <bpt id="p1">[</bpt>mise en forme composite<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> fonctionnalité.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>For information about how format strings control the string representation of floating-point values, see the <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept> topics.</source>
          <target state="translated">Pour plus d’informations sur la façon dont les chaînes de format contrôlent la représentation sous forme de chaîne de valeurs à virgule flottante, consultez le <bpt id="p1">[</bpt>des chaînes de Format numériques Standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> et <bpt id="p2">[</bpt>les chaînes de Format numériques personnalisées<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept> rubriques.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><bpt id="p1">**</bpt>Parsing strings<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Analyser des chaînes<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>You can convert the string representation of a floating-point value to a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value by calling the <ph id="ph2">&lt;xref:System.Single.Parse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Single.TryParse%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez convertir la représentation sous forme de chaîne d’une valeur à virgule flottante à un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur en appelant le <ph id="ph2">&lt;xref:System.Single.Parse%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Single.TryParse%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>If the parse operation fails, the <ph id="ph1">&lt;xref:System.Single.Parse%2A&gt;</ph> method throws an exception, whereas the <ph id="ph2">&lt;xref:System.Single.TryParse%2A&gt;</ph> method returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Si l’opération d’analyse échoue, le <ph id="ph1">&lt;xref:System.Single.Parse%2A&gt;</ph> méthode lève une exception, tandis que la <ph id="ph2">&lt;xref:System.Single.TryParse%2A&gt;</ph> méthode renvoie <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><bpt id="p1">**</bpt>Type conversion<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Conversion de type<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The <ph id="ph1">&lt;xref:System.Single&gt;</ph> structure provides an explicit interface implementation for the <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface, which supports conversion between any two standard .NET Framework data types.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single&gt;</ph> structure fournit une implémentation d’interface explicite pour le <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface, qui prend en charge la conversion entre les deux types de données .NET Framework standards.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Language compilers also support the implicit conversion of values for all other standard numeric types except for the conversion of <ph id="ph1">&lt;xref:System.Double&gt;</ph> to <ph id="ph2">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">Compilateurs de langage prennent également en charge la conversion implicite des valeurs pour tous les autres types numériques standards, à l’exception de la conversion de <ph id="ph1">&lt;xref:System.Double&gt;</ph> à <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Conversion of a value of any standard numeric type other than a <ph id="ph1">&lt;xref:System.Double&gt;</ph> to a <ph id="ph2">&lt;xref:System.Single&gt;</ph> is a widening conversion and does not require the use of a casting operator or conversion method.</source>
          <target state="translated">Conversion d’une valeur de n’importe quel type numérique standard autres qu’un <ph id="ph1">&lt;xref:System.Double&gt;</ph> à un <ph id="ph2">&lt;xref:System.Single&gt;</ph> est une conversion étendue et ne nécessite pas l’utilisation d’une méthode d’opérateur ou de conversion cast.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>However, conversion of 32-bit and 64-bit integer values can involve a loss of precision.</source>
          <target state="translated">Toutefois, la conversion de valeurs entières 32 bits et 64 bits peut impliquer une perte de précision.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The following table lists the differences in precision for 32-bit, 64-bit, and <ph id="ph1">&lt;xref:System.Double&gt;</ph> types:</source>
          <target state="translated">Le tableau suivant répertorie les différences de précision de 32 bits, 64 bits, et <ph id="ph1">&lt;xref:System.Double&gt;</ph> types :</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Type</source>
          <target state="translated">Type</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Maximum precision (in decimal digits)</source>
          <target state="translated">Précision maximale (en chiffres décimaux)</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Internal precision (in decimal digits)</source>
          <target state="translated">Précision interne (en chiffres décimaux)</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>15</source>
          <target state="translated">15</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>17</source>
          <target state="translated">17</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><ph id="ph1">&lt;xref:System.Int32&gt;</ph> and <ph id="ph2">&lt;xref:System.UInt32&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Int32&gt;</ph> et <ph id="ph2">&lt;xref:System.UInt32&gt;</ph></target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>10</source>
          <target state="translated">10</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>10</source>
          <target state="translated">10</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source><ph id="ph1">&lt;xref:System.Int64&gt;</ph> and <ph id="ph2">&lt;xref:System.UInt64&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Int64&gt;</ph> et <ph id="ph2">&lt;xref:System.UInt64&gt;</ph></target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>19</source>
          <target state="translated">19</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>19</source>
          <target state="translated">19</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>7</source>
          <target state="translated">7</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>9</source>
          <target state="translated">9</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>The problem of precision most frequently affects <ph id="ph1">&lt;xref:System.Single&gt;</ph> values that are converted to <ph id="ph2">&lt;xref:System.Double&gt;</ph> values.</source>
          <target state="translated">Le problème de précision affecte plus fréquemment <ph id="ph1">&lt;xref:System.Single&gt;</ph> les valeurs sont converties en <ph id="ph2">&lt;xref:System.Double&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>In the following example, two values produced by identical division operations are unequal, because one of the values is a single-precision floating point value that is converted to a <ph id="ph1">&lt;xref:System.Double&gt;</ph>.</source>
          <target state="translated">Dans l’exemple suivant, deux valeurs produites par des opérations de division identiques sont inégales, car une des valeurs est une simple précision valeur à virgule flottante qui est convertie en un <ph id="ph1">&lt;xref:System.Double&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>All members of this type are thread safe.</source>
          <target state="translated">Tous les membres de ce type sont thread-safe.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>Members that appear to modify instance state actually return a new instance initialized with the new value.</source>
          <target state="translated">Les membres qui semblent modifier l’état de l’instance retournent en fait une nouvelle instance initialisée avec la nouvelle valeur.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Single">
          <source>As with any other type, reading and writing to a shared variable that contains an instance of this type must be protected by a lock to guarantee thread safety.</source>
          <target state="translated">Comme avec tout autre type, la lecture et en écriture à une variable partagée qui contient une instance de ce type doivent être protégées par un verrou pour garantir la sécurité des threads.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="T:System.Single">
          <source>Compares this instance to a specified object or to another <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> instance and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified object or the other <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> instance.</source>
          <target state="translated">Compare cette instance à un objet spécifié ou à une autre instance de <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> et retourne un entier qui indique si la valeur de cette instance est inférieure, égale ou supérieure à la valeur de l'objet spécifié ou de l'autre instance de <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source>An object to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objet à comparer ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source>Compares this instance to a specified object and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified object.</source>
          <target state="translated">Compare cette instance à un objet spécifié et retourne un entier qui indique si la valeur de cette instance est inférieure, égale ou supérieure à la valeur de l'objet spécifié.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source>A signed number indicating the relative values of this instance and <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Nombre signé indiquant les valeurs relatives de cette instance et <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valeur renvoyée</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Description</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Description</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Inférieur à zéro</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance is less than <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Cette instance est inférieure à <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source>This instance is not a number (<ph id="ph1">&lt;see cref="F:System.Single.NaN" /&gt;</ph>) and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is a number.</source>
          <target state="translated">Cette instance n'est pas un nombre (<ph id="ph1">&lt;see cref="F:System.Single.NaN" /&gt;</ph>) et <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est un nombre.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zéro</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance is equal to <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Cette instance est égale à <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source>This instance and value are both not a number (<ph id="ph1">&lt;see cref="F:System.Single.NaN" /&gt;</ph>), <ph id="ph2">&lt;see cref="F:System.Single.PositiveInfinity" /&gt;</ph>, or <ph id="ph3">&lt;see cref="F:System.Single.NegativeInfinity" /&gt;</ph>.</source>
          <target state="translated">Cette instance et cette valeur sont toutes deux des non-nombres (<ph id="ph1">&lt;see cref="F:System.Single.NaN" /&gt;</ph>), <ph id="ph2">&lt;see cref="F:System.Single.PositiveInfinity" /&gt;</ph> ou <ph id="ph3">&lt;see cref="F:System.Single.NegativeInfinity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Supérieur à zéro</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance is greater than <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Cette instance est supérieure à <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source>This instance is a number and <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not a number (<ph id="ph2">&lt;see cref="F:System.Single.NaN" /&gt;</ph>).</source>
          <target state="translated">Cette instance est un nombre et <ph id="ph1">&lt;paramref name="value" /&gt;</ph> n'est pas un nombre (<ph id="ph2">&lt;see cref="F:System.Single.NaN" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Object)">
          <source>The <ph id="ph1">`value`</ph> parameter must be <ph id="ph2">`null`</ph> or an instance of <ph id="ph3">&lt;xref:System.Single&gt;</ph>; otherwise, an exception is thrown.</source>
          <target state="translated">Le <ph id="ph1">`value`</ph> le paramètre doit être <ph id="ph2">`null`</ph> ou une instance de <ph id="ph3">&lt;xref:System.Single&gt;</ph>; sinon, une exception est levée.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Object)">
          <source>Any instance of <ph id="ph1">&lt;xref:System.Single&gt;</ph>, regardless of its value, is considered greater than <ph id="ph2">`null`</ph>.</source>
          <target state="translated">N’importe quelle instance de <ph id="ph1">&lt;xref:System.Single&gt;</ph>, quelle que soit sa valeur, est considéré comme supérieur à <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Object)">
          <source>Values must be identical to be considered equal.</source>
          <target state="translated">Les valeurs doivent être identiques pour être considérées comme égales.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Object)">
          <source>Particularly when floating-point values depend on multiple mathematical operations, it is common for them to lose precision and for their values to be nearly identical except for their least significant digits.</source>
          <target state="translated">En particulier lorsque les valeurs à virgule flottante dépendent de plusieurs opérations mathématiques, il est courant pour des pertes de précision et de leurs valeurs sont presque identiques à l’exception de leurs chiffres les moins significatifs.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Object)">
          <source>Because of this, the return value of the <ph id="ph1">&lt;xref:System.Single.CompareTo%2A&gt;</ph> method may seem surprising at times.</source>
          <target state="translated">Pour cette raison, la valeur de retour de la <ph id="ph1">&lt;xref:System.Single.CompareTo%2A&gt;</ph> méthode peut sembler surprenante dans certains cas.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Object)">
          <source>For example, multiplication by a particular value followed by division by the same value should produce the original value, but in the following example, the computed value turns out to be greater than the original value.</source>
          <target state="translated">Par exemple, la multiplication par une valeur particulière, suivie de division par la même valeur doit produire la valeur d’origine, mais dans l’exemple suivant, la valeur calculée s’avère pour être supérieure à la valeur d’origine.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Object)">
          <source>Showing all significant digits of the two values by using the "R" <bpt id="p1">[</bpt>standard numeric format string<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> indicates that the computed value differs from the original value in its least significant digits.</source>
          <target state="translated">Affichage de tous les chiffres significatifs des deux valeurs à l’aide de « R » <bpt id="p1">[</bpt>chaîne de format numérique standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> indique que la valeur calculée diffère de la valeur d’origine dans ses chiffres les moins significatifs.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Object)">
          <source>For information about handling such comparisons, see the Remarks section of the <ph id="ph1">&lt;xref:System.Single.Equals%28System.Single%29&gt;</ph> method.</source>
          <target state="translated">Pour plus d’informations sur la gestion de ces comparaisons, consultez la section Notes de la <ph id="ph1">&lt;xref:System.Single.Equals%28System.Single%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Object)">
          <source>This method is implemented to support the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface.</source>
          <target state="translated">Cette méthode est implémentée pour prendre en charge la <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Object)">
          <source>Note that, although a <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph> is not considered to be equal to another <ph id="ph2">&lt;xref:System.Single.NaN&gt;</ph> (even itself), the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface requires that <ph id="ph4">`A.CompareTo(A)`</ph> return zero.</source>
          <target state="translated">Notez que, bien qu’un <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph> n’est pas considéré comme égal à un autre <ph id="ph2">&lt;xref:System.Single.NaN&gt;</ph> (y compris lui-même), le <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface requiert que <ph id="ph4">`A.CompareTo(A)`</ph> retourne zéro.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Object)">
          <source>Precision in Comparisons</source>
          <target state="translated">Précision dans les comparaisons</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Object)">
          <source>The precision of floating-point numbers beyond the documented precision is specific to the implementation and version of the .NET Framework.</source>
          <target state="translated">La précision des nombres à virgule flottante au-delà de la précision documentée est spécifique à l’implémentation et la version du .NET Framework.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Object)">
          <source>Consequently, a comparison of two particular numbers might change between versions of the .NET Framework because the precision of the numbers' internal representation might change.</source>
          <target state="translated">Par conséquent, une comparaison de deux nombres particuliers peut changer entre les versions du .NET Framework, car la précision de la représentation interne des nombres peut changer.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Object)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Single.CompareTo%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Single.CompareTo%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> n'est pas un <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source>A single-precision floating-point number to compare.</source>
          <target state="translated">Nombre à virgule flottante simple précision à comparer.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source>Compares this instance to a specified single-precision floating-point number and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified single-precision floating-point number.</source>
          <target state="translated">Compare cette instance à un nombre à virgule flottante simple précision spécifié et retourne un entier qui indique si la valeur de cette instance est inférieure, égale ou supérieure à celle du nombre à virgule flottante simple précision spécifié.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source>A signed number indicating the relative values of this instance and <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Nombre signé indiquant les valeurs relatives de cette instance et <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valeur renvoyée</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Description</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Description</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Inférieur à zéro</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance is less than <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Cette instance est inférieure à <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source>This instance is not a number (<ph id="ph1">&lt;see cref="F:System.Single.NaN" /&gt;</ph>) and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is a number.</source>
          <target state="translated">Cette instance n'est pas un nombre (<ph id="ph1">&lt;see cref="F:System.Single.NaN" /&gt;</ph>) et <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est un nombre.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zéro</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance is equal to <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Cette instance est égale à <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source>Both this instance and <ph id="ph1">&lt;paramref name="value" /&gt;</ph> are not a number (<ph id="ph2">&lt;see cref="F:System.Single.NaN" /&gt;</ph>), <ph id="ph3">&lt;see cref="F:System.Single.PositiveInfinity" /&gt;</ph>, or <ph id="ph4">&lt;see cref="F:System.Single.NegativeInfinity" /&gt;</ph>.</source>
          <target state="translated">Cette instance et <ph id="ph1">&lt;paramref name="value" /&gt;</ph> sont tous deux des non-nombres (<ph id="ph2">&lt;see cref="F:System.Single.NaN" /&gt;</ph>), <ph id="ph3">&lt;see cref="F:System.Single.PositiveInfinity" /&gt;</ph> ou <ph id="ph4">&lt;see cref="F:System.Single.NegativeInfinity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Supérieur à zéro</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance is greater than <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Cette instance est supérieure à <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Single.CompareTo(System.Single)">
          <source>This instance is a number and <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not a number (<ph id="ph2">&lt;see cref="F:System.Single.NaN" /&gt;</ph>).</source>
          <target state="translated">Cette instance est un nombre et <ph id="ph1">&lt;paramref name="value" /&gt;</ph> n'est pas un nombre (<ph id="ph2">&lt;see cref="F:System.Single.NaN" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>Values must be identical to be considered equal.</source>
          <target state="translated">Les valeurs doivent être identiques pour être considérées comme égales.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>It is common for floating-point values to lose precision and to become nearly identical except for their least significant digits, especially when the values depend on multiple mathematical operations.</source>
          <target state="translated">Il est courant pour les valeurs à virgule flottante à la perte de précision et de devenir presque identiques à l’exception de leurs chiffres les moins significatifs, en particulier lorsque les valeurs dépendent de plusieurs opérations mathématiques.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>Because of this, the return value of the <ph id="ph1">&lt;xref:System.Single.CompareTo%2A&gt;</ph> method at times may seem surprising.</source>
          <target state="translated">Pour cette raison, la valeur de retour de la <ph id="ph1">&lt;xref:System.Single.CompareTo%2A&gt;</ph> méthode peut parfois sembler étonnant.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>For example, multiplication by any value followed by division by the same value should produce the original value.</source>
          <target state="translated">Par exemple, la multiplication par n’importe quelle valeur suivie de division par la même valeur doit produire la valeur d’origine.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>However, in the following example, the computed value turns out to be greater than the original value.</source>
          <target state="translated">Toutefois, dans l’exemple suivant, la valeur calculée s’avère pour être supérieure à la valeur d’origine.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>Showing all significant digits of the two values by using the "R" <bpt id="p1">[</bpt>standard numeric format string<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> indicates that the computed value differs from the original value in its least significant digits.</source>
          <target state="translated">Affichage de tous les chiffres significatifs des deux valeurs à l’aide de « R » <bpt id="p1">[</bpt>chaîne de format numérique standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> indique que la valeur calculée diffère de la valeur d’origine dans ses chiffres les moins significatifs.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>For information about handling such comparisons, see the Remarks section of the <ph id="ph1">&lt;xref:System.Single.Equals%28System.Single%29&gt;</ph> method.</source>
          <target state="translated">Pour plus d’informations sur la gestion de ces comparaisons, consultez la section Notes de la <ph id="ph1">&lt;xref:System.Single.Equals%28System.Single%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>This method implements the <ph id="ph1">&lt;xref:System.IComparable%601?displayProperty=nameWithType&gt;</ph> interface and performs slightly better than the <ph id="ph2">&lt;xref:System.Single.CompareTo%2A?displayProperty=nameWithType&gt;</ph> method because it does not have to convert the <ph id="ph3">`value`</ph> parameter to an object.</source>
          <target state="translated">Cette méthode implémente la <ph id="ph1">&lt;xref:System.IComparable%601?displayProperty=nameWithType&gt;</ph> de l’interface et effectue légèrement meilleures que les <ph id="ph2">&lt;xref:System.Single.CompareTo%2A?displayProperty=nameWithType&gt;</ph> (méthode), car il n’a pas à convertir le <ph id="ph3">`value`</ph> paramètre à un objet.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>Note that, although an object whose value is <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph> is not considered equal to another object whose value is <ph id="ph2">&lt;xref:System.Single.NaN&gt;</ph> (even itself), the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> interface requires that <ph id="ph4">`A.CompareTo(A)`</ph> return zero.</source>
          <target state="translated">Notez que, même si un objet dont la valeur est <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph> n’est pas considéré comme égal à un autre objet dont la valeur est <ph id="ph2">&lt;xref:System.Single.NaN&gt;</ph> (y compris lui-même), le <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> interface requiert que <ph id="ph4">`A.CompareTo(A)`</ph> retourne zéro.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>Widening Conversions</source>
          <target state="translated">conversions étendues</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>Depending on your programming language, it might be possible to code a <ph id="ph1">&lt;xref:System.Single.CompareTo%2A&gt;</ph> method where the parameter type has fewer bits (is narrower) than the instance type.</source>
          <target state="translated">Selon votre langage de programmation, il est possible au code un <ph id="ph1">&lt;xref:System.Single.CompareTo%2A&gt;</ph> méthode dans laquelle le type de paramètre comporte moins de bits (est plus restreint) que le type d’instance.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>This is possible because some programming languages perform an implicit widening conversion that represents the parameter as a type with as many bits as the instance.</source>
          <target state="translated">Cela est possible, car certains langages de programmation effectuent une conversion étendue implicite qui représente le paramètre en tant que type avec autant de bits que l’instance.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>For example, suppose the instance type is <ph id="ph1">&lt;xref:System.Single&gt;</ph> and the parameter type is <ph id="ph2">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">Par exemple, supposons que le type d’instance est <ph id="ph1">&lt;xref:System.Single&gt;</ph> et le type de paramètre est <ph id="ph2">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>The Microsoft C# compiler generates instructions to represent the value of the parameter as a <ph id="ph1">&lt;xref:System.Single&gt;</ph> object, then generates a <ph id="ph2">&lt;xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType&gt;</ph> method that compares the values of the instance and the widened representation of the parameter.</source>
          <target state="translated">Le compilateur Microsoft c# génère des instructions pour représenter la valeur du paramètre comme un <ph id="ph1">&lt;xref:System.Single&gt;</ph> de l’objet, puis génère un <ph id="ph2">&lt;xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType&gt;</ph> méthode qui compare les valeurs de l’instance et la représentation étendue du paramètre.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>Consult your programming language's documentation to determine if its compiler performs implicit widening conversions of numeric types.</source>
          <target state="translated">Consultez la documentation de votre langage de programmation pour déterminer si son compilateur exécute des conversions étendues implicites des types numériques.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>For more information, see the <bpt id="p1">[</bpt>Type Conversion Tables<ept id="p1">](~/docs/standard/base-types/conversion-tables.md)</ept> topic.</source>
          <target state="translated">Pour plus d’informations, consultez la <bpt id="p1">[</bpt>tableaux de Conversion de Type<ept id="p1">](~/docs/standard/base-types/conversion-tables.md)</ept> rubrique.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>Precision in Comparisons</source>
          <target state="translated">Précision dans les comparaisons</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>The precision of floating-point numbers beyond the documented precision is specific to the implementation and version of the .NET Framework.</source>
          <target state="translated">La précision des nombres à virgule flottante au-delà de la précision documentée est spécifique à l’implémentation et la version du .NET Framework.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>Consequently, a comparison of two particular numbers might change between versions of the .NET Framework because the precision of the numbers' internal representation might change.</source>
          <target state="translated">Par conséquent, une comparaison de deux nombres particuliers peut changer entre les versions du .NET Framework, car la précision de la représentation interne des nombres peut changer.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.CompareTo(System.Single)">
          <source>The following code example demonstrates generic and nongeneric versions of the <ph id="ph1">&lt;xref:System.Single.CompareTo%2A&gt;</ph> method for several value and reference types.</source>
          <target state="translated">L’exemple de code suivant montre les versions génériques et non génériques de la <ph id="ph1">&lt;xref:System.Single.CompareTo%2A&gt;</ph> méthode pour plusieurs types valeur et référence.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="F:System.Single.Epsilon">
          <source>Represents the smallest positive <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> value that is greater than zero.</source>
          <target state="translated">Représente la valeur <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> positive la plus petite qui est supérieure à zéro.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="F:System.Single.Epsilon">
          <source>This field is constant.</source>
          <target state="translated">Ce champ est constant.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.Epsilon">
          <source>The value of the <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> property reflects the smallest positive <ph id="ph2">&lt;xref:System.Single&gt;</ph> value that is significant in numeric operations or comparisons when the value of the <ph id="ph3">&lt;xref:System.Single&gt;</ph> instance is zero.</source>
          <target state="translated">La valeur de la <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> propriété reflète la positive la plus petite <ph id="ph2">&lt;xref:System.Single&gt;</ph> qui est significative dans les opérations numériques ou les comparaisons lorsque la valeur de la <ph id="ph3">&lt;xref:System.Single&gt;</ph> instance est égale à zéro.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.Epsilon">
          <source>For example, the following code shows that zero and <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> are considered to be unequal values, whereas zero and half the value of <ph id="ph2">&lt;xref:System.Single.Epsilon&gt;</ph> are considered to be equal.</source>
          <target state="translated">Par exemple, le code suivant montre que zéro et <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> sont considérés comme des valeurs inégales, alors que zéro et la moitié de la valeur de <ph id="ph2">&lt;xref:System.Single.Epsilon&gt;</ph> sont considérées comme égales.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.Epsilon">
          <source>More precisely, the single-precision floating-point format consists of a sign, a 23-bit mantissa or significand, and an 8-bit exponent.</source>
          <target state="translated">Plus précisément, le format à virgule flottante simple précision se compose d’un signe, une mantisse de 23 bits ou mantisse et un exposant de 8 bits.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.Epsilon">
          <source>As the following example shows, zero has an exponent of -126 and a mantissa of 0.</source>
          <target state="translated">Comme le montre l’exemple suivant, le zéro a un exposant de-126 et une mantisse de 0.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.Epsilon">
          <source><ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> has an exponent of -126 and a mantissa of 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> a un exposant de-126 et une mantisse de 1.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.Epsilon">
          <source>This means that <ph id="ph1">&lt;xref:System.Single.Epsilon?displayProperty=nameWithType&gt;</ph> is the smallest positive <ph id="ph2">&lt;xref:System.Single&gt;</ph> value that is greater than zero and represents the smallest possible value and the smallest possible increment for a <ph id="ph3">&lt;xref:System.Single&gt;</ph> whose exponent is -126.</source>
          <target state="translated">Cela signifie que <ph id="ph1">&lt;xref:System.Single.Epsilon?displayProperty=nameWithType&gt;</ph> est une valeur positive la plus petite <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeur qui est supérieure à zéro et représente la plus petite valeur possible et le plus petit incrément possible pour un <ph id="ph3">&lt;xref:System.Single&gt;</ph> dont exposant est-126.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.Epsilon">
          <source>However, the <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> property is not a general measure of precision of the <ph id="ph2">&lt;xref:System.Single&gt;</ph> type; it applies only to <ph id="ph3">&lt;xref:System.Single&gt;</ph> instances that have a value of zero.</source>
          <target state="translated">Toutefois, le <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> propriété n’est pas une mesure générale de précision de la <ph id="ph2">&lt;xref:System.Single&gt;</ph> type ; elle s’applique uniquement aux <ph id="ph3">&lt;xref:System.Single&gt;</ph> instances qui ont une valeur égale à zéro.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.Epsilon">
          <source>The value of the <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> property is not equivalent to machine epsilon, which represents the upper bound of the relative error due to rounding in floating-point arithmetic.</source>
          <target state="translated">La valeur de la <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> propriété n’est pas équivalente à l’epsilon d’ordinateur, qui représente la limite supérieure de l’erreur relative en raison de l’arrondi dans l’arithmétique à virgule flottante.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.Epsilon">
          <source>The value of this constant is 1.4e-45.</source>
          <target state="translated">La valeur de cette constante est 1, 4e-45.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.Epsilon">
          <source>Two apparently equivalent floating-point numbers might not compare equal because of differences in their least significant digits.</source>
          <target state="translated">Deux nombres à virgule flottante apparemment équivalentes peuvent ne pas être considérés comme égaux en raison de différences dans leurs chiffres les moins significatifs.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.Epsilon">
          <source>For example, the C# expression, <ph id="ph1">`(float)1/3 == (float)0.33333`</ph>, does not compare equal because the division operation on the left side has maximum precision while the constant on the right side is precise only to the specified digits.</source>
          <target state="translated">Par exemple, l’expression c# <ph id="ph1">`(float)1/3 == (float)0.33333`</ph>, ne pas être égaux, car l’opération de division sur le côté gauche présente une précision maximale alors que la constante située à droite est uniquement pour les chiffres spécifiés.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.Epsilon">
          <source>If you create a custom algorithm that determines whether two floating-point numbers can be considered equal, you must use a value that is greater than the <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> constant to establish the acceptable absolute margin of difference for the two values to be considered equal.</source>
          <target state="translated">Si vous créez un algorithme personnalisé qui détermine si deux nombres à virgule flottante peuvent être considérés comme égaux, vous devez utiliser une valeur qui est supérieure à la <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> pour établir la marge absolue acceptable de différence pour les deux valeurs (constante) considérées comme égales.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.Epsilon">
          <source>(Typically, that margin of difference is many times greater than <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph>.)</source>
          <target state="translated">(En général, la marge de différence est plusieurs fois supérieure à <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.Epsilon">
          <source>Platform Notes</source>
          <target state="translated">Notes sur les plateformes</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.Epsilon">
          <source>On ARM systems, the value of the <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> constant is too small to be detected, so it equates to zero.</source>
          <target state="translated">Sur les systèmes ARM, la valeur de la <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> constante est trop petite pour être détecté, elle est égale à zéro.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.Epsilon">
          <source>You can define an alternative epsilon value that equals 1.175494351E-38 instead.</source>
          <target state="translated">Vous pouvez définir une valeur de remplacement epsilon égal à 1,175494351e-38 à la place.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="T:System.Single">
          <source>Returns a value indicating whether two instances of <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> represent the same value.</source>
          <target state="translated">Retourne une valeur indiquant si deux instances de <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> représentent la même valeur.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Single.Equals(System.Object)">
          <source>An object to compare with this instance.</source>
          <target state="translated">Objet à comparer à cette instance.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Single.Equals(System.Object)">
          <source>Returns a value indicating whether this instance is equal to a specified object.</source>
          <target state="translated">Retourne une valeur indiquant si cette instance équivaut à un objet spécifié.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Single.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> is an instance of <ph id="ph3">&lt;see cref="T:System.Single" /&gt;</ph> and equals the value of this instance; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> est une instance de <ph id="ph3">&lt;see cref="T:System.Single" /&gt;</ph> et est égal à la valeur de cette instance ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Single.Equals%2A&gt;</ph> method should be used with caution, because two apparently equivalent values can be unequal due to the differing precision of the two values.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single.Equals%2A&gt;</ph> méthode doit être utilisée avec précaution, car les deux valeurs apparemment équivalentes peuvent être différentes en raison de leur différence de précision des deux valeurs.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Object)">
          <source>The following example reports that the <ph id="ph1">&lt;xref:System.Single&gt;</ph> value .3333 and the <ph id="ph2">&lt;xref:System.Single&gt;</ph> returned by dividing 1 by 3 are unequal.</source>
          <target state="translated">L’exemple suivant indique que le <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur.3333 et <ph id="ph2">&lt;xref:System.Single&gt;</ph> retournée en divisant 1 par 3 ne sont pas égales.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Object)">
          <source>Rather than comparing for equality, one recommended technique involves defining an acceptable margin of difference between two values (such as .01% of one of the values).</source>
          <target state="translated">Au lieu de la comparaison d’égalité, recommandée technique consiste à définir une marge acceptable de différence entre deux valeurs (tel que. % 01 d’une des valeurs).</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Object)">
          <source>If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to differences in precision and, therefore, the values are likely to be equal.</source>
          <target state="translated">Si la valeur absolue de la différence entre les deux valeurs est inférieure ou égale à cette marge, la différence est probablement en raison de différences de précision et, par conséquent, les valeurs sont susceptibles d’être égale.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Object)">
          <source>The following example uses this technique to compare .33333 and 1/3, the two <ph id="ph1">&lt;xref:System.Single&gt;</ph> values that the previous code example found to be unequal.</source>
          <target state="translated">L’exemple suivant utilise cette technique pour comparer.33333 et 1/3, les deux <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeurs que l’exemple de code précédent a détectées accentuées.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Object)">
          <source>In this case, the values are equal.</source>
          <target state="translated">Dans ce cas, les valeurs sont égales.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Object)">
          <source>Because <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> defines the minimum expression of a positive value whose range is near zero, the margin of difference must be greater than <ph id="ph2">&lt;xref:System.Single.Epsilon&gt;</ph>.</source>
          <target state="translated">Étant donné que <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> définit l’expression minimum d’une valeur positive dont la plage est proche de zéro, la marge de différence doit être supérieure à <ph id="ph2">&lt;xref:System.Single.Epsilon&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Object)">
          <source>Typically, it is many times greater than <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph>.</source>
          <target state="translated">En règle générale, il est plusieurs fois supérieure à <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Object)">
          <source>The precision of floating-point numbers beyond the documented precision is specific to the implementation and version of the .NET Framework.</source>
          <target state="translated">La précision des nombres à virgule flottante au-delà de la précision documentée est spécifique à l’implémentation et la version du .NET Framework.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Object)">
          <source>Consequently, a comparison of two particular numbers might change between versions of the .NET Framework because the precision of the numbers' internal representation might change.</source>
          <target state="translated">Par conséquent, une comparaison de deux nombres particuliers peut changer entre les versions du .NET Framework, car la précision de la représentation interne des nombres peut changer.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Object)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Single.Equals%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Single.Equals%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Object)">
          <source>Compiler overload resolution may account for an apparent difference in the behavior of the two <ph id="ph1">&lt;see cref="M:System.Single.Equals(System.Object)" /&gt;</ph> method overloads.</source>
          <target state="translated">La résolution de surcharge du compilateur peut-être représenter une différence apparente le comportement des deux <ph id="ph1">&lt;see cref="M:System.Single.Equals(System.Object)" /&gt;</ph> surcharges de méthode.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Object)">
          <source>If an implicit conversion between the <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> argument and a <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> is defined and the argument is not typed as an <ph id="ph3">&lt;see cref="T:System.Object" /&gt;</ph>, compilers may perform an implicit conversion and call the <ph id="ph4">&lt;see cref="M:System.Single.Equals(System.Single)" /&gt;</ph> method.</source>
          <target state="translated">Si une conversion implicite entre les <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> argument et un <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> est défini et l’argument n’est pas typé comme un <ph id="ph3">&lt;see cref="T:System.Object" /&gt;</ph>, compilateurs peuvent effectuer une conversion implicite et l’appel de la <ph id="ph4">&lt;see cref="M:System.Single.Equals(System.Single)" /&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Object)">
          <source>Otherwise, they call the <ph id="ph1">&lt;see cref="M:System.Single.Equals(System.Object)" /&gt;</ph> method, which always returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> if its <ph id="ph3">&lt;paramref name="obj" /&gt;</ph> argument is not a <ph id="ph4">&lt;see cref="T:System.Single" /&gt;</ph> value.</source>
          <target state="translated">Sinon, elles appellent la <ph id="ph1">&lt;see cref="M:System.Single.Equals(System.Object)" /&gt;</ph> (méthode), qui retourne toujours <ph id="ph2">&lt;see langword="false" /&gt;</ph> si son <ph id="ph3">&lt;paramref name="obj" /&gt;</ph> argument n’est pas un <ph id="ph4">&lt;see cref="T:System.Single" /&gt;</ph> valeur.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Object)">
          <source>The following example illustrates the difference in behavior between the two method overloads.</source>
          <target state="translated">L’exemple suivant illustre la différence de comportement entre les surcharges de deux méthode.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Object)">
          <source>In the case of all primitive numeric types except for <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph> in Visual Basic and except for <ph id="ph2">&lt;see cref="T:System.Decimal" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Double" /&gt;</ph> in C#, the first comparison returns <ph id="ph4">&lt;see langword="true" /&gt;</ph> because the compiler automatically performs a widening conversion and calls the <ph id="ph5">&lt;see cref="M:System.Single.Equals(System.Single)" /&gt;</ph> method, whereas the second comparison returns <ph id="ph6">&lt;see langword="false" /&gt;</ph> because the compiler calls the <ph id="ph7">&lt;see cref="M:System.Single.Equals(System.Object)" /&gt;</ph> method.</source>
          <target state="translated">Dans le cas de tous les types numériques primitifs à l’exception de <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph> en Visual Basic et à l’exception de <ph id="ph2">&lt;see cref="T:System.Decimal" /&gt;</ph> et <ph id="ph3">&lt;see cref="T:System.Double" /&gt;</ph> en c#, la première comparaison retourne <ph id="ph4">&lt;see langword="true" /&gt;</ph> , car le compilateur effectue automatiquement une conversion étendue et appels le <ph id="ph5">&lt;see cref="M:System.Single.Equals(System.Single)" /&gt;</ph> (méthode), tandis que la deuxième comparaison retourne <ph id="ph6">&lt;see langword="false" /&gt;</ph> , car le compilateur appelle le <ph id="ph7">&lt;see cref="M:System.Single.Equals(System.Object)" /&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Single.Equals(System.Single)">
          <source>An object to compare with this instance.</source>
          <target state="translated">Objet à comparer à cette instance.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Single.Equals(System.Single)">
          <source>Returns a value indicating whether this instance and a specified <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> object represent the same value.</source>
          <target state="translated">Retourne une valeur indiquant si cette instance et un objet <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> spécifié représentent la même valeur.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Single.Equals(System.Single)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> is equal to this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> est égal à cette instance ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>This method implements the <ph id="ph1">&lt;xref:System.IEquatable%601?displayProperty=nameWithType&gt;</ph> interface, and performs slightly better than <ph id="ph2">&lt;xref:System.Single.Equals%2A&gt;</ph> because it does not have to convert the <ph id="ph3">`obj`</ph> parameter to an object.</source>
          <target state="translated">Cette méthode implémente la <ph id="ph1">&lt;xref:System.IEquatable%601?displayProperty=nameWithType&gt;</ph> de l’interface et effectue légèrement meilleures que <ph id="ph2">&lt;xref:System.Single.Equals%2A&gt;</ph> , car il n’a pas à convertir le <ph id="ph3">`obj`</ph> paramètre d’objet.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>Widening Conversions</source>
          <target state="translated">conversions étendues</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>Depending on your programming language, it might be possible to code an <ph id="ph1">&lt;xref:System.Single.Equals%2A&gt;</ph> method where the parameter type has fewer bits (is narrower) than the instance type.</source>
          <target state="translated">Selon votre langage de programmation, il est possible au code un <ph id="ph1">&lt;xref:System.Single.Equals%2A&gt;</ph> méthode dans laquelle le type de paramètre comporte moins de bits (est plus restreint) que le type d’instance.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>This is possible because some programming languages perform an implicit widening conversion that represents the parameter as a type with as many bits as the instance.</source>
          <target state="translated">Cela est possible, car certains langages de programmation effectuent une conversion étendue implicite qui représente le paramètre en tant que type avec autant de bits que l’instance.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>For example, suppose the instance type is <ph id="ph1">&lt;xref:System.Single&gt;</ph> and the parameter type is <ph id="ph2">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">Par exemple, supposons que le type d’instance est <ph id="ph1">&lt;xref:System.Single&gt;</ph> et le type de paramètre est <ph id="ph2">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>The Microsoft C# compiler generates instructions to represent the value of the parameter as a <ph id="ph1">&lt;xref:System.Single&gt;</ph> object, and then generates a <ph id="ph2">&lt;xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType&gt;</ph> method that compares the values of the instance and the widened representation of the parameter.</source>
          <target state="translated">Le compilateur Microsoft c# génère des instructions pour représenter la valeur du paramètre comme un <ph id="ph1">&lt;xref:System.Single&gt;</ph> de l’objet, puis génère un <ph id="ph2">&lt;xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType&gt;</ph> méthode qui compare les valeurs de l’instance et la représentation étendue du paramètre.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>Consult your programming language's documentation to determine if its compiler performs implicit widening conversions of numeric types.</source>
          <target state="translated">Consultez la documentation de votre langage de programmation pour déterminer si son compilateur exécute des conversions étendues implicites des types numériques.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>For more information, see the <bpt id="p1">[</bpt>Type Conversion Tables<ept id="p1">](~/docs/standard/base-types/conversion-tables.md)</ept> topic.</source>
          <target state="translated">Pour plus d’informations, consultez la <bpt id="p1">[</bpt>tableaux de Conversion de Type<ept id="p1">](~/docs/standard/base-types/conversion-tables.md)</ept> rubrique.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>Precision in Comparisons</source>
          <target state="translated">Précision dans les comparaisons</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>The <ph id="ph1">&lt;xref:System.Single.Equals%2A&gt;</ph> method should be used with caution, because two apparently equivalent values can be unequal because of the differing precision of the two values.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single.Equals%2A&gt;</ph> méthode doit être utilisée avec précaution, car les deux valeurs apparemment équivalentes peuvent être inégaux en raison de leur différence de précision des deux valeurs.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>The following example reports that the <ph id="ph1">&lt;xref:System.Single&gt;</ph> value .3333 and the <ph id="ph2">&lt;xref:System.Single&gt;</ph> returned by dividing 1 by 3 are unequal.</source>
          <target state="translated">L’exemple suivant indique que le <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur.3333 et <ph id="ph2">&lt;xref:System.Single&gt;</ph> retournée en divisant 1 par 3 ne sont pas égales.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>One comparison technique that avoids the problems associated with comparing for equality involves defining an acceptable margin of difference between two values (such as .01% of one of the values).</source>
          <target state="translated">Technique d’une comparaison qui permet d’éviter les problèmes associés à la comparaison d’égalité implique la définition d’une marge acceptable de différence entre deux valeurs (tel que. % 01 d’une des valeurs).</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be an outcome of differences in precision and, therefore, the values are likely to be equal.</source>
          <target state="translated">Si la valeur absolue de la différence entre les deux valeurs est inférieure ou égale à cette marge, la différence est susceptible d’être un résultat de différences de précision et, par conséquent, les valeurs sont susceptibles d’être égale.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>The following example uses this technique to compare .33333 and 1/3, which are the two <ph id="ph1">&lt;xref:System.Single&gt;</ph> values that the previous code example found to be unequal.</source>
          <target state="translated">L’exemple suivant utilise cette technique pour comparer.33333 et 1/3, qui sont les deux <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeurs que l’exemple de code précédent a détectées accentuées.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>In this case, the values are equal.</source>
          <target state="translated">Dans ce cas, les valeurs sont égales.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>Because <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> defines the minimum expression of a positive value whose range is near zero, the margin of difference must be greater than <ph id="ph2">&lt;xref:System.Single.Epsilon&gt;</ph>.</source>
          <target state="translated">Étant donné que <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> définit l’expression minimum d’une valeur positive dont la plage est proche de zéro, la marge de différence doit être supérieure à <ph id="ph2">&lt;xref:System.Single.Epsilon&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>Typically, it is many times greater than <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph>.</source>
          <target state="translated">En règle générale, il est plusieurs fois supérieure à <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>Because of this, we recommend that you do not use <ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph> when comparing <ph id="ph2">&lt;xref:System.Double&gt;</ph> values for equality.</source>
          <target state="translated">Pour cette raison, nous vous recommandons de ne pas utiliser <ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph> lors de la comparaison <ph id="ph2">&lt;xref:System.Double&gt;</ph> valeurs sont égales.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>A second technique that avoids the problems associated with comparing for equality involves comparing the difference between two floating-point numbers with some absolute value.</source>
          <target state="translated">Une seconde technique qui permet d’éviter les problèmes associés à la comparaison d’égalité implique la comparaison de la différence entre deux nombres à virgule flottante avec une valeur absolue.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>If the difference is less than or equal to that absolute value, the numbers are equal.</source>
          <target state="translated">Si la différence est inférieure ou égale à cette valeur absolue, les nombres sont égaux.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>If it is greater, the numbers are not equal.</source>
          <target state="translated">Si elle est supérieure, les nombres ne sont pas égaux.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>One way to do this is to arbitrarily select an absolute value.</source>
          <target state="translated">Pour ce faire consiste à arbitrairement sélectionner une valeur absolue.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>However, this is problematic, because an acceptable margin of difference depends on the magnitude of the <ph id="ph1">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">Toutefois, cela est problématique, car une marge acceptable de différence dépend de la grandeur de la <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>A second way takes advantage of a design feature of the floating-point format: The difference between the mantissa components in the integer representations of two floating-point values indicates the number of possible floating-point values that separates the two values.</source>
          <target state="translated">Une deuxième méthode tire parti d’une fonctionnalité de conception du format à virgule flottante : la différence entre les composants de mantisse dans les représentations sous forme d’entier de deux valeurs à virgule flottante indique le nombre de valeurs à virgule flottante possibles qui sépare le deux valeurs.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>For example, the difference between 0.0 and <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> is 1, because <ph id="ph2">&lt;xref:System.Single.Epsilon&gt;</ph> is the smallest representable value when working with a <ph id="ph3">&lt;xref:System.Single&gt;</ph> whose value is zero.</source>
          <target state="translated">Par exemple, la différence entre 0,0 et <ph id="ph1">&lt;xref:System.Single.Epsilon&gt;</ph> est 1, car <ph id="ph2">&lt;xref:System.Single.Epsilon&gt;</ph> est la plus petite valeur représentable lorsque vous travaillez avec un <ph id="ph3">&lt;xref:System.Single&gt;</ph> dont la valeur est égale à zéro.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>The following example uses this technique to compare .33333 and 1/3, which are the two <ph id="ph1">&lt;xref:System.Double&gt;</ph> values that the previous code example with the <ph id="ph2">&lt;xref:System.Single.Equals%28System.Single%29&gt;</ph> method found to be unequal.</source>
          <target state="translated">L’exemple suivant utilise cette technique pour comparer.33333 et 1/3, qui sont les deux <ph id="ph1">&lt;xref:System.Double&gt;</ph> les valeurs que l’exemple de code précédent avec le <ph id="ph2">&lt;xref:System.Single.Equals%28System.Single%29&gt;</ph> méthode trouvée accentuées.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>Note that the example uses the <ph id="ph1">&lt;xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType&gt;</ph> methods to convert a single-precision floating-point value to its integer representation.</source>
          <target state="translated">Notez que l’exemple utilise le <ph id="ph1">&lt;xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType&gt;</ph> méthodes pour convertir une valeur à virgule flottante simple précision en sa représentation sous forme d’entier.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>The precision of floating-point numbers beyond the documented precision is specific to the implementation and version of the .NET Framework.</source>
          <target state="translated">La précision des nombres à virgule flottante au-delà de la précision documentée est spécifique à l’implémentation et la version du .NET Framework.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>Consequently, a comparison of two numbers might produce different results depending on the version of the .NET Framework, because the precision of the numbers' internal representation might change.</source>
          <target state="translated">Par conséquent, une comparaison de deux nombres peut produire des résultats différents selon la version du .NET Framework, car la précision de la représentation interne des nombres peut-être changer.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>Compiler overload resolution may account for an apparent difference in the behavior of the two <ph id="ph1">&lt;see cref="M:System.Single.Equals(System.Object)" /&gt;</ph> method overloads.</source>
          <target state="translated">La résolution de surcharge du compilateur peut-être représenter une différence apparente le comportement des deux <ph id="ph1">&lt;see cref="M:System.Single.Equals(System.Object)" /&gt;</ph> surcharges de méthode.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>If an implicit conversion between the <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> argument and a <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> is defined and the argument is not typed as an <ph id="ph3">&lt;see cref="T:System.Object" /&gt;</ph>, compilers may perform an implicit conversion and call the <ph id="ph4">&lt;see cref="M:System.Single.Equals(System.Single)" /&gt;</ph> method.</source>
          <target state="translated">Si une conversion implicite entre les <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> argument et un <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> est défini et l’argument n’est pas typé comme un <ph id="ph3">&lt;see cref="T:System.Object" /&gt;</ph>, compilateurs peuvent effectuer une conversion implicite et l’appel de la <ph id="ph4">&lt;see cref="M:System.Single.Equals(System.Single)" /&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>Otherwise, they call the <ph id="ph1">&lt;see cref="M:System.Single.Equals(System.Object)" /&gt;</ph> method, which always returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> if its <ph id="ph3">&lt;paramref name="obj" /&gt;</ph> argument is not a <ph id="ph4">&lt;see cref="T:System.Single" /&gt;</ph> value.</source>
          <target state="translated">Sinon, elles appellent la <ph id="ph1">&lt;see cref="M:System.Single.Equals(System.Object)" /&gt;</ph> (méthode), qui retourne toujours <ph id="ph2">&lt;see langword="false" /&gt;</ph> si son <ph id="ph3">&lt;paramref name="obj" /&gt;</ph> argument n’est pas un <ph id="ph4">&lt;see cref="T:System.Single" /&gt;</ph> valeur.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>The following example illustrates the difference in behavior between the two method overloads.</source>
          <target state="translated">L’exemple suivant illustre la différence de comportement entre les surcharges de deux méthode.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Equals(System.Single)">
          <source>In the case of all primitive numeric types except for <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph> in Visual Basic and except for <ph id="ph2">&lt;see cref="T:System.Decimal" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Double" /&gt;</ph> in C#, the first comparison returns <ph id="ph4">&lt;see langword="true" /&gt;</ph> because the compiler automatically performs a widening conversion and calls the <ph id="ph5">&lt;see cref="M:System.Single.Equals(System.Single)" /&gt;</ph> method, whereas the second comparison returns <ph id="ph6">&lt;see langword="false" /&gt;</ph> because the compiler calls the <ph id="ph7">&lt;see cref="M:System.Single.Equals(System.Object)" /&gt;</ph> method.</source>
          <target state="translated">Dans le cas de tous les types numériques primitifs à l’exception de <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph> en Visual Basic et à l’exception de <ph id="ph2">&lt;see cref="T:System.Decimal" /&gt;</ph> et <ph id="ph3">&lt;see cref="T:System.Double" /&gt;</ph> en c#, la première comparaison retourne <ph id="ph4">&lt;see langword="true" /&gt;</ph> , car le compilateur effectue automatiquement une conversion étendue et appels le <ph id="ph5">&lt;see cref="M:System.Single.Equals(System.Single)" /&gt;</ph> (méthode), tandis que la deuxième comparaison retourne <ph id="ph6">&lt;see langword="false" /&gt;</ph> , car le compilateur appelle le <ph id="ph7">&lt;see cref="M:System.Single.Equals(System.Object)" /&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Single.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Retourne le code de hachage de cette instance.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Single.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Code de hachage d'un entier signé 32 bits.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Single.GetTypeCode">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.TypeCode" /&gt;</ph> for value type <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph>.</source>
          <target state="translated">Retourne le <ph id="ph1">&lt;see cref="T:System.TypeCode" /&gt;</ph> du type valeur <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Single.GetTypeCode">
          <source>The enumerated constant, <ph id="ph1">&lt;see cref="F:System.TypeCode.Single" /&gt;</ph>.</source>
          <target state="translated">Constante énumérée, <ph id="ph1">&lt;see cref="F:System.TypeCode.Single" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Single.IsInfinity(System.Single)">
          <source>A single-precision floating-point number.</source>
          <target state="translated">Nombre à virgule flottante simple précision.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Single.IsInfinity(System.Single)">
          <source>Returns a value indicating whether the specified number evaluates to negative or positive infinity.</source>
          <target state="translated">Retourne une valeur indiquant si la valeur du nombre spécifié est l'infini négatif ou positif.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Single.IsInfinity(System.Single)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="f" /&gt;</ph> evaluates to <ph id="ph3">&lt;see cref="F:System.Single.PositiveInfinity" /&gt;</ph> or <ph id="ph4">&lt;see cref="F:System.Single.NegativeInfinity" /&gt;</ph>; otherwise, <ph id="ph5">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="f" /&gt;</ph> a la valeur <ph id="ph3">&lt;see cref="F:System.Single.PositiveInfinity" /&gt;</ph> ou <ph id="ph4">&lt;see cref="F:System.Single.NegativeInfinity" /&gt;</ph> ; sinon, <ph id="ph5">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.IsInfinity(System.Single)">
          <source>Floating-point operations return <ph id="ph1">&lt;xref:System.Single.PositiveInfinity&gt;</ph> or <ph id="ph2">&lt;xref:System.Single.NegativeInfinity&gt;</ph> to signal an overflow condition.</source>
          <target state="translated">Les opérations à virgule flottante retournent <ph id="ph1">&lt;xref:System.Single.PositiveInfinity&gt;</ph> ou <ph id="ph2">&lt;xref:System.Single.NegativeInfinity&gt;</ph> pour signaler une condition de dépassement de capacité.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.IsInfinity(System.Single)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Single.IsInfinity%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Single.IsInfinity%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Single.IsNaN(System.Single)">
          <source>A single-precision floating-point number.</source>
          <target state="translated">Nombre à virgule flottante simple précision.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Single.IsNaN(System.Single)">
          <source>Returns a value that indicates whether the specified value is not a number (<ph id="ph1">&lt;see cref="F:System.Single.NaN" /&gt;</ph>).</source>
          <target state="translated">Retourne une valeur qui indique si la valeur spécifiée n'est pas un nombre (<ph id="ph1">&lt;see cref="F:System.Single.NaN" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Single.IsNaN(System.Single)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="f" /&gt;</ph> evaluates to not a number (<ph id="ph3">&lt;see cref="F:System.Single.NaN" /&gt;</ph>); otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la valeur de <ph id="ph2">&lt;paramref name="f" /&gt;</ph> est un non-nombre (<ph id="ph3">&lt;see cref="F:System.Single.NaN" /&gt;</ph>) ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.IsNaN(System.Single)">
          <source>Floating-point operations return <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph> to signal that that result of the operation is undefined.</source>
          <target state="translated">Les opérations à virgule flottante retournent <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph> pour signaler que le résultat de l’opération est non défini.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.IsNaN(System.Single)">
          <source>For example, dividing 0.0 by 0.0 results in <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph>.</source>
          <target state="translated">Par exemple, la division de 0,0 par 0,0 entraîne <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.IsNaN(System.Single)">
          <source><ph id="ph1">&lt;xref:System.Single.IsNaN%2A&gt;</ph> returns <ph id="ph2">`false`</ph> if a <ph id="ph3">&lt;xref:System.Single&gt;</ph> value is either <ph id="ph4">&lt;xref:System.Single.PositiveInfinity&gt;</ph> or <ph id="ph5">&lt;xref:System.Single.NegativeInfinity&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Single.IsNaN%2A&gt;</ph> Retourne <ph id="ph2">`false`</ph> si un <ph id="ph3">&lt;xref:System.Single&gt;</ph> valeur est soit <ph id="ph4">&lt;xref:System.Single.PositiveInfinity&gt;</ph> ou <ph id="ph5">&lt;xref:System.Single.NegativeInfinity&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.IsNaN(System.Single)">
          <source>To test for these values, use the <ph id="ph1">&lt;xref:System.Single.IsInfinity%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Single.IsPositiveInfinity%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Single.IsNegativeInfinity%2A&gt;</ph> methods.</source>
          <target state="translated">Pour tester ces valeurs, utilisez la <ph id="ph1">&lt;xref:System.Single.IsInfinity%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Single.IsPositiveInfinity%2A&gt;</ph>, et <ph id="ph3">&lt;xref:System.Single.IsNegativeInfinity%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.IsNaN(System.Single)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Single.IsNaN%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Single.IsNaN%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Single.IsNegativeInfinity(System.Single)">
          <source>A single-precision floating-point number.</source>
          <target state="translated">Nombre à virgule flottante simple précision.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Single.IsNegativeInfinity(System.Single)">
          <source>Returns a value indicating whether the specified number evaluates to negative infinity.</source>
          <target state="translated">Retourne une valeur indiquant si le nombre spécifié est équivalent à l'infini négatif.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Single.IsNegativeInfinity(System.Single)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="f" /&gt;</ph> evaluates to <ph id="ph3">&lt;see cref="F:System.Single.NegativeInfinity" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="f" /&gt;</ph> a la valeur <ph id="ph3">&lt;see cref="F:System.Single.NegativeInfinity" /&gt;</ph> ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.IsNegativeInfinity(System.Single)">
          <source>Floating-point operations return <ph id="ph1">&lt;xref:System.Single.NegativeInfinity&gt;</ph> to signal an overflow condition.</source>
          <target state="translated">Les opérations à virgule flottante retournent <ph id="ph1">&lt;xref:System.Single.NegativeInfinity&gt;</ph> pour signaler une condition de dépassement de capacité.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.IsNegativeInfinity(System.Single)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Single.IsNegativeInfinity%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Single.IsNegativeInfinity%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Single.IsPositiveInfinity(System.Single)">
          <source>A single-precision floating-point number.</source>
          <target state="translated">Nombre à virgule flottante simple précision.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Single.IsPositiveInfinity(System.Single)">
          <source>Returns a value indicating whether the specified number evaluates to positive infinity.</source>
          <target state="translated">Retourne une valeur indiquant si le nombre spécifié est équivalent à l'infini positif.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Single.IsPositiveInfinity(System.Single)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="f" /&gt;</ph> evaluates to <ph id="ph3">&lt;see cref="F:System.Single.PositiveInfinity" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="f" /&gt;</ph> a la valeur <ph id="ph3">&lt;see cref="F:System.Single.PositiveInfinity" /&gt;</ph> ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.IsPositiveInfinity(System.Single)">
          <source>Floating-point operations return <ph id="ph1">&lt;xref:System.Single.PositiveInfinity&gt;</ph> to signal an overflow condition.</source>
          <target state="translated">Les opérations à virgule flottante retournent <ph id="ph1">&lt;xref:System.Single.PositiveInfinity&gt;</ph> pour signaler une condition de dépassement de capacité.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.IsPositiveInfinity(System.Single)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Single.IsPositiveInfinity%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Single.IsPositiveInfinity%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="F:System.Single.MaxValue">
          <source>Represents the largest possible value of <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph>.</source>
          <target state="translated">Représente la plus grande valeur possible de <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="F:System.Single.MaxValue">
          <source>This field is constant.</source>
          <target state="translated">Ce champ est constant.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.MaxValue">
          <source>The value of this constant is positive 3.40282347E+38.</source>
          <target state="translated">La valeur de cette constante est positive 3.40282347E + 38.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.MaxValue">
          <source>The result of an operation that exceeds <ph id="ph1">&lt;xref:System.Single.MaxValue?displayProperty=nameWithType&gt;</ph> is <ph id="ph2">&lt;xref:System.Single.PositiveInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Le résultat d’une opération qui dépasse <ph id="ph1">&lt;xref:System.Single.MaxValue?displayProperty=nameWithType&gt;</ph> est <ph id="ph2">&lt;xref:System.Single.PositiveInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.MaxValue">
          <source>In the following example, <ph id="ph1">&lt;xref:System.Single.PositiveInfinity?displayProperty=nameWithType&gt;</ph> results from addition, multiplication, and exponentiation operations when the result exceeds <ph id="ph2">&lt;xref:System.Single.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Dans l’exemple suivant, <ph id="ph1">&lt;xref:System.Single.PositiveInfinity?displayProperty=nameWithType&gt;</ph> entraîne des opérations d’addition, la multiplication et élévation lorsque le résultat dépasse <ph id="ph2">&lt;xref:System.Single.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.MaxValue">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Single.MaxValue&gt;</ph> constant.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Single.MaxValue&gt;</ph> constante.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="F:System.Single.MinValue">
          <source>Represents the smallest possible value of <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph>.</source>
          <target state="translated">Représente la plus petite valeur possible de <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="F:System.Single.MinValue">
          <source>This field is constant.</source>
          <target state="translated">Ce champ est constant.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.MinValue">
          <source>The value of this constant is negative 3.402823e38.</source>
          <target state="translated">La valeur de cette constante est moins 3, 402823E38.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.MinValue">
          <source>The result of an operation that is less than <ph id="ph1">&lt;xref:System.Single.MinValue?displayProperty=nameWithType&gt;</ph> is <ph id="ph2">&lt;xref:System.Single.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Le résultat d’une opération qui est inférieur à <ph id="ph1">&lt;xref:System.Single.MinValue?displayProperty=nameWithType&gt;</ph> est <ph id="ph2">&lt;xref:System.Single.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.MinValue">
          <source>In the following example, <ph id="ph1">&lt;xref:System.Single.NegativeInfinity?displayProperty=nameWithType&gt;</ph> results from subtraction and multiplication operations when the result is less than <ph id="ph2">&lt;xref:System.Single.MinValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Dans l’exemple suivant, <ph id="ph1">&lt;xref:System.Single.NegativeInfinity?displayProperty=nameWithType&gt;</ph> résultant d’opérations de soustraction et multiplication lorsque le résultat est inférieur à <ph id="ph2">&lt;xref:System.Single.MinValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.MinValue">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Single.MinValue&gt;</ph> constant.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Single.MinValue&gt;</ph> constante.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="F:System.Single.NaN">
          <source>Represents not a number (<ph id="ph1">&lt;see langword="NaN" /&gt;</ph>).</source>
          <target state="translated">Représente une valeur autre qu'un nombre (<ph id="ph1">&lt;see langword="NaN" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="F:System.Single.NaN">
          <source>This field is constant.</source>
          <target state="translated">Ce champ est constant.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.NaN">
          <source>A method or operator returns <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph> when the result of an operation is undefined.</source>
          <target state="translated">Une méthode ou un opérateur retourne <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph> lorsque le résultat d’une opération n’est pas défini.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.NaN">
          <source>For example, the result of dividing zero by zero is <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph>, as the following example shows.</source>
          <target state="translated">Par exemple, le résultat de la division de zéro par zéro est <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph>, comme le montre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.NaN">
          <source>(But note that dividing a non-zero number by zero returns either <ph id="ph1">&lt;xref:System.Single.PositiveInfinity&gt;</ph> or <ph id="ph2">&lt;xref:System.Single.NegativeInfinity&gt;</ph>, depending on the sign of the divisor.)</source>
          <target state="translated">(Toutefois, notez que la division d’un nombre différent de zéro par zéro retourne <ph id="ph1">&lt;xref:System.Single.PositiveInfinity&gt;</ph> ou <ph id="ph2">&lt;xref:System.Single.NegativeInfinity&gt;</ph>, selon le signe du diviseur.)</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.NaN">
          <source>In addition, a method call with a <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph> value or an operation on a <ph id="ph2">&lt;xref:System.Single.NaN&gt;</ph> value returns <ph id="ph3">&lt;xref:System.Single.NaN&gt;</ph>, as the following example shows.</source>
          <target state="translated">En outre, un appel de méthode avec un <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph> valeur ou une opération sur un <ph id="ph2">&lt;xref:System.Single.NaN&gt;</ph> retourne la valeur <ph id="ph3">&lt;xref:System.Single.NaN&gt;</ph>, comme le montre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.NaN">
          <source>Use the <ph id="ph1">&lt;xref:System.Single.IsNaN%2A&gt;</ph> method to determine whether a value is not a number.</source>
          <target state="translated">Utilisez la <ph id="ph1">&lt;xref:System.Single.IsNaN%2A&gt;</ph> méthode pour déterminer si une valeur n’est pas un nombre.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.NaN">
          <source>In general, <ph id="ph1">&lt;xref:System.Single&gt;</ph> operators cannot be used to compare <ph id="ph2">&lt;xref:System.Single.NaN?displayProperty=nameWithType&gt;</ph> with other <ph id="ph3">&lt;xref:System.Single&gt;</ph> values, although comparison methods (such as <ph id="ph4">&lt;xref:System.Single.Equals%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Single.CompareTo%2A&gt;</ph>) can.</source>
          <target state="translated">En général, <ph id="ph1">&lt;xref:System.Single&gt;</ph> opérateurs ne peut pas être utilisés pour comparer <ph id="ph2">&lt;xref:System.Single.NaN?displayProperty=nameWithType&gt;</ph> avec d’autres <ph id="ph3">&lt;xref:System.Single&gt;</ph> valeurs, bien que les méthodes de comparaison (tels que <ph id="ph4">&lt;xref:System.Single.Equals%2A&gt;</ph> et <ph id="ph5">&lt;xref:System.Single.CompareTo%2A&gt;</ph>) peut.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.NaN">
          <source>The following example illustrates the difference in behavior between <ph id="ph1">&lt;xref:System.Single&gt;</ph> comparison operators and methods.</source>
          <target state="translated">L’exemple suivant illustre la différence de comportement entre les <ph id="ph1">&lt;xref:System.Single&gt;</ph> les méthodes et les opérateurs de comparaison.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.NaN">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph> constant.</source>
          <target state="translated">L’exemple suivant illustre la <ph id="ph1">&lt;xref:System.Single.NaN&gt;</ph> constante.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="F:System.Single.NegativeInfinity">
          <source>Represents negative infinity.</source>
          <target state="translated">Représente l'infini négatif.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="F:System.Single.NegativeInfinity">
          <source>This field is constant.</source>
          <target state="translated">Ce champ est constant.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.NegativeInfinity">
          <source>The value of this constant is the result of dividing a negative number by zero.</source>
          <target state="translated">La valeur de cette constante est le résultat de la division par zéro d’un nombre négatif.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.NegativeInfinity">
          <source>This constant is returned when the result of an operation is less than <ph id="ph1">&lt;xref:System.Single.MinValue&gt;</ph>.</source>
          <target state="translated">Cette constante est retournée quand le résultat d’une opération est inférieur à <ph id="ph1">&lt;xref:System.Single.MinValue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.NegativeInfinity">
          <source>Use <ph id="ph1">&lt;xref:System.Single.IsNegativeInfinity%2A&gt;</ph> to determine whether a value evaluates to negative infinity.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Single.IsNegativeInfinity%2A&gt;</ph> pour déterminer si une valeur correspond à l’infini négatif.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.NegativeInfinity">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Single.NegativeInfinity&gt;</ph> constant.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Single.NegativeInfinity&gt;</ph> constante.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Single.op_Equality(System.Single,System.Single)">
          <source>The first value to compare.</source>
          <target state="translated">Première valeur à comparer.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Single.op_Equality(System.Single,System.Single)">
          <source>The second value to compare.</source>
          <target state="translated">Deuxième valeur à comparer.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Single.op_Equality(System.Single,System.Single)">
          <source>Returns a value that indicates whether two specified <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> values are equal.</source>
          <target state="translated">Retourne une valeur qui indique si deux valeurs <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> spécifiées sont égales.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Single.op_Equality(System.Single,System.Single)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> are equal; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="left" /&gt;</ph> et <ph id="ph3">&lt;paramref name="right" /&gt;</ph> sont égales ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.op_Equality(System.Single,System.Single)">
          <source>The <ph id="ph1">&lt;xref:System.Single.op_Equality%2A&gt;</ph> method defines the equality operator for <ph id="ph2">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single.op_Equality%2A&gt;</ph> méthode définit l’opérateur d’égalité pour <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Single.op_GreaterThan(System.Single,System.Single)">
          <source>The first value to compare.</source>
          <target state="translated">Première valeur à comparer.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Single.op_GreaterThan(System.Single,System.Single)">
          <source>The second value to compare.</source>
          <target state="translated">Deuxième valeur à comparer.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Single.op_GreaterThan(System.Single,System.Single)">
          <source>Returns a value that indicates whether a specified <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> value is greater than another specified <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> value.</source>
          <target state="translated">Retourne une valeur qui indique si une valeur <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> spécifique est supérieure à une autre valeur <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> spécifique.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Single.op_GreaterThan(System.Single,System.Single)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is greater than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="left" /&gt;</ph> est supérieur à <ph id="ph3">&lt;paramref name="right" /&gt;</ph> ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.op_GreaterThan(System.Single,System.Single)">
          <source>The <ph id="ph1">&lt;xref:System.Single.op_GreaterThan%2A&gt;</ph> method defines the operation of the greater-than operator for <ph id="ph2">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single.op_GreaterThan%2A&gt;</ph> méthode définit l’opération de la plus grande-que l’opérateur pour <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)">
          <source>The first value to compare.</source>
          <target state="translated">Première valeur à comparer.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)">
          <source>The second value to compare.</source>
          <target state="translated">Deuxième valeur à comparer.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)">
          <source>Returns a value that indicates whether a specified <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> value is greater than or equal to another specified <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> value.</source>
          <target state="translated">Retourne une valeur qui indique si une valeur <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> spécifique est supérieure ou égale à une autre valeur <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> spécifique.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is greater than or equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="left" /&gt;</ph> est supérieur ou égal à <ph id="ph3">&lt;paramref name="right" /&gt;</ph> ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)">
          <source>The <ph id="ph1">&lt;xref:System.Single.op_GreaterThanOrEqual%2A&gt;</ph> method defines the operation of the greater-than-or-equal operator for <ph id="ph2">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single.op_GreaterThanOrEqual%2A&gt;</ph> méthode définit l’opération de l’opérateur supérieur ou égal pour <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Single.op_Inequality(System.Single,System.Single)">
          <source>The first value to compare.</source>
          <target state="translated">Première valeur à comparer.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Single.op_Inequality(System.Single,System.Single)">
          <source>The second value to compare.</source>
          <target state="translated">Deuxième valeur à comparer.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Single.op_Inequality(System.Single,System.Single)">
          <source>Returns a value that indicates whether two specified <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> values are not equal.</source>
          <target state="translated">Retourne une valeur qui indique si deux valeurs <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> spécifiées sont différentes.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Single.op_Inequality(System.Single,System.Single)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> are not equal; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="left" /&gt;</ph> et <ph id="ph3">&lt;paramref name="right" /&gt;</ph> ne sont pas égales ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.op_Inequality(System.Single,System.Single)">
          <source>The <ph id="ph1">&lt;xref:System.Single.op_Inequality%2A&gt;</ph> method defines the inequality operator for <ph id="ph2">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single.op_Inequality%2A&gt;</ph> méthode définit l’opérateur d’inégalité pour <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Single.op_LessThan(System.Single,System.Single)">
          <source>The first value to compare.</source>
          <target state="translated">Première valeur à comparer.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Single.op_LessThan(System.Single,System.Single)">
          <source>The second value to compare.</source>
          <target state="translated">Deuxième valeur à comparer.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Single.op_LessThan(System.Single,System.Single)">
          <source>Returns a value that indicates whether a specified <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> value is less than another specified <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> value.</source>
          <target state="translated">Retourne une valeur qui indique si une valeur <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> spécifique est inférieure à une autre valeur <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> spécifique.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Single.op_LessThan(System.Single,System.Single)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is less than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="left" /&gt;</ph> est inférieur à <ph id="ph3">&lt;paramref name="right" /&gt;</ph> ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.op_LessThan(System.Single,System.Single)">
          <source>The <ph id="ph1">&lt;xref:System.Single.op_LessThan%2A&gt;</ph> method defines the operation of the less-than operator for <ph id="ph2">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single.op_LessThan%2A&gt;</ph> méthode définit l’opération moins-que l’opérateur pour <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)">
          <source>The first value to compare.</source>
          <target state="translated">Première valeur à comparer.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)">
          <source>The second value to compare.</source>
          <target state="translated">Deuxième valeur à comparer.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)">
          <source>Returns a value that indicates whether a specified <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> value is less than or equal to another specified <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> value.</source>
          <target state="translated">Retourne une valeur qui indique si une valeur <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> spécifique est inférieure ou égale à une autre valeur <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> spécifique.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is less than or equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="left" /&gt;</ph> est inférieur ou égal à <ph id="ph3">&lt;paramref name="right" /&gt;</ph> ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)">
          <source>The <ph id="ph1">&lt;xref:System.Single.op_LessThanOrEqual%2A&gt;</ph> method defines the operation of the less-than-or-equal operator for <ph id="ph2">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single.op_LessThanOrEqual%2A&gt;</ph> méthode définit l’opération de l’opérateur inférieur ou égal pour <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="T:System.Single">
          <source>Converts the string representation of a number to its single-precision floating-point number equivalent.</source>
          <target state="translated">Convertit la chaîne d'un nombre en nombre à virgule flottante simple précision équivalent.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String)">
          <source>A string that contains a number to convert.</source>
          <target state="translated">Chaîne contenant un nombre à convertir.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String)">
          <source>Converts the string representation of a number to its single-precision floating-point number equivalent.</source>
          <target state="translated">Convertit la chaîne d'un nombre en nombre à virgule flottante simple précision équivalent.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String)">
          <source>A single-precision floating-point number equivalent to the numeric value or symbol specified in <ph id="ph1">&lt;paramref name="s" /&gt;</ph>.</source>
          <target state="translated">Nombre à virgule flottante simple précision équivalant à la valeur numérique ou au symbole spécifié dans <ph id="ph1">&lt;paramref name="s" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>The <ph id="ph1">`s`</ph> parameter can contain the current culture's <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph>, or a string of the form:</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre peut contenir de la culture actuelle <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph>, ou une chaîne sous la forme :</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt>sign<ept id="p2">*</ept>] [<bpt id="p3">*</bpt>integral-digits<ept id="p3">*</ept>[<bpt id="p4">*</bpt>,<ept id="p4">*</ept>]]<bpt id="p5">*</bpt>integral-digits<ept id="p5">*</ept>[<bpt id="p6">*</bpt>.<ept id="p6">*</ept>[<bpt id="p7">*</bpt>fractional-digits<ept id="p7">*</ept>]][e[<bpt id="p8">*</bpt>sign<ept id="p8">*</ept>]<bpt id="p9">*</bpt>exponential-digits<ept id="p9">*</ept>][<bpt id="p10">*</bpt>ws<ept id="p10">*</ept>]</source>
          <target state="translated">[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt>sign<ept id="p2">*</ept>] [<bpt id="p3">*</bpt>integral-digits<ept id="p3">*</ept>[<bpt id="p4">*</bpt>,<ept id="p4">*</ept>]]<bpt id="p5">*</bpt>integral-digits<ept id="p5">*</ept>[<bpt id="p6">*</bpt>.<ept id="p6">*</ept>[<bpt id="p7">*</bpt>fractional-digits<ept id="p7">*</ept>]][e[<bpt id="p8">*</bpt>sign<ept id="p8">*</ept>]<bpt id="p9">*</bpt>exponential-digits<ept id="p9">*</ept>][<bpt id="p10">*</bpt>ws<ept id="p10">*</ept>]</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>Elements in square brackets ([ and ]) are optional.</source>
          <target state="translated">Les éléments entre crochets ([ et ]) sont facultatifs.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>The following table describes each element.</source>
          <target state="translated">Le tableau suivant décrit chaque élément.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>Element</source>
          <target state="translated">Élément</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>A series of white space characters.</source>
          <target state="translated">Une série de caractères d’espace blanc.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>A negative sign symbol or a positive sign symbol.</source>
          <target state="translated">Symbole du signe négatif ou le symbole du signe positif.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>Valid sign characters are determined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> properties of the current culture.</source>
          <target state="translated">Caractères de signe valides sont déterminés par le <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> propriétés de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>Only a leading sign can be used.</source>
          <target state="translated">Peut être utilisé uniquement un signe de début.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>A series of digits ranging from 0 to 9 that specify the integral part of the number.</source>
          <target state="translated">Une série de chiffres allant de 0 à 9 qui spécifie la partie entière du nombre.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>Runs of <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> can be partitioned by a group-separator symbol.</source>
          <target state="translated">S’exécute de <bpt id="p1">*</bpt>chiffres intégraux<ept id="p1">*</ept> peuvent être partitionnées par un symbole de séparateur de groupes.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>For example, in some cultures a comma (,) separates groups of thousands.</source>
          <target state="translated">Par exemple, dans certaines cultures une virgule (,) sépare les groupes de milliers.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>The <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> element can be absent if the string contains the <bpt id="p2">*</bpt>fractional-digits<ept id="p2">*</ept> element.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>chiffres intégraux<ept id="p1">*</ept> élément peut être absent si la chaîne contient la <bpt id="p2">*</bpt>chiffres fractionnaires<ept id="p2">*</ept> élément.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source><bpt id="p1">*</bpt>,<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>,<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>A culture-specific thousands separator symbol.</source>
          <target state="translated">Spécifiques à la culture des milliers symbole de séparateur.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source><bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>.<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>A culture-specific decimal point symbol.</source>
          <target state="translated">Un symbole décimal spécifiques à la culture.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>A series of digits ranging from 0 to 9 that specify the fractional part of the number.</source>
          <target state="translated">Une série de chiffres allant de 0 à 9 qui spécifie la partie fractionnaire du nombre.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>E</source>
          <target state="translated">E</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</source>
          <target state="translated">Le « e » ou un caractère « E », ce qui indique que la valeur est représentée dans la notation exponentielle (scientifique).</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>A series of digits ranging from 0 to 9 that specify an exponent.</source>
          <target state="translated">Une série de chiffres allant de 0 à 9 qui spécifie un exposant.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>The <ph id="ph1">`s`</ph> parameter is interpreted using a combination of the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> flags.</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre est interprété à l’aide d’une combinaison de la <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> indicateurs.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>This means that white space and thousands separators are allowed but currency symbols are not.</source>
          <target state="translated">Cela signifie que les espaces blancs et des milliers séparateurs sont autorisées mais ne sont pas les symboles monétaires.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>To explicitly define the elements (such as currency symbols, thousands separators, and white space) that can be present in <ph id="ph1">`s`</ph>, use the <ph id="ph2">&lt;xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29&gt;</ph> method overload.</source>
          <target state="translated">Pour définir explicitement les éléments (tels que les symboles monétaires, des milliers séparateurs et espace blanc) qui peuvent être présents dans <ph id="ph1">`s`</ph>, utilisez le <ph id="ph2">&lt;xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>The <ph id="ph1">`s`</ph> parameter is parsed by using the formatting information in a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that is initialized for the current system culture.</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre est analysé en utilisant les informations de mise en forme dans un <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet initialisé pour la culture système actuelle.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>To parse a string by using the formatting information of a specific culture, use the <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> method.</source>
          <target state="translated">Pour analyser une chaîne en utilisant les informations de mise en forme d’une culture spécifique, utilisez la <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29&gt;</ph> ou <ph id="ph2">&lt;xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>Ordinarily, if you pass the <ph id="ph1">&lt;xref:System.Single.Parse%2A&gt;</ph> method a string that is created by calling the <ph id="ph2">&lt;xref:System.Single.ToString%2A&gt;</ph> method, the original <ph id="ph3">&lt;xref:System.Single&gt;</ph> value is returned.</source>
          <target state="translated">En règle générale, si vous passez le <ph id="ph1">&lt;xref:System.Single.Parse%2A&gt;</ph> méthode une chaîne qui est créé en appelant le <ph id="ph2">&lt;xref:System.Single.ToString%2A&gt;</ph> , la méthode <ph id="ph3">&lt;xref:System.Single&gt;</ph> valeur est retournée.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>However, because of a loss of precision, the values may not be equal.</source>
          <target state="translated">Toutefois, en raison d’une perte de précision, les valeurs ne peuvent pas être égales.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>If a separator is encountered in the <ph id="ph1">`s`</ph> parameter during a parse operation, and the applicable currency or number decimal and group separators are the same, the parse operation assumes that the separator is a decimal separator rather than a group separator.</source>
          <target state="translated">Si un séparateur est rencontré dans le <ph id="ph1">`s`</ph> paramètre pendant une opération d’analyse et la devise ou un nombre décimal et les séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>For more information about separators, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les séparateurs, consultez <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, et <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%29&gt;</ph> method to convert an array of strings to equivalent <ph id="ph2">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%29&gt;</ph> méthode pour convertir un tableau de chaînes en équivalent <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> does not represent a number in a valid format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> ne représente pas un nombre au format valide.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> represents a number less than <ph id="ph2">&lt;see cref="F:System.Single.MinValue" /&gt;</ph> or greater than <ph id="ph3">&lt;see cref="F:System.Single.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> représente un nombre inférieur à <ph id="ph2">&lt;see cref="F:System.Single.MinValue" /&gt;</ph> ou supérieur à <ph id="ph3">&lt;see cref="F:System.Single.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A string that contains a number to convert.</source>
          <target state="translated">Chaîne contenant un nombre à convertir.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A bitwise combination of enumeration values that indicates the style elements that can be present in <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Combinaison au niveau du bit des valeurs d’énumération qui indique les éléments de style pouvant être présents dans <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A typical value to specify is <ph id="ph1">&lt;see cref="F:System.Globalization.NumberStyles.Float" /&gt;</ph> combined with <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowThousands" /&gt;</ph>.</source>
          <target state="translated">Une valeur typique à spécifier est <ph id="ph1">&lt;see cref="F:System.Globalization.NumberStyles.Float" /&gt;</ph> combinée avec <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowThousands" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Converts the string representation of a number in a specified style to its single-precision floating-point number equivalent.</source>
          <target state="translated">Convertit la chaîne d'un nombre dans un style spécifié en nombre à virgule flottante simple précision équivalent.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A single-precision floating-point number that is equivalent to the numeric value or symbol specified in <ph id="ph1">&lt;paramref name="s" /&gt;</ph>.</source>
          <target state="translated">Nombre à virgule flottante en simple précision équivalant à la valeur numérique ou au symbole spécifié dans <ph id="ph1">&lt;paramref name="s" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <ph id="ph1">`style`</ph> parameter defines the style elements (such as white space, thousands separators, and currency symbols) that are allowed in the <ph id="ph2">`s`</ph> parameter for the parse operation to succeed.</source>
          <target state="translated">Le <ph id="ph1">`style`</ph> paramètre définit les éléments de style (tels que des espaces blancs, des milliers les séparateurs et les symboles monétaires) qui sont autorisés dans les <ph id="ph2">`s`</ph> paramètre pour l’opération d’analyse.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>It must be a combination of bit flags from the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration.</source>
          <target state="translated">Il doit être une combinaison de bits indicateurs de le <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> énumération.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The following <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members are not supported:</source>
          <target state="translated">Les éléments suivants <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> membres ne sont pas pris en charge :</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <ph id="ph1">`s`</ph> parameter can contain the current culture's <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre peut contenir de la culture actuelle <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Depending on the value of <ph id="ph1">`style`</ph>, it can also take the form:</source>
          <target state="translated">Selon la valeur de <ph id="ph1">`style`</ph>, elle peut également prendre la forme :</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt><ph id="ph1">$</ph><ept id="p2">*</ept>][<bpt id="p3">*</bpt>sign<ept id="p3">*</ept>][<bpt id="p4">*</bpt>integral-digits<ept id="p4">*</ept>[<bpt id="p5">*</bpt>,<ept id="p5">*</ept>]]<bpt id="p6">*</bpt>integral-digits<ept id="p6">*</ept>[<bpt id="p7">*</bpt>.<ept id="p7">*</ept>[<bpt id="p8">*</bpt>fractional-digits<ept id="p8">*</ept>]][E[<bpt id="p9">*</bpt>sign<ept id="p9">*</ept>]<bpt id="p10">*</bpt>exponential-digits<ept id="p10">*</ept>][<bpt id="p11">*</bpt>ws<ept id="p11">*</ept>]</source>
          <target state="translated">[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt><ph id="ph1">$</ph><ept id="p2">*</ept>][<bpt id="p3">*</bpt>sign<ept id="p3">*</ept>][<bpt id="p4">*</bpt>integral-digits<ept id="p4">*</ept>[<bpt id="p5">*</bpt>,<ept id="p5">*</ept>]]<bpt id="p6">*</bpt>integral-digits<ept id="p6">*</ept>[<bpt id="p7">*</bpt>.<ept id="p7">*</ept>[<bpt id="p8">*</bpt>fractional-digits<ept id="p8">*</ept>]][E[<bpt id="p9">*</bpt>sign<ept id="p9">*</ept>]<bpt id="p10">*</bpt>exponential-digits<ept id="p10">*</ept>][<bpt id="p11">*</bpt>ws<ept id="p11">*</ept>]</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Elements in square brackets ([ and ]) are optional.</source>
          <target state="translated">Les éléments entre crochets ([ et ]) sont facultatifs.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The following table describes each element.</source>
          <target state="translated">Le tableau suivant décrit chaque élément.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A series of white-space characters.</source>
          <target state="translated">Une série de caractères d’espace blanc.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>White space can appear at the beginning of <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`s`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Espace blanc peut apparaître au début de <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> indicateur, qui peuvent apparaître à la fin de <ph id="ph4">`s`</ph> si <ph id="ph5">`style`</ph> inclut la <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A culture-specific currency symbol.</source>
          <target state="translated">Un symbole monétaire spécifique à la culture.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Its position in the string is defined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType&gt;</ph> properties of the current culture.</source>
          <target state="translated">Sa position dans la chaîne est définie par le <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType&gt;</ph> propriétés de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The current culture's currency symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Symbole de devise de la culture actuelle peut apparaître dans <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A negative sign symbol (-) or a positive sign symbol (+).</source>
          <target state="translated">Un symbole négatif (-) ou un signe positif (+) de symboles.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The sign can appear at the beginning of <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`s`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Le signe peut apparaître au début de <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType&gt;</ph> indicateur, qui peuvent apparaître à la fin de <ph id="ph4">`s`</ph> si <ph id="ph5">`style`</ph> inclut la <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Parentheses can be used in <ph id="ph1">`s`</ph> to indicate a negative value if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Parenthèses peuvent être utilisées dans <ph id="ph1">`s`</ph> pour indiquer une valeur négative si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A series of digits ranging from 0 to 9 that specify the integral part of the number.</source>
          <target state="translated">Une série de chiffres allant de 0 à 9 qui spécifie la partie entière du nombre.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> element can be absent if the string contains the <bpt id="p2">*</bpt>fractional-digits<ept id="p2">*</ept> element.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>chiffres intégraux<ept id="p1">*</ept> élément peut être absent si la chaîne contient la <bpt id="p2">*</bpt>chiffres fractionnaires<ept id="p2">*</ept> élément.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>,</source>
          <target state="translated">,</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A culture-specific group separator.</source>
          <target state="translated">Un séparateur de groupes spécifique à la culture.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The current culture's group separator symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> flag</source>
          <target state="translated">Symbole de séparateur de groupes de la culture actuelle peut apparaître dans <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> indicateur</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>.</source>
          <target state="translated">.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A culture-specific decimal point symbol.</source>
          <target state="translated">Un symbole décimal spécifiques à la culture.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The current culture's decimal point symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Symbole de virgule décimale de la culture actuelle peut apparaître dans <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A series of digits ranging from 0 to 9 that specify the fractional part of the number.</source>
          <target state="translated">Une série de chiffres allant de 0 à 9 qui spécifie la partie fractionnaire du nombre.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Fractional digits can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Chiffres fractionnaires peuvent apparaître dans <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>E</source>
          <target state="translated">E</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</source>
          <target state="translated">Le « e » ou un caractère « E », ce qui indique que la valeur est représentée dans la notation exponentielle (scientifique).</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <ph id="ph1">`value`</ph> parameter can represent a number in exponential notation if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Le <ph id="ph1">`value`</ph> paramètre peut représenter un nombre en notation exponentielle si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A series of digits ranging from 0 to 9 that specify an exponent.</source>
          <target state="translated">Une série de chiffres allant de 0 à 9 qui spécifie un exposant.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A string with digits only (which corresponds to the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType&gt;</ph> style) always parses successfully.</source>
          <target state="translated">Une chaîne contenant uniquement des chiffres (qui correspond à la <ph id="ph1">&lt;xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType&gt;</ph> style) toujours analysée avec succès.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The remaining <ph id="ph1">&lt;xref:System.Globalization.NumberStyles?displayProperty=nameWithType&gt;</ph> members control elements that may be present, but are not required to be present, in the input string.</source>
          <target state="translated">Les autres <ph id="ph1">&lt;xref:System.Globalization.NumberStyles?displayProperty=nameWithType&gt;</ph> membres contrôlent des éléments qui peuvent être présents, mais ne doivent pas être présents dans la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The following table indicates how individual <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> flags affect the elements that may be present in <ph id="ph2">`s`</ph>.</source>
          <target state="translated">Le tableau suivant indique comment chaque <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> indicateurs affectent les éléments qui peuvent être présents dans <ph id="ph2">`s`</ph>.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>NumberStyles value</source>
          <target state="translated">Valeur NumberStyles</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Elements permitted in <ph id="ph1">`s`</ph> in addition to digits</source>
          <target state="translated">Éléments autorisés dans <ph id="ph1">`s`</ph> en plus des chiffres</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> element only.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>chiffres intégraux<ept id="p1">*</ept> élément uniquement.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The decimal point (<bpt id="p1">*</bpt>.<ept id="p1">*</ept>) and <bpt id="p2">*</bpt>fractional-digits<ept id="p2">*</ept> elements.</source>
          <target state="translated">Le point décimal (<bpt id="p1">*</bpt>.<ept id="p1">*</ept>) et <bpt id="p2">*</bpt>chiffres fractionnaires<ept id="p2">*</ept> éléments.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The "e" or "E" character, which indicates exponential notation.</source>
          <target state="translated">Le « e » ou un caractère « E », ce qui indique la notation exponentielle.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>This flag by itself supports values in the form <bpt id="p1">*</bpt>digits<ept id="p1">*</ept>E<bpt id="p2">*</bpt>digits<ept id="p2">*</ept>; additional flags are needed to successfully parse strings with such elements as positive or negative signs and decimal point symbols.</source>
          <target state="translated">Cet indicateur par lui-même prend en charge les valeurs sous la forme <bpt id="p1">*</bpt>chiffres<ept id="p1">*</ept>E<bpt id="p2">*</bpt>chiffres<ept id="p2">*</ept>; autres indicateurs sont nécessaires pour analyser correctement les chaînes avec des éléments tels que des signes positifs ou négatifs et des symboles de séparateur décimal.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the beginning of <ph id="ph1">`s`</ph>.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> élément au début de <ph id="ph1">`s`</ph>.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the end of <ph id="ph1">`s`</ph>.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> élément à la fin de <ph id="ph1">`s`</ph>.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the beginning of <ph id="ph1">`s`</ph>.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>signe<ept id="p1">*</ept> élément au début de <ph id="ph1">`s`</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the end of <ph id="ph1">`s`</ph>.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>signe<ept id="p1">*</ept> élément à la fin de <ph id="ph1">`s`</ph>.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element in the form of parentheses enclosing the numeric value.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>signe<ept id="p1">*</ept> élément sous la forme de parenthèses entourant la valeur numérique.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The thousands separator (,) element.</source>
          <target state="translated">Les milliers élément séparateur (,).</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The currency ($) element.</source>
          <target state="translated">Élément de devise ($).</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>All elements.</source>
          <target state="translated">Tous les éléments.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>However, <ph id="ph1">`s`</ph> cannot represent a hexadecimal number or a number in exponential notation.</source>
          <target state="translated">Toutefois, <ph id="ph1">`s`</ph> ne peut pas représenter un nombre hexadécimal ou un nombre en notation exponentielle.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the beginning or end of <ph id="ph1">`s`</ph>, <bpt id="p2">*</bpt>sign<ept id="p2">*</ept> at the beginning of <ph id="ph2">`s`</ph>, and the decimal point (.) symbol.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> élément au début ou à la fin de <ph id="ph1">`s`</ph>, <bpt id="p2">*</bpt>signe<ept id="p2">*</ept> au début de <ph id="ph2">`s`</ph>et le symbole de virgule décimale (.).</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <ph id="ph1">`s`</ph> parameter can also use exponential notation.</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre peut également utiliser la notation exponentielle.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <ph id="ph1">`ws`</ph>, <ph id="ph2">`sign`</ph>, thousands separator (,) and decimal point (.) elements.</source>
          <target state="translated">Le <ph id="ph1">`ws`</ph>, <ph id="ph2">`sign`</ph>, des milliers séparateur (,) et des éléments de virgule décimale (.).</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>All elements.</source>
          <target state="translated">Tous les éléments.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>However, <ph id="ph1">`s`</ph> cannot represent a hexadecimal number.</source>
          <target state="translated">Toutefois, <ph id="ph1">`s`</ph> ne peut pas représenter un nombre hexadécimal.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Some examples of <ph id="ph1">`s`</ph> are "100", "-123,456,789", "123.45e+6", "+500", "5e2", "3.1416", "600.", "-.123", and "-Infinity".</source>
          <target state="translated">Quelques exemples de <ph id="ph1">`s`</ph> sont « 100 », «-123 456 789 », « 123.45e + 6 », « + 500 », « 5e2 », « 3,1416 », « 600 », «-. 123 », et «-Infinity ».</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <ph id="ph1">`s`</ph> parameter is parsed using the formatting information in a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that is initialized for the current system culture.</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre est analysé en utilisant les informations de mise en forme dans un <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet initialisé pour la culture système actuelle.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>To specify the culture whose formatting information is used for the parse operation, call the <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> overload.</source>
          <target state="translated">Pour spécifier la culture dont les informations de mise en forme sont utilisées pour l’opération d’analyse, appelez le <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> de surcharge.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Ordinarily, if you pass the <ph id="ph1">&lt;xref:System.Single.Parse%2A&gt;</ph> method a string that is created by calling the <ph id="ph2">&lt;xref:System.Single.ToString%2A&gt;</ph> method, the original <ph id="ph3">&lt;xref:System.Single&gt;</ph> value is returned.</source>
          <target state="translated">En règle générale, si vous passez le <ph id="ph1">&lt;xref:System.Single.Parse%2A&gt;</ph> méthode une chaîne qui est créé en appelant le <ph id="ph2">&lt;xref:System.Single.ToString%2A&gt;</ph> , la méthode <ph id="ph3">&lt;xref:System.Single&gt;</ph> valeur est retournée.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>However, because of a loss of precision, the values may not be equal.</source>
          <target state="translated">Toutefois, en raison d’une perte de précision, les valeurs ne peuvent pas être égales.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>If a separator is encountered in the <ph id="ph1">`s`</ph> parameter during a parse operation, and the applicable currency or number decimal and group separators are the same, the parse operation assumes that the separator is a decimal separator rather than a group separator.</source>
          <target state="translated">Si un séparateur est rencontré dans le <ph id="ph1">`s`</ph> paramètre pendant une opération d’analyse et la devise ou un nombre décimal et les séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>For more information about separators, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les séparateurs, consultez <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, et <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29&gt;</ph> method to parse the string representations of <ph id="ph2">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29&gt;</ph> méthode pour analyser les représentations sous forme de chaîne de <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The example uses formatting information for the en-US culture.</source>
          <target state="translated">L’exemple utilise les informations de mise en forme pour la culture en-US.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is not a number in a valid format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> n’est pas un nombre exprimé dans un format valide.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> represents a number that is less than <ph id="ph2">&lt;see cref="F:System.Single.MinValue" /&gt;</ph> or greater than <ph id="ph3">&lt;see cref="F:System.Single.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> représente un nombre qui est inférieur à <ph id="ph2">&lt;see cref="F:System.Single.MinValue" /&gt;</ph> ou supérieur à <ph id="ph3">&lt;see cref="F:System.Single.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source><ph id="ph1">&lt;paramref name="style" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Globalization.NumberStyles" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="style" /&gt;</ph> n’est pas une valeur <ph id="ph2">&lt;see cref="T:System.Globalization.NumberStyles" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)">
          <source><ph id="ph1">&lt;paramref name="style" /&gt;</ph> includes the <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="style" /&gt;</ph> inclut la valeur <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>A string that contains a number to convert.</source>
          <target state="translated">Chaîne contenant un nombre à convertir.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>An object that supplies culture-specific formatting information about <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Objet qui fournit des informations de mise en forme propres à la culture sur <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>Converts the string representation of a number in a specified culture-specific format to its single-precision floating-point number equivalent.</source>
          <target state="translated">Convertit la chaîne d'un nombre dans un format propre à la culture spécifiée en nombre à virgule flottante simple précision équivalent.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>A single-precision floating-point number equivalent to the numeric value or symbol specified in <ph id="ph1">&lt;paramref name="s" /&gt;</ph>.</source>
          <target state="translated">Nombre à virgule flottante simple précision équivalant à la valeur numérique ou au symbole spécifié dans <ph id="ph1">&lt;paramref name="s" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>This overload is typically used to convert text that can be formatted in a variety of ways to a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value.</source>
          <target state="translated">Cette surcharge est généralement utilisée pour convertir du texte qui peut être mis en forme de différentes façons pour un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>For example, it can be used to convert the text entered by a user into an HTML text box to a numeric value.</source>
          <target state="translated">Par exemple, il peut être utilisé pour convertir le texte entré par un utilisateur dans une zone de texte HTML à une valeur numérique.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">`s`</ph> parameter is interpreted using a combination of the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> flags.</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre est interprété à l’aide d’une combinaison de la <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> indicateurs.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">`s`</ph> parameter can contain <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType&gt;</ph> for the culture specified by <ph id="ph5">`provider`</ph>, or it can contain a string of the form:</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre peut contenir <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType&gt;</ph>, ou <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType&gt;</ph> pour la culture spécifiée par <ph id="ph5">`provider`</ph>, ou il peut contenir une chaîne sous la forme :</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt>sign<ept id="p2">*</ept>]<bpt id="p3">*</bpt>integral-digits<ept id="p3">*</ept>[<bpt id="p4">*</bpt>.<ept id="p4">*</ept>[<bpt id="p5">*</bpt>fractional-digits<ept id="p5">*</ept>]][E[<bpt id="p6">*</bpt>sign<ept id="p6">*</ept>]<bpt id="p7">*</bpt>exponential-digits<ept id="p7">*</ept>][<bpt id="p8">*</bpt>ws<ept id="p8">*</ept>]</source>
          <target state="translated">[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt>sign<ept id="p2">*</ept>]<bpt id="p3">*</bpt>integral-digits<ept id="p3">*</ept>[<bpt id="p4">*</bpt>.<ept id="p4">*</ept>[<bpt id="p5">*</bpt>fractional-digits<ept id="p5">*</ept>]][E[<bpt id="p6">*</bpt>sign<ept id="p6">*</ept>]<bpt id="p7">*</bpt>exponential-digits<ept id="p7">*</ept>][<bpt id="p8">*</bpt>ws<ept id="p8">*</ept>]</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>Optional elements are framed in square brackets ([ and ]).</source>
          <target state="translated">Éléments facultatifs sont encadrés par des crochets ([et]).</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>Elements that contain the term "digits" consist of a series of numeric characters ranging from 0 to 9.</source>
          <target state="translated">Les éléments qui contiennent le terme « chiffres » sont constitués d’une série de chiffres allant de 0 à 9.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>Element</source>
          <target state="translated">Élément</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>A series of white-space characters.</source>
          <target state="translated">Une série de caractères d’espace blanc.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>A negative sign symbol (-) or a positive sign symbol (+).</source>
          <target state="translated">Un symbole négatif (-) ou un signe positif (+) de symboles.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>A series of digits ranging from 0 to 9 that specify the integral part of the number.</source>
          <target state="translated">Une série de chiffres allant de 0 à 9 qui spécifie la partie entière du nombre.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>Runs of <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> can be partitioned by a group-separator symbol.</source>
          <target state="translated">S’exécute de <bpt id="p1">*</bpt>chiffres intégraux<ept id="p1">*</ept> peuvent être partitionnées par un symbole de séparateur de groupes.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>For example, in some cultures a comma (,) separates groups of thousands.</source>
          <target state="translated">Par exemple, dans certaines cultures une virgule (,) sépare les groupes de milliers.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>The <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> element can be absent if the string contains the <bpt id="p2">*</bpt>fractional-digits<ept id="p2">*</ept> element.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>chiffres intégraux<ept id="p1">*</ept> élément peut être absent si la chaîne contient la <bpt id="p2">*</bpt>chiffres fractionnaires<ept id="p2">*</ept> élément.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>.</source>
          <target state="translated">.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>A culture-specific decimal point symbol.</source>
          <target state="translated">Un symbole décimal spécifiques à la culture.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>A series of digits ranging from 0 to 9 that specify the fractional part of the number.</source>
          <target state="translated">Une série de chiffres allant de 0 à 9 qui spécifie la partie fractionnaire du nombre.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>E</source>
          <target state="translated">E</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</source>
          <target state="translated">Le « e » ou un caractère « E », ce qui indique que la valeur est représentée dans la notation exponentielle (scientifique).</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>A series of digits ranging from 0 to 9 that specify an exponent.</source>
          <target state="translated">Une série de chiffres allant de 0 à 9 qui spécifie un exposant.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>For more information about numeric formats, see the <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept> topic.</source>
          <target state="translated">Pour plus d’informations sur les formats numériques, consultez la <bpt id="p1">[</bpt>mise en forme des Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept> rubrique.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation whose <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific formatting information.</source>
          <target state="translated">Le <ph id="ph1">`provider`</ph> paramètre est un <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implémentation dont <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> méthode retourne un <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet qui fournit des informations de mise en forme propres à la culture.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>When the <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29&gt;</ph> method is invoked, it calls the <ph id="ph2">`provider`</ph> parameter's <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method and passes it a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> type.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29&gt;</ph> méthode est appelée, elle appelle la <ph id="ph2">`provider`</ph> du paramètre <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> (méthode) et lui passe un <ph id="ph4">&lt;xref:System.Type&gt;</ph> objet qui représente le <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> type.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method then returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides information about the format of the <ph id="ph3">`s`</ph> parameter.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> méthode renvoie alors le <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet qui fournit des informations sur le format de le <ph id="ph3">`s`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>There are three ways to use the <ph id="ph1">`provider`</ph> parameter to supply custom formatting information to the parse operation:</source>
          <target state="translated">Il existe trois façons d’utiliser le <ph id="ph1">`provider`</ph> paramètre pour fournir des informations de mise en forme personnalisées à l’opération d’analyse :</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>You can pass a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that supplies formatting information.</source>
          <target state="translated">Vous pouvez passer un <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objet qui représente la culture qui fournit des informations de mise en forme.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information for that culture.</source>
          <target state="translated">Son <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> méthode retourne la <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet qui fournit des informations de mise en forme numériques pour cette culture.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>You can pass the actual <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information.</source>
          <target state="translated">Vous pouvez passer le réel <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet qui fournit des informations de mise en forme numériques.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>(Its implementation of <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> just returns itself.)</source>
          <target state="translated">(Son implémentation de <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> retourne simplement lui-même.)</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>You can pass a custom object that implements <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>.</source>
          <target state="translated">Vous pouvez passer un objet personnalisé qui implémente <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method instantiates and returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information.</source>
          <target state="translated">Son <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> méthode instancie et retourne le <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet qui fournit des informations de mise en forme.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph> or a <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> cannot be obtained, the formatting information for the current system culture is used.</source>
          <target state="translated">Si <ph id="ph1">`provider`</ph> est <ph id="ph2">`null`</ph> ou un <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> ne peut pas être obtenu, les informations de mise en forme pour la culture système en cours est utilisée.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>If a separator is encountered in the <ph id="ph1">`s`</ph> parameter during a parse operation, and the applicable currency or number decimal and group separators are the same, the parse operation assumes that the separator is a decimal separator rather than a group separator.</source>
          <target state="translated">Si un séparateur est rencontré dans le <ph id="ph1">`s`</ph> paramètre pendant une opération d’analyse et la devise ou un nombre décimal et les séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>For more information about separators, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les séparateurs, consultez <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, et <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>Some examples of <ph id="ph1">`s`</ph> are "100", "-123,456,789", "123.45e+6", "+500", "5e2", "3.1416", "600.", "-.123", and "-Infinity".</source>
          <target state="translated">Quelques exemples de <ph id="ph1">`s`</ph> sont « 100 », «-123 456 789 », « 123.45e + 6 », « + 500 », « 5e2 », « 3,1416 », « 600 », «-. 123 », et «-Infinity ».</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>The following example is the button click event handler of a Web form.</source>
          <target state="translated">L’exemple suivant est le bouton sur le Gestionnaire d’événements d’un formulaire Web.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>It uses the array returned by the <ph id="ph1">&lt;xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType&gt;</ph> property to determine the user's locale.</source>
          <target state="translated">Il utilise le tableau retourné par la <ph id="ph1">&lt;xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType&gt;</ph> propriété pour déterminer les paramètres régionaux de l’utilisateur.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>It then instantiates a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that corresponds to that locale.</source>
          <target state="translated">Il instancie ensuite un <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objet qui correspond à ces paramètres régionaux.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that belongs to that <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object is then passed to the <ph id="ph3">&lt;xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29&gt;</ph> method to convert the user's input to a <ph id="ph4">&lt;xref:System.Single&gt;</ph> value.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet qui appartient à cet <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objet est ensuite transmis à la <ph id="ph3">&lt;xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29&gt;</ph> d’entrée de méthode pour convertir l’utilisateur à un <ph id="ph4">&lt;xref:System.Single&gt;</ph> valeur.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> does not represent a number in a valid format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> ne représente pas un nombre au format valide.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> represents a number less than <ph id="ph2">&lt;see cref="F:System.Single.MinValue" /&gt;</ph> or greater than <ph id="ph3">&lt;see cref="F:System.Single.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> représente un nombre inférieur à <ph id="ph2">&lt;see cref="F:System.Single.MinValue" /&gt;</ph> ou supérieur à <ph id="ph3">&lt;see cref="F:System.Single.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A string that contains a number to convert.</source>
          <target state="translated">Chaîne contenant un nombre à convertir.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A bitwise combination of enumeration values that indicates the style elements that can be present in <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Combinaison au niveau du bit des valeurs d’énumération qui indique les éléments de style pouvant être présents dans <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A typical value to specify is <ph id="ph1">&lt;see cref="F:System.Globalization.NumberStyles.Float" /&gt;</ph> combined with <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowThousands" /&gt;</ph>.</source>
          <target state="translated">Une valeur typique à spécifier est <ph id="ph1">&lt;see cref="F:System.Globalization.NumberStyles.Float" /&gt;</ph> combinée avec <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowThousands" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>An object that supplies culture-specific formatting information about <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Objet qui fournit des informations de mise en forme propres à la culture sur <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Converts the string representation of a number in a specified style and culture-specific format to its single-precision floating-point number equivalent.</source>
          <target state="translated">Convertit la chaîne d'un nombre dans un style et un format propre à la culture spécifiés en nombre à virgule flottante simple précision équivalent.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A single-precision floating-point number equivalent to the numeric value or symbol specified in <ph id="ph1">&lt;paramref name="s" /&gt;</ph>.</source>
          <target state="translated">Nombre à virgule flottante simple précision équivalant à la valeur numérique ou au symbole spécifié dans <ph id="ph1">&lt;paramref name="s" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <ph id="ph1">`style`</ph> parameter defines the style elements (such as white space, thousands separators, and currency symbols) that are allowed in the <ph id="ph2">`s`</ph> parameter for the parse operation to succeed.</source>
          <target state="translated">Le <ph id="ph1">`style`</ph> paramètre définit les éléments de style (tels que des espaces blancs, des milliers les séparateurs et les symboles monétaires) qui sont autorisés dans les <ph id="ph2">`s`</ph> paramètre pour l’opération d’analyse.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>It must be a combination of bit flags from the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration.</source>
          <target state="translated">Il doit être une combinaison de bits indicateurs de le <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> énumération.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The following <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members are not supported:</source>
          <target state="translated">Les éléments suivants <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> membres ne sont pas pris en charge :</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <ph id="ph1">`s`</ph> parameter can contain <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType&gt;</ph> for the culture specified by <ph id="ph5">`provider`</ph>.</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre peut contenir <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType&gt;</ph>, ou <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType&gt;</ph> pour la culture spécifiée par <ph id="ph5">`provider`</ph>.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Depending on the value of <ph id="ph1">`style`</ph>, it can also take the form:</source>
          <target state="translated">Selon la valeur de <ph id="ph1">`style`</ph>, elle peut également prendre la forme :</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>] [<bpt id="p2">*</bpt><ph id="ph1">$</ph><ept id="p2">*</ept>] [<bpt id="p3">*</bpt>sign<ept id="p3">*</ept>][<bpt id="p4">*</bpt>integral-digits<ept id="p4">*</ept>,]<bpt id="p5">*</bpt>integral-digits<ept id="p5">*</ept>[.[<bpt id="p6">*</bpt>fractional-digits<ept id="p6">*</ept>]][E[<bpt id="p7">*</bpt>sign<ept id="p7">*</ept>]<bpt id="p8">*</bpt>exponential-digits<ept id="p8">*</ept>][<bpt id="p9">*</bpt>ws<ept id="p9">*</ept>]</source>
          <target state="translated">[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>] [<bpt id="p2">*</bpt><ph id="ph1">$</ph><ept id="p2">*</ept>] [<bpt id="p3">*</bpt>sign<ept id="p3">*</ept>][<bpt id="p4">*</bpt>integral-digits<ept id="p4">*</ept>,]<bpt id="p5">*</bpt>integral-digits<ept id="p5">*</ept>[.[<bpt id="p6">*</bpt>fractional-digits<ept id="p6">*</ept>]][E[<bpt id="p7">*</bpt>sign<ept id="p7">*</ept>]<bpt id="p8">*</bpt>exponential-digits<ept id="p8">*</ept>][<bpt id="p9">*</bpt>ws<ept id="p9">*</ept>]</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Elements framed in square brackets ([ and ]) are optional.</source>
          <target state="translated">Éléments encadrés par des crochets ([et]) sont facultatifs.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The following table describes each element.</source>
          <target state="translated">Le tableau suivant décrit chaque élément.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Element</source>
          <target state="translated">Élément</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A series of white-space characters.</source>
          <target state="translated">Une série de caractères d’espace blanc.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>White space can appear at the beginning of <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`s`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Espace blanc peut apparaître au début de <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> indicateur, qui peuvent apparaître à la fin de <ph id="ph4">`s`</ph> si <ph id="ph5">`style`</ph> inclut la <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A culture-specific currency symbol.</source>
          <target state="translated">Un symbole monétaire spécifique à la culture.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Its position in the string is defined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType&gt;</ph> properties of the current culture.</source>
          <target state="translated">Sa position dans la chaîne est définie par le <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType&gt;</ph> propriétés de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The current culture's currency symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Symbole de devise de la culture actuelle peut apparaître dans <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A negative sign symbol (-) or a positive sign symbol (+).</source>
          <target state="translated">Un symbole négatif (-) ou un signe positif (+) de symboles.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The sign can appear at the beginning of <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`s`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Le signe peut apparaître au début de <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType&gt;</ph> indicateur, qui peuvent apparaître à la fin de <ph id="ph4">`s`</ph> si <ph id="ph5">`style`</ph> inclut la <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Parentheses can be used in <ph id="ph1">`s`</ph> to indicate a negative value if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Parenthèses peuvent être utilisées dans <ph id="ph1">`s`</ph> pour indiquer une valeur négative si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A series of digits ranging from 0 to 9 that specify the integral part of the number.</source>
          <target state="translated">Une série de chiffres allant de 0 à 9 qui spécifie la partie entière du nombre.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> element can be absent if the string contains the <bpt id="p2">*</bpt>fractional-digits<ept id="p2">*</ept> element.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>chiffres intégraux<ept id="p1">*</ept> élément peut être absent si la chaîne contient la <bpt id="p2">*</bpt>chiffres fractionnaires<ept id="p2">*</ept> élément.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>,</source>
          <target state="translated">,</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A culture-specific group separator.</source>
          <target state="translated">Un séparateur de groupes spécifique à la culture.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The current culture's group separator symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> flag</source>
          <target state="translated">Symbole de séparateur de groupes de la culture actuelle peut apparaître dans <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> indicateur</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>.</source>
          <target state="translated">.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A culture-specific decimal point symbol.</source>
          <target state="translated">Un symbole décimal spécifiques à la culture.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The current culture's decimal point symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Symbole de virgule décimale de la culture actuelle peut apparaître dans <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A series of digits ranging from 0 to 9 that specify the fractional part of the number.</source>
          <target state="translated">Une série de chiffres allant de 0 à 9 qui spécifie la partie fractionnaire du nombre.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Fractional digits can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Chiffres fractionnaires peuvent apparaître dans <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>E</source>
          <target state="translated">E</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</source>
          <target state="translated">Le « e » ou un caractère « E », ce qui indique que la valeur est représentée dans la notation exponentielle (scientifique).</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <ph id="ph1">`s`</ph> parameter can represent a number in exponential notation if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre peut représenter un nombre en notation exponentielle si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A series of digits ranging from 0 to 9 that specify an exponent.</source>
          <target state="translated">Une série de chiffres allant de 0 à 9 qui spécifie un exposant.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A string with digits only (which corresponds to the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType&gt;</ph> style) always parses successfully.</source>
          <target state="translated">Une chaîne contenant uniquement des chiffres (qui correspond à la <ph id="ph1">&lt;xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType&gt;</ph> style) toujours analysée avec succès.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The remaining <ph id="ph1">&lt;xref:System.Globalization.NumberStyles?displayProperty=nameWithType&gt;</ph> members control elements that may be present, but are not required to be present, in the input string.</source>
          <target state="translated">Les autres <ph id="ph1">&lt;xref:System.Globalization.NumberStyles?displayProperty=nameWithType&gt;</ph> membres contrôlent des éléments qui peuvent être présents, mais ne doivent pas être présents dans la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The following table indicates how individual <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> flags affect the elements that may be present in <ph id="ph2">`s`</ph>.</source>
          <target state="translated">Le tableau suivant indique comment chaque <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> indicateurs affectent les éléments qui peuvent être présents dans <ph id="ph2">`s`</ph>.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>NumberStyles value</source>
          <target state="translated">Valeur NumberStyles</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Elements permitted in <ph id="ph1">`s`</ph> in addition to digits</source>
          <target state="translated">Éléments autorisés dans <ph id="ph1">`s`</ph> en plus des chiffres</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> element only.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>chiffres intégraux<ept id="p1">*</ept> élément uniquement.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The decimal point (<bpt id="p1">*</bpt>.<ept id="p1">*</ept>) and <bpt id="p2">*</bpt>fractional-digits<ept id="p2">*</ept> elements.</source>
          <target state="translated">Le point décimal (<bpt id="p1">*</bpt>.<ept id="p1">*</ept>) et <bpt id="p2">*</bpt>chiffres fractionnaires<ept id="p2">*</ept> éléments.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The "e" or "E" character, which indicates exponential notation.</source>
          <target state="translated">Le « e » ou un caractère « E », ce qui indique la notation exponentielle.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>This flag by itself supports values in the form <bpt id="p1">*</bpt>digits<ept id="p1">*</ept>E<bpt id="p2">*</bpt>digits<ept id="p2">*</ept>; additional flags are needed to successfully parse strings with such elements as positive or negative signs and decimal point symbols.</source>
          <target state="translated">Cet indicateur par lui-même prend en charge les valeurs sous la forme <bpt id="p1">*</bpt>chiffres<ept id="p1">*</ept>E<bpt id="p2">*</bpt>chiffres<ept id="p2">*</ept>; autres indicateurs sont nécessaires pour analyser correctement les chaînes avec des éléments tels que des signes positifs ou négatifs et des symboles de séparateur décimal.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the beginning of <ph id="ph1">`s`</ph>.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> élément au début de <ph id="ph1">`s`</ph>.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the end of <ph id="ph1">`s`</ph>.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> élément à la fin de <ph id="ph1">`s`</ph>.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the beginning of <ph id="ph1">`s`</ph>.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>signe<ept id="p1">*</ept> élément au début de <ph id="ph1">`s`</ph>.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the end of <ph id="ph1">`s`</ph>.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>signe<ept id="p1">*</ept> élément à la fin de <ph id="ph1">`s`</ph>.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element in the form of parentheses enclosing the numeric value.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>signe<ept id="p1">*</ept> élément sous la forme de parenthèses entourant la valeur numérique.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The thousands separator (,) element.</source>
          <target state="translated">Les milliers élément séparateur (,).</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The currency ($) element.</source>
          <target state="translated">Élément de devise ($).</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>All elements.</source>
          <target state="translated">Tous les éléments.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>However, <ph id="ph1">`s`</ph> cannot represent a hexadecimal number or a number in exponential notation.</source>
          <target state="translated">Toutefois, <ph id="ph1">`s`</ph> ne peut pas représenter un nombre hexadécimal ou un nombre en notation exponentielle.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the beginning or end of <ph id="ph1">`s`</ph>, <bpt id="p2">*</bpt>sign<ept id="p2">*</ept> at the beginning of <ph id="ph2">`s`</ph>, and the decimal point (.) symbol.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> élément au début ou à la fin de <ph id="ph1">`s`</ph>, <bpt id="p2">*</bpt>signe<ept id="p2">*</ept> au début de <ph id="ph2">`s`</ph>et le symbole de virgule décimale (.).</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <ph id="ph1">`s`</ph> parameter can also use exponential notation.</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre peut également utiliser la notation exponentielle.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <ph id="ph1">`ws`</ph>, <ph id="ph2">`sign`</ph>, thousands separator (,) and decimal point (.) elements.</source>
          <target state="translated">Le <ph id="ph1">`ws`</ph>, <ph id="ph2">`sign`</ph>, des milliers séparateur (,) et des éléments de virgule décimale (.).</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>All elements.</source>
          <target state="translated">Tous les éléments.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>However, <ph id="ph1">`s`</ph> cannot represent a hexadecimal number.</source>
          <target state="translated">Toutefois, <ph id="ph1">`s`</ph> ne peut pas représenter un nombre hexadécimal.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation.</source>
          <target state="translated">Le <ph id="ph1">`provider`</ph> paramètre est un <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> mise en œuvre.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific information about the format of <ph id="ph3">`value`</ph>.</source>
          <target state="translated">Son <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> méthode retourne un <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet qui fournit des informations spécifiques à la culture concernant le format de <ph id="ph3">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Typically, <ph id="ph1">`provider`</ph> can be any one of the following:</source>
          <target state="translated">En règle générale, <ph id="ph1">`provider`</ph> peut prendre l’une des opérations suivantes :</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that provides numeric formatting information.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objet qui représente la culture qui fournit des informations de mise en forme numériques.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information.</source>
          <target state="translated">Son <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> méthode retourne la <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet qui fournit des informations de mise en forme numériques.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet qui fournit des informations de mise en forme.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>(Its implementation of <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> just returns itself.)</source>
          <target state="translated">(Son implémentation de <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> retourne simplement lui-même.)</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A custom object that implements <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> and uses the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> method to instantiate and return the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information.</source>
          <target state="translated">Un objet personnalisé qui implémente <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> et utilise le <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> méthode pour instancier et retourner le <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet qui fournit des informations de mise en forme.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for the current culture is used.</source>
          <target state="translated">Si <ph id="ph1">`provider`</ph> est <ph id="ph2">`null`</ph>, le <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> de l’objet de la culture actuelle est utilisé.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>If a separator is encountered in the <ph id="ph1">`s`</ph> parameter during a parse operation, and the applicable currency or number decimal and group separators are the same, the parse operation assumes that the separator is a decimal separator rather than a group separator.</source>
          <target state="translated">Si un séparateur est rencontré dans le <ph id="ph1">`s`</ph> paramètre pendant une opération d’analyse et la devise ou un nombre décimal et les séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>For more information about separators, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les séparateurs, consultez <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, et <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> method to parse the string representations of <ph id="ph2">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">Le code suivant exemple utilise le <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> méthode pour analyser les représentations sous forme de chaîne de <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Each string in an array is parsed using the formatting conventions of the en-US, nl-NL, and a custom culture.</source>
          <target state="translated">Chaque chaîne dans un tableau est analysée à l’aide des conventions de format de l’en-US, nl-NL et une culture personnalisée.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The custom culture defines its group separator symbol as the underscore ("_") and its group size as two.</source>
          <target state="translated">La culture personnalisée définit son symbole de séparateur de groupe en tant que le trait de soulignement (« _ ») et sa taille de groupe sous forme de deux.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> does not represent a numeric value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> ne représente pas une valeur numérique.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="style" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Globalization.NumberStyles" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="style" /&gt;</ph> n’est pas une valeur <ph id="ph2">&lt;see cref="T:System.Globalization.NumberStyles" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="style" /&gt;</ph> is the <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="style" /&gt;</ph> est la valeur <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> represents a number that is less than <ph id="ph2">&lt;see cref="F:System.Single.MinValue" /&gt;</ph> or greater than <ph id="ph3">&lt;see cref="F:System.Single.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> représente un nombre qui est inférieur à <ph id="ph2">&lt;see cref="F:System.Single.MinValue" /&gt;</ph> ou supérieur à <ph id="ph3">&lt;see cref="F:System.Single.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="F:System.Single.PositiveInfinity">
          <source>Represents positive infinity.</source>
          <target state="translated">Représente l'infini positif.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="F:System.Single.PositiveInfinity">
          <source>This field is constant.</source>
          <target state="translated">Ce champ est constant.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.PositiveInfinity">
          <source>The value of this constant is the result of dividing a positive number by zero.</source>
          <target state="translated">La valeur de cette constante est le résultat de la division par zéro d’un nombre positif.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.PositiveInfinity">
          <source>This constant is returned when the result of an operation is greater than <ph id="ph1">&lt;xref:System.Single.MaxValue&gt;</ph>.</source>
          <target state="translated">Cette constante est retournée quand le résultat d’une opération est supérieur à <ph id="ph1">&lt;xref:System.Single.MaxValue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.PositiveInfinity">
          <source>Use <ph id="ph1">&lt;xref:System.Single.IsPositiveInfinity%2A&gt;</ph> to determine whether a value evaluates to positive infinity.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Single.IsPositiveInfinity%2A&gt;</ph> pour déterminer si une valeur correspond à l’infini positif.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Single.PositiveInfinity">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Single.PositiveInfinity&gt;</ph> constant.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Single.PositiveInfinity&gt;</ph> constante.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Ce paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the current instance is not zero; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la valeur de l'instance actuelle est différente de zéro ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Single&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Single&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L’alternative recommandée consiste à appeler le <ph id="ph1">&lt;xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Ce paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The value of the current instance, converted to a <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>.</source>
          <target state="translated">Valeur de l'instance actuelle, convertie en <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Single&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Single&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L’alternative recommandée consiste à appeler le <ph id="ph1">&lt;xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Ce paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>This conversion is not supported.</source>
          <target state="translated">Cette conversion n'est pas prise en charge.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>Attempting to use this method throws an <ph id="ph1">&lt;see cref="T:System.InvalidCastException" /&gt;</ph>.</source>
          <target state="translated">Toute tentative d'utilisation de cette méthode lève une <ph id="ph1">&lt;see cref="T:System.InvalidCastException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>This conversion is not supported.</source>
          <target state="translated">Cette conversion n'est pas prise en charge.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>No value is returned.</source>
          <target state="translated">Aucune valeur n'est retournée.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>In all cases.</source>
          <target state="translated">Dans tous les cas.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Ce paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>This conversion is not supported.</source>
          <target state="translated">Cette conversion n'est pas prise en charge.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>Attempting to use this method throws an <ph id="ph1">&lt;see cref="T:System.InvalidCastException" /&gt;</ph>.</source>
          <target state="translated">Toute tentative d'utilisation de cette méthode lève une <ph id="ph1">&lt;see cref="T:System.InvalidCastException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>This conversion is not supported.</source>
          <target state="translated">Cette conversion n'est pas prise en charge.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>No value is returned.</source>
          <target state="translated">Aucune valeur n'est retournée.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>In all cases.</source>
          <target state="translated">Dans tous les cas.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Ce paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The value of the current instance, converted to a <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph>.</source>
          <target state="translated">Valeur de l'instance actuelle, convertie en <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Single&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Single&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L’alternative recommandée consiste à appeler le <ph id="ph1">&lt;xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Ce paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The value of the current instance, converted to a <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph>.</source>
          <target state="translated">Valeur de l'instance actuelle, convertie en <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Single&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Single&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L’alternative recommandée consiste à appeler le <ph id="ph1">&lt;xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Ce paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The value of the current instance, converted to an <ph id="ph1">&lt;see cref="T:System.Int16" /&gt;</ph>.</source>
          <target state="translated">Valeur de l'instance actuelle, convertie en <ph id="ph1">&lt;see cref="T:System.Int16" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Single&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Single&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L’alternative recommandée consiste à appeler le <ph id="ph1">&lt;xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Ce paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>The value of the current instance, converted to an <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>.</source>
          <target state="translated">Valeur de l'instance actuelle, convertie en <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Single&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Single&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L’alternative recommandée consiste à appeler le <ph id="ph1">&lt;xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Ce paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>The value of the current instance, converted to an <ph id="ph1">&lt;see cref="T:System.Int64" /&gt;</ph>.</source>
          <target state="translated">Valeur de l'instance actuelle, convertie en <ph id="ph1">&lt;see cref="T:System.Int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Single&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Single&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L’alternative recommandée consiste à appeler le <ph id="ph1">&lt;xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Ce paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The value of the current instance, converted to an <ph id="ph1">&lt;see cref="T:System.SByte" /&gt;</ph>.</source>
          <target state="translated">Valeur de l'instance actuelle, convertie en <ph id="ph1">&lt;see cref="T:System.SByte" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Single&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Single&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L’alternative recommandée consiste à appeler le <ph id="ph1">&lt;xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Ce paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>The value of the current instance, unchanged.</source>
          <target state="translated">Valeur de l'instance actuelle, inchangée.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Single&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Single&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The type to which to convert this <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> value.</source>
          <target state="translated">Type dans lequel convertir cette valeur <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>An object that supplies information about the format of the returned value.</source>
          <target state="translated">Objet qui fournit des informations sur le format de la valeur retournée.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The value of the current instance, converted to <ph id="ph1">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Valeur de l'instance actuelle, convertie en <ph id="ph1">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Single&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Single&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) <ph id="ph3">&lt;xref:System.Convert.ChangeType%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L’alternative recommandée consiste à appeler la <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> en Visual Basic) <ph id="ph3">&lt;xref:System.Convert.ChangeType%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Ce paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The value of the current instance, converted to a <ph id="ph1">&lt;see cref="T:System.UInt16" /&gt;</ph>.</source>
          <target state="translated">Valeur de l'instance actuelle, convertie en <ph id="ph1">&lt;see cref="T:System.UInt16" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Single&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Single&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L’alternative recommandée consiste à appeler le <ph id="ph1">&lt;xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Ce paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The value of the current instance, converted to a <ph id="ph1">&lt;see cref="T:System.UInt32" /&gt;</ph>.</source>
          <target state="translated">Valeur de l'instance actuelle, convertie en <ph id="ph1">&lt;see cref="T:System.UInt32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Single&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Single&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L’alternative recommandée consiste à appeler le <ph id="ph1">&lt;xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Ce paramètre est ignoré.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>The value of the current instance, converted to a <ph id="ph1">&lt;see cref="T:System.UInt64" /&gt;</ph>.</source>
          <target state="translated">Valeur de l'instance actuelle, convertie en <ph id="ph1">&lt;see cref="T:System.UInt64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Single&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Single&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L’alternative recommandée consiste à appeler le <ph id="ph1">&lt;xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="T:System.Single">
          <source>Converts the numeric value of this instance to its equivalent string representation.</source>
          <target state="translated">Convertit la valeur numérique de cette instance en sa représentation équivalente sous forme de chaîne.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.Single.ToString">
          <source>Converts the numeric value of this instance to its equivalent string representation.</source>
          <target state="translated">Convertit la valeur numérique de cette instance en sa représentation équivalente sous forme de chaîne.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Single.ToString">
          <source>The string representation of the value of this instance.</source>
          <target state="translated">Représentation sous forme de chaîne de la valeur de cette instance.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>The <ph id="ph1">&lt;xref:System.Single.ToString&gt;</ph> method formats a <ph id="ph2">&lt;xref:System.Single&gt;</ph> value in the default ("G", or general) format of the current culture.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single.ToString&gt;</ph> méthode formats un <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeur dans la valeur par défaut (« G » ou général) format de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>If you want to specify a different format or culture, use the other overloads of the <ph id="ph1">&lt;xref:System.Single.ToString%2A&gt;</ph> method, as follows:</source>
          <target state="translated">Si vous souhaitez spécifier un autre format ou la culture, utilisez les autres surcharges de la <ph id="ph1">&lt;xref:System.Single.ToString%2A&gt;</ph> méthode, comme suit :</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>To use format</source>
          <target state="translated">Pour utiliser le format</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>For culture</source>
          <target state="translated">Pour la culture</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>Use the overload</source>
          <target state="translated">Utilisez la surcharge</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>Default ("G") format</source>
          <target state="translated">Format par défaut (« G »)</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>A specific culture</source>
          <target state="translated">Une culture spécifique</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>A specific format</source>
          <target state="translated">Un format spécifique</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>Default (current) culture</source>
          <target state="translated">Culture (actuel) par défaut</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>A specific format</source>
          <target state="translated">Un format spécifique</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>A specific culture</source>
          <target state="translated">Une culture spécifique</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>The return value can be <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph>, or a string of the form:</source>
          <target state="translated">La valeur de retour peut être <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph>, ou une chaîne sous la forme :</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>[sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]</source>
          <target state="translated">[sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>Optional elements are framed in square brackets ([ and ]).</source>
          <target state="translated">Éléments facultatifs sont encadrés par des crochets ([et]).</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>Elements that contain the term "digits" consist of a series of numeric characters ranging from 0 to 9.</source>
          <target state="translated">Les éléments qui contiennent le terme « chiffres » sont constitués d’une série de chiffres allant de 0 à 9.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>The following table lists each element:</source>
          <target state="translated">Le tableau suivant répertorie chaque élément :</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>Element</source>
          <target state="translated">Élément</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>A negative sign or positive sign symbol.</source>
          <target state="translated">Un signe négatif ou le symbole du signe positif.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>A series of digits specifying the integral part of the number.</source>
          <target state="translated">Une série de chiffres spécifiant la partie entière du nombre.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>Integral-digits can be absent if there are fractional-digits.</source>
          <target state="translated">Chiffres intégraux peuvent être absents s’il y a des chiffres fractionnaires.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>'.'</source>
          <target state="translated">'.'</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>A culture-specific decimal point symbol.</source>
          <target state="translated">Un symbole décimal spécifiques à la culture.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>A series of digits specifying the fractional part of the number.</source>
          <target state="translated">Une série de chiffres spécifiant la partie fractionnaire du nombre.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>'e'</source>
          <target state="translated">« e »</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>A lowercase character 'e', indicating exponential (scientific) notation.</source>
          <target state="translated">Un caractère minuscule « e », indiquant la notation exponentielle (scientifique).</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>A series of digits specifying an exponent.</source>
          <target state="translated">Une série de chiffres spécifiant un exposant.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>Some examples of the return value are "100", "-123,456,789", "123.45e+6", "500", "3.1416", "600", "-0.123", and "-Infinity".</source>
          <target state="translated">Sont des exemples de la valeur de retour « 100 », «-123 456 789 », « 123.45e + 6 », « 500 », « 3,1416 », « 600 », « -0,123 », et «-Infinity ».</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</source>
          <target state="translated">Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite en détail dans les rubriques de mise en forme suivantes :</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>For more information about numeric format specifiers, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les spécificateurs de format numérique, consultez <bpt id="p1">[</bpt>des chaînes de Format numériques Standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> et <bpt id="p2">[</bpt>les chaînes de Format numériques personnalisées<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>For more information about formatting, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la mise en forme, consultez <bpt id="p1">[</bpt>mise en forme des Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>The following example uses the default <ph id="ph1">&lt;xref:System.Single.ToString%2A?displayProperty=nameWithType&gt;</ph> method to display the string representations of a number of <ph id="ph2">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">L’exemple suivant utilise la valeur par défaut <ph id="ph1">&lt;xref:System.Single.ToString%2A?displayProperty=nameWithType&gt;</ph> méthode pour afficher les représentations sous forme de chaîne d’un nombre de <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString">
          <source>The following code example illustrates the use of the <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%29&gt;</ph> method along with the <ph id="ph2">&lt;xref:System.Single.ToString&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%29&gt;</ph> méthode avec la <ph id="ph2">&lt;xref:System.Single.ToString&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Objet qui fournit des informations de mise en forme propres à la culture.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>Converts the numeric value of this instance to its equivalent string representation using the specified culture-specific format information.</source>
          <target state="translated">Convertit la valeur numérique de cette instance en sa représentation sous forme de chaîne équivalente à l'aide des informations de format spécifiques à la culture donnée.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>The string representation of the value of this instance as specified by <ph id="ph1">&lt;paramref name="provider" /&gt;</ph>.</source>
          <target state="translated">Représentation sous forme de chaîne de la valeur de cette instance, comme indiqué par <ph id="ph1">&lt;paramref name="provider" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>The <ph id="ph1">&lt;xref:System.Single.ToString%28System.IFormatProvider%29&gt;</ph> method formats a <ph id="ph2">&lt;xref:System.Single&gt;</ph> value in the default ("G", or general) format of a specified culture.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single.ToString%28System.IFormatProvider%29&gt;</ph> méthode formats un <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeur dans la valeur par défaut (« G » ou général) le format d’une culture spécifiée.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>If you want to specify a different format or the current culture, use the other overloads of the <ph id="ph1">&lt;xref:System.Single.ToString%2A&gt;</ph> method, as follows:</source>
          <target state="translated">Si vous souhaitez spécifier un autre format ou la culture actuelle, utilisez les autres surcharges de la <ph id="ph1">&lt;xref:System.Single.ToString%2A&gt;</ph> méthode, comme suit :</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>To use format</source>
          <target state="translated">Pour utiliser le format</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>For culture</source>
          <target state="translated">Pour la culture</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>Use the overload</source>
          <target state="translated">Utilisez la surcharge</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>Default ("G") format</source>
          <target state="translated">Format par défaut (« G »)</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>Default (current) culture</source>
          <target state="translated">Culture (actuel) par défaut</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>A specific format</source>
          <target state="translated">Un format spécifique</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>Default (current) culture</source>
          <target state="translated">Culture (actuel) par défaut</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>A specific format</source>
          <target state="translated">Un format spécifique</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>A specific culture</source>
          <target state="translated">Une culture spécifique</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>The return value can be <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph>, or a string of the form:</source>
          <target state="translated">La valeur de retour peut être <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph>, ou une chaîne sous la forme :</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>[sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]</source>
          <target state="translated">[sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>Optional elements are framed in square brackets ([ and ]).</source>
          <target state="translated">Éléments facultatifs sont encadrés par des crochets ([et]).</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>Elements containing the term "digits" consist of a series of numeric characters ranging from 0 to 9.</source>
          <target state="translated">Les éléments contenant le terme « chiffres » sont constitués d’une série de chiffres allant de 0 à 9.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>The following table lists each element.</source>
          <target state="translated">Le tableau suivant répertorie chaque élément.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>Element</source>
          <target state="translated">Élément</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>sign</source>
          <target state="translated">sign</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>A negative sign or positive sign symbol.</source>
          <target state="translated">Un signe négatif ou le symbole du signe positif.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>integral-digits</source>
          <target state="translated">chiffres intégraux</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>A series of digits specifying the integral part of the number.</source>
          <target state="translated">Une série de chiffres spécifiant la partie entière du nombre.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>Integral-digits can be absent if there are fractional-digits.</source>
          <target state="translated">Chiffres intégraux peuvent être absents s’il y a des chiffres fractionnaires.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>'.'</source>
          <target state="translated">'.'</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>A culture-specific decimal point symbol.</source>
          <target state="translated">Un symbole décimal spécifiques à la culture.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>fractional-digits</source>
          <target state="translated">chiffres fractionnaires</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>A series of digits specifying the fractional part of the number.</source>
          <target state="translated">Une série de chiffres spécifiant la partie fractionnaire du nombre.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>'e'</source>
          <target state="translated">« e »</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>A lowercase character 'e', indicating exponential (scientific) notation.</source>
          <target state="translated">Un caractère minuscule « e », indiquant la notation exponentielle (scientifique).</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>exponential-digits</source>
          <target state="translated">chiffres exponentiels</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>A series of digits specifying an exponent.</source>
          <target state="translated">Une série de chiffres spécifiant un exposant.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>Some examples of the return value are "100", "-123,456,789", "123.45e+6", "500", "3.1416", "600", "-0.123", and "-Infinity".</source>
          <target state="translated">Sont des exemples de la valeur de retour « 100 », «-123 456 789 », « 123.45e + 6 », « 500 », « 3,1416 », « 600 », « -0,123 », et «-Infinity ».</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</source>
          <target state="translated">Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite en détail dans les rubriques de mise en forme suivantes :</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>For more information about numeric format specifiers, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les spécificateurs de format numérique, consultez <bpt id="p1">[</bpt>des chaînes de Format numériques Standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> et <bpt id="p2">[</bpt>les chaînes de Format numériques personnalisées<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>For more information about formatting, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la mise en forme, consultez <bpt id="p1">[</bpt>mise en forme des Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation whose <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object.</source>
          <target state="translated">Le <ph id="ph1">`provider`</ph> paramètre est un <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implémentation dont <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> méthode retourne un <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>Typically, <ph id="ph1">`provider`</ph> is a <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object or a <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object.</source>
          <target state="translated">En règle générale, <ph id="ph1">`provider`</ph> est un <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objet ou un <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>The <ph id="ph1">`provider`</ph> parameter supplies culture-specific information used in formatting.</source>
          <target state="translated">Le <ph id="ph1">`provider`</ph> paramètre fournit des informations spécifiques à la culture utilisées dans la mise en forme.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the return value is formatted using the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> data for the current culture.</source>
          <target state="translated">Si <ph id="ph1">`provider`</ph> est <ph id="ph2">`null`</ph>, la valeur de retour est mise en forme à l’aide de la <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> données pour la culture actuelle.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>To convert a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value to its string representation using a specified culture and a specific format string, call the <ph id="ph2">&lt;xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour convertir un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur en sa représentation de chaîne à l’aide d’une culture spécifiée et une chaîne de format spécifique, appel de la <ph id="ph2">&lt;xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.IFormatProvider)">
          <source>The following example displays the string representation of two <ph id="ph1">&lt;xref:System.Single&gt;</ph> values using <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objects that represent several different cultures.</source>
          <target state="translated">L’exemple suivant affiche la représentation sous forme de chaîne de deux <ph id="ph1">&lt;xref:System.Single&gt;</ph> à l’aide des valeurs <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objets qui représentent plusieurs cultures différentes.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Single.ToString(System.String)">
          <source>A numeric format string.</source>
          <target state="translated">Chaîne de format numérique.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Single.ToString(System.String)">
          <source>Converts the numeric value of this instance to its equivalent string representation, using the specified format.</source>
          <target state="translated">Convertit la valeur numérique de cette instance en sa représentation sous forme de chaîne équivalente en utilisant le format spécifié.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Single.ToString(System.String)">
          <source>The string representation of the value of this instance as specified by <ph id="ph1">&lt;paramref name="format" /&gt;</ph>.</source>
          <target state="translated">Représentation sous forme de chaîne de la valeur de cette instance, comme indiqué par <ph id="ph1">&lt;paramref name="format" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Single.ToString%28System.String%29&gt;</ph> method formats a <ph id="ph2">&lt;xref:System.Single&gt;</ph> value in a specified format by using the conventions of the current culture.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single.ToString%28System.String%29&gt;</ph> méthode formats un <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeur dans un format spécifié en utilisant les conventions de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>If you want to use the default ("G", or general) format or specify a different culture, use the other overloads of the <ph id="ph1">&lt;xref:System.Single.ToString%2A&gt;</ph> method, as follows:</source>
          <target state="translated">Si vous souhaitez utiliser la valeur par défaut (« G » ou général) format ou spécifiez une autre culture, utilisez les autres surcharges de la <ph id="ph1">&lt;xref:System.Single.ToString%2A&gt;</ph> méthode, comme suit :</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>To use format</source>
          <target state="translated">Pour utiliser le format</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>For culture</source>
          <target state="translated">Pour la culture</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>Use the overload</source>
          <target state="translated">Utilisez la surcharge</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>Default ("G") format</source>
          <target state="translated">Format par défaut (« G »)</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>Default (current) culture</source>
          <target state="translated">Culture (actuel) par défaut</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>Default ("G") format</source>
          <target state="translated">Format par défaut (« G »)</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>A specific culture</source>
          <target state="translated">Une culture spécifique</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>A specific format</source>
          <target state="translated">Un format spécifique</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>A specific culture</source>
          <target state="translated">Une culture spécifique</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>The return value can be <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph>, or the string representation of the value of the current instance, as specified by <ph id="ph4">`format`</ph>.</source>
          <target state="translated">La valeur de retour peut être <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph>, ou la représentation sous forme de chaîne de la valeur de l’instance actuelle, telle que spécifiée par <ph id="ph4">`format`</ph>.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>The <ph id="ph1">`format`</ph> parameter can be any valid standard numeric format specifier except for D and X, as well as any combination of custom numeric format specifiers.</source>
          <target state="translated">Le <ph id="ph1">`format`</ph> paramètre peut être n’importe quel spécificateur de format numérique standard valide à l’exception de D et X, ainsi que toute combinaison de spécificateurs de format numériques personnalisées.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>If format is <ph id="ph1">`null`</ph> or an empty string, the return value is formatted with the general numeric format specifier ("G").</source>
          <target state="translated">Si le format est <ph id="ph1">`null`</ph> ou une chaîne vide, la valeur de retour est mis en forme avec le spécificateur de format numérique général (« G »).</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</source>
          <target state="translated">Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite en détail dans les rubriques de mise en forme suivantes :</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>For more information about numeric format specifiers, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les spécificateurs de format numérique, consultez <bpt id="p1">[</bpt>des chaînes de Format numériques Standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> et <bpt id="p2">[</bpt>les chaînes de Format numériques personnalisées<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>For more information about formatting, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la mise en forme, consultez <bpt id="p1">[</bpt>mise en forme des Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>By default, the return value only contains 7 digits of precision although a maximum of 9 digits is maintained internally.</source>
          <target state="translated">Par défaut, la valeur de retour contient uniquement les 7 chiffres de précision bien qu’un maximum de 9 chiffres est géré en interne.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>If the value of this instance has greater than 7 digits, <ph id="ph1">&lt;xref:System.Single.ToString%28System.String%29&gt;</ph> returns <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph> instead of the expected number.</source>
          <target state="translated">Si la valeur de cette instance est supérieure à 7 chiffres, <ph id="ph1">&lt;xref:System.Single.ToString%28System.String%29&gt;</ph> retourne <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph> au lieu du nombre attendu.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>If you require more precision, specify <ph id="ph1">`format`</ph> with the "G9" format specification, which always returns 9 digits of precision, or "R", which returns 7 digits if the number can be represented with that precision or 9 digits if the number can only be represented with maximum precision.</source>
          <target state="translated">Si vous avez besoin d’une plus grande précision, spécifiez <ph id="ph1">`format`</ph> avec la spécification de format « G9 », qui retourne toujours 9 chiffres de précision, ou « R », qui retourne 7 chiffres si le nombre peut être représenté avec cette précision ou 9 chiffres si le nombre ne peut être représenté. avec la précision maximale.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>The following example defines a numeric value and formats it as a currency value by using the "C" standard numeric format string and as a numeric value to three decimal places by using the "N" standard numeric format string.</source>
          <target state="translated">L’exemple suivant définit une valeur numérique et la forme en tant que valeur monétaire en utilisant la chaîne de format numérique standard « C » et en tant que valeur numérique à trois décimales à l’aide de la chaîne de format numérique standard « N ».</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>The result strings are formatted by using the conventions of the en-US culture.</source>
          <target state="translated">Les chaînes résultantes sont mises en forme en utilisant les conventions de la culture en-US.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>For more information on numeric format strings, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les chaînes de format numérique, consultez <bpt id="p1">[</bpt>des chaînes de Format numériques Standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> et <bpt id="p2">[</bpt>les chaînes de Format numériques personnalisées<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>The following example displays several <ph id="ph1">&lt;xref:System.Single&gt;</ph> values using each of the supported standard numeric format specifiers together with two custom numeric format strings.</source>
          <target state="translated">L’exemple suivant affiche plusieurs <ph id="ph1">&lt;xref:System.Single&gt;</ph> à l’aide de chacun des spécificateurs de format numérique standard pris en charge ainsi que deux chaînes de format numériques personnalisées.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>One of those custom format strings illustrates how to pad a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value with leading zeros.</source>
          <target state="translated">Une de ces chaînes de format personnalisées illustre comment remplir un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur avec des zéros non significatifs.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String)">
          <source>In converting the numeric values to strings, the example uses the formatting conventions of the en-US culture.</source>
          <target state="translated">Convertir les valeurs numériques en chaînes, l’exemple utilise les conventions de mise en forme de la culture en-US.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Single.ToString(System.String)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> n'est pas valide.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>A numeric format string.</source>
          <target state="translated">Chaîne de format numérique.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Objet qui fournit des informations de mise en forme propres à la culture.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>Converts the numeric value of this instance to its equivalent string representation using the specified format and culture-specific format information.</source>
          <target state="translated">Convertit la valeur numérique de cette instance en sa représentation sous forme de chaîne équivalente à l'aide du format spécifié et des informations de format spécifiques à la culture.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>The string representation of the value of this instance as specified by <ph id="ph1">&lt;paramref name="format" /&gt;</ph> and <ph id="ph2">&lt;paramref name="provider" /&gt;</ph>.</source>
          <target state="translated">Représentation sous forme de chaîne de la valeur de cette instance, telle que spécifiée par <ph id="ph1">&lt;paramref name="format" /&gt;</ph> et <ph id="ph2">&lt;paramref name="provider" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">&lt;xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> method formats a <ph id="ph2">&lt;xref:System.Single&gt;</ph> value in a specified format of a specified culture.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> méthode formats un <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeur dans un format spécifié d’une culture spécifiée.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>If you want to use default format or culture settings, use the other overloads of the <ph id="ph1">&lt;xref:System.Single.ToString%2A&gt;</ph> method, as follows:</source>
          <target state="translated">Si vous souhaitez utiliser les paramètres de format ou la culture par défaut, utilisez les autres surcharges de la <ph id="ph1">&lt;xref:System.Single.ToString%2A&gt;</ph> méthode, comme suit :</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>To use format</source>
          <target state="translated">Pour utiliser le format</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>For culture</source>
          <target state="translated">Pour la culture</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>Use the overload</source>
          <target state="translated">Utilisez la surcharge</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>Default ("G") format</source>
          <target state="translated">Format par défaut (« G »)</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>Default (current) culture</source>
          <target state="translated">Culture (actuel) par défaut</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>Default ("G") format</source>
          <target state="translated">Format par défaut (« G »)</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>A specific culture</source>
          <target state="translated">Une culture spécifique</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>A specific format</source>
          <target state="translated">Un format spécifique</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>Default (current) culture</source>
          <target state="translated">Culture (actuel) par défaut</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>The return value can be <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph>, or the string representation of the value of the current instance, as specified by <ph id="ph4">`format`</ph>.</source>
          <target state="translated">La valeur de retour peut être <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph>, ou la représentation sous forme de chaîne de la valeur de l’instance actuelle, telle que spécifiée par <ph id="ph4">`format`</ph>.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">`format`</ph> parameter can be any valid standard numeric format specifier except for D and X, as well as any combination of custom numeric format specifiers.</source>
          <target state="translated">Le <ph id="ph1">`format`</ph> paramètre peut être n’importe quel spécificateur de format numérique standard valide à l’exception de D et X, ainsi que toute combinaison de spécificateurs de format numériques personnalisées.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>If <ph id="ph1">`format`</ph> is <ph id="ph2">`null`</ph> or an empty string, the return value for this instance is formatted with the general numeric format specifier ("G").</source>
          <target state="translated">Si <ph id="ph1">`format`</ph> est <ph id="ph2">`null`</ph> ou une chaîne vide, la valeur de retour de cette instance est mise en forme avec le spécificateur de format numérique général (« G »).</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</source>
          <target state="translated">Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite en détail dans les rubriques de mise en forme suivantes :</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>For more information about numeric format specifiers, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les spécificateurs de format numérique, consultez <bpt id="p1">[</bpt>des chaînes de Format numériques Standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> et <bpt id="p2">[</bpt>les chaînes de Format numériques personnalisées<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>For more information about formatting, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la mise en forme, consultez <bpt id="p1">[</bpt>mise en forme des Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation whose <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object.</source>
          <target state="translated">Le <ph id="ph1">`provider`</ph> paramètre est un <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implémentation dont <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> méthode retourne un <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>Typically, <ph id="ph1">`provider`</ph> is a <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object or a <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object.</source>
          <target state="translated">En règle générale, <ph id="ph1">`provider`</ph> est un <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objet ou un <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">`provider`</ph> parameter supplies culture-specific information used in formatting.</source>
          <target state="translated">Le <ph id="ph1">`provider`</ph> paramètre fournit des informations spécifiques à la culture utilisées dans la mise en forme.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the return value is formatted with the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for the current culture.</source>
          <target state="translated">Si <ph id="ph1">`provider`</ph> est <ph id="ph2">`null`</ph>, la valeur de retour est mis en forme avec la <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet pour la culture actuelle.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>By default, the return value only contains 7 digits of precision although a maximum of 9 digits is maintained internally.</source>
          <target state="translated">Par défaut, la valeur de retour contient uniquement les 7 chiffres de précision bien qu’un maximum de 9 chiffres est géré en interne.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>If the value of this instance has greater than 7 digits, <ph id="ph1">&lt;xref:System.Single.ToString%2A&gt;</ph> returns <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph> instead of the expected number.</source>
          <target state="translated">Si la valeur de cette instance est supérieure à 7 chiffres, <ph id="ph1">&lt;xref:System.Single.ToString%2A&gt;</ph> retourne <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph> au lieu du nombre attendu.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>If you require more precision, specify <ph id="ph1">`format`</ph> with the "G9" format specification, which always returns 9 digits of precision, or "R", which returns 7 digits if the number can be represented with that precision or 9 digits if the number can only be represented with maximum precision.</source>
          <target state="translated">Si vous avez besoin d’une plus grande précision, spécifiez <ph id="ph1">`format`</ph> avec la spécification de format « G9 », qui retourne toujours 9 chiffres de précision, ou « R », qui retourne 7 chiffres si le nombre peut être représenté avec cette précision ou 9 chiffres si le nombre ne peut être représenté. avec la précision maximale.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.ToString(System.String,System.IFormatProvider)">
          <source>The following example displays a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value using each of the supported standard numeric format specifiers for several different cultures.</source>
          <target state="translated">L’exemple suivant affiche un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valeur à l’aide de chacun des spécificateurs de format numérique standard pris en charge pour plusieurs cultures différentes.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="T:System.Single">
          <source>Converts the string representation of a number to its single-precision floating-point number equivalent.</source>
          <target state="translated">Convertit la chaîne d'un nombre en nombre à virgule flottante simple précision équivalent.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="T:System.Single">
          <source>A return value indicates whether the conversion succeeded or failed.</source>
          <target state="translated">Une valeur de retour indique si la conversion a réussi ou a échoué.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>A string representing a number to convert.</source>
          <target state="translated">Chaîne représentant un nombre à convertir.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>When this method returns, contains single-precision floating-point number equivalent to the numeric value or symbol contained in <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept>, if the conversion succeeded, or zero if the conversion failed.</source>
          <target state="translated">Quand cette méthode est retournée, contient le nombre à virgule flottante simple précision équivalent à la valeur numérique ou au symbole contenu dans <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept> si la conversion a réussi, ou zéro si elle a échoué.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>The conversion fails if the <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept> parameter is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, is not a number in a valid format, or represents a number less than <ph id="ph3">&lt;see cref="F:System.Single.MinValue" /&gt;</ph> or greater than <ph id="ph4">&lt;see cref="F:System.Single.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La conversion échoue si le paramètre <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept> est <ph id="ph1">&lt;see langword="null" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, n’est pas un nombre dans un format valide ou représente un nombre inférieur à <ph id="ph3">&lt;see cref="F:System.Single.MinValue" /&gt;</ph> ou supérieur à <ph id="ph4">&lt;see cref="F:System.Single.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>This parameter is passed uninitialized; any value originally supplied in <bpt id="p1">&lt;c&gt;</bpt>result<ept id="p1">&lt;/c&gt;</ept> will be overwritten.</source>
          <target state="translated">Ce paramètre est passé sous forme non initialisée. Toute valeur fournie initialement dans <bpt id="p1">&lt;c&gt;</bpt>result<ept id="p1">&lt;/c&gt;</ept> sera remplacée.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>Converts the string representation of a number to its single-precision floating-point number equivalent.</source>
          <target state="translated">Convertit la chaîne d'un nombre en nombre à virgule flottante simple précision équivalent.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>A return value indicates whether the conversion succeeded or failed.</source>
          <target state="translated">Une valeur de retour indique si la conversion a réussi ou a échoué.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="s" /&gt;</ph> was converted successfully; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la conversion de <ph id="ph2">&lt;paramref name="s" /&gt;</ph> est réussie ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>This overload differs from the <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType&gt;</ph> method by returning a Boolean value that indicates whether the parse operation succeeded instead of returning the parsed numeric value.</source>
          <target state="translated">Cette surcharge diffère la <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType&gt;</ph> méthode en retournant une valeur booléenne qui indique si l’opération d’analyse a réussi au lieu de retourner la valeur numérique analysée.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>It eliminates the need to use exception handling to test for a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> in the event that <ph id="ph2">`s`</ph> is invalid and cannot be successfully parsed.</source>
          <target state="translated">Elle élimine la nécessité d’utiliser la gestion des exceptions pour tester un <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> dans le cas où <ph id="ph2">`s`</ph> n’est pas valide et ne peut pas être analysée avec succès.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>The <ph id="ph1">`s`</ph> parameter can contain <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph> (the string comparison is case-sensitive), or a string of the form:</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre peut contenir <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph> (la comparaison de chaînes respecte la casse), ou une chaîne sous la forme :</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>[ws][sign][integral-digits,]integral-digits[.[fractional-digits]][e[sign]exponential-digits][ws]</source>
          <target state="translated">[ws][sign][integral-digits,]integral-digits[.[fractional-digits]][e[sign]exponential-digits][ws]</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>Elements in square brackets are optional.</source>
          <target state="translated">Les éléments entre crochets sont facultatifs.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>The following table describes each element.</source>
          <target state="translated">Le tableau suivant décrit chaque élément.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>Element</source>
          <target state="translated">Élément</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>A series of white-space characters.</source>
          <target state="translated">Une série de caractères d’espace blanc.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>A negative sign or positive sign symbol.</source>
          <target state="translated">Un signe négatif ou le symbole du signe positif.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>A series of numeric characters ranging from 0 to 9 that specify the integral part of the number.</source>
          <target state="translated">Une série de chiffres allant de 0 à 9 qui spécifie la partie entière du nombre.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>Integral-digits can be absent if there are fractional-digits.</source>
          <target state="translated">Chiffres intégraux peuvent être absents s’il y a des chiffres fractionnaires.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source><bpt id="p1">*</bpt>,<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>,<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>A culture-specific group separator symbol.</source>
          <target state="translated">Un symbole de séparateur de groupes spécifique à la culture.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source><bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>.<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>A culture-specific decimal point symbol.</source>
          <target state="translated">Un symbole décimal spécifiques à la culture.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>A series of numeric characters ranging from 0 to 9 that specify the fractional part of the number.</source>
          <target state="translated">Une série de caractères numériques comprises entre 0 et 9 qui spécifie la partie fractionnaire du nombre.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source><bpt id="p1">*</bpt>E<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>E<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>An uppercase or lowercase character 'e', that indicates exponential (scientific) notation.</source>
          <target state="translated">Un majuscule ou minuscule caractère 'e', qui indique la notation exponentielle (scientifique).</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>A series of numeric characters ranging from 0 to 9 that specify an exponent.</source>
          <target state="translated">Une série de caractères numériques comprises entre 0 et 9 qui spécifie un exposant.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>The <ph id="ph1">`s`</ph> parameter is interpreted using a combination of the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> flags.</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre est interprété à l’aide d’une combinaison de la <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> indicateurs.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>This means that white space and thousands separators are allowed but currency symbols are not.</source>
          <target state="translated">Cela signifie que les espaces blancs et des milliers séparateurs sont autorisées mais ne sont pas les symboles monétaires.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>To explicitly define the elements (such as currency symbols, thousands separators, and white space) that can be present in <ph id="ph1">`s`</ph>, use the <ph id="ph2">&lt;xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29&gt;</ph> method overload.</source>
          <target state="translated">Pour définir explicitement les éléments (tels que les symboles monétaires, des milliers séparateurs et espace blanc) qui peuvent être présents dans <ph id="ph1">`s`</ph>, utilisez le <ph id="ph2">&lt;xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>The <ph id="ph1">`s`</ph> parameter is parsed using the formatting information in a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that is initialized for the current system culture.</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre est analysé en utilisant les informations de mise en forme dans un <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet initialisé pour la culture système actuelle.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>To parse a string using the formatting information of some other specified culture, use the <ph id="ph1">&lt;xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29&gt;</ph> method overload.</source>
          <target state="translated">Pour analyser une chaîne en utilisant les informations de mise en forme d’une autre culture spécifiée, utilisez la <ph id="ph1">&lt;xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>Ordinarily, if you pass the <ph id="ph1">&lt;xref:System.Single.TryParse%2A?displayProperty=nameWithType&gt;</ph> method a string that is created by calling the <ph id="ph2">&lt;xref:System.Single.ToString%2A?displayProperty=nameWithType&gt;</ph> method, the original <ph id="ph3">&lt;xref:System.Single&gt;</ph> value is returned.</source>
          <target state="translated">En règle générale, si vous passez le <ph id="ph1">&lt;xref:System.Single.TryParse%2A?displayProperty=nameWithType&gt;</ph> méthode une chaîne qui est créé en appelant le <ph id="ph2">&lt;xref:System.Single.ToString%2A?displayProperty=nameWithType&gt;</ph> , la méthode <ph id="ph3">&lt;xref:System.Single&gt;</ph> valeur est retournée.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>However, because of a loss of precision, the values may not be equal.</source>
          <target state="translated">Toutefois, en raison d’une perte de précision, les valeurs ne peuvent pas être égales.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>If a separator is encountered in the <ph id="ph1">`s`</ph> parameter during a parse operation, and the applicable currency or number decimal and group separators are the same, the parse operation assumes that the separator is a decimal separator rather than a group separator.</source>
          <target state="translated">Si un séparateur est rencontré dans le <ph id="ph1">`s`</ph> paramètre pendant une opération d’analyse et la devise ou un nombre décimal et les séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>For more information about separators, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les séparateurs, consultez <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, et <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29&gt;</ph> method to convert the string representations of numeric values to <ph id="ph2">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29&gt;</ph> méthode pour convertir les représentations sous forme de chaîne de valeurs numériques à <ph id="ph2">&lt;xref:System.Single&gt;</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Single@)">
          <source>It assumes that en-US is the current culture.</source>
          <target state="translated">Il suppose qu’en-US est la culture actuelle.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>A string representing a number to convert.</source>
          <target state="translated">Chaîne représentant un nombre à convertir.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>A bitwise combination of enumeration values that indicates the permitted format of <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Combinaison au niveau du bit des valeurs d’énumération qui indique le format autorisé de <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>A typical value to specify is <ph id="ph1">&lt;see cref="F:System.Globalization.NumberStyles.Float" /&gt;</ph> combined with <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowThousands" /&gt;</ph>.</source>
          <target state="translated">Une valeur typique à spécifier est <ph id="ph1">&lt;see cref="F:System.Globalization.NumberStyles.Float" /&gt;</ph> combinée avec <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowThousands" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>An object that supplies culture-specific formatting information about <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Objet qui fournit des informations de mise en forme propres à la culture sur <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>When this method returns, contains the single-precision floating-point number equivalent to the numeric value or symbol contained in <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept>, if the conversion succeeded, or zero if the conversion failed.</source>
          <target state="translated">Quand cette méthode est retournée, contient le nombre à virgule flottante simple précision équivalent à la valeur numérique ou au symbole contenu dans <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept> si la conversion a réussi, ou zéro si elle a échoué.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The conversion fails if the <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept> parameter is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, is not in a format compliant with <bpt id="p2">&lt;c&gt;</bpt>style<ept id="p2">&lt;/c&gt;</ept>, represents a number less than <ph id="ph3">&lt;see cref="F:System.Single.MinValue" /&gt;</ph> or greater than <ph id="ph4">&lt;see cref="F:System.Single.MaxValue" /&gt;</ph>, or if <bpt id="p3">&lt;c&gt;</bpt>style<ept id="p3">&lt;/c&gt;</ept> is not a valid combination of <ph id="ph5">&lt;see cref="T:System.Globalization.NumberStyles" /&gt;</ph> enumerated constants.</source>
          <target state="translated">La conversion échoue si le paramètre <bpt id="p1">&lt;c&gt;</bpt>s<ept id="p1">&lt;/c&gt;</ept> est <ph id="ph1">&lt;see langword="null" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, n’est pas dans un format conforme à <bpt id="p2">&lt;c&gt;</bpt>style<ept id="p2">&lt;/c&gt;</ept>, représente un nombre inférieur à <ph id="ph3">&lt;see cref="F:System.Single.MinValue" /&gt;</ph> ou supérieur à <ph id="ph4">&lt;see cref="F:System.Single.MaxValue" /&gt;</ph>, ou encore si <bpt id="p3">&lt;c&gt;</bpt>style<ept id="p3">&lt;/c&gt;</ept> n’est pas une combinaison valide de constantes énumérées <ph id="ph5">&lt;see cref="T:System.Globalization.NumberStyles" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>This parameter is passed uninitialized; any value originally supplied in <bpt id="p1">&lt;c&gt;</bpt>result<ept id="p1">&lt;/c&gt;</ept> will be overwritten.</source>
          <target state="translated">Ce paramètre est passé sous forme non initialisée. Toute valeur fournie initialement dans <bpt id="p1">&lt;c&gt;</bpt>result<ept id="p1">&lt;/c&gt;</ept> sera remplacée.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>Converts the string representation of a number in a specified style and culture-specific format to its single-precision floating-point number equivalent.</source>
          <target state="translated">Convertit la chaîne d'un nombre dans un style et un format propre à la culture spécifiés en nombre à virgule flottante simple précision équivalent.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>A return value indicates whether the conversion succeeded or failed.</source>
          <target state="translated">Une valeur de retour indique si la conversion a réussi ou a échoué.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="s" /&gt;</ph> was converted successfully; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la conversion de <ph id="ph2">&lt;paramref name="s" /&gt;</ph> est réussie ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>This overload differs from the <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> method by returning a Boolean value that indicates whether the parse operation succeeded instead of returning the parsed numeric value.</source>
          <target state="translated">Cette surcharge diffère la <ph id="ph1">&lt;xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> méthode en retournant une valeur booléenne qui indique si l’opération d’analyse a réussi au lieu de retourner la valeur numérique analysée.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>It eliminates the need to use exception handling to test for a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> in the event that <ph id="ph2">`s`</ph> is invalid and cannot be successfully parsed.</source>
          <target state="translated">Elle élimine la nécessité d’utiliser la gestion des exceptions pour tester un <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> dans le cas où <ph id="ph2">`s`</ph> n’est pas valide et ne peut pas être analysée avec succès.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <ph id="ph1">`style`</ph> parameter defines the allowable format of the <ph id="ph2">`s`</ph> parameter for the parse operation to succeed.</source>
          <target state="translated">Le <ph id="ph1">`style`</ph> paramètre définit le format autorisé de le <ph id="ph2">`s`</ph> paramètre pour l’opération d’analyse.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>It must be a combination of bit flags from the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration.</source>
          <target state="translated">Il doit être une combinaison de bits indicateurs de le <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> énumération.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The following <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members are not supported:</source>
          <target state="translated">Les éléments suivants <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> membres ne sont pas pris en charge :</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <ph id="ph1">`s`</ph> parameter can contain <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph> for the culture indicated by <ph id="ph5">`provider`</ph>.</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre peut contenir <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph> pour la culture indiquée par <ph id="ph5">`provider`</ph>.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>In addition, depending on the value of <ph id="ph1">`style`</ph>, the <ph id="ph2">`s`</ph> parameter may include the following elements:</source>
          <target state="translated">En outre, selon la valeur de <ph id="ph1">`style`</ph>, le <ph id="ph2">`s`</ph> paramètre peut inclure les éléments suivants :</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>[ws] [$] [sign][integral-digits,]integral-digits[.fractional-digits][e[sign]exponential-digits][ws]</source>
          <target state="translated">[ws] [$] [sign][integral-digits,]integral-digits[.fractional-digits][e[sign]exponential-digits][ws]</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>Elements in square brackets ([ and ]) are optional.</source>
          <target state="translated">Les éléments entre crochets ([ et ]) sont facultatifs.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The following table describes each element.</source>
          <target state="translated">Le tableau suivant décrit chaque élément.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>Element</source>
          <target state="translated">Élément</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>Optional white space.</source>
          <target state="translated">Espace blanc facultatif.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>White space can appear at the beginning of <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Espace blanc peut apparaître au début de <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>It can appear at the end of <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Il peut apparaître à la fin de <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>A culture-specific currency symbol.</source>
          <target state="translated">Un symbole monétaire spécifique à la culture.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>Its position in the string is defined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType&gt;</ph> properties of the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object returned by the <ph id="ph4">&lt;xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType&gt;</ph> method of the <ph id="ph5">`provider`</ph> parameter.</source>
          <target state="translated">Sa position dans la chaîne est définie par le <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType&gt;</ph> ou <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType&gt;</ph> propriétés de la <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet retourné par la <ph id="ph4">&lt;xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType&gt;</ph> méthode de le <ph id="ph5">`provider`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The currency symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Le symbole monétaire peut apparaître dans <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>An optional sign.</source>
          <target state="translated">Un signe facultatif.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The sign can appear at the beginning of <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`s`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Le signe peut apparaître au début de <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType&gt;</ph> indicateur, qui peuvent apparaître à la fin de <ph id="ph4">`s`</ph> si <ph id="ph5">`style`</ph> inclut la <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>Parentheses can be used in <ph id="ph1">`s`</ph> to indicate a negative value if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Parenthèses peuvent être utilisées dans <ph id="ph1">`s`</ph> pour indiquer une valeur négative si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>A series of digits ranging from 0 to 9 that specify the integral part of the number.</source>
          <target state="translated">Une série de chiffres allant de 0 à 9 qui spécifie la partie entière du nombre.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>Integral-digits can be absent if there are fractional-digits.</source>
          <target state="translated">Chiffres intégraux peuvent être absents s’il y a des chiffres fractionnaires.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source><bpt id="p1">*</bpt>,<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>,<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>A culture-specific thousands separator symbol.</source>
          <target state="translated">Spécifiques à la culture des milliers symbole de séparateur.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The current culture's thousands separator symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Des milliers de la culture actuelle symbole de séparateur peut apparaître dans <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source><bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>.<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>A culture-specific decimal point symbol.</source>
          <target state="translated">Un symbole décimal spécifiques à la culture.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The current culture's decimal point symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Symbole de virgule décimale de la culture actuelle peut apparaître dans <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>A series of digits ranging from 0 to 9 that specify the fractional part of the number.</source>
          <target state="translated">Une série de chiffres allant de 0 à 9 qui spécifie la partie fractionnaire du nombre.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>Fractional digits can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Chiffres fractionnaires peuvent apparaître dans <ph id="ph1">`s`</ph> si <ph id="ph2">`style`</ph> inclut la <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source><bpt id="p1">*</bpt>e<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>e<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The e or E character, which indicates that <ph id="ph1">`s`</ph> can represent a number using exponential notation.</source>
          <target state="translated">Le caractère e ou E, qui indique que <ph id="ph1">`s`</ph> peut représenter un nombre en notation exponentielle.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <ph id="ph1">`s`</ph> parameter can represent a number in exponential notation if style includes the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre peut représenter un nombre en notation exponentielle si le style inclut le <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>A series of digits ranging from 0 to 9 that specify an exponent.</source>
          <target state="translated">Une série de chiffres allant de 0 à 9 qui spécifie un exposant.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>A string with digits only (which corresponds to the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType&gt;</ph> style) always parses successfully.</source>
          <target state="translated">Une chaîne contenant uniquement des chiffres (qui correspond à la <ph id="ph1">&lt;xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType&gt;</ph> style) toujours analysée avec succès.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The remaining <ph id="ph1">&lt;xref:System.Globalization.NumberStyles?displayProperty=nameWithType&gt;</ph> members control elements that may be but are not required to be present in the input string.</source>
          <target state="translated">Les autres <ph id="ph1">&lt;xref:System.Globalization.NumberStyles?displayProperty=nameWithType&gt;</ph> membres contrôlent des éléments qui peuvent être, mais ne doivent pas être présents dans la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The following table indicates how individual <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> flags affect the elements that may be present in <ph id="ph2">`s`</ph>.</source>
          <target state="translated">Le tableau suivant indique comment chaque <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> indicateurs affectent les éléments qui peuvent être présents dans <ph id="ph2">`s`</ph>.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>NumberStyles value</source>
          <target state="translated">Valeur NumberStyles</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>Elements permitted in s in addition to digits</source>
          <target state="translated">Éléments autorisés dans s en plus des chiffres</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> element only.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>chiffres intégraux<ept id="p1">*</ept> élément uniquement.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
          <target state="translated">L’élément de langage <bpt id="p1">*</bpt>.<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>and <bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept> elements.</source>
          <target state="translated">et <bpt id="p1">*</bpt>chiffres fractionnaires<ept id="p1">*</ept> éléments.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <ph id="ph1">`s`</ph> parameter can also use exponential notation.</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre peut également utiliser la notation exponentielle.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>This flag by itself supports values in the form <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept>E<bpt id="p2">*</bpt>exponential-digits<ept id="p2">*</ept>; additional flags are needed to successfully parse strings in exponential notation with such elements as positive or negative signs and decimal point symbols.</source>
          <target state="translated">Cet indicateur par lui-même prend en charge les valeurs sous la forme <bpt id="p1">*</bpt>chiffres intégraux<ept id="p1">*</ept>E<bpt id="p2">*</bpt>chiffres exponentiels<ept id="p2">*</ept>; supplémentaires nécessaires pour analyser correctement les chaînes en notation exponentielle avec des éléments tels que les indicateurs signes positifs ou négatifs et des symboles de séparateur décimal.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the beginning of <ph id="ph1">`s`</ph>.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> élément au début de <ph id="ph1">`s`</ph>.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the end of <ph id="ph1">`s`</ph>.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> élément à la fin de <ph id="ph1">`s`</ph>.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the beginning of <ph id="ph1">`s`</ph>.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>signe<ept id="p1">*</ept> élément au début de <ph id="ph1">`s`</ph>.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the end of <ph id="ph1">`s`</ph>.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>signe<ept id="p1">*</ept> élément à la fin de <ph id="ph1">`s`</ph>.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element in the form of parentheses enclosing the numeric value.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>signe<ept id="p1">*</ept> élément sous la forme de parenthèses entourant la valeur numérique.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <bpt id="p1">*</bpt>,<ept id="p1">*</ept> element.</source>
          <target state="translated">Le <bpt id="p1">*</bpt>,<ept id="p1">*</ept> élément.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <bpt id="p1">*</bpt><ph id="ph1">$</ph><ept id="p1">*</ept> element.</source>
          <target state="translated">Le <bpt id="p1">*</bpt> <ph id="ph1">$</ph> <ept id="p1">*</ept> élément.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>All.</source>
          <target state="translated">Tout le monde.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <ph id="ph1">`s`</ph> parameter cannot represent a hexadecimal number or a number in exponential notation.</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre ne peut pas représenter un nombre hexadécimal ou un nombre en notation exponentielle.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the beginning or end of <ph id="ph1">`s`</ph>, <bpt id="p2">*</bpt>sign<ept id="p2">*</ept> at the beginning of <ph id="ph2">`s`</ph>, and the <bpt id="p3">*</bpt>.<ept id="p3">*</ept></source>
          <target state="translated">Le <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> élément au début ou à la fin de <ph id="ph1">`s`</ph>, <bpt id="p2">*</bpt>signe<ept id="p2">*</ept> au début de <ph id="ph2">`s`</ph>et le <bpt id="p3">*</bpt>.<ept id="p3">*</ept></target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>symbol.</source>
          <target state="translated">symbole.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <ph id="ph1">`s`</ph> parameter can also use exponential notation.</source>
          <target state="translated">Le <ph id="ph1">`s`</ph> paramètre peut également utiliser la notation exponentielle.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <ph id="ph1">`ws`</ph>, <ph id="ph2">`sign`</ph>, thousands separator (<bpt id="p1">*</bpt>,),<ept id="p1">*</ept> and decimal point (<bpt id="p2">*</bpt>.<ept id="p2">*</ept>) elements.</source>
          <target state="translated">Le <ph id="ph1">`ws`</ph>, <ph id="ph2">`sign`</ph>, des milliers séparateur (<bpt id="p1">*</bpt>,),<ept id="p1">*</ept> et séparateur décimal (<bpt id="p2">*</bpt>.<ept id="p2">*</ept>) éléments.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>All styles, except <ph id="ph1">`s`</ph> cannot represent a hexadecimal number.</source>
          <target state="translated">Tous les styles, à l’exception <ph id="ph1">`s`</ph> ne peut pas représenter un nombre hexadécimal.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation whose <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific formatting information.</source>
          <target state="translated">Le <ph id="ph1">`provider`</ph> paramètre est un <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implémentation dont <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> méthode retourne un <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet qui fournit des informations de mise en forme propres à la culture.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>When the <ph id="ph1">&lt;xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29&gt;</ph> method is invoked, it calls the <ph id="ph2">`provider`</ph> parameter's <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method and passes it a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> type.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29&gt;</ph> méthode est appelée, elle appelle la <ph id="ph2">`provider`</ph> du paramètre <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> (méthode) et lui passe un <ph id="ph4">&lt;xref:System.Type&gt;</ph> objet qui représente le <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> type.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method then returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides information about the format of the <ph id="ph3">`s`</ph> parameter.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> méthode renvoie alors le <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet qui fournit des informations sur le format de le <ph id="ph3">`s`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>There are three ways to use the <ph id="ph1">`provider`</ph> parameter to supply custom formatting information to the parse operation:</source>
          <target state="translated">Il existe trois façons d’utiliser le <ph id="ph1">`provider`</ph> paramètre pour fournir des informations de mise en forme personnalisées à l’opération d’analyse :</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>You can pass a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that supplies formatting information.</source>
          <target state="translated">Vous pouvez passer un <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objet qui représente la culture qui fournit des informations de mise en forme.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information for that culture.</source>
          <target state="translated">Son <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> méthode retourne la <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet qui fournit des informations de mise en forme numériques pour cette culture.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>You can pass the actual <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information.</source>
          <target state="translated">Vous pouvez passer le réel <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet qui fournit des informations de mise en forme numériques.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>(Its implementation of <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> just returns itself.)</source>
          <target state="translated">(Son implémentation de <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> retourne simplement lui-même.)</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>You can pass a custom object that implements <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>.</source>
          <target state="translated">Vous pouvez passer un objet personnalisé qui implémente <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method instantiates and returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information.</source>
          <target state="translated">Son <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> méthode instancie et retourne le <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet qui fournit des informations de mise en forme.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the formatting of <ph id="ph3">`s`</ph> is interpreted based on the <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object of the current culture.</source>
          <target state="translated">Si <ph id="ph1">`provider`</ph> est <ph id="ph2">`null`</ph>, la mise en forme de <ph id="ph3">`s`</ph> est interprété en fonction de la <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objet de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>If a separator is encountered in the <ph id="ph1">`s`</ph> parameter during a parse operation, and the applicable currency or number decimal and group separators are the same, the parse operation assumes that the separator is a decimal separator rather than a group separator.</source>
          <target state="translated">Si un séparateur est rencontré dans le <ph id="ph1">`s`</ph> paramètre pendant une opération d’analyse et la devise ou un nombre décimal et les séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>For more information about separators, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les séparateurs, consultez <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, et <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType&gt;</ph> method to parse the string representation of numbers that have a particular style and are formatted using the conventions of a particular culture.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType&gt;</ph> méthode pour analyser la représentation sous forme de chaîne de nombres qui ont un style spécifique en utilisant les conventions d’une culture particulière.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source><ph id="ph1">&lt;paramref name="style" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Globalization.NumberStyles" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="style" /&gt;</ph> n’est pas une valeur <ph id="ph2">&lt;see cref="T:System.Globalization.NumberStyles" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)">
          <source><ph id="ph1">&lt;paramref name="style" /&gt;</ph> is the <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="style" /&gt;</ph> est la valeur <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>