<Type Name="Single" FullName="System.Single">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9a57b52d8b5395640ddf322aa25bf12210496090" /><Meta Name="ms.sourcegitcommit" Value="f9e71795ba0f9c2dfaa74bec233343ed0f3ffd99" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/15/2019" /><Meta Name="ms.locfileid" Value="57924445" /></Metadata><TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Single" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IComparable(Of Single), IConvertible, IEquatable(Of Single), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type single = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un nombre à virgule flottante simple précision.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Single> type de valeur représente un nombre de 32 bits simple précision avec des valeurs comprises entre moins 3, 402823E38 et plus 3, 402823E38, ainsi que le zéro positif ou négatif, <xref:System.Single.PositiveInfinity>, <xref:System.Single.NegativeInfinity>et pas un nombre (<xref:System.Single.NaN>). Il est destiné à représenter des valeurs qui sont extrêmement volumineux (par exemple, les distances entre les planètes ou galaxies) ou extrêmement petit (par exemple, la masse moléculaire de substance en kilogrammes) et qui sont souvent imprécises (par exemple la distance entre la terre et un autre système solaire ). Le <xref:System.Single> type est conforme à la IEC 60559 : 1989 (IEEE 754) standard pour l’arithmétique à virgule flottante binaire.  
  
 Cette rubrique contient les sections suivantes :  
  
-   [Précision et une représentation à virgule flottante](#Precision)  
  
-   [Test d’égalité](#Equality)  
  
-   [Exceptions et les valeurs à virgule flottante](#Exceptions)  
  
-   [Conversion de type et la structure unique](#Conversion)  
  
-   [Fonctionnalités à virgule flottante](#Functionality)  
  
 <xref:System.Single?displayProperty=nameWithType> Fournit des méthodes permettant de comparer les instances de ce type, pour convertir la valeur d’une instance en sa représentation sous forme de chaîne et pour convertir la représentation sous forme de chaîne d’un nombre en une instance de ce type. Pour plus d’informations sur comment les codes de spécification de format contrôlent la représentation sous forme de chaîne des types valeur, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md), [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md), et [numérique personnalisé Chaînes de format](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Précision et une représentation à virgule flottante  
 Le <xref:System.Single> type de données stocke les valeurs à virgule flottante simple précision dans un format binaire 32 bits, comme indiqué dans le tableau suivant :  
  
|Élément|Bits|  
|----------|----------|  
|Mantisse|0-22|  
|Exposant|23-30|  
|Connexion (0 = positif, 1 = négatif)|31|  
  
 Tout comme les fractions décimales ne peut pas représenter précisément certaines valeurs fractionnaires (par exemple 1/3 ou <xref:System.Math.PI?displayProperty=nameWithType>), fractions binaires sont ne peut pas représenter certaines valeurs fractionnaires. Par exemple, 2/10, qui est représentée précisément par.2 comme une fraction décimale, est représenté par.0011111001001100 sous forme de fraction binaire, avec le modèle « 1100 » extensible à l’infini. Dans ce cas, la valeur à virgule flottante fournit une représentation imprécise du nombre qu’il représente. Effectuer des opérations de mathématiques supplémentaires sur la valeur à virgule flottante d’origine souvent augmente son manque de précision. Par exemple, si vous comparez les résultats de la multiplication.3 par 10 et ajout.3 à.3 neuf fois, vous verrez cet ajout produit le résultat moins précis, car elle comporte huit davantage d’opérations de multiplication. Notez que cette disparité est visible uniquement si vous affichez les deux <xref:System.Single> valeurs à l’aide de « R » [chaîne de format numérique standard](~/docs/standard/base-types/standard-numeric-format-strings.md), qui, si nécessaire, affiche tous les 9 chiffres de précision pris en charge par le <xref:System.Single> type.  
  
 [!code-csharp[System.Single.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation1.cs#3)]
 [!code-vb[System.Single.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation1.vb#3)]  
  
 Étant donné que des nombres ne peut pas être représentées exactement comme valeurs binaires fractionnaires, nombres à virgule flottante peuvent uniquement des nombres réels approximatives.  
  
 Tous les nombres à virgule flottante ont un nombre limité de chiffres significatifs, lequel détermine également la façon dont une valeur à virgule flottante s’apparentent précisément un nombre réel. Un <xref:System.Single> valeur a jusqu'à 7 chiffres décimaux de précision, bien qu’un maximum de 9 chiffres soit maintenu en interne. Cela signifie que certaines opérations à virgule flottante n’ont peut-être pas la précision pour modifier une valeur à virgule flottante. L’exemple suivant définit une valeur à virgule flottante simple précision élevée, puis ajoute le produit de <xref:System.Single.Epsilon?displayProperty=nameWithType> et trillion celui à celui-ci. Toutefois, le produit est trop petit pour modifier la valeur à virgule flottante d’origine. Son chiffre le moins significatif est millièmes, tandis que le chiffre le plus significatif dans le produit est 10<sup>-30</sup>.  
  
 [!code-csharp[System.Single.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation2.cs#4)]
 [!code-vb[System.Single.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation2.vb#4)]  
  
 La précision limitée d’un nombre à virgule flottante a plusieurs conséquences :  
  
-   Deux nombres à virgule flottante qui apparaissent égaux pour une précision particulière ne peuvent pas considérés comme égaux, car leurs chiffres les moins significatifs sont différents. Dans l’exemple suivant, une série de nombres sont additionnés, et leur total est comparée avec leur total attendu. Bien que les deux valeurs semblent être identiques, un appel à la `Equals` méthode indique qu’ils ne sont pas.  
  
     [!code-csharp[System.Single.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Single.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist3.vb#6)]  
  
     Si vous modifiez les éléments de format dans le <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> instruction à partir de `{0}` et `{1}` à `{0:R}` et `{1:R}` pour afficher tous les chiffres significatifs des deux <xref:System.Single> valeurs, il est clair que les deux valeurs sont inégales, car d’une perte de précision pendant les opérations d’addition. Dans ce cas, le problème peut être résolu en appelant le <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> méthode pour arrondir le <xref:System.Single> valeurs à la précision de votre choix avant d’effectuer la comparaison.  
  
-   Une opération mathématique ou de comparaison qui utilise un nombre à virgule flottante peut ne pas donne le même résultat si un nombre décimal est utilisé, étant donné que le nombre à virgule flottante binaire ne peut pas égal au nombre décimal. Un exemple précédent illustre cela en affichant le résultat de la multiplication.3 par 10 et en ajoutant.3 à.3 neuf fois.  
  
     Lorsque la précision dans les opérations numériques avec les valeurs fractionnaires est importante, utilisez la <xref:System.Decimal> au lieu du type le <xref:System.Single> type. Lors de la précision dans les opérations numériques avec des valeurs intégrales au-delà de la plage de la <xref:System.Int64> ou <xref:System.UInt64> types est important, utilisez le <xref:System.Numerics.BigInteger> type.  
  
-   Une valeur ne peut pas effectuer un aller-retour si un nombre à virgule flottante est impliqué. Une valeur est dite d’aller-retour si une opération convertit un nombre à virgule flottante d’origine vers un autre formulaire, l’opération inverse retransforme la forme convertie en un nombre à virgule flottante, et le nombre à virgule flottante final est égal à l’original nombre à virgule flottante. L’aller-retour peut échouer car un ou plusieurs chiffres les moins significatifs sont perdus ou modifiés dans une conversion. Dans l’exemple suivant, trois <xref:System.Single> valeurs sont converties en chaînes et enregistrés dans un fichier. Comme le montre la sortie, bien que les valeurs semblent identiques, les valeurs restaurés ne valent pas les valeurs d’origine.  
  
     [!code-csharp[System.Single.Structure#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist4a.cs#17)]
     [!code-vb[System.Single.Structure#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList4a.vb#17)]  
  
     Dans ce cas, les valeurs peuvent être l’aller-retour avec succès à l’aide de la « G9 » [chaîne de format numérique standard](~/docs/standard/base-types/standard-numeric-format-strings.md) pour conserver la précision de <xref:System.Single> valeurs, comme le montre l’exemple suivant.  
  
     [!code-csharp[System.Single.Structure#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/PrecisionList5a.cs#18)]
     [!code-vb[System.Single.Structure#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList5a.vb#18)]  
  
-   <xref:System.Single> les valeurs ont moins de précision que <xref:System.Double> valeurs. Un <xref:System.Single> valeur est convertie en un équivalent apparemment <xref:System.Double> souvent n’est pas égale la <xref:System.Double> valeur en raison des différences de précision. Dans l’exemple suivant, le résultat des opérations de division identique est assigné à un <xref:System.Double> valeur et un <xref:System.Single> valeur. Après le <xref:System.Single> valeur est convertie en un <xref:System.Double>, une comparaison des deux valeurs montre qu’ils sont inégaux.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Pour éviter ce problème, soit utiliser le <xref:System.Double> de type de données à la place de la <xref:System.Single> type de données, ou utilisez le <xref:System.Math.Round%2A> méthode afin que les deux valeurs ont la même précision.  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Test d’égalité  
 Pour être considérées comme égales, deux <xref:System.Single> valeurs doivent représenter des valeurs identiques. Toutefois, en raison de différences de précision entre les valeurs, ou en raison d’une perte de précision par une ou les deux valeurs, les valeurs à virgule flottante sont censés être identiques souvent s’avérer accentuées en raison des différences dans leurs chiffres les moins significatifs. Par conséquent, les appels à la <xref:System.Single.Equals%2A> méthode pour déterminer si deux valeurs sont égales, ou des appels à la <xref:System.Single.CompareTo%2A> méthode pour déterminer la relation entre deux <xref:System.Single> valeurs, souvent donner des résultats inattendus. Ceci est évident dans l’exemple suivant, où deux égal apparemment <xref:System.Single> valeurs s’avèrent pour être inégaux, car la première valeur est 7 chiffres de précision, tandis que la deuxième valeur a 9.  
  
 [!code-csharp[System.Single.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Single.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison1.vb#9)]  
  
 Les valeurs calculées qui suivent des chemins de code différents, et qui sont manipulées de différentes façons, souvent s’avérer inégaux. Dans l’exemple suivant, un <xref:System.Single> valeur est mis au carré, et ensuite la racine carrée est calculée pour restaurer la valeur d’origine. Une seconde <xref:System.Single> est multipliée par 3.51 et carré avant la racine carrée du résultat est divisée par 3.51 pour restaurer la valeur d’origine. Bien que les deux valeurs semblent identiques, un appel à la <xref:System.Single.Equals%28System.Single%29> méthode indique qu’ils ne sont pas égaux. Pour retourner une chaîne de résultat qui affiche tous les chiffres significatifs de chacun d’eux à l’aide de la chaîne de format standard « G9 » <xref:System.Single> valeur indique que la deuxième valeur est.0000000000001 inférieure à la première.  
  
 [!code-csharp[System.Single.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Single.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison2.vb#10)]  
  
 Dans les cas où une perte de précision est susceptible d’affecter le résultat d’une comparaison, vous pouvez utiliser les techniques suivantes au lieu d’appeler le <xref:System.Single.Equals%2A> ou <xref:System.Single.CompareTo%2A> méthode :  
  
-   Appelez le <xref:System.Math.Round%2A?displayProperty=nameWithType> pour s’assurer que les deux valeurs ont la même précision. L’exemple suivant modifie un exemple précédent pour utiliser cette approche, afin que les deux valeurs fractionnaires sont équivalentes.  
  
     [!code-csharp[System.Single.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Single.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison3.vb#11)]  
  
     Notez que le problème de précision s’applique toujours à l’arrondi des valeurs du milieu. Pour plus d'informations, voir la méthode <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Test d’égalité approximative au lieu de l’égalité. Cette technique exige que vous définissez soit absolu montant par lequel les deux valeurs peuvent différer mais toujours être égal ou que vous définissez une quantité relative par lequel la plus petite valeur peut différer de la plus grande valeur.  
  
    > [!WARNING]
    >  <xref:System.Single.Epsilon?displayProperty=nameWithType> est parfois utilisé comme mesure absolue de la distance entre deux <xref:System.Single> lors du test d’égalité des valeurs.  Toutefois, <xref:System.Single.Epsilon?displayProperty=nameWithType> mesure la plus petite valeur possible qui peut être ajoutée à ou soustraite, un <xref:System.Single> dont la valeur est égale à zéro. Pour la plupart des positif et négatif <xref:System.Single> valeurs, la valeur de <xref:System.Single.Epsilon?displayProperty=nameWithType> est trop petite pour être détecté. Par conséquent, à l’exception des valeurs qui sont égales à zéro, nous déconseillons son utilisation dans les tests d’égalité.  
  
     L’exemple suivant utilise cette dernière approche pour définir un `IsApproximatelyEqual` méthode qui teste la différence relative entre les deux valeurs. Il compare également le résultat d’appels à la `IsApproximatelyEqual` (méthode) et le <xref:System.Single.Equals%28System.Single%29> (méthode).  
  
     [!code-csharp[System.Single.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Single.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Exceptions et les valeurs à virgule flottante  
 Opérations avec des valeurs à virgule flottante ne lèvent pas d’exceptions, contrairement aux opérations avec des types intégraux, qui lèvent des exceptions dans le cas des opérations illégales telles que la division par zéro ou de dépassement de capacité.  Au lieu de cela, dans ces situations, le résultat d’une opération à virgule flottante est zéro, l’infini positif, infini négatif ou une valeur non numérique (NaN) :  
  
-   Si le résultat d’une opération à virgule flottante est trop petit pour le format de destination, le résultat est zéro. Cela peut se produire lorsque deux très petits nombres à virgule flottante sont multipliés, comme le montre l’exemple suivant.  
  
     [!code-csharp[System.Single.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Single.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional1.vb#1)]  
  
-   Si la grandeur du résultat d’une opération à virgule flottante dépasse la plage du format de destination, le résultat de l’opération est <xref:System.Single.PositiveInfinity> ou <xref:System.Single.NegativeInfinity>, selon le cas pour le signe du résultat. Le résultat d’une opération qui dépassent <xref:System.Single.MaxValue?displayProperty=nameWithType> est <xref:System.Single.PositiveInfinity>et le résultat d’une opération qui dépassent <xref:System.Single.MinValue?displayProperty=nameWithType> est <xref:System.Single.NegativeInfinity>, comme illustré dans l’exemple suivant.  
  
     [!code-csharp[System.Single.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Single.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Single.PositiveInfinity> entraîne également à partir d’une division par zéro avec un dividende positif, et <xref:System.Single.NegativeInfinity> provient d’une division par zéro avec un dividende négatif.  
  
-   Si une opération à virgule flottante n’est pas valide, le résultat de l’opération est <xref:System.Single.NaN>. Par exemple, <xref:System.Single.NaN> entraîne des opérations suivantes :  
  
    -   Division par zéro avec un dividende égale à zéro. Notez que les autres cas de division par zéro entraînent soit <xref:System.Single.PositiveInfinity> ou <xref:System.Single.NegativeInfinity>.  
  
    -   Toute opération à virgule flottante avec une entrée non valide. Par exemple, une tentative de recherche retourne la racine carrée d’une valeur négative <xref:System.Single.NaN>.  
  
    -   Toute opération avec un argument dont la valeur est <xref:System.Single.NaN?displayProperty=nameWithType>.  
  
<a name="Conversion"></a>   
## <a name="type-conversions-and-the-single-structure"></a>Conversions de types et la structure unique  
 Le <xref:System.Single> structure ne définit pas d’opérateur de conversion explicite ou implicite ; au lieu de cela, les conversions sont implémentées par le compilateur.  
  
 Le tableau suivant répertorie les conversions possibles d’une valeur des autres types numériques primitifs à un <xref:System.Single> valeur, il indique également si la conversion est restrictive ou étendue et si résultant <xref:System.Single> peut avoir moins de précision que le valeur d’origine.  
  
|Conversion de|Étendues/restrictive|Perte de précision|  
|---------------------|-------------------------|--------------------------------|  
|<xref:System.Byte>|Widening|Non|  
|<xref:System.Decimal>|Widening<br /><br /> Notez que C# nécessite un opérateur de conversion.|Oui. <xref:System.Decimal> prend en charge de 29 chiffres décimaux de précision. <xref:System.Single> prend en charge 9.|  
|<xref:System.Double>|Conversions restrictives ; out-of-range sont converties en <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> ou <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.|Oui. <xref:System.Double> prend en charge de 17 chiffres décimaux de précision. <xref:System.Single> prend en charge 9.|  
|<xref:System.Int16>|Widening|Non|  
|<xref:System.Int32>|Widening|Oui. <xref:System.Int32> prend en charge de 10 chiffres décimaux de précision. <xref:System.Single> prend en charge 9.|  
|<xref:System.Int64>|Widening|Oui. <xref:System.Int64> prend en charge de 19 chiffres décimaux de précision. <xref:System.Single> prend en charge 9.|  
|<xref:System.SByte>|Widening|Non|  
|<xref:System.UInt16>|Widening|Non|  
|<xref:System.UInt32>|Widening|Oui. <xref:System.UInt32> prend en charge de 10 chiffres décimaux de précision. <xref:System.Single> prend en charge 9.|  
|<xref:System.UInt64>|Widening|Oui. <xref:System.Int64> prend en charge 20 chiffres décimaux de précision. <xref:System.Single> prend en charge 9.|  
  
 L’exemple suivant convertit la valeur minimale ou maximale d’autres types numériques primitifs à un <xref:System.Single> valeur.  
  
 [!code-csharp[System.Single.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert1.cs#20)]
 [!code-vb[System.Single.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert1.vb#20)]  
  
 En outre, le <xref:System.Double> valeurs <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, et <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> convertir à <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, et <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectivement.  
  
 Notez que la conversion de la valeur de certains types numériques à une <xref:System.Single> valeur peut impliquer une perte de précision. Comme l’illustre l’exemple, une perte de précision est possible lors de la conversion <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt32>, et <xref:System.UInt64> valeurs <xref:System.Single> valeurs.  
  
 La conversion d’un <xref:System.Single> valeur un <xref:System.Double> est une conversion étendue. La conversion peut entraîner une perte de précision si le <xref:System.Double> type n’a pas une représentation précise pour le <xref:System.Single> valeur.  
  
 La conversion d’un <xref:System.Single> valeur autre que sur une valeur de tout type numérique primitif un <xref:System.Double> est une conversion restrictive et nécessite un opérateur de conversion (en C#) ou une méthode de conversion (en Visual Basic). Les valeurs en dehors de la plage du type de données cible, qui sont définies par le type de cible `MinValue` et `MaxValue` se comportent des propriétés, comme indiqué dans le tableau suivant.  
  
|Type cible|Résultat|  
|-----------------|------------|  
|N’importe quel type intégral|Un <xref:System.OverflowException> exception si la conversion se produit dans un contexte vérifié.<br /><br /> Si la conversion se produit dans un contexte non vérifié (la valeur par défaut en C#), l’opération de conversion réussit mais déborde de la valeur.|  
|<xref:System.Decimal>|Un <xref:System.OverflowException> exception,|  
  
 En outre, <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, et <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> lever un <xref:System.OverflowException> pour les conversions en entiers dans un contexte vérifié, mais ces dépassement des valeurs lorsque convertis en entiers dans un contexte non vérifié. Pour les conversions <xref:System.Decimal>, elles lèvent toujours un <xref:System.OverflowException>. Pour les conversions <xref:System.Double>, ils convertis vers <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, et <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectivement.  
  
 Notez qu’une perte de précision peut-être provenir de la conversion d’un <xref:System.Single> valeur à un autre type numérique. Dans le cas de conversion non intégrales <xref:System.Single> valeurs, comme le montre la sortie de l’exemple, la partie fractionnaire est perdue lorsque la <xref:System.Single> valeur est arrondie (comme dans Visual Basic) ou tronqué (comme dans C#). Pour les conversions <xref:System.Decimal> valeurs, le <xref:System.Single> valeur ne peut pas avoir une représentation précise dans le type de données cible.  
  
 L’exemple suivant convertit un nombre de <xref:System.Single> valeurs à plusieurs autres types numériques. Les conversions se produisent dans un contexte vérifié dans Visual Basic (la valeur par défaut) et en C# (raison de la [vérifiée](~/docs/csharp/language-reference/keywords/checked.md) mot clé). La sortie de l’exemple montre le résultat pour les conversions a été archivé à la fois un contexte non vérifié. Vous pouvez effectuer des conversions dans un contexte non vérifié dans Visual Basic en compilant avec le `/removeintchecks+` commutateur de compilateur et en C# en commentant la `checked` instruction.  
  
 [!code-csharp[System.Single.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert2.cs#21)]
 [!code-vb[System.Single.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert2.vb#21)]  
  
 Pour plus d’informations sur la conversion des types numériques, consultez [Conversion de Type dans le .NET Framework](~/docs/standard/base-types/type-conversion.md) et [tableaux de Conversion de Type](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Fonctionnalités à virgule flottante  
 Le <xref:System.Single> structure et les types associés fournissent des méthodes pour effectuer les catégories des opérations suivantes :  
  
-   **Comparaison de valeurs**. Vous pouvez appeler la <xref:System.Single.Equals%2A> méthode pour déterminer si deux <xref:System.Single> valeurs sont égales, ou le <xref:System.Single.CompareTo%2A> méthode pour déterminer la relation entre deux valeurs.  
  
     Le <xref:System.Single> prend également en charge un ensemble complet d’opérateurs de comparaison. Par exemple, vous pouvez tester l’égalité ou d’inégalité ou déterminer si une valeur est supérieure ou égale à une autre valeur. Si l’un des opérandes est une <xref:System.Double>, le <xref:System.Single> valeur est convertie en un <xref:System.Double> avant d’effectuer la comparaison. Si l’un des opérandes est un type intégral, il est converti en un <xref:System.Single> avant d’effectuer la comparaison. Bien que ceux-ci sont des conversions étendues, ils peuvent impliquer une perte de précision.  
  
    > [!WARNING]
    >  En raison de différences de précision, deux <xref:System.Single> les valeurs que vous attendez d’être égal peuvent s’avérer pour être inégaux, ce qui affecte le résultat de la comparaison. Consultez le [test d’égalité](#Equality) section pour plus d’informations sur la comparaison de deux <xref:System.Single> valeurs.  
  
     Vous pouvez également appeler le <xref:System.Single.IsNaN%2A>, <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>, et <xref:System.Single.IsNegativeInfinity%2A> méthodes pour tester ces valeurs spéciales.  
  
-   **Opérations mathématiques**. Les opérations arithmétiques courantes telles que l’addition, soustraction, multiplication et division sont implémentées par les compilateurs de langage et les instructions de langage CIL (Common Intermediate) plutôt que par <xref:System.Single> méthodes. Si l’autre opérande dans une opération mathématique est un <xref:System.Double>, le <xref:System.Single> est converti en un <xref:System.Double> avant d’effectuer l’opération et le résultat de l’opération est également un <xref:System.Double> valeur. Si l’autre opérande est un type intégral, il est converti en un <xref:System.Single> avant d’effectuer l’opération et le résultat de l’opération est également un <xref:System.Single> valeur.  
  
     Vous pouvez effectuer d’autres opérations mathématiques en appelant `static` (`Shared` en Visual Basic) méthodes dans la <xref:System.Math?displayProperty=nameWithType> classe. Il s’agit des méthodes supplémentaires couramment utilisés pour les opérations arithmétiques (tels que <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, et <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), géométrie (tel que <xref:System.Math.Cos%2A?displayProperty=nameWithType> et <xref:System.Math.Sin%2A?displayProperty=nameWithType>) et de calcul (comme <xref:System.Math.Log%2A?displayProperty=nameWithType>).  Dans tous les cas, le <xref:System.Single> valeur est convertie en un <xref:System.Double>.  
  
     Vous pouvez également manipuler les bits individuels d’un <xref:System.Single> valeur. Le <xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType> méthode retourne son modèle de bits dans un tableau d’octets.  En passant ce tableau d’octets à la <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> (méthode), vous pouvez également conserver la <xref:System.Single> modèle de valeur de bit dans un entier 32 bits.  
  
-   **Arrondi**. Arrondi est souvent utilisé comme une technique permettant de réduire l’impact des différences entre les valeurs provoquées par des problèmes de représentation à virgule flottante et de précision. Vous pouvez arrondir un <xref:System.Single> valeur en appelant le <xref:System.Math.Round%2A?displayProperty=nameWithType> (méthode). Toutefois, notez que le <xref:System.Single> valeur est convertie en un <xref:System.Double> avant que la méthode est appelée, et la conversion peut impliquer une perte de précision.  
  
-   **Mise en forme**. Vous pouvez convertir un <xref:System.Single> valeur à sa représentation sous forme de chaîne en appelant le <xref:System.Single.ToString%2A> méthode ou à l’aide de la [mise en forme composite](~/docs/standard/base-types/composite-formatting.md) fonctionnalité. Pour plus d’informations sur la façon dont les chaînes de format contrôlent la représentation sous forme de chaîne de valeurs à virgule flottante, consultez le [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md) rubriques.  
  
-   **Analyse de chaînes**. Vous pouvez convertir la représentation sous forme de chaîne d’une valeur à virgule flottante en une <xref:System.Single> valeur en appelant le <xref:System.Single.Parse%2A> ou <xref:System.Single.TryParse%2A> (méthode). Si l’opération d’analyse échoue, le <xref:System.Single.Parse%2A> méthode lève une exception, tandis que le <xref:System.Single.TryParse%2A> retourne de la méthode `false`.  
  
-   **Conversion de type**. Le <xref:System.Single> structure fournit une implémentation d’interface explicite pour le <xref:System.IConvertible> interface, qui prend en charge la conversion entre les deux types de données .NET Framework standards. Les compilateurs de langage prennent également en charge la conversion implicite des valeurs pour tous les autres types numériques standards à l’exception de la conversion de <xref:System.Double> à <xref:System.Single> valeurs. Conversion d’une valeur de n’importe quel type numérique standard autres qu’un <xref:System.Double> à un <xref:System.Single> est une conversion étendue et ne requiert pas l’utilisation d’une méthode de conversion ou d’opérateur de cast.  
  
     Toutefois, la conversion de valeurs entières 32 bits et 64 bits peut entraîner une perte de précision. Le tableau suivant répertorie les différences de précision pour 32 bits, 64 bits, et <xref:System.Double> types :  
  
    |Type|Précision maximale (en chiffres décimaux)|Précision interne (en chiffres décimaux)|  
    |----------|---------------------------------------------|----------------------------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int32> et <xref:System.UInt32>|10|10|  
    |<xref:System.Int64> et <xref:System.UInt64>|19|19|  
    |<xref:System.Single>|7|9|  
  
     Le problème de précision affecte plus fréquemment <xref:System.Single> les valeurs sont converties en <xref:System.Double> valeurs. Dans l’exemple suivant, deux valeurs produites par des opérations de division identiques sont inégaux, car une des valeurs est une simple précision valeur à virgule flottante qui est convertie en un <xref:System.Double>.  
  
     [!code-csharp[System.Single.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Single.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist1.vb#5)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tous les membres de ce type sont thread-safe. Les membres qui semblent modifier l’état de l’instance retournent en fait une nouvelle instance initialisée avec la nouvelle valeur. Comme avec tout autre type, la lecture et écriture à une variable partagée qui contient une instance de ce type doivent être protégées par un verrou pour garantir la sécurité des threads.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Double" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compare cette instance à un objet spécifié ou à une autre instance de <see cref="T:System.Single" /> et retourne un entier qui indique si la valeur de cette instance est inférieure, égale ou supérieure à la valeur de l'objet spécifié ou de l'autre instance de <see cref="T:System.Single" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Objet à comparer ou <see langword="null" />.</param>
        <summary>Compare cette instance à un objet spécifié et retourne un entier qui indique si la valeur de cette instance est inférieure, égale ou supérieure à la valeur de l'objet spécifié.</summary>
        <returns>Nombre signé indiquant les valeurs relatives de cette instance et <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valeur de retour 
 </term><description> Description  
 </description></listheader><item><term> Inférieure à zéro 
 </term><description> Cette instance est inférieure à <paramref name="value" />.  
  
ou 
Cette instance n'est pas un nombre (<see cref="F:System.Single.NaN" />) et <paramref name="value" /> est un nombre.  
  
 </description></item><item><term> Zéro 
 </term><description> Cette instance est égale à <paramref name="value" />.  
  
ou 
Cette instance et cette valeur sont toutes deux des non-nombres (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" /> ou <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description> Cette instance est supérieure à <paramref name="value" />.  
  
ou 
Cette instance est un nombre et <paramref name="value" /> n'est pas un nombre (<see cref="F:System.Single.NaN" />).  
  
ou 
 <paramref name="value" /> est <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `value` paramètre doit être `null` ou une instance de <xref:System.Single>; sinon, une exception est levée. N’importe quelle instance de <xref:System.Single>, quelle que soit sa valeur, est considéré comme supérieur `null`.  
  
 Les valeurs doivent être identiques pour être considérées comme égales. En particulier lorsque les valeurs à virgule flottante dépendent de plusieurs opérations mathématiques, il est courant de perte de précision et de leurs valeurs être quasiment identique à l’exception de leurs chiffres les moins significatifs. Pour cette raison, la valeur de retour de la <xref:System.Single.CompareTo%2A> méthode peut sembler surprenante dans certains cas. Par exemple, la multiplication par une valeur particulière, suivie de division par la même valeur doit produire la valeur d’origine, mais dans l’exemple suivant, la valeur calculée s’avère pour être supérieure à la valeur d’origine. Affichage de tous les chiffres significatifs des deux valeurs à l’aide de « R » [chaîne de format numérique standard](~/docs/standard/base-types/standard-numeric-format-strings.md) indique que la valeur calculée diffère de la valeur d’origine dans ses chiffres les moins significatifs. Pour plus d’informations sur la gestion de ces comparaisons, consultez la section Notes de la <xref:System.Single.Equals%28System.Single%29> (méthode).  
  
 [!code-csharp[System.Single.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Single.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto3.vb#2)]  
  
 Cette méthode est implémentée pour prendre en charge la <xref:System.IComparable> interface. Notez que, même si un <xref:System.Single.NaN> n’est pas considéré comme égal à un autre <xref:System.Single.NaN> (y compris à lui-même), le <xref:System.IComparable> interface requiert que `A.CompareTo(A)` retournent la valeur zéro.  
  
## <a name="precision-in-comparisons"></a>Précision dans les comparaisons  
 La précision des nombres à virgule flottante au-delà de la précision documentée est spécifique à l’implémentation et la version du .NET Framework. Par conséquent, une comparaison de deux nombres particuliers peut changer entre les versions du .NET Framework, car la précision de la représentation interne des nombres peut changer.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Single.CompareTo%2A> (méthode).  
  
 [!code-cpp[System.Single#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#16)]
 [!code-csharp[System.Single#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#16)]
 [!code-vb[System.Single#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> n’est pas un <see cref="T:System.Single" />.</exception>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(float value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : single -&gt; int&#xA;override this.CompareTo : single -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Nombre à virgule flottante simple précision à comparer.</param>
        <summary>Compare cette instance à un nombre à virgule flottante simple précision spécifié et retourne un entier qui indique si la valeur de cette instance est inférieure, égale ou supérieure à celle du nombre à virgule flottante simple précision spécifié.</summary>
        <returns>Nombre signé indiquant les valeurs relatives de cette instance et <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valeur de retour 
 </term><description> Description  
 </description></listheader><item><term> Inférieure à zéro 
 </term><description> Cette instance est inférieure à <paramref name="value" />.  
  
ou 
Cette instance n'est pas un nombre (<see cref="F:System.Single.NaN" />) et <paramref name="value" /> est un nombre.  
  
 </description></item><item><term> Zéro 
 </term><description> Cette instance est égale à <paramref name="value" />.  
  
ou 
Cette instance et <paramref name="value" /> sont tous deux des non-nombres (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" /> ou <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description> Cette instance est supérieure à <paramref name="value" />.  
  
ou 
Cette instance est un nombre et <paramref name="value" /> n'est pas un nombre (<see cref="F:System.Single.NaN" />).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les valeurs doivent être identiques pour être considérées comme égales. Il est courant pour les valeurs à virgule flottante à une perte de précision et deviennent presque identiques à l’exception de leurs chiffres les moins significatifs, en particulier lorsque les valeurs dépendent de plusieurs opérations mathématiques. Pour cette raison, la valeur de retour de la <xref:System.Single.CompareTo%2A> méthode peut parfois sembler surprenante. Par exemple, la multiplication par n’importe quelle valeur suivie de division par la même valeur doit produire la valeur d’origine. Toutefois, dans l’exemple suivant, la valeur calculée s’avère pour être supérieure à la valeur d’origine. Affichage de tous les chiffres significatifs des deux valeurs à l’aide de « R » [chaîne de format numérique standard](~/docs/standard/base-types/standard-numeric-format-strings.md) indique que la valeur calculée diffère de la valeur d’origine dans ses chiffres les moins significatifs. Pour plus d’informations sur la gestion de ces comparaisons, consultez la section Notes de la <xref:System.Single.Equals%28System.Single%29> (méthode).  
  
 [!code-csharp[System.Single.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Single.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto2.vb#1)]  
  
 Cette méthode implémente la <xref:System.IComparable%601?displayProperty=nameWithType> interface et effectue légèrement meilleures que le <xref:System.Single.CompareTo%2A?displayProperty=nameWithType> (méthode), car il n’a pas à convertir le `value` paramètre à un objet.  
  
 Notez que, même si un objet dont la valeur est <xref:System.Single.NaN> n’est pas considéré comme égal à un autre objet dont la valeur est <xref:System.Single.NaN> (y compris à lui-même), le <xref:System.IComparable%601> interface requiert que `A.CompareTo(A)` retournent la valeur zéro.  
  
## <a name="widening-conversions"></a>conversions étendues  
 Selon votre langage de programmation, il est parfois possible au code un <xref:System.Single.CompareTo%2A> méthode où le type de paramètre comporte moins de bits (est plus restreint) que le type d’instance. Cela est possible, car certains langages de programmation effectuent une conversion étendue implicite qui représente le paramètre en tant que type avec autant de bits que l’instance.  
  
 Par exemple, supposons que le type d’instance est <xref:System.Single> et le type de paramètre est <xref:System.Int32>. Le compilateur Microsoft C# génère des instructions pour représenter la valeur du paramètre comme un <xref:System.Single> de l’objet, puis génère un <xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType> méthode qui compare les valeurs de l’instance et la représentation étendue du paramètre.  
  
 Consultez la documentation de votre langage de programmation pour déterminer si son compilateur effectue des conversions étendues implicites des types numériques. Pour plus d’informations, consultez le [tableaux de Conversion de Type](~/docs/standard/base-types/conversion-tables.md) rubrique.  
  
## <a name="precision-in-comparisons"></a>Précision dans les comparaisons  
 La précision des nombres à virgule flottante au-delà de la précision documentée est spécifique à l’implémentation et la version du .NET Framework. Par conséquent, une comparaison de deux nombres particuliers peut changer entre les versions du .NET Framework, car la précision de la représentation interne des nombres peut changer.  
  
   
  
## Examples  
 L’exemple de code suivant montre des versions génériques et de la <xref:System.Single.CompareTo%2A> méthode pour plusieurs types valeur et référence.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 Epsilon = float32(1.401298E-45)" />
      <MemberSignature Language="DocId" Value="F:System.Single.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Single  = 1.401298E-45" />
      <MemberSignature Language="C++ CLI" Value="public: float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : single" Usage="System.single.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>1.401298E-45</MemberValue>
      <Docs>
        <summary>Représente la valeur <see cref="T:System.Single" /> positive la plus petite qui est supérieure à zéro. Ce champ est constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de la <xref:System.Single.Epsilon> propriété reflète la positive la plus petite <xref:System.Single> qui est significative dans les opérations numériques ou les comparaisons lorsque la valeur de la <xref:System.Single> instance est égale à zéro. Par exemple, le code suivant montre que zéro et <xref:System.Single.Epsilon> sont considérés comme des valeurs inégales, alors que zéro et la moitié de la valeur de <xref:System.Single.Epsilon> sont considérées comme égales.  
  
 [!code-csharp[System.Single.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Single.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon.vb#5)]  
  
 Plus précisément, le format à virgule flottante simple précision se compose d’un signe, une mantisse de 23 bits ou mantisse et un exposant de 8 bits. Comme le montre l’exemple suivant, zéro a un exposant de-126 et une mantisse de 0. <xref:System.Single.Epsilon> a un exposant de-126 et une mantisse de 1. Cela signifie que <xref:System.Single.Epsilon?displayProperty=nameWithType> est la positive la plus petite <xref:System.Single> valeur qui est supérieure à zéro et représente la plus petite valeur possible et le plus petit incrément possible pour un <xref:System.Single> dont exposant est-126.  
  
 [!code-csharp[System.Single.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Single.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon1.vb#6)]  
  
 Toutefois, le <xref:System.Single.Epsilon> propriété n’est pas une mesure générale de précision de la <xref:System.Single> tapez ; elle s’applique uniquement aux <xref:System.Single> instances qui ont une valeur égale à zéro.  
  
> [!NOTE]
>  La valeur de la <xref:System.Single.Epsilon> propriété n’est pas équivalente à epsilon d’ordinateur, qui représente la limite supérieure de l’erreur relative en raison de l’arrondi dans l’arithmétique à virgule flottante.  
  
 La valeur de cette constante est 1, 4e-45.  
  
 Deux nombres à virgule flottante apparemment équivalentes peuvent ne pas être considérés comme égaux en raison de différences dans leurs chiffres les moins significatifs. Par exemple, l’expression C# `(float)1/3 == (float)0.33333`, ne vérifie l’égalité, car l’opération de division sur le côté gauche présente la précision maximale alors que la constante sur le côté droit est uniquement pour les chiffres spécifiés. Si vous créez un algorithme personnalisé qui détermine si deux nombres à virgule flottante peuvent être considérés comme égaux, vous devez utiliser une valeur qui est supérieure à la <xref:System.Single.Epsilon> pour établir la marge absolue acceptable de différence pour les deux valeurs (constante) considérées comme égales. (En règle générale, cette marge de différence est plusieurs fois supérieure à <xref:System.Single.Epsilon>.)  
  
## <a name="platform-notes"></a>Notes de la plateforme  
 Sur les systèmes ARM, la valeur de la <xref:System.Single.Epsilon> constante étant trop petite pour être détecté, ce qui équivaut à zéro. Vous pouvez définir une valeur de remplacement epsilon égale à 1.175494351E-38 à la place.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une valeur indiquant si deux instances de <see cref="T:System.Single" /> représentent la même valeur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à comparer à cette instance.</param>
        <summary>Retourne une valeur indiquant si cette instance équivaut à un objet spécifié.</summary>
        <returns><see langword="true" /> si <paramref name="obj" /> est une instance de <see cref="T:System.Single" /> et est égal à la valeur de cette instance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Single.Equals%2A> méthode doit être utilisée avec précaution, car deux valeurs apparemment équivalentes peuvent être différentes en raison de la précision différente de deux valeurs. L’exemple suivant indique que le <xref:System.Single> valeur.3333 et <xref:System.Single> retournée en divisant 1 par 3 ne sont pas égales.  
  
 [!code-csharp[System.Single.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#3)]
 [!code-vb[System.Single.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#3)]  
  
 Au lieu de la comparaison d’égalité, recommandée technique implique la définition d’une marge acceptable de différence entre deux valeurs (tel que. % 01 d’une des valeurs). Si la valeur absolue de la différence entre les deux valeurs est inférieure ou égale à cette marge, la différence est susceptible d’être en raison des différences de précision et, par conséquent, les valeurs sont susceptibles d’être égal. L’exemple suivant utilise cette technique pour comparer.33333 et 1/3, les deux <xref:System.Single> valeurs qui peuvent pour être inégaux l’exemple de code précédent.  
  
 [!code-csharp[System.Single.Epsilon#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#4)]
 [!code-vb[System.Single.Epsilon#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#4)]  
  
 Dans ce cas, les valeurs sont égales.  
  
> [!NOTE]
>  Étant donné que <xref:System.Single.Epsilon> définit l’expression minimum d’une valeur positive dont la plage est proche de zéro, la marge de différence doit être supérieure à <xref:System.Single.Epsilon>. En règle générale, il est beaucoup plus important que <xref:System.Single.Epsilon>.  
  
 La précision des nombres à virgule flottante au-delà de la précision documentée est spécifique à l’implémentation et la version du .NET Framework. Par conséquent, une comparaison de deux nombres particuliers peut changer entre les versions du .NET Framework, car la précision de la représentation interne des nombres peut changer.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Single.Equals%2A> (méthode).  
  
 [!code-cpp[System.Single#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#17)]
 [!code-csharp[System.Single#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#17)]
 [!code-vb[System.Single#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#17)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Résolution de surcharge du compilateur peut-être représenter une différence apparente dans le comportement des deux <see cref="M:System.Single.Equals(System.Object)" /> surcharges de méthode. Si une conversion implicite entre le <paramref name="obj" /> argument et un <see cref="T:System.Single" /> est défini et l’argument n’est pas typé comme un <see cref="T:System.Object" />, compilateurs peuvent effectuer une conversion implicite et l’appel de la <see cref="M:System.Single.Equals(System.Single)" /> (méthode). Sinon, elles appellent la <see cref="M:System.Single.Equals(System.Object)" /> (méthode), qui retourne toujours <see langword="false" /> si son <paramref name="obj" /> argument n’est pas un <see cref="T:System.Single" /> valeur. L’exemple suivant illustre la différence de comportement entre les surcharges de deux méthode. Dans le cas de tous les types numériques primitifs à l’exception de <see cref="T:System.Double" /> en Visual Basic et à l’exception de <see cref="T:System.Decimal" /> et <see cref="T:System.Double" /> en C#, la première comparaison retourne <see langword="true" /> , car le compilateur effectue automatiquement une conversion étendue et des appels le <see cref="M:System.Single.Equals(System.Single)" /> (méthode), tandis que la deuxième comparaison retourne <see langword="false" /> , car le compilateur appelle le <see cref="M:System.Single.Equals(System.Object)" /> (méthode).  
  
[!code-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [!code-vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Single.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (float obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float32 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(float obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : single -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à comparer à cette instance.</param>
        <summary>Retourne une valeur indiquant si cette instance et un objet <see cref="T:System.Single" /> spécifié représentent la même valeur.</summary>
        <returns><see langword="true" /> si <paramref name="obj" /> est égal à cette instance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode implémente la <xref:System.IEquatable%601?displayProperty=nameWithType> interface et effectue légèrement meilleures que <xref:System.Single.Equals%2A> , car il n’a pas à convertir le `obj` paramètre à un objet.  
  
## <a name="widening-conversions"></a>conversions étendues  
 Selon votre langage de programmation, il est parfois possible au code un <xref:System.Single.Equals%2A> méthode où le type de paramètre comporte moins de bits (est plus restreint) que le type d’instance. Cela est possible, car certains langages de programmation effectuent une conversion étendue implicite qui représente le paramètre en tant que type avec autant de bits que l’instance.  
  
 Par exemple, supposons que le type d’instance est <xref:System.Single> et le type de paramètre est <xref:System.Int32>. Le compilateur Microsoft C# génère des instructions pour représenter la valeur du paramètre comme un <xref:System.Single> de l’objet, puis génère un <xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType> méthode qui compare les valeurs de l’instance et la représentation étendue du paramètre.  
  
 Consultez la documentation de votre langage de programmation pour déterminer si son compilateur effectue des conversions étendues implicites des types numériques. Pour plus d’informations, consultez le [tableaux de Conversion de Type](~/docs/standard/base-types/conversion-tables.md) rubrique.  
  
## <a name="precision-in-comparisons"></a>Précision dans les comparaisons  
 Le <xref:System.Single.Equals%2A> méthode doit être utilisée avec précaution, car deux valeurs apparemment équivalentes peuvent être différentes en raison de la précision différente de deux valeurs. L’exemple suivant indique que le <xref:System.Single> valeur.3333 et <xref:System.Single> retournée en divisant 1 par 3 ne sont pas égales.  
  
 [!code-csharp[System.Single.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#1)]
 [!code-vb[System.Single.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#1)]  
  
 Technique d’une comparaison qui permet d’éviter les problèmes associés à la comparaison d’égalité implique la définition d’une marge acceptable de différence entre deux valeurs (tel que. % 01 d’une des valeurs). Si la valeur absolue de la différence entre les deux valeurs est inférieure ou égale à cette marge, la différence est susceptible d’être un résultat des différences de précision et, par conséquent, les valeurs sont susceptibles d’être égal. L’exemple suivant utilise cette technique pour comparer.33333 et 1/3, qui sont les deux <xref:System.Single> valeurs qui peuvent pour être inégaux l’exemple de code précédent.  
  
 [!code-csharp[System.Single.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#2)]
 [!code-vb[System.Single.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#2)]  
  
 Dans ce cas, les valeurs sont égales.  
  
> [!NOTE]
>  Étant donné que <xref:System.Single.Epsilon> définit l’expression minimum d’une valeur positive dont la plage est proche de zéro, la marge de différence doit être supérieure à <xref:System.Single.Epsilon>. En règle générale, il est beaucoup plus important que <xref:System.Single.Epsilon>. Pour cette raison, nous vous recommandons de ne pas utiliser <xref:System.Double.Epsilon> lors de la comparaison <xref:System.Double> valeurs sont égales.  
  
 Une deuxième technique qui permet d’éviter les problèmes associés à la comparaison d’égalité implique la comparaison de la différence entre deux nombres à virgule flottante avec une valeur absolue. Si la différence est inférieure ou égale à cette valeur absolue, les nombres sont égaux. Si elle est supérieure, les nombres ne sont pas égaux. Pour ce faire consiste à arbitrairement sélectionner une valeur absolue. Toutefois, cela peut être problématique, car une marge acceptable de différence dépend de l’ampleur de la <xref:System.Single> valeurs. Une deuxième méthode tire parti d’une fonctionnalité de conception du format à virgule flottante : La différence entre les composants de mantisse dans les représentations sous forme d’entier de deux valeurs à virgule flottante indique le nombre de valeurs à virgule flottante possibles qui sépare les deux valeurs. Par exemple, la différence entre 0.0 et <xref:System.Single.Epsilon> est 1, parce que <xref:System.Single.Epsilon> est la plus petite valeur représentable lorsque vous travaillez avec un <xref:System.Single> dont la valeur est égale à zéro. L’exemple suivant utilise cette technique pour comparer.33333 et 1/3, qui sont les deux <xref:System.Double> valeurs que l’exemple de code précédent avec le <xref:System.Single.Equals%28System.Single%29> méthode trouvée accentuées. Notez que l’exemple utilise le <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> et <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> méthodes pour convertir une valeur à virgule flottante simple précision en sa représentation sous forme d’entier.  
  
 [!code-csharp[System.Single.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Single.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsabs1.vb#1)]  
  
 La précision des nombres à virgule flottante au-delà de la précision documentée est spécifique à l’implémentation et la version du .NET Framework. Par conséquent, une comparaison de deux nombres peut produire des résultats différents selon la version du .NET Framework, car la précision de la représentation interne des nombres peut changer.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Résolution de surcharge du compilateur peut-être représenter une différence apparente dans le comportement des deux <see cref="M:System.Single.Equals(System.Object)" /> surcharges de méthode. Si une conversion implicite entre le <paramref name="obj" /> argument et un <see cref="T:System.Single" /> est défini et l’argument n’est pas typé comme un <see cref="T:System.Object" />, compilateurs peuvent effectuer une conversion implicite et l’appel de la <see cref="M:System.Single.Equals(System.Single)" /> (méthode). Sinon, elles appellent la <see cref="M:System.Single.Equals(System.Object)" /> (méthode), qui retourne toujours <see langword="false" /> si son <paramref name="obj" /> argument n’est pas un <see cref="T:System.Single" /> valeur. L’exemple suivant illustre la différence de comportement entre les surcharges de deux méthode. Dans le cas de tous les types numériques primitifs à l’exception de <see cref="T:System.Double" /> en Visual Basic et à l’exception de <see cref="T:System.Decimal" /> et <see cref="T:System.Double" /> en C#, la première comparaison retourne <see langword="true" /> , car le compilateur effectue automatiquement une conversion étendue et des appels le <see cref="M:System.Single.Equals(System.Single)" /> (méthode), tandis que la deuxième comparaison retourne <see langword="false" /> , car le compilateur appelle le <see cref="M:System.Single.Equals(System.Object)" /> (méthode).  
  
[!code-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [!code-vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Single.Equals(System.Object)" />
        <altmember cref="Overload:System.Single.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="single.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage de cette instance.</summary>
        <returns>Code de hachage d'un entier signé 32 bits.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="single.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le <see cref="T:System.TypeCode" /> du type valeur <see cref="T:System.Single" />.</summary>
        <returns>Constante énumérée, <see cref="F:System.TypeCode.Single" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsFinite(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(float f);" />
      <MemberSignature Language="F#" Value="static member IsFinite : single -&gt; bool" Usage="System.single.IsFinite f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : single -&gt; bool" Usage="System.single.IsInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Nombre à virgule flottante simple précision.</param>
        <summary>Retourne une valeur indiquant si la valeur du nombre spécifié est l'infini négatif ou positif.</summary>
        <returns><see langword="true" /> si <paramref name="f" /> a la valeur <see cref="F:System.Single.PositiveInfinity" /> ou <see cref="F:System.Single.NegativeInfinity" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les opérations à virgule flottante retournent <xref:System.Single.PositiveInfinity> ou <xref:System.Single.NegativeInfinity> pour signaler une condition de dépassement de capacité.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Single.IsInfinity%2A> (méthode).  
  
 [!code-cpp[System.Single#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#11)]
 [!code-csharp[System.Single#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#11)]
 [!code-vb[System.Single#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNaN(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(float f);" />
      <MemberSignature Language="F#" Value="static member IsNaN : single -&gt; bool" Usage="System.single.IsNaN f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Nombre à virgule flottante simple précision.</param>
        <summary>Retourne une valeur qui indique si la valeur spécifiée n'est pas un nombre (<see cref="F:System.Single.NaN" />).</summary>
        <returns><see langword="true" /> si la valeur de <paramref name="f" /> est un non-nombre (<see cref="F:System.Single.NaN" />) ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les opérations à virgule flottante retournent <xref:System.Single.NaN> pour signaler que le résultat de l’opération est non défini. Par exemple, la division de 0,0 par 0,0 entraîne <xref:System.Single.NaN>.  
  
> [!NOTE]
>  <xref:System.Single.IsNaN%2A> Retourne `false` si un <xref:System.Single> valeur est soit <xref:System.Single.PositiveInfinity> ou <xref:System.Single.NegativeInfinity>. Pour tester ces valeurs, utilisez le <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>, et <xref:System.Single.IsNegativeInfinity%2A> méthodes.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Single.IsNaN%2A> (méthode).  
  
 [!code-cpp[System.Single#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#8)]
 [!code-csharp[System.Single#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#8)]
 [!code-vb[System.Single#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegative(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegative : single -&gt; bool" Usage="System.single.IsNegative f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegativeInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : single -&gt; bool" Usage="System.single.IsNegativeInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Nombre à virgule flottante simple précision.</param>
        <summary>Retourne une valeur indiquant si le nombre spécifié est équivalent à l'infini négatif.</summary>
        <returns><see langword="true" /> si <paramref name="f" /> a la valeur <see cref="F:System.Single.NegativeInfinity" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les opérations à virgule flottante retournent <xref:System.Single.NegativeInfinity> pour signaler une condition de dépassement de capacité.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Single.IsNegativeInfinity%2A> (méthode).  
  
 [!code-cpp[System.Single#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#13)]
 [!code-csharp[System.Single#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#13)]
 [!code-vb[System.Single#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsNormal : single -&gt; bool" Usage="System.single.IsNormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsPositiveInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : single -&gt; bool" Usage="System.single.IsPositiveInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Nombre à virgule flottante simple précision.</param>
        <summary>Retourne une valeur indiquant si le nombre spécifié est équivalent à l'infini positif.</summary>
        <returns><see langword="true" /> si <paramref name="f" /> a la valeur <see cref="F:System.Single.PositiveInfinity" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les opérations à virgule flottante retournent <xref:System.Single.PositiveInfinity> pour signaler une condition de dépassement de capacité.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Single.IsPositiveInfinity%2A> (méthode).  
  
 [!code-cpp[System.Single#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#12)]
 [!code-csharp[System.Single#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#12)]
 [!code-vb[System.Single#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsSubnormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : single -&gt; bool" Usage="System.single.IsSubnormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MaxValue = float32(3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Single  = 3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : single" Usage="System.single.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.402823E+38</MemberValue>
      <Docs>
        <summary>Représente la plus grande valeur possible de <see cref="T:System.Single" />. Ce champ est constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette constante est positif 3.40282347E + 38.  
  
 Le résultat d’une opération qui dépasse <xref:System.Single.MaxValue?displayProperty=nameWithType> est <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>. Dans l’exemple suivant, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> entraîne des opérations d’addition, la multiplication et une puissance lorsque le résultat dépasse <xref:System.Single.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Single.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Single.MaxValue> constante.  
  
 [!code-cpp[System.Single#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#4)]
 [!code-csharp[System.Single#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#4)]
 [!code-vb[System.Single#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const float MinValue = -3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MinValue = float32(-3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Single  = -3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MinValue = -3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : single" Usage="System.single.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-3.402823E+38</MemberValue>
      <Docs>
        <summary>Représente la plus petite valeur possible de <see cref="T:System.Single" />. Ce champ est constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette constante est moins 3, 402823E38.  
  
 Le résultat d’une opération qui est inférieur à <xref:System.Single.MinValue?displayProperty=nameWithType> est <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Dans l’exemple suivant, <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> résulte de la soustraction et multiplication des opérations lorsque le résultat est inférieur à <xref:System.Single.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Single.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Single.MinValue> constante.  
  
 [!code-cpp[System.Single#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#5)]
 [!code-csharp[System.Single#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#5)]
 [!code-vb[System.Single#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const float NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NaN = float32(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Single  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: float NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : single" Usage="System.single.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Représente une valeur autre qu'un nombre (<see langword="NaN" />). Ce champ est constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une méthode ou un opérateur retourne <xref:System.Single.NaN> lorsque le résultat d’une opération est indéfini. Par exemple, le résultat de la division de zéro par zéro est <xref:System.Single.NaN>, comme illustré dans l’exemple suivant. (Mais notez que la division d’un nombre différent de zéro par zéro retourne <xref:System.Single.PositiveInfinity> ou <xref:System.Single.NegativeInfinity>, selon le signe du diviseur.)  
  
 [!code-csharp[System.Single.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#1)]
 [!code-vb[System.Single.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#1)]  
  
 En outre, un appel de méthode avec un <xref:System.Single.NaN> valeur ou une opération sur un <xref:System.Single.NaN> retourne la valeur <xref:System.Single.NaN>, comme illustré dans l’exemple suivant.  
  
 [!code-csharp[System.Single.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#2)]
 [!code-vb[System.Single.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#2)]  
  
 Utilisez le <xref:System.Single.IsNaN%2A> méthode pour déterminer si une valeur n’est pas un nombre. En règle générale, <xref:System.Single> opérateurs ne peuvent pas être utilisés pour comparer <xref:System.Single.NaN?displayProperty=nameWithType> avec d’autres <xref:System.Single> valeurs, bien que les méthodes de comparaison (tels que <xref:System.Single.Equals%2A> et <xref:System.Single.CompareTo%2A>) peut. L’exemple suivant illustre la différence de comportement entre les <xref:System.Single> les méthodes et les opérateurs de comparaison.  
  
 [!code-csharp[System.Single.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/single.nan4.cs#4)]
 [!code-vb[System.Single.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/single.nan4.vb#4)]  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Single.NaN> constante.  
  
 [!code-cpp[System.Single#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#7)]
 [!code-csharp[System.Single#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#7)]
 [!code-vb[System.Single#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNaN(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NegativeInfinity = float32(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Single  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : single" Usage="System.single.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Représente l'infini négatif. Ce champ est constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette constante est le résultat de la division d’un nombre négatif par zéro.  
  
 Cette constante est retournée quand le résultat d’une opération est inférieur à <xref:System.Single.MinValue>.  
  
 Utilisez <xref:System.Single.IsNegativeInfinity%2A> pour déterminer si une valeur correspond à l’infini négatif.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Single.NegativeInfinity> constante.  
  
 [!code-cpp[System.Single#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#9)]
 [!code-csharp[System.Single#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#9)]
 [!code-vb[System.Single#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Equality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : single * single -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si deux valeurs <see cref="T:System.Single" /> spécifiées sont égales.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> et <paramref name="right" /> sont égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Single.op_Equality%2A> méthode définit l’opérateur d’égalité pour <xref:System.Single> valeurs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : single * single -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Single" /> spécifique est supérieure à une autre valeur <see cref="T:System.Single" /> spécifique.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> est supérieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Single.op_GreaterThan%2A> méthode définit l’opération de la plus grande-que l’opérateur pour <xref:System.Single> valeurs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : single * single -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Single" /> spécifique est supérieure ou égale à une autre valeur <see cref="T:System.Single" /> spécifique.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> est supérieur ou égal à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Single.op_GreaterThanOrEqual%2A> méthode définit l’opération de l’opérateur supérieur ou égal pour <xref:System.Single> valeurs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Inequality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : single * single -&gt; bool" Usage="System.single.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si deux valeurs <see cref="T:System.Single" /> spécifiées sont différentes.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> et <paramref name="right" /> ne sont pas égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Single.op_Inequality%2A> méthode définit l’opérateur d’inégalité pour <xref:System.Single> valeurs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : single * single -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Single" /> spécifique est inférieure à une autre valeur <see cref="T:System.Single" /> spécifique.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> est inférieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Single.op_LessThan%2A> méthode définit l’opération d’inférieur-que l’opérateur pour <xref:System.Single> valeurs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : single * single -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Single" /> spécifique est inférieure ou égale à une autre valeur <see cref="T:System.Single" /> spécifique.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> est inférieur ou égal à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Single.op_LessThanOrEqual%2A> méthode définit l’opération de l’opérateur inférieur ou égal pour <xref:System.Single> valeurs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit la chaîne d'un nombre en nombre à virgule flottante simple précision équivalent.</summary>
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; single" Usage="System.single.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne contenant un nombre à convertir.</param>
        <summary>Convertit la chaîne d'un nombre en nombre à virgule flottante simple précision équivalent.</summary>
        <returns>Nombre à virgule flottante simple précision équivalant à la valeur numérique ou au symbole spécifié dans <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `s` paramètre peut contenir de la culture actuelle <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, ou une chaîne au format :  
  
 [*ws*][*sign*] [*integral-digits*[*,*]]*integral-digits*[*.*[*fractional-digits*]][e[*sign*]*exponential-digits*][*ws*]  
  
 Les éléments entre crochets ([ et ]) sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Une série de caractères d’espace blanc.|  
|*sign*|Symbole du signe négatif ou un symbole de signe positif. Les caractères de signe valides sont déterminés par le <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> et <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> propriétés de la culture actuelle. Uniquement un signe de début peut être utilisé.|  
|*integral-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie entière du nombre. Les exécutions de *chiffres intégraux* peuvent être partitionnées par un symbole de séparateur de groupes. Par exemple, dans certaines cultures une virgule (,) sépare les groupes de milliers. Le *chiffres intégraux* élément peut être absent si la chaîne contient le *chiffres fractionnaires* élément.|  
|*,*|Des milliers spécifiques à la culture des symboles de séparateur.|  
|*.*|Un symbole décimal spécifique à la culture.|  
|*fractional-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie fractionnaire du nombre.|  
|E|Le « e » ou un caractère « E », ce qui indique que la valeur est représentée dans la notation exponentielle (scientifique).|  
|*exponential-digits*|Une série de chiffres allant de 0 à 9 qui spécifie un exposant.|  
  
 Le `s` paramètre est interprété en utilisant une combinaison de la <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> et <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> indicateurs. Cela signifie que les espaces blancs et des milliers les séparateurs sont autorisés, mais les symboles monétaires ne sont pas. Pour définir explicitement les éléments (tels que les symboles monétaires, des milliers, séparateurs et l’espace blanc) qui peuvent être présents dans `s`, utiliser le <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> surcharge de méthode.  
  
 Le `s` paramètre est analysé en utilisant les informations de mise en forme dans un <xref:System.Globalization.NumberFormatInfo> objet initialisé pour la culture système actuelle. Pour plus d'informations, consultez <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Pour analyser une chaîne en utilisant les informations de mise en forme d’une culture spécifique, utilisez le <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> ou <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> (méthode).  
  
 En règle générale, si vous passez le <xref:System.Single.Parse%2A> méthode une chaîne qui est créé en appelant le <xref:System.Single.ToString%2A> (méthode), la version d’origine <xref:System.Single> valeur est retournée. Toutefois, en raison d’une perte de précision, les valeurs peut-être pas égales.  
  
 Si un séparateur est rencontré dans le `s` paramètre pendant une opération d’analyse et la devise ou un nombre décimal et des séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur. Pour plus d’informations sur les séparateurs, consultez <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, et <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Single.Parse%28System.String%29> méthode pour convertir un tableau de chaînes en équivalent <xref:System.Single> valeurs.  
  
 [!code-csharp[System.Single.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse1.cs#2)]
 [!code-vb[System.Single.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> ne représente pas un nombre dans un format valide.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> représente un nombre inférieur à <see cref="F:System.Single.MinValue" /> ou supérieur à <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analyse de chaînes numériques dans .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; single" Usage="System.single.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne contenant un nombre à convertir.</param>
        <param name="style">Combinaison de bits de valeurs d'énumération qui indique les éléments de style qui peuvent être présents dans <paramref name="s" />. Une valeur typique à spécifier est <see cref="F:System.Globalization.NumberStyles.Float" /> combinée avec <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Convertit la chaîne d'un nombre dans un style spécifié en nombre à virgule flottante simple précision équivalent.</summary>
        <returns>Nombre à virgule flottante en simple précision équivalant à la valeur numérique ou au symbole spécifié dans <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `style` paramètre définit les éléments de style (tels que des espaces blancs, des milliers séparateurs et les symboles monétaires) qui sont autorisés dans les `s` paramètre pour l’opération d’analyse. Il doit être une combinaison d’indicateurs de bits de le <xref:System.Globalization.NumberStyles> énumération. Ce qui suit <xref:System.Globalization.NumberStyles> membres ne sont pas pris en charge :  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Le `s` paramètre peut contenir de la culture actuelle <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>. Selon la valeur de `style`, il peut également prendre la forme :  
  
 [*ws*][*$*][*sign*][*integral-digits*[*,*]]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 Les éléments entre crochets ([ et ]) sont facultatifs. Le tableau suivant décrit chaque élément.  
  
 *ws*  
 Une série de caractères d’espace blanc. Espace blanc peut apparaître au début de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> indicateur et il peuvent apparaître à la fin de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> indicateur.  
  
 $  
 Un symbole monétaire spécifique à la culture. Sa position dans la chaîne est définie par le <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> et <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propriétés de la culture actuelle. Symbole de devise de la culture actuelle peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> indicateur.  
  
 *sign*  
 Un symbole négatif (-) ou un signe positif (+) de symboles. Le signe peut apparaître au début de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> indicateur et il peuvent apparaître à la fin de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> indicateur. Parenthèses peuvent être utilisées dans `s` pour indiquer une valeur négative si `style` inclut le <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> indicateur.  
  
 *integral-digits*  
 Une série de chiffres allant de 0 à 9 qui spécifie la partie entière du nombre. Le *chiffres intégraux* élément peut être absent si la chaîne contient le *chiffres fractionnaires* élément.  
  
 ,  
 Un séparateur de groupe spécifique à la culture. Symbole de séparateur de groupe de la culture actuelle peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> indicateur  
  
 .  
 Un symbole décimal spécifique à la culture. Symbole de virgule décimale de la culture actuelle peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> indicateur.  
  
 *fractional-digits*  
 Une série de chiffres allant de 0 à 9 qui spécifie la partie fractionnaire du nombre. Les chiffres fractionnaires peuvent apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> indicateur.  
  
 E  
 Le « e » ou un caractère « E », ce qui indique que la valeur est représentée dans la notation exponentielle (scientifique). Le `value` paramètre peut représenter un nombre en notation exponentielle si `style` inclut le <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> indicateur.  
  
 *exponential-digits*  
 Une série de chiffres allant de 0 à 9 qui spécifie un exposant.  
  
> [!NOTE]
> Les caractères (U + 0000) NUL fin `s` sont ignorés par l’opération d’analyse, quelle que soit la valeur de la `style` argument.

 Une chaîne contenant uniquement des chiffres (qui correspond à la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) toujours analysée avec succès. Les autres <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> membres contrôlent des éléments qui peuvent être présents, mais ne sont pas requis pour être présents dans la chaîne d’entrée. Le tableau suivant indique comment chaque <xref:System.Globalization.NumberStyles> indicateurs affectent les éléments qui peuvent être présents dans `s`.  
  
|Valeur NumberStyles|Éléments autorisés dans `s` en plus des chiffres|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Le *chiffres intégraux* élément uniquement.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|La virgule décimale (*.*) et *chiffres fractionnaires* éléments.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Le « e » ou un caractère « E », ce qui indique la notation exponentielle. Cet indicateur en lui-même prend en charge les valeurs sous la forme *chiffres*E*chiffres*; autres indicateurs sont nécessaires pour analyser correctement les chaînes avec des éléments tels que les signes positifs ou négatifs et des symboles de séparateur décimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Le *ws* élément au début de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Le *ws* élément à la fin de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Le *connexion* élément au début de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Le *connexion* élément à la fin de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Le *connexion* élément sous la forme de parenthèses entourant la valeur numérique.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Les milliers élément séparateur (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Élément de devise ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Tous les éléments. Toutefois, `s` ne peut pas représenter un nombre hexadécimal ou un nombre en notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Float>|Le *ws* élément au début ou à la fin de `s`, *connexion* au début de `s`et le symbole de virgule décimale (.). Le `s` paramètre peut également utiliser la notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Number>|Le `ws`, `sign`, des milliers séparateur (,) et les éléments de la virgule décimale (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Tous les éléments. Toutefois, `s` ne peut pas représenter un nombre hexadécimal.|  
  
 Quelques exemples de `s` sont « 100 », «-123 456 789 », « 123.45e + 6 », « + 500 », « 5e2 », « 3,1416 », « 600 », «-. 123 », et «-Infinity ».  
  
 Le `s` paramètre est analysé en utilisant les informations de mise en forme dans un <xref:System.Globalization.NumberFormatInfo> objet initialisé pour la culture système actuelle. Pour spécifier la culture dont les informations mise en forme sont utilisées pour l’opération d’analyse, appelez le <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> de surcharge.  
  
 En règle générale, si vous passez le <xref:System.Single.Parse%2A> méthode une chaîne qui est créé en appelant le <xref:System.Single.ToString%2A> (méthode), la version d’origine <xref:System.Single> valeur est retournée. Toutefois, en raison d’une perte de précision, les valeurs peut-être pas égales.  
  
 Si un séparateur est rencontré dans le `s` paramètre pendant une opération d’analyse et la devise ou un nombre décimal et des séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur. Pour plus d’informations sur les séparateurs, consultez <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, et <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> méthode pour analyser les représentations sous forme de chaîne de <xref:System.Single> valeurs. L’exemple utilise les informations de mise en forme pour la culture en-US.  
  
 [!code-csharp[System.Single.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse2.cs#3)]
 [!code-vb[System.Single.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> n’est pas un nombre exprimé dans un format valide.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> représente un nombre qui est inférieur à <see cref="F:System.Single.MinValue" /> ou supérieur à <see cref="F:System.Single.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> n’est pas une valeur <see cref="T:System.Globalization.NumberStyles" />.  
  
ou 
 <paramref name="style" /> inclut la valeur <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analyse de chaînes numériques dans .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; single" Usage="System.single.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne contenant un nombre à convertir.</param>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture sur <paramref name="s" />.</param>
        <summary>Convertit la chaîne d'un nombre dans un format propre à la culture spécifiée en nombre à virgule flottante simple précision équivalent.</summary>
        <returns>Nombre à virgule flottante simple précision équivalant à la valeur numérique ou au symbole spécifié dans <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est généralement utilisée pour convertir du texte qui peut être mis en forme de différentes façons pour un <xref:System.Single> valeur. Par exemple, il peut être utilisé pour convertir le texte entré par un utilisateur dans une zone de texte HTML en valeur numérique.  
  
 Le `s` paramètre est interprété en utilisant une combinaison de la <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> et <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> indicateurs. Le `s` paramètre peut contenir <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, ou <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> pour la culture spécifiée par `provider`, ou il peut contenir une chaîne sous la forme :  
  
 [*ws*][*sign*]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 Éléments facultatifs sont encadrés par des crochets ([et]). Les éléments qui contiennent le terme « chiffres » se composent d’une série de caractères numériques comprises entre 0 et 9.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Une série de caractères d’espace blanc.|  
|*sign*|Un symbole négatif (-) ou un signe positif (+) de symboles.|  
|*integral-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie entière du nombre. Les exécutions de *chiffres intégraux* peuvent être partitionnées par un symbole de séparateur de groupes. Par exemple, dans certaines cultures une virgule (,) sépare les groupes de milliers. Le *chiffres intégraux* élément peut être absent si la chaîne contient le *chiffres fractionnaires* élément.|  
|.|Un symbole décimal spécifique à la culture.|  
|*fractional-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie fractionnaire du nombre.|  
|E|Le « e » ou un caractère « E », ce qui indique que la valeur est représentée dans la notation exponentielle (scientifique).|  
|*exponential-digits*|Une série de chiffres allant de 0 à 9 qui spécifie un exposant.|  
  
 Pour plus d’informations sur les formats numériques, consultez le [mise en forme des Types](~/docs/standard/base-types/formatting-types.md) rubrique.  
  
 Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation dont <xref:System.IFormatProvider.GetFormat%2A> méthode retourne un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme propres à la culture. Lorsque le <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> méthode est appelée, elle appelle le `provider` du paramètre <xref:System.IFormatProvider.GetFormat%2A> (méthode) et le transmet un <xref:System.Type> objet qui représente le <xref:System.Globalization.NumberFormatInfo> type. Le <xref:System.IFormatProvider.GetFormat%2A> méthode renvoie alors le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations sur le format de le `s` paramètre. Il existe trois façons d’utiliser le `provider` paramètre pour fournir des informations de mise en forme personnalisées à l’opération d’analyse :  
  
-   Vous pouvez passer un <xref:System.Globalization.CultureInfo> objet qui représente la culture qui fournit des informations de mise en forme. Son <xref:System.Globalization.CultureInfo.GetFormat%2A> méthode retourne le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme numériques pour cette culture.  
  
-   Vous pouvez passer le texte réel <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme numériques. (Son implémentation de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retourne simplement lui-même.)  
  
-   Vous pouvez passer un objet personnalisé qui implémente <xref:System.IFormatProvider>. Son <xref:System.IFormatProvider.GetFormat%2A> méthode instancie et retourne le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme.  
  
 Si `provider` est `null` ou un <xref:System.Globalization.NumberFormatInfo> ne peut pas être obtenu, les informations de mise en forme pour la culture système actuelle est utilisée.  
  
 Si un séparateur est rencontré dans le `s` paramètre pendant une opération d’analyse et la devise ou un nombre décimal et des séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur. Pour plus d’informations sur les séparateurs, consultez <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, et <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
 Quelques exemples de `s` sont « 100 », «-123 456 789 », « 123.45e + 6 », « + 500 », « 5e2 », « 3,1416 », « 600 », «-. 123 », et «-Infinity ».  
  
   
  
## Examples  
 L’exemple suivant est le bouton sur le Gestionnaire d’événements d’un formulaire Web. Il utilise le tableau retourné par la <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> propriété afin de déterminer les paramètres régionaux de l’utilisateur. Il instancie ensuite un <xref:System.Globalization.CultureInfo> objet qui correspond à ces paramètres régionaux. Le <xref:System.Globalization.NumberFormatInfo> objet appartient à celle <xref:System.Globalization.CultureInfo> objet est ensuite passé à la <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> d’entrée de méthode pour convertir l’utilisateur à un <xref:System.Single> valeur.  
  
 [!code-csharp[ParseMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#1)]
 [!code-vb[ParseMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> ne représente pas un nombre dans un format valide.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> représente un nombre inférieur à <see cref="F:System.Single.MinValue" /> ou supérieur à <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analyse de chaînes numériques dans .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Single" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne contenant un nombre à convertir.</param>
        <param name="style">Combinaison de bits de valeurs d'énumération qui indique les éléments de style qui peuvent être présents dans <paramref name="s" />. Une valeur typique à spécifier est <see cref="F:System.Globalization.NumberStyles.Float" /> combinée avec <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture sur <paramref name="s" />.</param>
        <summary>Convertit la chaîne d'un nombre dans un style et un format propre à la culture spécifiés en nombre à virgule flottante simple précision équivalent.</summary>
        <returns>Nombre à virgule flottante simple précision équivalant à la valeur numérique ou au symbole spécifié dans <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `style` paramètre définit les éléments de style (tels que des espaces blancs, des milliers séparateurs et les symboles monétaires) qui sont autorisés dans les `s` paramètre pour l’opération d’analyse. Il doit être une combinaison d’indicateurs de bits de le <xref:System.Globalization.NumberStyles> énumération. Ce qui suit <xref:System.Globalization.NumberStyles> membres ne sont pas pris en charge :  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Le `s` paramètre peut contenir <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, ou <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> pour la culture spécifiée par `provider`. Selon la valeur de `style`, il peut également prendre la forme :  
  
 [*ws*] [*$*] [*sign*][*integral-digits*,]*integral-digits*[.[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 Éléments encadrés par des crochets ([et]) sont facultatives. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Une série de caractères d’espace blanc. Espace blanc peut apparaître au début de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> indicateur et il peuvent apparaître à la fin de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> indicateur.|  
|$|Un symbole monétaire spécifique à la culture. Sa position dans la chaîne est définie par le <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> et <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propriétés de la culture actuelle. Symbole de devise de la culture actuelle peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> indicateur.|  
|*sign*|Un symbole négatif (-) ou un signe positif (+) de symboles. Le signe peut apparaître au début de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> indicateur et il peuvent apparaître à la fin de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> indicateur. Parenthèses peuvent être utilisées dans `s` pour indiquer une valeur négative si `style` inclut le <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> indicateur.|  
|*integral-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie entière du nombre. Le *chiffres intégraux* élément peut être absent si la chaîne contient le *chiffres fractionnaires* élément.|  
|,|Un séparateur de groupe spécifique à la culture. Symbole de séparateur de groupe de la culture actuelle peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> indicateur|  
|.|Un symbole décimal spécifique à la culture. Symbole de virgule décimale de la culture actuelle peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> indicateur.|  
|*fractional-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie fractionnaire du nombre. Les chiffres fractionnaires peuvent apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> indicateur.|  
|E|Le « e » ou un caractère « E », ce qui indique que la valeur est représentée dans la notation exponentielle (scientifique). Le `s` paramètre peut représenter un nombre en notation exponentielle si `style` inclut le <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> indicateur.|  
|*exponential-digits*|Une série de chiffres allant de 0 à 9 qui spécifie un exposant.|  
  
> [!NOTE]
> Les caractères (U + 0000) NUL fin `s` sont ignorés par l’opération d’analyse, quelle que soit la valeur de la `style` argument.

 Une chaîne contenant uniquement des chiffres (qui correspond à la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) toujours analysée avec succès. Les autres <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> membres contrôlent des éléments qui peuvent être présents, mais ne sont pas requis pour être présents dans la chaîne d’entrée. Le tableau suivant indique comment chaque <xref:System.Globalization.NumberStyles> indicateurs affectent les éléments qui peuvent être présents dans `s`.  
  
|Valeur NumberStyles|Éléments autorisés dans `s` en plus des chiffres|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Le *chiffres intégraux* élément uniquement.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|La virgule décimale (*.*) et *chiffres fractionnaires* éléments.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Le « e » ou un caractère « E », ce qui indique la notation exponentielle. Cet indicateur en lui-même prend en charge les valeurs sous la forme *chiffres*E*chiffres*; autres indicateurs sont nécessaires pour analyser correctement les chaînes avec des éléments tels que les signes positifs ou négatifs et des symboles de séparateur décimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Le *ws* élément au début de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Le *ws* élément à la fin de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Le *connexion* élément au début de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Le *connexion* élément à la fin de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Le *connexion* élément sous la forme de parenthèses entourant la valeur numérique.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Les milliers élément séparateur (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Élément de devise ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Tous les éléments. Toutefois, `s` ne peut pas représenter un nombre hexadécimal ou un nombre en notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Float>|Le *ws* élément au début ou à la fin de `s`, *connexion* au début de `s`et le symbole de virgule décimale (.). Le `s` paramètre peut également utiliser la notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Number>|Le `ws`, `sign`, des milliers séparateur (,) et les éléments de la virgule décimale (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Tous les éléments. Toutefois, `s` ne peut pas représenter un nombre hexadécimal.|  
  
 Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation. Son <xref:System.IFormatProvider.GetFormat%2A> méthode retourne un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations spécifiques à la culture concernant le format de `value`. En règle générale, `provider` peut prendre l’une des opérations suivantes :  
  
-   Un <xref:System.Globalization.CultureInfo> objet qui représente la culture qui fournit des informations de mise en forme numériques. Son <xref:System.Globalization.CultureInfo.GetFormat%2A> méthode retourne le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme numériques.  
  
-   Un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme. (Son implémentation de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retourne simplement lui-même.)  
  
-   Un objet personnalisé qui implémente <xref:System.IFormatProvider> et utilise le <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> méthode pour instancier et retourner le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme.  
  
 Si `provider` est `null`, le <xref:System.Globalization.NumberFormatInfo> de l’objet pour la culture actuelle est utilisée.  
  
 Si un séparateur est rencontré dans le `s` paramètre pendant une opération d’analyse et la devise ou un nombre décimal et des séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur. Pour plus d’informations sur les séparateurs, consultez <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, et <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> méthode pour analyser les représentations sous forme de chaîne de <xref:System.Single> valeurs. Chaque chaîne dans un tableau est analysée à l’aide de conventions de format de l’en-US, nl-NL et une culture personnalisée. La culture personnalisée définit son symbole de séparateur de groupe en tant que le trait de soulignement (« _ ») et sa taille de groupe sous forme de deux.  
  
 [!code-csharp[System.Single.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse3.cs#4)]
 [!code-vb[System.Single.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> ne représente pas une valeur numérique.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> n’est pas une valeur <see cref="T:System.Globalization.NumberStyles" />.  
  
ou 
 <paramref name="style" /> est la valeur <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> représente un nombre qui est inférieur à <see cref="F:System.Single.MinValue" /> ou supérieur à <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analyse de chaînes numériques dans .NET</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const float PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PositiveInfinity = float32(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Single  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : single" Usage="System.single.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Représente l'infini positif. Ce champ est constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette constante est le résultat de la division d’un nombre positif par zéro.  
  
 Cette constante est retournée quand le résultat d’une opération est supérieur à <xref:System.Single.MaxValue>.  
  
 Utilisez <xref:System.Single.IsPositiveInfinity%2A> pour déterminer si une valeur correspond à l’infini positif.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Single.PositiveInfinity> constante.  
  
 [!code-cpp[System.Single#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#10)]
 [!code-csharp[System.Single#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#10)]
 [!code-vb[System.Single#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns><see langword="true" /> si la valeur de l'instance actuelle est différente de zéro ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Single> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Single> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Cette conversion n'est pas prise en charge. Toute tentative d'utilisation de cette méthode lève une <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Cette conversion n'est pas prise en charge. Aucune valeur n'est retournée.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Dans tous les cas.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Cette conversion n'est pas prise en charge. Toute tentative d'utilisation de cette méthode lève une <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Cette conversion n'est pas prise en charge. Aucune valeur n'est retournée.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Dans tous les cas.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Single> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.Double" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Single> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Single> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Single> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Single> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Single> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Single> est castée en interface <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Type dans lequel convertir cette valeur <see cref="T:System.Single" />.</param>
        <param name="provider">Objet qui fournit des informations sur le format de la valeur retournée.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Single> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le `static` (`Shared` en Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Single> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Single> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Valeur de l'instance actuelle, convertie en <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Single> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit la valeur numérique de cette instance en sa représentation équivalente sous forme de chaîne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="single.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convertit la valeur numérique de cette instance en sa représentation équivalente sous forme de chaîne.</summary>
        <returns>Représentation sous forme de chaîne de la valeur de cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Single.ToString> méthode formats un <xref:System.Single> valeur dans la valeur par défaut (« G » ou général), format de la culture actuelle. Si vous souhaitez spécifier un autre format ou la culture, utilisez les autres surcharges de la <xref:System.Single.ToString%2A> méthode, comme suit :  
  
|Pour utiliser le format|Pour la culture|Utilisez la surcharge|  
|-------------------|-----------------|----------------------|  
|Format par défaut (« G »)|Une culture spécifique|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Un format spécifique|Culture par défaut (actuelle)|<xref:System.Single.ToString%28System.String%29>|  
|Un format spécifique|Une culture spécifique|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 La valeur de retour peut être <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, ou une chaîne au format :  
  
 [signe] chiffres intégraux [. [chiffres fractionnaires]] [e [signe] chiffres exponentiels]  
  
 Éléments facultatifs sont encadrés par des crochets ([et]). Les éléments qui contiennent le terme « chiffres » se composent d’une série de caractères numériques comprises entre 0 et 9. Le tableau suivant répertorie chaque élément :  
  
|Élément|Description |  
|-------------|-----------------|  
|*sign*|Un signe négatif ou le symbole du signe positif.|  
|*integral-digits*|Une série de chiffres spécifiant la partie entière du nombre. Chiffres intégraux peuvent être absents s’il existe des chiffres fractionnaires.|  
|'.'|Un symbole décimal spécifique à la culture.|  
|*fractional-digits*|Une série de chiffres spécifiant la partie fractionnaire du nombre.|  
|'e'|Un caractère minuscule « e », indiquant la notation exponentielle (scientifique).|  
|*exponential-digits*|Une série de chiffres spécifiant un exposant.|  
  
 Sont des exemples de la valeur de retour « 100 », «-123 456 789 », « 123.45e + 6 », « 500 », « 3,1416 », « 600 », « -0,123 », et «-Infinity ».  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques de mise en forme suivantes :  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 L’exemple suivant utilise la valeur par défaut <xref:System.Single.ToString%2A?displayProperty=nameWithType> méthode pour afficher les représentations sous forme de chaîne d’un nombre de <xref:System.Single> valeurs.  
  
 [!code-csharp[System.Single.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#1)]
 [!code-vb[System.Single.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#1)]  
  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Single.Parse%28System.String%29> méthode avec le <xref:System.Single.ToString> (méthode).  
  
 [!code-cpp[System.Single#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#3)]
 [!code-csharp[System.Single#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#3)]
 [!code-vb[System.Single#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="single.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Convertit la valeur numérique de cette instance en sa représentation sous forme de chaîne équivalente à l'aide des informations de format spécifiques à la culture donnée.</summary>
        <returns>Représentation sous forme de chaîne de la valeur de cette instance, comme indiqué par <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Single.ToString%28System.IFormatProvider%29> méthode formats un <xref:System.Single> valeur de format d’une culture spécifiée dans la valeur par défaut (« G » ou général). Si vous souhaitez spécifier un autre format ou la culture actuelle, utilisez les autres surcharges de la <xref:System.Single.ToString%2A> méthode, comme suit :  
  
|Pour utiliser le format|Pour la culture|Utilisez la surcharge|  
|-------------------|-----------------|----------------------|  
|Format par défaut (« G »)|Culture par défaut (actuelle)|<xref:System.Single.ToString>|  
|Un format spécifique|Culture par défaut (actuelle)|<xref:System.Single.ToString%28System.String%29>|  
|Un format spécifique|Une culture spécifique|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 La valeur de retour peut être <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, ou une chaîne au format :  
  
 [signe] chiffres intégraux [. [chiffres fractionnaires]] [e [signe] chiffres exponentiels]  
  
 Éléments facultatifs sont encadrés par des crochets ([et]). Les éléments contenant le terme « chiffres » se composent d’une série de caractères numériques comprises entre 0 et 9. Le tableau suivant répertorie chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|sign|Un signe négatif ou le symbole du signe positif.|  
|chiffres intégraux|Une série de chiffres spécifiant la partie entière du nombre. Chiffres intégraux peuvent être absents s’il existe des chiffres fractionnaires.|  
|'.'|Un symbole décimal spécifique à la culture.|  
|fractional-digits|Une série de chiffres spécifiant la partie fractionnaire du nombre.|  
|'e'|Un caractère minuscule « e », indiquant la notation exponentielle (scientifique).|  
|chiffres exponentiels|Une série de chiffres spécifiant un exposant.|  
  
 Sont des exemples de la valeur de retour « 100 », «-123 456 789 », « 123.45e + 6 », « 500 », « 3,1416 », « 600 », « -0,123 », et «-Infinity ».  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques de mise en forme suivantes :  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
 Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation dont <xref:System.IFormatProvider.GetFormat%2A> méthode retourne un <xref:System.Globalization.NumberFormatInfo> objet. En règle générale, `provider` est un <xref:System.Globalization.CultureInfo> objet ou un <xref:System.Globalization.NumberFormatInfo> objet. Le `provider` paramètre fournit des informations spécifiques à la culture utilisées dans la mise en forme. Si `provider` est `null`, la valeur de retour est mise en forme à l’aide de la <xref:System.Globalization.NumberFormatInfo> données pour la culture actuelle.  
  
 Pour convertir un <xref:System.Single> valeur à sa représentation sous forme de chaîne à l’aide d’une culture spécifiée et une chaîne de format spécifique, appel le <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant affiche la représentation sous forme de chaîne de deux <xref:System.Single> des valeurs en utilisant <xref:System.Globalization.CultureInfo> objets qui représentent plusieurs cultures différentes.  
  
 [!code-csharp[System.Single.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#2)]
 [!code-vb[System.Single.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="single.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format numérique.</param>
        <summary>Convertit la valeur numérique de cette instance en sa représentation sous forme de chaîne équivalente en utilisant le format spécifié.</summary>
        <returns>Représentation sous forme de chaîne de la valeur de cette instance, comme indiqué par <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Single.ToString%28System.String%29> méthode formats un <xref:System.Single> valeur dans un format spécifié en utilisant les conventions de la culture actuelle. Si vous souhaitez utiliser la valeur par défaut (« G » ou général) mettre en forme ou spécifier une autre culture, utilisez les autres surcharges de la <xref:System.Single.ToString%2A> méthode, comme suit :  
  
|Pour utiliser le format|Pour la culture|Utilisez la surcharge|  
|-------------------|-----------------|----------------------|  
|Format par défaut (« G »)|Culture par défaut (actuelle)|<xref:System.Single.ToString>|  
|Format par défaut (« G »)|Une culture spécifique|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Un format spécifique|Une culture spécifique|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 La valeur de retour peut être <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, ou la représentation sous forme de chaîne de la valeur de l’instance actuelle, telle que spécifiée par `format`.  
  
 Le `format` paramètre peut être n’importe quel spécificateur de format numérique standard valide à l’exception de D et X, ainsi que n’importe quelle combinaison de spécificateurs de format numériques personnalisés. Si le format est `null` ou une chaîne vide, la valeur de retour est mis en forme avec le spécificateur de format numérique général (« G »).  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques de mise en forme suivantes :  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
 Par défaut, la valeur de retour contient seulement 7 chiffres de précision bien qu’un maximum de 9 chiffres soit maintenu en interne. Si la valeur de cette instance est supérieure à 7 chiffres, <xref:System.Single.ToString%28System.String%29> retourne <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> ou <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> au lieu du nombre attendu. Si vous avez besoin de plus de précision, spécifiez `format` avec la spécification de format « G9 », qui retourne toujours 9 chiffres de précision, ou « R », qui retourne 7 chiffres si le nombre peut être représenté avec cette précision ou 9 chiffres si le nombre ne peut être représenté. avec la précision maximale.  
  
   
  
## Examples  
 L’exemple suivant définit une valeur numérique et formats en tant que valeur monétaire en utilisant la chaîne de format numérique standard « C » et en tant que valeur numérique à trois décimales en utilisant la chaîne de format numérique standard « N ». Les chaînes de résultat sont mis en forme en utilisant les conventions de la culture en-US. Pour plus d’informations sur les chaînes de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Single.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString7.cs#7)]
 [!code-vb[System.Single.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString7.vb#7)]  
  
 L’exemple suivant affiche plusieurs <xref:System.Single> des valeurs en utilisant chacun des spécificateurs de format numérique standard pris en charge ainsi que deux chaînes de format numériques personnalisées. Une de ces chaînes de format personnalisées illustre comment remplir un <xref:System.Single> valeur avec des zéros non significatifs. Convertir les valeurs numériques en chaînes, l’exemple utilise les conventions de mise en forme de la culture en-US.  
  
 [!code-csharp[System.Single.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#3)]
 [!code-vb[System.Single.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> n'est pas valide.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Comment : remplir un nombre avec des zéros non significatifs</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="single.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format numérique.</param>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Convertit la valeur numérique de cette instance en sa représentation sous forme de chaîne équivalente à l'aide du format spécifié et des informations de format spécifiques à la culture.</summary>
        <returns>Représentation sous forme de chaîne de la valeur de cette instance, telle que spécifiée par <paramref name="format" /> et <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29> méthode formats un <xref:System.Single> valeur dans un format spécifié d’une culture spécifiée. Si vous souhaitez utiliser les paramètres de format ou de la culture par défaut, utilisez les autres surcharges de la <xref:System.Single.ToString%2A> méthode, comme suit :  
  
|Pour utiliser le format|Pour la culture|Utilisez la surcharge|  
|-------------------|-----------------|----------------------|  
|Format par défaut (« G »)|Culture par défaut (actuelle)|<xref:System.Single.ToString>|  
|Format par défaut (« G »)|Une culture spécifique|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Un format spécifique|Culture par défaut (actuelle)|<xref:System.Single.ToString%28System.String%29>|  
  
 La valeur de retour peut être <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, ou la représentation sous forme de chaîne de la valeur de l’instance actuelle, telle que spécifiée par `format`.  
  
 Le `format` paramètre peut être n’importe quel spécificateur de format numérique standard valide à l’exception de D et X, ainsi que n’importe quelle combinaison de spécificateurs de format numériques personnalisés. Si `format` est `null` ou une chaîne vide, la valeur de retour pour cette instance est formatée avec le spécificateur de format numérique général (« G »).  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques de mise en forme suivantes :  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
 Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation dont <xref:System.IFormatProvider.GetFormat%2A> méthode retourne un <xref:System.Globalization.NumberFormatInfo> objet. En règle générale, `provider` est un <xref:System.Globalization.CultureInfo> objet ou un <xref:System.Globalization.NumberFormatInfo> objet. Le `provider` paramètre fournit des informations spécifiques à la culture utilisées dans la mise en forme. Si `provider` est `null`, la valeur de retour est formatée avec le <xref:System.Globalization.NumberFormatInfo> objet pour la culture actuelle.  
  
 Par défaut, la valeur de retour contient seulement 7 chiffres de précision bien qu’un maximum de 9 chiffres soit maintenu en interne. Si la valeur de cette instance est supérieure à 7 chiffres, <xref:System.Single.ToString%2A> retourne <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> ou <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> au lieu du nombre attendu. Si vous avez besoin de plus de précision, spécifiez `format` avec la spécification de format « G9 », qui retourne toujours 9 chiffres de précision, ou « R », qui retourne 7 chiffres si le nombre peut être représenté avec cette précision ou 9 chiffres si le nombre ne peut être représenté. avec la précision maximale.  
  
   
  
## Examples  
 L’exemple suivant affiche un <xref:System.Single> valeur à l’aide de chacun des spécificateurs de format numérique standard pris en charge pour plusieurs cultures différentes.  
  
 [!code-csharp[System.Single.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#4)]
 [!code-vb[System.Single.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Comment : remplir un nombre avec des zéros non significatifs</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="single.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit la chaîne d'un nombre en nombre à virgule flottante simple précision équivalent. Une valeur de retour indique si la conversion a réussi ou a échoué.</summary>
        <altmember cref="Overload:System.Single.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne représentant un nombre à convertir.</param>
        <param name="result">Lorsque cette méthode est retournée, contient le nombre à virgule flottante simple précision équivalant à la valeur numérique ou au symbole contenu dans <paramref name="s" /> si la conversion a réussi, ou zéro si elle a échoué. La conversion échoue si le paramètre <paramref name="s" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />, n'est pas un nombre dans un format valide ou représente un nombre inférieur à <see cref="F:System.Single.MinValue" /> ou supérieur à <see cref="F:System.Single.MaxValue" />. Ce paramètre est passé non initialisé ; toute valeur fournie initialement dans <paramref name="result" /> sera remplacée.</param>
        <summary>Convertit la chaîne d'un nombre en nombre à virgule flottante simple précision équivalent. Une valeur de retour indique si la conversion a réussi ou a échoué.</summary>
        <returns><see langword="true" /> si la conversion de <paramref name="s" /> est réussie ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge diffère la <xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType> méthode en retournant une valeur booléenne qui indique si l’opération d’analyse a réussi au lieu de retourner la valeur numérique analysée. Il élimine la nécessité d’utiliser la gestion des exceptions pour tester un <xref:System.FormatException> dans le cas où `s` n’est pas valide et ne peut pas être analysée avec succès.  
  
 Le `s` paramètre peut contenir <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> (la comparaison de chaînes respecte la casse), ou une chaîne au format :  
  
 [ws] [connexion] [chiffres intégraux,] chiffres intégraux [. [chiffres fractionnaires]] [e [signe] chiffres exponentiels] [ws]  
  
 Les éléments entre crochets sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Une série de caractères d’espace blanc.|  
|*sign*|Un signe négatif ou le symbole du signe positif.|  
|*integral-digits*|Une série de caractères numériques comprises entre 0 et 9 qui spécifie la partie entière du nombre. Chiffres intégraux peuvent être absents s’il existe des chiffres fractionnaires.|  
|*,*|Un symbole de séparateur de groupe spécifique à la culture.|  
|*.*|Un symbole décimal spécifique à la culture.|  
|*fractional-digits*|Une série de caractères numériques comprises entre 0 et 9 qui spécifie la partie fractionnaire du nombre.|  
|*E*|Un majuscule ou minuscule caractère « e », qui indique la notation exponentielle (scientifique).|  
|*exponential-digits*|Une série de caractères numériques comprises entre 0 et 9 qui spécifie un exposant.|  
  
 Le `s` paramètre est interprété en utilisant une combinaison de la <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> et <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> indicateurs. Cela signifie que les espaces blancs et des milliers les séparateurs sont autorisés, mais les symboles monétaires ne sont pas. Pour définir explicitement les éléments (tels que les symboles monétaires, des milliers, séparateurs et l’espace blanc) qui peuvent être présents dans `s`, utiliser le <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> surcharge de méthode.  
  
 Le `s` paramètre est analysé en utilisant les informations de mise en forme dans un <xref:System.Globalization.NumberFormatInfo> objet initialisé pour la culture système actuelle. Pour plus d'informations, consultez <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Pour analyser une chaîne en utilisant les informations de mise en forme d’une autre culture spécifiée, utilisez la <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> surcharge de méthode.  
  
 En règle générale, si vous passez le <xref:System.Single.TryParse%2A?displayProperty=nameWithType> méthode une chaîne qui est créé en appelant le <xref:System.Single.ToString%2A?displayProperty=nameWithType> (méthode), la version d’origine <xref:System.Single> valeur est retournée. Toutefois, en raison d’une perte de précision, les valeurs peut-être pas égales.  
  
 Si un séparateur est rencontré dans le `s` paramètre pendant une opération d’analyse et la devise ou un nombre décimal et des séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur. Pour plus d’informations sur les séparateurs, consultez <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, et <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29> méthode pour convertir les représentations sous forme de chaîne de valeurs numériques à <xref:System.Single> valeurs. Il suppose qu’en-US est la culture actuelle.  
  
 [!code-csharp[System.Single.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Single.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analyse de chaînes numériques dans .NET</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne représentant un nombre à convertir.</param>
        <param name="style">Combinaison d'opérations de bits de valeurs d'énumération qui indique le format autorisé du paramètre <paramref name="s" />. Une valeur typique à spécifier est <see cref="F:System.Globalization.NumberStyles.Float" /> combinée avec <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture sur <paramref name="s" />.</param>
        <param name="result">Lorsque cette méthode est retournée, contient le nombre à virgule flottante simple précision équivalant à la valeur numérique ou au symbole contenu dans <paramref name="s" /> si la conversion a réussi, ou zéro si elle a échoué. La conversion échoue si le paramètre <paramref name="s" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />, n'est pas dans un format conforme à <paramref name="style" />, représente un nombre inférieur à <see cref="F:System.Single.MinValue" /> ou supérieur à <see cref="F:System.Single.MaxValue" />, ou encore si <paramref name="style" /> n'est pas une combinaison valide de constantes énumérées <see cref="T:System.Globalization.NumberStyles" />. Ce paramètre est passé non initialisé ; toute valeur fournie initialement dans <paramref name="result" /> sera remplacée.</param>
        <summary>Convertit la chaîne d'un nombre dans un style et un format propre à la culture spécifiés en nombre à virgule flottante simple précision équivalent. Une valeur de retour indique si la conversion a réussi ou a échoué.</summary>
        <returns><see langword="true" /> si la conversion de <paramref name="s" /> est réussie ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge diffère la <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> méthode en retournant une valeur booléenne qui indique si l’opération d’analyse a réussi au lieu de retourner la valeur numérique analysée. Il élimine la nécessité d’utiliser la gestion des exceptions pour tester un <xref:System.FormatException> dans le cas où `s` n’est pas valide et ne peut pas être analysée avec succès.  
  
 Le `style` paramètre définit le format autorisé de le `s` paramètre pour l’opération d’analyse. Il doit être une combinaison d’indicateurs de bits de le <xref:System.Globalization.NumberStyles> énumération. Ce qui suit <xref:System.Globalization.NumberStyles> membres ne sont pas pris en charge :  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 Le `s` paramètre peut contenir <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> pour la culture indiquée par `provider`. En outre, selon la valeur de `style`, le `s` paramètre peut inclure les éléments suivants :  
  
 [ws] [$] [connexion] [chiffres intégraux,] chiffres intégraux [.chiffres fractionnaires] [e [signe] chiffres exponentiels] [ws]  
  
 Les éléments entre crochets ([ et ]) sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Espace blanc facultatif. Espace blanc peut apparaître au début de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> indicateur. Elle peut apparaître à la fin de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> indicateur.|  
|*$*|Un symbole monétaire spécifique à la culture. Sa position dans la chaîne est définie par le <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> ou <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propriétés de la <xref:System.Globalization.NumberFormatInfo> objet retourné par la <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> méthode de le `provider` paramètre. Le symbole monétaire peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> indicateur.|  
|*sign*|Un signe facultatif. Le signe peut apparaître au début de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> indicateur et il peuvent apparaître à la fin de `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> indicateur. Parenthèses peuvent être utilisées dans `s` pour indiquer une valeur négative si `style` inclut le <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> indicateur.|  
|*integral-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie entière du nombre. Chiffres intégraux peuvent être absents s’il existe des chiffres fractionnaires.|  
|*,*|Des milliers spécifiques à la culture des symboles de séparateur. Plusieurs milliers de la culture actuelle symbole séparateur peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> indicateur.|  
|*.*|Un symbole décimal spécifique à la culture. Symbole de virgule décimale de la culture actuelle peut apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> indicateur.|  
|*fractional-digits*|Une série de chiffres allant de 0 à 9 qui spécifie la partie fractionnaire du nombre. Les chiffres fractionnaires peuvent apparaître dans `s` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> indicateur.|  
|*e*|Le caractère e ou E, qui indique que `s` peut représenter un nombre en notation exponentielle. Le `s` paramètre peut représenter un nombre en notation exponentielle si le style inclut le <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> indicateur.|  
|*exponential-digits*|Une série de chiffres allant de 0 à 9 qui spécifie un exposant.|  
  
> [!NOTE]
> Les caractères (U + 0000) NUL fin `s` sont ignorés par l’opération d’analyse, quelle que soit la valeur de la `style` argument.

 Une chaîne contenant uniquement des chiffres (qui correspond à la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) toujours analysée avec succès. Les autres <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> membres contrôlent des éléments qui peuvent être, mais ne doivent pas être présents dans la chaîne d’entrée. Le tableau suivant indique comment chaque <xref:System.Globalization.NumberStyles> indicateurs affectent les éléments qui peuvent être présents dans `s`.  
  
|Valeur NumberStyles|Éléments autorisés dans s en plus des chiffres|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Le *chiffres intégraux* élément uniquement.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|L’élément de langage *.* et *chiffres fractionnaires* éléments.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Le `s` paramètre peut également utiliser la notation exponentielle. Cet indicateur en lui-même prend en charge les valeurs sous la forme *chiffres intégraux*E*chiffres exponentiels*; autres indicateurs sont nécessaires pour analyser correctement les chaînes en notation exponentielle avec des éléments tels que signes positifs ou négatifs et des symboles de séparateur décimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Le *ws* élément au début de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Le *ws* élément à la fin de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Le *connexion* élément au début de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Le *connexion* élément à la fin de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Le *connexion* élément sous la forme de parenthèses entourant la valeur numérique.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Le *,* élément.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Le *$* élément.|  
|<xref:System.Globalization.NumberStyles.Currency>|Tout le monde. Le `s` paramètre ne peut pas représenter un nombre hexadécimal ou un nombre en notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Float>|Le *ws* élément au début ou à la fin de `s`, *connexion* au début de `s`et le *.* symbole. Le `s` paramètre peut également utiliser la notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Number>|Le `ws`, `sign`, des milliers séparateur (*,),* et séparateur décimal (*.*) éléments.|  
|<xref:System.Globalization.NumberStyles.Any>|Tous les styles, à l’exception `s` ne peut pas représenter un nombre hexadécimal.|  
  
 Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation dont <xref:System.IFormatProvider.GetFormat%2A> méthode retourne un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme propres à la culture. Lorsque le <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> méthode est appelée, elle appelle le `provider` du paramètre <xref:System.IFormatProvider.GetFormat%2A> (méthode) et le transmet un <xref:System.Type> objet qui représente le <xref:System.Globalization.NumberFormatInfo> type. Le <xref:System.IFormatProvider.GetFormat%2A> méthode renvoie alors le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations sur le format de le `s` paramètre. Il existe trois façons d’utiliser le `provider` paramètre pour fournir des informations de mise en forme personnalisées à l’opération d’analyse :  
  
-   Vous pouvez passer un <xref:System.Globalization.CultureInfo> objet qui représente la culture qui fournit des informations de mise en forme. Son <xref:System.Globalization.CultureInfo.GetFormat%2A> méthode retourne le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme numériques pour cette culture.  
  
-   Vous pouvez passer le texte réel <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme numériques. (Son implémentation de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retourne simplement lui-même.)  
  
-   Vous pouvez passer un objet personnalisé qui implémente <xref:System.IFormatProvider>. Son <xref:System.IFormatProvider.GetFormat%2A> méthode instancie et retourne le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme.  
  
 Si `provider` est `null`, la mise en forme de `s` est interprété selon le <xref:System.Globalization.NumberFormatInfo> objet de la culture actuelle.  
  
 Si un séparateur est rencontré dans le `s` paramètre pendant une opération d’analyse et la devise ou un nombre décimal et des séparateurs de groupes sont identiques, l’opération d’analyse suppose que le séparateur est un séparateur décimal plutôt qu’un groupe séparateur. Pour plus d’informations sur les séparateurs, consultez <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, et <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType> méthode pour analyser la représentation sous forme de chaîne de nombres qui ont un style particulier et sont formatés en utilisant les conventions d’une culture particulière.  
  
 [!code-csharp[System.Single.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#2)]
 [!code-vb[System.Single.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> n’est pas une valeur <see cref="T:System.Globalization.NumberStyles" />.  
  
ou 
 <paramref name="style" /> est la valeur <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analyse de chaînes numériques dans .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>