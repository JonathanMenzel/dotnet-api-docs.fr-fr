<Type Name="Math" FullName="System.Math">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c2a23b572b68e3d10d101512088abd060687a734" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39822306" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Math" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Math extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Math" />
  <TypeSignature Language="VB.NET" Value="Public Class Math" />
  <TypeSignature Language="C++ CLI" Value="public ref class Math abstract sealed" />
  <TypeSignature Language="F#" Value="type Math = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="45975-101">Fournit des constantes et des méthodes statiques pour des fonctions trigonométriques, logarithmiques et d'autres fonctions mathématiques courantes.</span>
      <span class="sxs-lookup">
        <span data-stu-id="45975-101">Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-102">L’exemple suivant utilise plusieurs fonctions mathématiques et trigonométriques à partir de la <xref:System.Math> classe pour calculer les angles internes d’un trapèze.</span><span class="sxs-lookup"><span data-stu-id="45975-102">The following example uses several mathematical and trigonometric functions from the <xref:System.Math> class to calculate the inner angles of a trapezoid.</span></span>  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Abs">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="45975-103">Retourne la valeur absolue d'un nombre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-103">Returns the absolute value of a specified number.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static decimal Abs (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Abs(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Abs(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member Abs : decimal -&gt; decimal" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-104">Nombre qui est supérieur ou égal à <see cref="F:System.Decimal.MinValue" />, mais inférieur ou égal à <see cref="F:System.Decimal.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-104">A number that is greater than or equal to <see cref="F:System.Decimal.MinValue" />, but less than or equal to <see cref="F:System.Decimal.MaxValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-105">Retourne la valeur absolue d'un nombre <see cref="T:System.Decimal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-105">Returns the absolute value of a <see cref="T:System.Decimal" /> number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-106">Nombre décimal x, tel que 0 ≤ x ≤<see cref="F:System.Decimal.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-106">A decimal number, x, such that 0 ≤ x ≤<see cref="F:System.Decimal.MaxValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-107">La valeur absolue d’un <xref:System.Decimal> est sa valeur numérique sans son signe.</span><span class="sxs-lookup"><span data-stu-id="45975-107">The absolute value of a <xref:System.Decimal> is its numeric value without its sign.</span></span> <span data-ttu-id="45975-108">Par exemple, la valeur absolue de 1.2 et -1.2 est 1.2.</span><span class="sxs-lookup"><span data-stu-id="45975-108">For example, the absolute value of both 1.2 and -1.2 is 1.2.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-109">L’exemple suivant utilise le <xref:System.Math.Abs%28System.Decimal%29> méthode pour obtenir la valeur absolue d’un nombre de <xref:System.Decimal> valeurs.</span><span class="sxs-lookup"><span data-stu-id="45975-109">The following example uses the <xref:System.Math.Abs%28System.Decimal%29> method to get the absolute value of a number of <xref:System.Decimal> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Math.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(double value);" />
      <MemberSignature Language="F#" Value="static member Abs : double -&gt; double" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-110">Nombre qui est supérieur ou égal à <see cref="F:System.Double.MinValue" />, mais inférieur ou égal à <see cref="F:System.Double.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-110">A number that is greater than or equal to <see cref="F:System.Double.MinValue" />, but less than or equal to <see cref="F:System.Double.MaxValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-111">Retourne la valeur absolue d'un nombre à virgule flottante double précision.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-111">Returns the absolute value of a double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-112">Nombre à virgule flottante double précision x, tel que 0 ≤ x ≤<see cref="F:System.Double.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-112">A double-precision floating-point number, x, such that 0 ≤ x ≤<see cref="F:System.Double.MaxValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-113">La valeur absolue d’un <xref:System.Double> est sa valeur numérique sans son signe.</span><span class="sxs-lookup"><span data-stu-id="45975-113">The absolute value of a <xref:System.Double> is its numeric value without its sign.</span></span> <span data-ttu-id="45975-114">Par exemple, la valeur absolue de 1.2e03 et - 1.2e03 est 1.2e03.</span><span class="sxs-lookup"><span data-stu-id="45975-114">For example, the absolute value of both 1.2e03 and -1.2e03 is 1.2e03.</span></span>  
  
 <span data-ttu-id="45975-115">Si `value` est égal à <xref:System.Double.NegativeInfinity> ou <xref:System.Double.PositiveInfinity>, la valeur de retour est <xref:System.Double.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="45975-115">If `value` is equal to <xref:System.Double.NegativeInfinity> or <xref:System.Double.PositiveInfinity>, the return value is <xref:System.Double.PositiveInfinity>.</span></span> <span data-ttu-id="45975-116">Si `value` est égal à <xref:System.Double.NaN>, la valeur de retour est <xref:System.Double.NaN>.</span><span class="sxs-lookup"><span data-stu-id="45975-116">If `value` is equal to <xref:System.Double.NaN>, the return value is <xref:System.Double.NaN>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-117">L’exemple suivant utilise le <xref:System.Math.Abs%28System.Double%29> méthode pour obtenir la valeur absolue d’un nombre de <xref:System.Double> valeurs.</span><span class="sxs-lookup"><span data-stu-id="45975-117">The following example uses the <xref:System.Math.Abs%28System.Double%29> method to get the absolute value of a number of <xref:System.Double> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs2.cs#2)]
 [!code-vb[System.Math.Abs#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static short Abs (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Abs(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Abs(short value);" />
      <MemberSignature Language="F#" Value="static member Abs : int16 -&gt; int16" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-118">Nombre qui est supérieur à <see cref="F:System.Int16.MinValue" />, mais inférieur ou égal à <see cref="F:System.Int16.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-118">A number that is greater than <see cref="F:System.Int16.MinValue" />, but less than or equal to <see cref="F:System.Int16.MaxValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-119">Retourne la valeur absolue d'un entier signé 16 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-119">Returns the absolute value of a 16-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-120">Entier signé 16 bits x, tel que 0 ≤ x ≤<see cref="F:System.Int16.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-120">A 16-bit signed integer, x, such that 0 ≤ x ≤<see cref="F:System.Int16.MaxValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-121">La valeur absolue d’un <xref:System.Int16> est sa valeur numérique sans son signe.</span><span class="sxs-lookup"><span data-stu-id="45975-121">The absolute value of an <xref:System.Int16> is its numeric value without its sign.</span></span> <span data-ttu-id="45975-122">Par exemple, la valeur absolue de 123 et -123 est 123.</span><span class="sxs-lookup"><span data-stu-id="45975-122">For example, the absolute value of both 123 and -123 is 123.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-123">L’exemple suivant utilise le <xref:System.Math.Abs%28System.Int16%29> méthode pour obtenir la valeur absolue d’un nombre de <xref:System.Int16> valeurs.</span><span class="sxs-lookup"><span data-stu-id="45975-123">The following example uses the <xref:System.Math.Abs%28System.Int16%29> method to get the absolute value of a number of <xref:System.Int16> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs3.cs#3)]
 [!code-vb[System.Math.Abs#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="45975-124">
            <paramref name="value" /> est égal à <see cref="F:System.Int16.MinValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-124">
              <paramref name="value" /> equals <see cref="F:System.Int16.MinValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static int Abs (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Abs(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Abs(int value);" />
      <MemberSignature Language="F#" Value="static member Abs : int -&gt; int" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-125">Nombre qui est supérieur à <see cref="F:System.Int32.MinValue" />, mais inférieur ou égal à <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-125">A number that is greater than <see cref="F:System.Int32.MinValue" />, but less than or equal to <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-126">Retourne la valeur absolue d'un entier signé 32 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-126">Returns the absolute value of a 32-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-127">Entier signé 32 bits x, tel que 0 ≤ x ≤<see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-127">A 32-bit signed integer, x, such that 0 ≤ x ≤<see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-128">La valeur absolue d’un <xref:System.Int32> est sa valeur numérique sans son signe.</span><span class="sxs-lookup"><span data-stu-id="45975-128">The absolute value of an <xref:System.Int32> is its numeric value without its sign.</span></span> <span data-ttu-id="45975-129">Par exemple, la valeur absolue de 123 et -123 est 123.</span><span class="sxs-lookup"><span data-stu-id="45975-129">For example, the absolute value of both 123 and -123 is 123.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-130">L’exemple suivant utilise le <xref:System.Math.Abs%28System.Int32%29> méthode pour obtenir la valeur absolue d’un nombre de <xref:System.Int32> valeurs.</span><span class="sxs-lookup"><span data-stu-id="45975-130">The following example uses the <xref:System.Math.Abs%28System.Int32%29> method to get the absolute value of a number of <xref:System.Int32> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs4.cs#4)]
 [!code-vb[System.Math.Abs#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="45975-131">
            <paramref name="value" /> est égal à <see cref="F:System.Int32.MinValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-131">
              <paramref name="value" /> equals <see cref="F:System.Int32.MinValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static long Abs (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Abs(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Abs(long value);" />
      <MemberSignature Language="F#" Value="static member Abs : int64 -&gt; int64" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-132">Nombre qui est supérieur à <see cref="F:System.Int64.MinValue" />, mais inférieur ou égal à <see cref="F:System.Int64.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-132">A number that is greater than <see cref="F:System.Int64.MinValue" />, but less than or equal to <see cref="F:System.Int64.MaxValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-133">Retourne la valeur absolue d'un entier signé 64 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-133">Returns the absolute value of a 64-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-134">Entier signé 64 bits x, tel que 0 ≤ x ≤<see cref="F:System.Int64.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-134">A 64-bit signed integer, x, such that 0 ≤ x ≤<see cref="F:System.Int64.MaxValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-135">La valeur absolue d’un <xref:System.Int64> est sa valeur numérique sans son signe.</span><span class="sxs-lookup"><span data-stu-id="45975-135">The absolute value of an <xref:System.Int64> is its numeric value without its sign.</span></span> <span data-ttu-id="45975-136">Par exemple, la valeur absolue de 123 et -123 est 123.</span><span class="sxs-lookup"><span data-stu-id="45975-136">For example, the absolute value of both 123 and -123 is 123.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-137">L’exemple suivant utilise le <xref:System.Math.Abs%28System.Int64%29> méthode pour obtenir la valeur absolue d’un nombre de <xref:System.Int64> valeurs.</span><span class="sxs-lookup"><span data-stu-id="45975-137">The following example uses the <xref:System.Math.Abs%28System.Int64%29> method to get the absolute value of a number of <xref:System.Int64> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs5.cs#5)]
 [!code-vb[System.Math.Abs#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="45975-138">
            <paramref name="value" /> est égal à <see cref="F:System.Int64.MinValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-138">
              <paramref name="value" /> equals <see cref="F:System.Int64.MinValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static sbyte Abs (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Abs(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Abs(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member Abs : sbyte -&gt; sbyte" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-139">Nombre qui est supérieur à <see cref="F:System.SByte.MinValue" />, mais inférieur ou égal à <see cref="F:System.SByte.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-139">A number that is greater than <see cref="F:System.SByte.MinValue" />, but less than or equal to <see cref="F:System.SByte.MaxValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-140">Retourne la valeur absolue d'un entier signé 8 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-140">Returns the absolute value of an 8-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-141">Entier signé 8 bits x, tel que 0 ≤ x ≤<see cref="F:System.SByte.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-141">An 8-bit signed integer, x, such that 0 ≤ x ≤<see cref="F:System.SByte.MaxValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-142">La valeur absolue d’un octet signé est sa valeur numérique sans son signe.</span><span class="sxs-lookup"><span data-stu-id="45975-142">The absolute value of a signed byte is its numeric value without its sign.</span></span> <span data-ttu-id="45975-143">Par exemple, la valeur absolue de 12 et -12 est 12.</span><span class="sxs-lookup"><span data-stu-id="45975-143">For example, the absolute value of both 12 and -12 is 12.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-144">L’exemple suivant utilise le <xref:System.Math.Abs%28System.SByte%29> méthode pour obtenir la valeur absolue d’un nombre de <xref:System.SByte> valeurs.</span><span class="sxs-lookup"><span data-stu-id="45975-144">The following example uses the <xref:System.Math.Abs%28System.SByte%29> method to get the absolute value of a number of <xref:System.SByte> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs6.cs#6)]
 [!code-vb[System.Math.Abs#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="45975-145">
            <paramref name="value" /> est égal à <see cref="F:System.SByte.MinValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-145">
              <paramref name="value" /> equals <see cref="F:System.SByte.MinValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static float Abs (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Abs(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Abs(float value);" />
      <MemberSignature Language="F#" Value="static member Abs : single -&gt; single" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-146">Nombre qui est supérieur ou égal à <see cref="F:System.Single.MinValue" />, mais inférieur ou égal à <see cref="F:System.Single.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-146">A number that is greater than or equal to <see cref="F:System.Single.MinValue" />, but less than or equal to <see cref="F:System.Single.MaxValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-147">Retourne la valeur absolue d'un nombre à virgule flottante simple précision.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-147">Returns the absolute value of a single-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-148">Nombre à virgule flottante simple précision x, tel que 0 ≤ x ≤<see cref="F:System.Single.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-148">A single-precision floating-point number, x, such that 0 ≤ x ≤<see cref="F:System.Single.MaxValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-149">La valeur absolue d’un <xref:System.Single> est sa valeur numérique sans son signe.</span><span class="sxs-lookup"><span data-stu-id="45975-149">The absolute value of a <xref:System.Single> is its numeric value without its sign.</span></span> <span data-ttu-id="45975-150">Par exemple, la valeur absolue de 1.2e-03 et - 1.2e03 est 1.2e03.</span><span class="sxs-lookup"><span data-stu-id="45975-150">For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.</span></span>  
  
 <span data-ttu-id="45975-151">Si `value` est égal à <xref:System.Single.NegativeInfinity> ou <xref:System.Single.PositiveInfinity>, la valeur de retour est <xref:System.Single.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="45975-151">If `value` is equal to <xref:System.Single.NegativeInfinity> or <xref:System.Single.PositiveInfinity>, the return value is <xref:System.Single.PositiveInfinity>.</span></span> <span data-ttu-id="45975-152">Si `value` est égal à <xref:System.Single.NaN>, la valeur de retour est <xref:System.Single.NaN>.</span><span class="sxs-lookup"><span data-stu-id="45975-152">If `value` is equal to <xref:System.Single.NaN>, the return value is <xref:System.Single.NaN>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-153">L’exemple suivant utilise le <xref:System.Math.Abs%28System.Single%29> méthode pour obtenir la valeur absolue d’un nombre de <xref:System.Single> valeurs.</span><span class="sxs-lookup"><span data-stu-id="45975-153">The following example uses the <xref:System.Math.Abs%28System.Single%29> method to get the absolute value of a number of <xref:System.Single> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs7.cs#7)]
 [!code-vb[System.Math.Abs#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static double Acos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Acos(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Acos(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Acos(double d);" />
      <MemberSignature Language="F#" Value="static member Acos : double -&gt; double" Usage="System.Math.Acos d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-154">Nombre représentant un cosinus, où <c>d</c> doit être supérieur ou égal à -1, mais inférieur ou égal à 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-154">A number representing a cosine, where <c>d</c> must be greater than or equal to -1, but less than or equal to 1.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-155">Retourne l'angle dont le cosinus est le nombre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-155">Returns the angle whose cosine is the specified number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-156">Angle θ mesuré en radians, tel que 0 ≤θ≤π</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-156">An angle, θ, measured in radians, such that 0 ≤θ≤π</span>
          </span>
          <span data-ttu-id="45975-157">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-157">-or-</span>
          </span>
          <span data-ttu-id="45975-158">
            <see cref="F:System.Double.NaN" /> si <paramref name="d" /> &lt; -1 ou <paramref name="d" /> &gt; 1 ou <paramref name="d" /> est égal à <see cref="F:System.Double.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-158">
              <see cref="F:System.Double.NaN" /> if <paramref name="d" /> &lt; -1 or <paramref name="d" /> &gt; 1 or <paramref name="d" /> equals <see cref="F:System.Double.NaN" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-159">Multipliez la valeur de retour par 180 /<xref:System.Math.PI?displayProperty=nameWithType> pour convertir des radians en degrés.</span><span class="sxs-lookup"><span data-stu-id="45975-159">Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-160">L’exemple suivant utilise la <xref:System.Math.Acos%2A> méthode pour calculer les angles internes d’un trapèze donné.</span><span class="sxs-lookup"><span data-stu-id="45975-160">The following example uses the <xref:System.Math.Acos%2A> method to assist in the computation of the inner angles of a given trapezoid.</span></span>  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh">
      <MemberSignature Language="C#" Value="public static double Acosh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Acosh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Acosh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acosh (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Acosh(double d);" />
      <MemberSignature Language="F#" Value="static member Acosh : double -&gt; double" Usage="System.Math.Acosh d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static double Asin (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Asin(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Asin(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Asin(double d);" />
      <MemberSignature Language="F#" Value="static member Asin : double -&gt; double" Usage="System.Math.Asin d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-161">Nombre représentant un sinus, où <c>d</c> doit être supérieur ou égal à -1, mais inférieur ou égal à 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-161">A number representing a sine, where <c>d</c> must be greater than or equal to -1, but less than or equal to 1.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-162">Retourne l'angle dont le sinus est le nombre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-162">Returns the angle whose sine is the specified number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-163">Angle θ mesuré en radians, tel que -π/2 ≤θ≤π/2</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-163">An angle, θ, measured in radians, such that -π/2 ≤θ≤π/2</span>
          </span>
          <span data-ttu-id="45975-164">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-164">-or-</span>
          </span>
          <span data-ttu-id="45975-165">
            <see cref="F:System.Double.NaN" /> si <paramref name="d" /> &lt; -1 ou <paramref name="d" /> &gt; 1 ou <paramref name="d" /> est égal à <see cref="F:System.Double.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-165">
              <see cref="F:System.Double.NaN" /> if <paramref name="d" /> &lt; -1 or <paramref name="d" /> &gt; 1 or <paramref name="d" /> equals <see cref="F:System.Double.NaN" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-166">Une valeur de retournée positive représente un angle dans le sens inverse à partir de l’axe des x ; une valeur de retournée négative représente un angle dans le sens horaire.</span><span class="sxs-lookup"><span data-stu-id="45975-166">A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.</span></span>  
  
 <span data-ttu-id="45975-167">Multipliez la valeur de retour par 180 /<xref:System.Math.PI?displayProperty=nameWithType> pour convertir des radians en degrés.</span><span class="sxs-lookup"><span data-stu-id="45975-167">Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-168">L’exemple suivant utilise <xref:System.Math.Asin%2A> pour calculer les angles internes d’un trapèze donné.</span><span class="sxs-lookup"><span data-stu-id="45975-168">The following example uses <xref:System.Math.Asin%2A> to assist in the computation of the inner angles of a given trapezoid.</span></span>  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh">
      <MemberSignature Language="C#" Value="public static double Asinh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Asinh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Asinh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asinh (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Asinh(double d);" />
      <MemberSignature Language="F#" Value="static member Asinh : double -&gt; double" Usage="System.Math.Asinh d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static double Atan (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atan(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atan(double d);" />
      <MemberSignature Language="F#" Value="static member Atan : double -&gt; double" Usage="System.Math.Atan d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-169">Nombre représentant une tangente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-169">A number representing a tangent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-170">Retourne l'angle dont la tangente est le nombre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-170">Returns the angle whose tangent is the specified number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-171">Angle θ mesuré en radians, tel que -π/2 ≤θ≤π/2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-171">An angle, θ, measured in radians, such that -π/2 ≤θ≤π/2.</span>
          </span>
          <span data-ttu-id="45975-172">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-172">-or-</span>
          </span>
          <span data-ttu-id="45975-173">
            <see cref="F:System.Double.NaN" /> si <paramref name="d" /> est égal à <see cref="F:System.Double.NaN" />, -π/2 arrondi à la double précision (-1,5707963267949) si <paramref name="d" /> est égal à <see cref="F:System.Double.NegativeInfinity" />, ou π/2 arrondi à la double précision (1,5707963267949) si <paramref name="d" /> est égal à <see cref="F:System.Double.PositiveInfinity" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-173">
              <see cref="F:System.Double.NaN" /> if <paramref name="d" /> equals <see cref="F:System.Double.NaN" />, -π/2 rounded to double precision (-1.5707963267949) if <paramref name="d" /> equals <see cref="F:System.Double.NegativeInfinity" />, or π/2 rounded to double precision (1.5707963267949) if <paramref name="d" /> equals <see cref="F:System.Double.PositiveInfinity" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-174">Une valeur de retournée positive représente un angle dans le sens inverse à partir de l’axe des x ; une valeur de retournée négative représente un angle dans le sens horaire.</span><span class="sxs-lookup"><span data-stu-id="45975-174">A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.</span></span>  
  
 <span data-ttu-id="45975-175">Multipliez la valeur de retour par 180 /<xref:System.Math.PI?displayProperty=nameWithType> pour convertir des radians en degrés.</span><span class="sxs-lookup"><span data-stu-id="45975-175">Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-176">L’exemple suivant montre comment calculer l’arc tangente d’une valeur et l’afficher dans la console.</span><span class="sxs-lookup"><span data-stu-id="45975-176">The following example demonstrates how to calculate the arctangent of a value and display it to the console.</span></span>  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2">
      <MemberSignature Language="C#" Value="public static double Atan2 (double y, double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan2(float64 y, float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atan2(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan2 (y As Double, x As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atan2(double y, double x);" />
      <MemberSignature Language="F#" Value="static member Atan2 : double * double -&gt; double" Usage="System.Math.Atan2 (y, x)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="y" Type="System.Double" />
        <Parameter Name="x" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="y">
          <span data-ttu-id="45975-177">Coordonnée y d'un point.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-177">The y coordinate of a point.</span>
          </span>
        </param>
        <param name="x">
          <span data-ttu-id="45975-178">Coordonnée x d'un point.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-178">The x coordinate of a point.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-179">Retourne l'angle dont la tangente est le quotient de deux nombres spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-179">Returns the angle whose tangent is the quotient of two specified numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-180">Angle θ mesuré en radians, tel que -π≤θ≤π, et tan(θ) = <paramref name="y" /> / <paramref name="x" />, où (<paramref name="x" />, <paramref name="y" />) est un point du plan cartésien.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-180">An angle, θ, measured in radians, such that -π≤θ≤π, and tan(θ) = <paramref name="y" /> / <paramref name="x" />, where (<paramref name="x" />, <paramref name="y" />) is a point in the Cartesian plane.</span>
          </span>
          <span data-ttu-id="45975-181">Observez ce qui suit :</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-181">Observe the following:</span>
          </span>
          <span data-ttu-id="45975-182">-   Pour (<paramref name="x" />, <paramref name="y" />) dans le quadrant 1, 0 &lt; θ &lt; π/2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-182">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 1, 0 &lt; θ &lt; π/2.</span>
          </span>
          <span data-ttu-id="45975-183">-   Pour (<paramref name="x" />, <paramref name="y" />) dans le quadrant 2, π/2 &lt; θ≤π.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-183">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 2, π/2 &lt; θ≤π.</span>
          </span>
          <span data-ttu-id="45975-184">-   Pour (<paramref name="x" />, <paramref name="y" />) dans le quadrant 3, -π &lt; θ &lt; -π/2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-184">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 3, -π &lt; θ &lt; -π/2.</span>
          </span>
          <span data-ttu-id="45975-185">-   Pour (<paramref name="x" />, <paramref name="y" />) dans le quadrant 4, -π/2 &lt; θ &lt; 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-185">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 4, -π/2 &lt; θ &lt; 0.</span>
          </span>
          <span data-ttu-id="45975-186">La valeur de retour des points situés aux limites des quadrants est la suivante :</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-186">For points on the boundaries of the quadrants, the return value is the following:</span>
          </span>
          <span data-ttu-id="45975-187">-   Si y est égal à 0 et si x n’est pas négatif, alors θ = 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-187">-   If y is 0 and x is not negative, θ = 0.</span>
          </span>
          <span data-ttu-id="45975-188">-   Si y est égal à 0 et si x est négatif, alors θ = π.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-188">-   If y is 0 and x is negative, θ = π.</span>
          </span>
          <span data-ttu-id="45975-189">-   Si y est positif et x est égal à 0, alors θ = π/2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-189">-   If y is positive and x is 0, θ = π/2.</span>
          </span>
          <span data-ttu-id="45975-190">-   Si y est négatif et si x est égal à 0, alors θ = -π/2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-190">-   If y is negative and x is 0, θ = -π/2.</span>
          </span>
          <span data-ttu-id="45975-191">-   Si y est égal à 0 et si x est égal à 0, alors θ = 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-191">-   If y is 0 and x is 0, θ = 0.</span>
          </span>
          <span data-ttu-id="45975-192">Si <paramref name="x" /> ou <paramref name="y" /> est <see cref="F:System.Double.NaN" />, ou si <paramref name="x" /> et <paramref name="y" /> sont <see cref="F:System.Double.PositiveInfinity" /> ou <see cref="F:System.Double.NegativeInfinity" />, la méthode retourne <see cref="F:System.Double.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-192">If <paramref name="x" /> or <paramref name="y" /> is <see cref="F:System.Double.NaN" />, or if <paramref name="x" /> and <paramref name="y" /> are either <see cref="F:System.Double.PositiveInfinity" /> or <see cref="F:System.Double.NegativeInfinity" />, the method returns <see cref="F:System.Double.NaN" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-193">La valeur de retour est l’angle dans le plan cartésien formé par l’axe des abscisses et un vecteur à partir de l’origine (0,0) et se terminant au point, (x, y).</span><span class="sxs-lookup"><span data-stu-id="45975-193">The return value is the angle in the Cartesian plane formed by the x-axis, and a vector starting from the origin, (0,0), and terminating at the point, (x,y).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-194">L’exemple suivant montre comment calculer l’arc tangente d’un angle et un vecteur.</span><span class="sxs-lookup"><span data-stu-id="45975-194">The following example demonstrates how to calculate the arctangent of an angle and a vector.</span></span> <span data-ttu-id="45975-195">La valeur résultante est affichée dans la console.</span><span class="sxs-lookup"><span data-stu-id="45975-195">The resulting value is displayed in the console.</span></span>  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh">
      <MemberSignature Language="C#" Value="public static double Atanh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atanh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atanh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atanh (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atanh(double d);" />
      <MemberSignature Language="F#" Value="static member Atanh : double -&gt; double" Usage="System.Math.Atanh d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BigMul">
      <MemberSignature Language="C#" Value="public static long BigMul (int a, int b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 BigMul(int32 a, int32 b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.BigMul(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BigMul (a As Integer, b As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long BigMul(int a, int b);" />
      <MemberSignature Language="F#" Value="static member BigMul : int * int -&gt; int64" Usage="System.Math.BigMul (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="45975-196">Premier nombre à multiplier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-196">The first number to multiply.</span>
          </span>
        </param>
        <param name="b">
          <span data-ttu-id="45975-197">Second nombre à multiplier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-197">The second number to multiply.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-198">Génère le produit intégral de deux nombres 32 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-198">Produces the full product of two 32-bit numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-199">Nombre contenant le produit des nombres spécifiés</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-199">The number containing the product of the specified numbers.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-200">L’exemple suivant illustre l’utilisation de la <xref:System.Math.BigMul%2A> méthode pour calculer le produit de deux valeurs entières.</span><span class="sxs-lookup"><span data-stu-id="45975-200">The following example demonstrates the use of the <xref:System.Math.BigMul%2A> method to calculate the product of two integer values.</span></span>  
  
 [!code-cpp[math.bigmul#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.bigmul/CPP/bigmul.cpp#1)]
 [!code-csharp[math.bigmul#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.bigmul/CS/bigmul.cs#1)]
 [!code-vb[math.bigmul#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.bigmul/VB/bigmul.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt">
      <MemberSignature Language="C#" Value="public static double Cbrt (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cbrt(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cbrt(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cbrt (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cbrt(double d);" />
      <MemberSignature Language="F#" Value="static member Cbrt : double -&gt; double" Usage="System.Math.Cbrt d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ceiling">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="45975-201">Retourne la valeur du plus petit entier supérieur ou égal au nombre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-201">Returns the smallest integral value greater than or equal to the specified number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-202">Le comportement de cette méthode suit la norme IEEE 754, section 4.</span><span class="sxs-lookup"><span data-stu-id="45975-202">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="45975-203">Ce type d’arrondi est parfois appelé arrondi vers l’infini positif.</span><span class="sxs-lookup"><span data-stu-id="45975-203">This kind of rounding is sometimes called rounding toward positive infinity.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static decimal Ceiling (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Ceiling(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Ceiling(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Ceiling(System::Decimal d);" />
      <MemberSignature Language="F#" Value="static member Ceiling : decimal -&gt; decimal" Usage="System.Math.Ceiling d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-204">Nombre décimal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-204">A decimal number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-205">Retourne la plus petite valeur intégrale supérieure ou égale au nombre décimal spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-205">Returns the smallest integral value that is greater than or equal to the specified decimal number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-206">Plus petite valeur intégrale qui est supérieure ou égale à <paramref name="d" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-206">The smallest integral value that is greater than or equal to <paramref name="d" />.</span>
          </span>
          <span data-ttu-id="45975-207">Notez que cette méthode retourne un objet <see cref="T:System.Decimal" /> plutôt qu'un type intégral.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-207">Note that this method returns a <see cref="T:System.Decimal" /> instead of an integral type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-208">Le comportement de cette méthode suit la norme IEEE 754, section 4.</span><span class="sxs-lookup"><span data-stu-id="45975-208">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="45975-209">Ce type d’arrondi est parfois appelé arrondi vers l’infini positif.</span><span class="sxs-lookup"><span data-stu-id="45975-209">This kind of rounding is sometimes called rounding toward positive infinity.</span></span> <span data-ttu-id="45975-210">En d’autres termes, si `d` est un nombre positif, la présence de toute partie décimale entraîne `d` doit être arrondie à l’entier le plus élevé.</span><span class="sxs-lookup"><span data-stu-id="45975-210">In other words, if `d` is positive, the presence of any fractional component causes `d` to be rounded to the next highest integer.</span></span> <span data-ttu-id="45975-211">Si `d` est négatif, l’opération d’arrondi provoque une partie décimale de `d` sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="45975-211">If `d` is negative, the rounding operation causes any fractional component of `d` to be discarded.</span></span> <span data-ttu-id="45975-212">Le fonctionnement de cette méthode diffère la <xref:System.Math.Floor%28System.Decimal%29> (méthode), qui prend en charge l’arrondi vers l’infini négatif.</span><span class="sxs-lookup"><span data-stu-id="45975-212">The operation of this method differs from the <xref:System.Math.Floor%28System.Decimal%29> method, which supports rounding toward negative infinity.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-213">L’exemple suivant illustre la <xref:System.Math.Ceiling%28System.Decimal%29?displayProperty=nameWithType> (méthode) et l’oppose avec le <xref:System.Math.Floor%28System.Decimal%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="45975-213">The following example illustrates the <xref:System.Math.Ceiling%28System.Decimal%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Floor%28System.Decimal%29> method.</span></span>  
  
 [!code-csharp[System.Math.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#1)]
 [!code-vb[System.Math.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static double Ceiling (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Ceiling(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Ceiling(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Ceiling(double a);" />
      <MemberSignature Language="F#" Value="static member Ceiling : double -&gt; double" Usage="System.Math.Ceiling a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="45975-214">Nombre à virgule flottante double précision.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-214">A double-precision floating-point number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-215">Retourne la plus petite valeur intégrale supérieure ou égale au nombre à virgule flottante double précision spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-215">Returns the smallest integral value that is greater than or equal to the specified double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-216">Plus petite valeur intégrale qui est supérieure ou égale à <paramref name="a" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-216">The smallest integral value that is greater than or equal to <paramref name="a" />.</span>
          </span>
          <span data-ttu-id="45975-217">Si <paramref name="a" /> est égal à <see cref="F:System.Double.NaN" />, à <see cref="F:System.Double.NegativeInfinity" /> ou à <see cref="F:System.Double.PositiveInfinity" />, cette valeur est retournée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-217">If <paramref name="a" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, that value is returned.</span>
          </span>
          <span data-ttu-id="45975-218">Notez que cette méthode retourne un objet <see cref="T:System.Double" /> plutôt qu'un type intégral.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-218">Note that this method returns a <see cref="T:System.Double" /> instead of an integral type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-219">Le comportement de cette méthode suit la norme IEEE 754, section 4.</span><span class="sxs-lookup"><span data-stu-id="45975-219">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="45975-220">Ce type d’arrondi est parfois appelé arrondi vers l’infini positif.</span><span class="sxs-lookup"><span data-stu-id="45975-220">This kind of rounding is sometimes called rounding toward positive infinity.</span></span> <span data-ttu-id="45975-221">En d’autres termes, si `a` est un nombre positif, la présence de toute partie décimale entraîne `a` doit être arrondie à l’entier le plus élevé.</span><span class="sxs-lookup"><span data-stu-id="45975-221">In other words, if `a` is positive, the presence of any fractional component causes `a` to be rounded to the next highest integer.</span></span> <span data-ttu-id="45975-222">Si `a` est négatif, l’opération d’arrondi provoque une partie décimale de `a` sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="45975-222">If `a` is negative, the rounding operation causes any fractional component of `a` to be discarded.</span></span> <span data-ttu-id="45975-223">Le fonctionnement de cette méthode diffère la <xref:System.Math.Floor%28System.Double%29> (méthode), qui prend en charge l’arrondi vers l’infini négatif.</span><span class="sxs-lookup"><span data-stu-id="45975-223">The operation of this method differs from the <xref:System.Math.Floor%28System.Double%29> method, which supports rounding toward negative infinity.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-224">L’exemple suivant illustre la <xref:System.Math.Ceiling%28System.Double%29?displayProperty=nameWithType> (méthode) et l’oppose avec le <xref:System.Math.Floor%28System.Double%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="45975-224">The following example illustrates the <xref:System.Math.Ceiling%28System.Double%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Floor%28System.Double%29> method.</span></span>  
  
 [!code-csharp[System.Math.Ceiling#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#2)]
 [!code-vb[System.Math.Ceiling#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static byte Clamp (byte value, byte min, byte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Clamp(unsigned int8 value, unsigned int8 min, unsigned int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Byte,System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Byte, min As Byte, max As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Clamp(System::Byte value, System::Byte min, System::Byte max);" />
      <MemberSignature Language="F#" Value="static member Clamp : byte * byte * byte -&gt; byte" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
        <Parameter Name="min" Type="System.Byte" />
        <Parameter Name="max" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static decimal Clamp (decimal value, decimal min, decimal max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Clamp(valuetype System.Decimal value, valuetype System.Decimal min, valuetype System.Decimal max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Decimal,System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Decimal, min As Decimal, max As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Clamp(System::Decimal value, System::Decimal min, System::Decimal max);" />
      <MemberSignature Language="F#" Value="static member Clamp : decimal * decimal * decimal -&gt; decimal" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
        <Parameter Name="min" Type="System.Decimal" />
        <Parameter Name="max" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static double Clamp (double value, double min, double max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Clamp(float64 value, float64 min, float64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Double, min As Double, max As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Clamp(double value, double min, double max);" />
      <MemberSignature Language="F#" Value="static member Clamp : double * double * double -&gt; double" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="min" Type="System.Double" />
        <Parameter Name="max" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static short Clamp (short value, short min, short max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Clamp(int16 value, int16 min, int16 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int16,System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Short, min As Short, max As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Clamp(short value, short min, short max);" />
      <MemberSignature Language="F#" Value="static member Clamp : int16 * int16 * int16 -&gt; int16" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
        <Parameter Name="min" Type="System.Int16" />
        <Parameter Name="max" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static int Clamp (int value, int min, int max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Clamp(int32 value, int32 min, int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Integer, min As Integer, max As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Clamp(int value, int min, int max);" />
      <MemberSignature Language="F#" Value="static member Clamp : int * int * int -&gt; int" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="min" Type="System.Int32" />
        <Parameter Name="max" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static long Clamp (long value, long min, long max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Clamp(int64 value, int64 min, int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Long, min As Long, max As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Clamp(long value, long min, long max);" />
      <MemberSignature Language="F#" Value="static member Clamp : int64 * int64 * int64 -&gt; int64" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="min" Type="System.Int64" />
        <Parameter Name="max" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static sbyte Clamp (sbyte value, sbyte min, sbyte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Clamp(int8 value, int8 min, int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.SByte,System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As SByte, min As SByte, max As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Clamp(System::SByte value, System::SByte min, System::SByte max);" />
      <MemberSignature Language="F#" Value="static member Clamp : sbyte * sbyte * sbyte -&gt; sbyte" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
        <Parameter Name="min" Type="System.SByte" />
        <Parameter Name="max" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static float Clamp (float value, float min, float max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Clamp(float32 value, float32 min, float32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Single, min As Single, max As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Clamp(float value, float min, float max);" />
      <MemberSignature Language="F#" Value="static member Clamp : single * single * single -&gt; single" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="min" Type="System.Single" />
        <Parameter Name="max" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static ushort Clamp (ushort value, ushort min, ushort max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Clamp(unsigned int16 value, unsigned int16 min, unsigned int16 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt16,System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UShort, min As UShort, max As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Clamp(System::UInt16 value, System::UInt16 min, System::UInt16 max);" />
      <MemberSignature Language="F#" Value="static member Clamp : uint16 * uint16 * uint16 -&gt; uint16" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
        <Parameter Name="min" Type="System.UInt16" />
        <Parameter Name="max" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static uint Clamp (uint value, uint min, uint max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Clamp(unsigned int32 value, unsigned int32 min, unsigned int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt32,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UInteger, min As UInteger, max As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Clamp(System::UInt32 value, System::UInt32 min, System::UInt32 max);" />
      <MemberSignature Language="F#" Value="static member Clamp : uint32 * uint32 * uint32 -&gt; uint32" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
        <Parameter Name="min" Type="System.UInt32" />
        <Parameter Name="max" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static ulong Clamp (ulong value, ulong min, ulong max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Clamp(unsigned int64 value, unsigned int64 min, unsigned int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt64,System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As ULong, min As ULong, max As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Clamp(System::UInt64 value, System::UInt64 min, System::UInt64 max);" />
      <MemberSignature Language="F#" Value="static member Clamp : uint64 * uint64 * uint64 -&gt; uint64" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
        <Parameter Name="min" Type="System.UInt64" />
        <Parameter Name="max" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static double Cos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cos(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cos(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cos(double d);" />
      <MemberSignature Language="F#" Value="static member Cos : double -&gt; double" Usage="System.Math.Cos d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-225">Angle, mesuré en radians.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-225">An angle, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-226">Retourne le cosinus de l'angle spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-226">Returns the cosine of the specified angle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-227">Cosinus de <paramref name="d" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-227">The cosine of <paramref name="d" />.</span>
          </span>
          <span data-ttu-id="45975-228">Si <paramref name="d" /> est égal à <see cref="F:System.Double.NaN" />, à <see cref="F:System.Double.NegativeInfinity" /> ou à <see cref="F:System.Double.PositiveInfinity" />, cette méthode retourne <see cref="F:System.Double.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-228">If <paramref name="d" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, this method returns <see cref="F:System.Double.NaN" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-229">L’angle, `d`, doit être en radians.</span><span class="sxs-lookup"><span data-stu-id="45975-229">The angle, `d`, must be in radians.</span></span> <span data-ttu-id="45975-230">Multiplier par <xref:System.Math.PI?displayProperty=nameWithType>/180 pour convertir des degrés en radians.</span><span class="sxs-lookup"><span data-stu-id="45975-230">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 <span data-ttu-id="45975-231">Les valeurs acceptables de `d` comprises entre -9223372036854775295 et 9223372036854775295 approximativement.</span><span class="sxs-lookup"><span data-stu-id="45975-231">Acceptable values of `d` range from approximately -9223372036854775295 to approximately 9223372036854775295.</span></span> <span data-ttu-id="45975-232">Pour les valeurs en dehors de cette plage, le <xref:System.Math.Cos%2A> méthode retourne `d` inchangé au lieu de lever une exception.</span><span class="sxs-lookup"><span data-stu-id="45975-232">For values outside this range, the <xref:System.Math.Cos%2A> method returns `d` unchanged rather than throwing an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-233">L’exemple suivant utilise <xref:System.Math.Cos%2A> pour évaluer certaines identités trigonométriques pour des angles sélectionnés.</span><span class="sxs-lookup"><span data-stu-id="45975-233">The following example uses <xref:System.Math.Cos%2A> to evaluate certain trigonometric identities for selected angles.</span></span>  
  
 [!code-cpp[System.Math.SinCos#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinCos/CPP/sincos.cpp#1)]
 [!code-csharp[System.Math.SinCos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs#1)]
 [!code-vb[System.Math.SinCos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinCos/VB/sincos.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static double Cosh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cosh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cosh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cosh(double value);" />
      <MemberSignature Language="F#" Value="static member Cosh : double -&gt; double" Usage="System.Math.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-234">Angle, mesuré en radians.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-234">An angle, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-235">Retourne le cosinus hyperbolique de l'angle spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-235">Returns the hyperbolic cosine of the specified angle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-236">Cosinus hyperbolique de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-236">The hyperbolic cosine of <paramref name="value" />.</span>
          </span>
          <span data-ttu-id="45975-237">Si <paramref name="value" /> est égal à <see cref="F:System.Double.NegativeInfinity" /> ou <see cref="F:System.Double.PositiveInfinity" />, <see cref="F:System.Double.PositiveInfinity" /> est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-237">If <paramref name="value" /> is equal to <see cref="F:System.Double.NegativeInfinity" /> or <see cref="F:System.Double.PositiveInfinity" />, <see cref="F:System.Double.PositiveInfinity" /> is returned.</span>
          </span>
          <span data-ttu-id="45975-238">Si <paramref name="value" /> est égal à <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-238">If <paramref name="value" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-239">L’angle, `value`, doit être en radians.</span><span class="sxs-lookup"><span data-stu-id="45975-239">The angle, `value`, must be in radians.</span></span> <span data-ttu-id="45975-240">Multiplier par <xref:System.Math.PI?displayProperty=nameWithType>/180 pour convertir des degrés en radians.</span><span class="sxs-lookup"><span data-stu-id="45975-240">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-241">L’exemple suivant utilise <xref:System.Math.Cosh%2A> pour évaluer certaines identités hyperboliques pour des valeurs sélectionnées.</span><span class="sxs-lookup"><span data-stu-id="45975-241">The following example uses <xref:System.Math.Cosh%2A> to evaluate certain hyperbolic identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.SinhCosh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinhCosh/CPP/sinhcosh.cpp#1)]
 [!code-csharp[System.Math.SinhCosh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinhCosh/CS/sinhcosh.cs#1)]
 [!code-vb[System.Math.SinhCosh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinhCosh/VB/sinhcosh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivRem">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="45975-242">Calcule le quotient de deux nombres et retourne également le reste dans un paramètre de sortie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-242">Calculates the quotient of two numbers and also returns the remainder in an output parameter.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static int DivRem (int a, int b, out int result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 DivRem(int32 a, int32 b, [out] int32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (a As Integer, b As Integer, ByRef result As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int DivRem(int a, int b, [Runtime::InteropServices::Out] int % result);" />
      <MemberSignature Language="F#" Value="static member DivRem : int * int *  -&gt; int" Usage="System.Math.DivRem (a, b, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int32" />
        <Parameter Name="result" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="45975-243">Dividende.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-243">The dividend.</span>
          </span>
        </param>
        <param name="b">
          <span data-ttu-id="45975-244">Diviseur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-244">The divisor.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="45975-245">Reste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-245">The remainder.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-246">Calcule le quotient de deux entiers signés 32 bits et retourne également le reste dans un paramètre de sortie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-246">Calculates the quotient of two 32-bit signed integers and also returns the remainder in an output parameter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-247">Quotient des nombres spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-247">The quotient of the specified numbers.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-248">Le reste est calculé à l’aide de l’opération de modulo.</span><span class="sxs-lookup"><span data-stu-id="45975-248">The remainder is calculated by using the modulus operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-249">L’exemple suivant montre le <xref:System.Math.DivRem%28System.Int32%2CSystem.Int32%2CSystem.Int32%40%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="45975-249">The following example demonstrates the <xref:System.Math.DivRem%28System.Int32%2CSystem.Int32%2CSystem.Int32%40%29> method.</span></span>  
  
 [!code-csharp[System.Math.DivRem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.divrem/cs/divrem1.cs#1)]
 [!code-vb[System.Math.DivRem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.divrem/vb/divrem1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <span data-ttu-id="45975-250">
            <paramref name="b" /> est égal à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-250">
              <paramref name="b" /> is zero.</span>
          </span>
        </exception>
        <altmember cref="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static long DivRem (long a, long b, out long result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 DivRem(int64 a, int64 b, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int64,System.Int64,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (a As Long, b As Long, ByRef result As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long DivRem(long a, long b, [Runtime::InteropServices::Out] long % result);" />
      <MemberSignature Language="F#" Value="static member DivRem : int64 * int64 *  -&gt; int64" Usage="System.Math.DivRem (a, b, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int64" />
        <Parameter Name="b" Type="System.Int64" />
        <Parameter Name="result" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="45975-251">Dividende.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-251">The dividend.</span>
          </span>
        </param>
        <param name="b">
          <span data-ttu-id="45975-252">Diviseur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-252">The divisor.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="45975-253">Reste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-253">The remainder.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-254">Calcule le quotient de deux entiers signés 64 bits et retourne également le reste dans un paramètre de sortie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-254">Calculates the quotient of two 64-bit signed integers and also returns the remainder in an output parameter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-255">Quotient des nombres spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-255">The quotient of the specified numbers.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-256">Le reste est calculé à l’aide de l’opération de modulo.</span><span class="sxs-lookup"><span data-stu-id="45975-256">The remainder is calculated by using the modulus operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-257">L’exemple suivant montre le <xref:System.Math.DivRem%28System.Int64%2CSystem.Int64%2CSystem.Int64%40%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="45975-257">The following example demonstrates the <xref:System.Math.DivRem%28System.Int64%2CSystem.Int64%2CSystem.Int64%40%29> method.</span></span>  
  
 [!code-csharp[System.Math.DivRem#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.divrem/cs/divrem2.cs#2)]
 [!code-vb[System.Math.DivRem#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.divrem/vb/divrem2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <span data-ttu-id="45975-258">
            <paramref name="b" /> est égal à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-258">
              <paramref name="b" /> is zero.</span>
          </span>
        </exception>
        <altmember cref="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="E">
      <MemberSignature Language="C#" Value="public const double E = 2.71828182845905;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 E = (2.71828182845905)" />
      <MemberSignature Language="DocId" Value="F:System.Math.E" />
      <MemberSignature Language="VB.NET" Value="Public Const E As Double  = 2.71828182845905" />
      <MemberSignature Language="C++ CLI" Value="public: double E = 2.71828182845905;" />
      <MemberSignature Language="F#" Value="val mutable E : double" Usage="System.Math.E" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>2.71828182845905</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="45975-259">Représente la base logarithmique naturelle spécifiée par la constante <see langword="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-259">Represents the natural logarithmic base, specified by the constant, <see langword="e" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-260">La valeur de ce champ est 2.7182818284590452354.</span><span class="sxs-lookup"><span data-stu-id="45975-260">The value of this field is 2.7182818284590452354.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-261">L’exemple suivant compare <xref:System.Math.E> avec la valeur calculée à partir d’une série de l’alimentation.</span><span class="sxs-lookup"><span data-stu-id="45975-261">The following example compares <xref:System.Math.E> with the value calculated from a power series.</span></span>  
  
 [!code-cpp[System.Math.E#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.E/CPP/efield.cpp#1)]
 [!code-csharp[System.Math.E#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.E/CS/efield.cs#1)]
 [!code-vb[System.Math.E#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.E/VB/efield.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static double Exp (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exp(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Exp(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exp(double d);" />
      <MemberSignature Language="F#" Value="static member Exp : double -&gt; double" Usage="System.Math.Exp d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-262">Nombre spécifiant une puissance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-262">A number specifying a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-263">Retourne <see langword="e" /> élevé à la puissance spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-263">Returns <see langword="e" /> raised to the specified power.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-264">Nombre <see langword="e" /> élevé à la puissance <paramref name="d" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-264">The number <see langword="e" /> raised to the power <paramref name="d" />.</span>
          </span>
          <span data-ttu-id="45975-265">Si <paramref name="d" /> est égal à <see cref="F:System.Double.NaN" /> ou <see cref="F:System.Double.PositiveInfinity" />, cette valeur est retournée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-265">If <paramref name="d" /> equals <see cref="F:System.Double.NaN" /> or <see cref="F:System.Double.PositiveInfinity" />, that value is returned.</span>
          </span>
          <span data-ttu-id="45975-266">Si <paramref name="d" /> est égal à <see cref="F:System.Double.NegativeInfinity" />, 0 est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-266">If <paramref name="d" /> equals <see cref="F:System.Double.NegativeInfinity" />, 0 is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-267">`e` est une constante mathématique dont la valeur est environ 2.71828.</span><span class="sxs-lookup"><span data-stu-id="45975-267">`e` is a mathematical constant whose value is approximately 2.71828.</span></span>  
  
 <span data-ttu-id="45975-268">Utilisez le <xref:System.Math.Pow%2A> méthode pour calculer les puissances des autres bases.</span><span class="sxs-lookup"><span data-stu-id="45975-268">Use the <xref:System.Math.Pow%2A> method to calculate powers of other bases.</span></span>  
  
 <span data-ttu-id="45975-269"><xref:System.Math.Exp%2A> est l’inverse de <xref:System.Math.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="45975-269"><xref:System.Math.Exp%2A> is the inverse of <xref:System.Math.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-270">L’exemple suivant utilise <xref:System.Math.Exp%2A> pour évaluer certaines identités exponentielles et logarithmiques pour des valeurs sélectionnées.</span><span class="sxs-lookup"><span data-stu-id="45975-270">The following example uses <xref:System.Math.Exp%2A> to evaluate certain exponential and logarithmic identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.Exp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Exp/CPP/exp.cpp#1)]
 [!code-csharp[System.Math.Exp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Exp/CS/exp.cs#1)]
 [!code-vb[System.Math.Exp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Exp/VB/exp.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Math.E" />
        <altmember cref="M:System.Math.Pow(System.Double,System.Double)" />
        <altmember cref="M:System.Math.Log(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Floor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="45975-271">Retourne la valeur du plus grand entier inférieur ou égal au nombre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-271">Returns the largest integral value less than or equal to the specified number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-272">Le comportement de cette méthode suit la norme IEEE 754, section 4.</span><span class="sxs-lookup"><span data-stu-id="45975-272">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="45975-273">Ce type d’arrondi est parfois appelé arrondi vers l’infini négatif.</span><span class="sxs-lookup"><span data-stu-id="45975-273">This kind of rounding is sometimes called rounding toward negative infinity.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static decimal Floor (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Floor(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Floor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Floor(System::Decimal d);" />
      <MemberSignature Language="F#" Value="static member Floor : decimal -&gt; decimal" Usage="System.Math.Floor d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-274">Nombre décimal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-274">A decimal number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-275">Retourne la valeur du plus grand entier inférieur ou égal au nombre décimal spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-275">Returns the largest integral value less than or equal to the specified decimal number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-276">Valeur du plus grand entier inférieur ou égal à <paramref name="d" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-276">The largest integral value less than or equal to <paramref name="d" />.</span>
          </span>
          <span data-ttu-id="45975-277">Notez que la méthode retourne une valeur intégrale de type <see cref="T:System.Decimal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-277">Note that the method returns an integral value of type <see cref="T:System.Decimal" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-278">Le comportement de cette méthode suit la norme IEEE 754, section 4.</span><span class="sxs-lookup"><span data-stu-id="45975-278">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="45975-279">Ce type d’arrondi est parfois appelé arrondi vers l’infini négatif.</span><span class="sxs-lookup"><span data-stu-id="45975-279">This kind of rounding is sometimes called rounding toward negative infinity.</span></span> <span data-ttu-id="45975-280">En d’autres termes, si `d` est positif, toute partie décimale est tronquée.</span><span class="sxs-lookup"><span data-stu-id="45975-280">In other words, if `d` is positive, any fractional component is truncated.</span></span> <span data-ttu-id="45975-281">Si `d` est négatif, la présence de n’importe quel composant fractionnaire entraîne un arrondi à l’entier inférieur.</span><span class="sxs-lookup"><span data-stu-id="45975-281">If `d` is negative, the presence of any fractional component causes it to be rounded to the smaller integer.</span></span> <span data-ttu-id="45975-282">Le fonctionnement de cette méthode diffère la <xref:System.Math.Ceiling%2A> (méthode), qui prend en charge l’arrondi vers l’infini positif.</span><span class="sxs-lookup"><span data-stu-id="45975-282">The operation of this method differs from the <xref:System.Math.Ceiling%2A> method, which supports rounding toward positive infinity.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-283">L’exemple suivant illustre la <xref:System.Math.Floor%28System.Decimal%29?displayProperty=nameWithType> (méthode) et l’oppose avec le <xref:System.Math.Ceiling%28System.Decimal%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="45975-283">The following example illustrates the <xref:System.Math.Floor%28System.Decimal%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Ceiling%28System.Decimal%29> method.</span></span>  
  
 [!code-csharp[System.Math.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#1)]
 [!code-vb[System.Math.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Decimal.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static double Floor (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Floor(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Floor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Floor(double d);" />
      <MemberSignature Language="F#" Value="static member Floor : double -&gt; double" Usage="System.Math.Floor d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-284">Nombre à virgule flottante double précision.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-284">A double-precision floating-point number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-285">Retourne la valeur du plus grand entier inférieur ou égal au nombre à virgule flottante double précision spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-285">Returns the largest integral value less than or equal to the specified double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-286">Valeur du plus grand entier inférieur ou égal à <paramref name="d" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-286">The largest integral value less than or equal to <paramref name="d" />.</span>
          </span>
          <span data-ttu-id="45975-287">Si <paramref name="d" /> est égal à <see cref="F:System.Double.NaN" />, à <see cref="F:System.Double.NegativeInfinity" /> ou à <see cref="F:System.Double.PositiveInfinity" />, cette valeur est retournée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-287">If <paramref name="d" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, that value is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-288">Le comportement de cette méthode suit la norme IEEE 754, section 4.</span><span class="sxs-lookup"><span data-stu-id="45975-288">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="45975-289">Ce type d’arrondi est parfois appelé arrondi vers l’infini négatif.</span><span class="sxs-lookup"><span data-stu-id="45975-289">This kind of rounding is sometimes called rounding toward negative infinity.</span></span> <span data-ttu-id="45975-290">En d’autres termes, si `d` est positif, toute partie décimale est tronquée.</span><span class="sxs-lookup"><span data-stu-id="45975-290">In other words, if `d` is positive, any fractional component is truncated.</span></span> <span data-ttu-id="45975-291">Si `d` est négatif, la présence de n’importe quel composant fractionnaire entraîne un arrondi à l’entier inférieur.</span><span class="sxs-lookup"><span data-stu-id="45975-291">If `d` is negative, the presence of any fractional component causes it to be rounded to the smaller integer.</span></span> <span data-ttu-id="45975-292">Le fonctionnement de cette méthode diffère la <xref:System.Math.Ceiling%2A> (méthode), qui prend en charge l’arrondi vers l’infini positif.</span><span class="sxs-lookup"><span data-stu-id="45975-292">The operation of this method differs from the <xref:System.Math.Ceiling%2A> method, which supports rounding toward positive infinity.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-293">L’exemple suivant illustre la <xref:System.Math.Floor%28System.Double%29?displayProperty=nameWithType> (méthode) et l’oppose avec le <xref:System.Math.Ceiling%28System.Double%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="45975-293">The following example illustrates the <xref:System.Math.Floor%28System.Double%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Ceiling%28System.Double%29> method.</span></span>  
  
 [!code-csharp[System.Math.Ceiling#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#2)]
 [!code-vb[System.Math.Ceiling#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="IEEERemainder">
      <MemberSignature Language="C#" Value="public static double IEEERemainder (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 IEEERemainder(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IEEERemainder (x As Double, y As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double IEEERemainder(double x, double y);" />
      <MemberSignature Language="F#" Value="static member IEEERemainder : double * double -&gt; double" Usage="System.Math.IEEERemainder (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">
          <span data-ttu-id="45975-294">Dividende.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-294">A dividend.</span>
          </span>
        </param>
        <param name="y">
          <span data-ttu-id="45975-295">Diviseur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-295">A divisor.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-296">Retourne le reste de la division d'un nombre spécifié par un autre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-296">Returns the remainder resulting from the division of a specified number by another specified number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-297">Nombre égal à <paramref name="x" /> - (<paramref name="y" /> Q), où Q est le quotient de <paramref name="x" /> / <paramref name="y" /> arrondi à l’entier le plus proche (si <paramref name="x" /> / <paramref name="y" /> se trouve à égale distance de deux entiers, l’entier pair est retourné).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-297">A number equal to <paramref name="x" /> - (<paramref name="y" /> Q), where Q is the quotient of <paramref name="x" /> / <paramref name="y" /> rounded to the nearest integer (if <paramref name="x" /> / <paramref name="y" /> falls halfway between two integers, the even integer is returned).</span>
          </span>
          <span data-ttu-id="45975-298">Si <paramref name="x" /> - (<paramref name="y" /> Q) est égal à zéro, la valeur retournée est +0 si <paramref name="x" /> est positif, ou -0 si <paramref name="x" /> est négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-298">If <paramref name="x" /> - (<paramref name="y" /> Q) is zero, the value +0 is returned if <paramref name="x" /> is positive, or -0 if <paramref name="x" /> is negative.</span>
          </span>
          <span data-ttu-id="45975-299">Si <paramref name="y" /> = 0, <see cref="F:System.Double.NaN" /> est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-299">If <paramref name="y" /> = 0, <see cref="F:System.Double.NaN" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-300">Cette opération est conforme à l’opération « remainder » défini dans la Section 5.1 de la norme ANSI/IEEE Std 754-1985 ; Norme IEEE pour l’arithmétique à virgule flottante binaire ; Institute of Electrical and Electronics Engineers, Inc. ; 1985.</span><span class="sxs-lookup"><span data-stu-id="45975-300">This operation complies with the remainder operation defined in Section 5.1 of ANSI/IEEE Std 754-1985; IEEE Standard for Binary Floating-Point Arithmetic; Institute of Electrical and Electronics Engineers, Inc; 1985.</span></span>  
  
 <span data-ttu-id="45975-301">Le <xref:System.Math.IEEERemainder%2A> méthode n’est pas le même que l’opérateur modulo.</span><span class="sxs-lookup"><span data-stu-id="45975-301">The <xref:System.Math.IEEERemainder%2A> method is not the same as the modulus operator.</span></span> <span data-ttu-id="45975-302">Bien que les deux retournent le reste après la division, les formules qu’ils utilisent sont différentes.</span><span class="sxs-lookup"><span data-stu-id="45975-302">Although both return the remainder after division, the formulas they use are different.</span></span> <span data-ttu-id="45975-303">La formule pour la <xref:System.Math.IEEERemainder%2A> méthode est :</span><span class="sxs-lookup"><span data-stu-id="45975-303">The formula for the <xref:System.Math.IEEERemainder%2A> method is:</span></span>  
  
```  
IEEERemainder = dividend - (divisor * Math.Round(dividend / divisor))  
```  
  
 <span data-ttu-id="45975-304">En revanche, la formule de l’opérateur modulo est :</span><span class="sxs-lookup"><span data-stu-id="45975-304">In contrast, the formula for the modulus operator is:</span></span>  
  
```  
Modulus = (Math.Abs(dividend) - (Math.Abs(divisor) *   
          (Math.Floor(Math.Abs(dividend) / Math.Abs(divisor))))) *   
          Math.Sign(dividend)  
```  
  
   
  
## Examples  
 <span data-ttu-id="45975-305">L’exemple suivant compare le reste retourné par la <xref:System.Math.IEEERemainder%2A> méthode avec le reste retourné par l’opérateur de division modulo.</span><span class="sxs-lookup"><span data-stu-id="45975-305">The following example contrasts the remainder returned by the <xref:System.Math.IEEERemainder%2A> method with the remainder returned by the modulus division operator.</span></span>  
  
 [!code-csharp[System.Math.IEEERemainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.ieeeremainder/cs/ieeeremainder1.cs#1)]
 [!code-vb[System.Math.IEEERemainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.ieeeremainder/vb/ieeeremainder1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="45975-306">Retourne le logarithme d'un nombre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-306">Returns the logarithm of a specified number.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(double d);" />
      <MemberSignature Language="F#" Value="static member Log : double -&gt; double" Usage="System.Math.Log d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-307">Nombre dont le logarithme doit être recherché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-307">The number whose logarithm is to be found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-308">Retourne le logarithme naturel (base <see langword="e" />) d'un nombre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-308">Returns the natural (base <see langword="e" />) logarithm of a specified number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-309">Une des valeurs du tableau suivant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-309">One of the values in the following table.</span>
          </span>
          <span data-ttu-id="45975-310">
            <list type="table">
              <listheader>
                <term>
                  <paramref name="d" /> paramètre  </term>
                <description> Valeur de retour  </description>
              </listheader>
              <item>
                <term> Positif  </term>
                <description> Logarithme népérien de <paramref name="d" /> ; à savoir, ln <paramref name="d" /> ou log e <paramref name="d" /></description>
              </item>
              <item>
                <term> Zéro  </term>
                <description>
                  <see cref="F:System.Double.NegativeInfinity" />
                </description>
              </item>
              <item>
                <term> Négatif  </term>
                <description>
                  <see cref="F:System.Double.NaN" />
                </description>
              </item>
              <item>
                <term> Égal à <see cref="F:System.Double.NaN" /></term>
                <description>
                  <see cref="F:System.Double.NaN" />
                </description>
              </item>
              <item>
                <term> Égal à <see cref="F:System.Double.PositiveInfinity" /></term>
                <description>
                  <see cref="F:System.Double.PositiveInfinity" />
                </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-310">
              <list type="table">
                <listheader>
                  <term>
                    <paramref name="d" /> parameter  </term>
                  <description> Return value  </description>
                </listheader>
                <item>
                  <term> Positive  </term>
                  <description> The natural logarithm of <paramref name="d" />; that is, ln <paramref name="d" />, or log e <paramref name="d" /></description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description>
                    <see cref="F:System.Double.NegativeInfinity" />
                  </description>
                </item>
                <item>
                  <term> Negative  </term>
                  <description>
                    <see cref="F:System.Double.NaN" />
                  </description>
                </item>
                <item>
                  <term> Equal to <see cref="F:System.Double.NaN" /></term>
                  <description>
                    <see cref="F:System.Double.NaN" />
                  </description>
                </item>
                <item>
                  <term> Equal to <see cref="F:System.Double.PositiveInfinity" /></term>
                  <description>
                    <see cref="F:System.Double.PositiveInfinity" />
                  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-311">Paramètre `d` est spécifié comme un nombre de base 10.</span><span class="sxs-lookup"><span data-stu-id="45975-311">Parameter `d` is specified as a base 10 number.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-312">L’exemple suivant illustre la <xref:System.Math.Log%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="45975-312">The following example illustrates the <xref:System.Math.Log%2A> method.</span></span>  
  
 [!code-csharp[System.Math.Log_Overloads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CS/log1.cs#2)]
 [!code-vb[System.Math.Log_Overloads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log_Overloads/VB/log1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Math.E" />
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double a, double newBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 a, float64 newBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (a As Double, newBase As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(double a, double newBase);" />
      <MemberSignature Language="F#" Value="static member Log : double * double -&gt; double" Usage="System.Math.Log (a, newBase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
        <Parameter Name="newBase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="45975-313">Nombre dont le logarithme doit être recherché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-313">The number whose logarithm is to be found.</span>
          </span>
        </param>
        <param name="newBase">
          <span data-ttu-id="45975-314">Base du logarithme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-314">The base of the logarithm.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-315">Retourne le logarithme d'un nombre spécifié dans une base spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-315">Returns the logarithm of a specified number in a specified base.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-316">Une des valeurs du tableau suivant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-316">One of the values in the following table.</span>
          </span>
          <span data-ttu-id="45975-317">(+Infini indique <see cref="F:System.Double.PositiveInfinity" />, -Infini indique <see cref="F:System.Double.NegativeInfinity" /> et NaN indique <see cref="F:System.Double.NaN" />.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-317">(+Infinity denotes <see cref="F:System.Double.PositiveInfinity" />, -Infinity denotes <see cref="F:System.Double.NegativeInfinity" />, and NaN denotes <see cref="F:System.Double.NaN" />.)</span>
          </span>
          <span data-ttu-id="45975-318">
            <list type="table">
              <listheader>
                <term>
                  <paramref name="a" />
                </term>
                <description>
                  <paramref name="newBase" />
                </description>
                <description> Valeur de retour  </description>
              </listheader>
              <item>
                <term>
                  <paramref name="a" />&gt; 0  </term>
                <description> (0 &lt;<paramref name="newBase" />&lt; 1) -ou-(<paramref name="newBase" />&gt; 1)  </description>
                <description> lognewBase(a)  </description>
              </item>
              <item>
                <term>
                  <paramref name="a" />&lt; 0  </term>
                <description> (n’importe quelle valeur)  </description>
                <description> NaN  </description>
              </item>
              <item>
                <term> (n’importe quelle valeur)  </term>
                <description>
                  <paramref name="newBase" />&lt; 0  </description>
                <description> NaN  </description>
              </item>
              <item>
                <term>
                  <paramref name="a" /> != 1  </term>
                <description>
                  <paramref name="newBase" /> = 0  </description>
                <description> NaN  </description>
              </item>
              <item>
                <term>
                  <paramref name="a" /> != 1  </term>
                <description>
                  <paramref name="newBase" /> = +Infini  </description>
                <description> NaN  </description>
              </item>
              <item>
                <term>
                  <paramref name="a" /> = NaN  </term>
                <description> (n’importe quelle valeur)  </description>
                <description> NaN  </description>
              </item>
              <item>
                <term> (n’importe quelle valeur)  </term>
                <description>
                  <paramref name="newBase" /> = NaN  </description>
                <description> NaN  </description>
              </item>
              <item>
                <term> (n’importe quelle valeur)  </term>
                <description>
                  <paramref name="newBase" /> = 1  </description>
                <description> NaN  </description>
              </item>
              <item>
                <term>
                  <paramref name="a" /> = 0  </term>
                <description> 0 &lt;<paramref name="newBase" />&lt; 1  </description>
                <description> +Infini  </description>
              </item>
              <item>
                <term>
                  <paramref name="a" /> = 0  </term>
                <description>
                  <paramref name="newBase" />&gt; 1  </description>
                <description> -Infini  </description>
              </item>
              <item>
                <term>
                  <paramref name="a" /> =  +Infini  </term>
                <description> 0 &lt;<paramref name="newBase" />&lt; 1  </description>
                <description> -Infini  </description>
              </item>
              <item>
                <term>
                  <paramref name="a" /> =  +Infini  </term>
                <description>
                  <paramref name="newBase" />&gt; 1  </description>
                <description> +Infini  </description>
              </item>
              <item>
                <term>
                  <paramref name="a" /> = 1  </term>
                <description>
                  <paramref name="newBase" /> = 0  </description>
                <description> 0  </description>
              </item>
              <item>
                <term>
                  <paramref name="a" /> = 1  </term>
                <description>
                  <paramref name="newBase" /> = +Infini  </description>
                <description> 0  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-318">
              <list type="table">
                <listheader>
                  <term>
                    <paramref name="a" />
                  </term>
                  <description>
                    <paramref name="newBase" />
                  </description>
                  <description> Return value  </description>
                </listheader>
                <item>
                  <term>
                    <paramref name="a" />&gt; 0  </term>
                  <description> (0 &lt;<paramref name="newBase" />&lt; 1) -or-(<paramref name="newBase" />&gt; 1)  </description>
                  <description> lognewBase(a)  </description>
                </item>
                <item>
                  <term>
                    <paramref name="a" />&lt; 0  </term>
                  <description> (any value)  </description>
                  <description> NaN  </description>
                </item>
                <item>
                  <term> (any value)  </term>
                  <description>
                    <paramref name="newBase" />&lt; 0  </description>
                  <description> NaN  </description>
                </item>
                <item>
                  <term>
                    <paramref name="a" /> != 1  </term>
                  <description>
                    <paramref name="newBase" /> = 0  </description>
                  <description> NaN  </description>
                </item>
                <item>
                  <term>
                    <paramref name="a" /> != 1  </term>
                  <description>
                    <paramref name="newBase" /> = +Infinity  </description>
                  <description> NaN  </description>
                </item>
                <item>
                  <term>
                    <paramref name="a" /> = NaN  </term>
                  <description> (any value)  </description>
                  <description> NaN  </description>
                </item>
                <item>
                  <term> (any value)  </term>
                  <description>
                    <paramref name="newBase" /> = NaN  </description>
                  <description> NaN  </description>
                </item>
                <item>
                  <term> (any value)  </term>
                  <description>
                    <paramref name="newBase" /> = 1  </description>
                  <description> NaN  </description>
                </item>
                <item>
                  <term>
                    <paramref name="a" /> = 0  </term>
                  <description> 0 &lt;<paramref name="newBase" />&lt; 1  </description>
                  <description> +Infinity  </description>
                </item>
                <item>
                  <term>
                    <paramref name="a" /> = 0  </term>
                  <description>
                    <paramref name="newBase" />&gt; 1  </description>
                  <description> -Infinity  </description>
                </item>
                <item>
                  <term>
                    <paramref name="a" /> =  +Infinity  </term>
                  <description> 0 &lt;<paramref name="newBase" />&lt; 1  </description>
                  <description> -Infinity  </description>
                </item>
                <item>
                  <term>
                    <paramref name="a" /> =  +Infinity  </term>
                  <description>
                    <paramref name="newBase" />&gt; 1  </description>
                  <description> +Infinity  </description>
                </item>
                <item>
                  <term>
                    <paramref name="a" /> = 1  </term>
                  <description>
                    <paramref name="newBase" /> = 0  </description>
                  <description> 0  </description>
                </item>
                <item>
                  <term>
                    <paramref name="a" /> = 1  </term>
                  <description>
                    <paramref name="newBase" /> = +Infinity  </description>
                  <description> 0  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-319">L’exemple suivant utilise <xref:System.Math.Log%2A> pour évaluer certaines identités logarithmiques pour les valeurs sélectionnées.</span><span class="sxs-lookup"><span data-stu-id="45975-319">The following example uses <xref:System.Math.Log%2A> to evaluate certain logarithmic identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.Log_Overloads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CPP/loggen.cpp#1)]
 [!code-csharp[System.Math.Log_Overloads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CS/loggen.cs#1)]
 [!code-vb[System.Math.Log_Overloads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log_Overloads/VB/loggen.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log10(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(double d);" />
      <MemberSignature Language="F#" Value="static member Log10 : double -&gt; double" Usage="System.Math.Log10 d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-320">Nombre dont le logarithme doit être recherché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-320">A number whose logarithm is to be found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-321">Retourne le logarithme de base 10 d'un nombre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-321">Returns the base 10 logarithm of a specified number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-322">Une des valeurs du tableau suivant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-322">One of the values in the following table.</span>
          </span>
          <span data-ttu-id="45975-323">
            <list type="table">
              <listheader>
                <term>
                  <paramref name="d" /> paramètre </term>
                <description> Valeur de retour </description>
              </listheader>
              <item>
                <term> Positif </term>
                <description> Logarithme en base 10 de <paramref name="d" /> ; à savoir, log 10<paramref name="d" />.  </description>
              </item>
              <item>
                <term> Zéro  </term>
                <description>
                  <see cref="F:System.Double.NegativeInfinity" />
                </description>
              </item>
              <item>
                <term> Négatif  </term>
                <description>
                  <see cref="F:System.Double.NaN" />
                </description>
              </item>
              <item>
                <term> Égal à <see cref="F:System.Double.NaN" /></term>
                <description>
                  <see cref="F:System.Double.NaN" />
                </description>
              </item>
              <item>
                <term> Égal à <see cref="F:System.Double.PositiveInfinity" /></term>
                <description>
                  <see cref="F:System.Double.PositiveInfinity" />
                </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-323">
              <list type="table">
                <listheader>
                  <term>
                    <paramref name="d" /> parameter  </term>
                  <description> Return value  </description>
                </listheader>
                <item>
                  <term> Positive  </term>
                  <description> The base 10 log of <paramref name="d" />; that is, log 10<paramref name="d" />.  </description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description>
                    <see cref="F:System.Double.NegativeInfinity" />
                  </description>
                </item>
                <item>
                  <term> Negative  </term>
                  <description>
                    <see cref="F:System.Double.NaN" />
                  </description>
                </item>
                <item>
                  <term> Equal to <see cref="F:System.Double.NaN" /></term>
                  <description>
                    <see cref="F:System.Double.NaN" />
                  </description>
                </item>
                <item>
                  <term> Equal to <see cref="F:System.Double.PositiveInfinity" /></term>
                  <description>
                    <see cref="F:System.Double.PositiveInfinity" />
                  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-324">Paramètre `d` est spécifié comme un nombre de base 10.</span><span class="sxs-lookup"><span data-stu-id="45975-324">Parameter `d` is specified as a base 10 number.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-325">L’exemple suivant utilise la <xref:System.Math.Log10%2A> méthode pour retourner le logarithme base 10 pour les valeurs sélectionnées.</span><span class="sxs-lookup"><span data-stu-id="45975-325">The following example uses the <xref:System.Math.Log10%2A> method to return the base 10 logarithm for selected values.</span></span>  
  
 [!code-csharp[System.Math.Log10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log10/CS/log10.cs#1)]
 [!code-vb[System.Math.Log10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log10/VB/log10.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Max">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="45975-326">Retourne le plus grand de deux nombres spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-326">Returns the larger of two specified numbers.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static byte Max (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Max(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Byte, val2 As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Max(System::Byte val1, System::Byte val2);" />
      <MemberSignature Language="F#" Value="static member Max : byte * byte -&gt; byte" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-327">Premier des deux entiers non signés 8 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-327">The first of two 8-bit unsigned integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-328">Second des deux entiers non signés 8 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-328">The second of two 8-bit unsigned integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-329">Retourne le plus grand de deux entiers non signés 8 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-329">Returns the larger of two 8-bit unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-330">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus grand).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-330">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-331">L’exemple suivant montre comment utiliser le <xref:System.Math.Max%2A> méthode pour retourner et afficher la plus grande de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-331">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Decimal, val2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Max(System::Decimal val1, System::Decimal val2);" />
      <MemberSignature Language="F#" Value="static member Max : decimal * decimal -&gt; decimal" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-332">Premier des deux nombres décimaux à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-332">The first of two decimal numbers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-333">Second des deux nombres décimaux à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-333">The second of two decimal numbers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-334">Retourne le plus grand de deux nombres décimaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-334">Returns the larger of two decimal numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-335">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus grand).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-335">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-336">L’exemple suivant montre comment utiliser le <xref:System.Math.Max%2A> méthode pour retourner et afficher la plus grande de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-336">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(float64 val1, float64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Double, val2 As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Max(double val1, double val2);" />
      <MemberSignature Language="F#" Value="static member Max : double * double -&gt; double" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-337">Premier des deux nombres à virgule flottante double précision à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-337">The first of two double-precision floating-point numbers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-338">Second des deux nombres à virgule flottante double précision à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-338">The second of two double-precision floating-point numbers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-339">Retourne le plus grand de deux nombres à virgule flottante double précision.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-339">Returns the larger of two double-precision floating-point numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-340">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus grand).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-340">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
          <span data-ttu-id="45975-341">Si <paramref name="val1" />, <paramref name="val2" /> ou <paramref name="val1" /> et <paramref name="val2" /> sont égaux à <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-341">If <paramref name="val1" />, <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-342">L’exemple suivant montre comment utiliser le <xref:System.Math.Max%2A> méthode pour retourner et afficher la plus grande de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-342">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static short Max (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Max(int16 val1, int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Short, val2 As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Max(short val1, short val2);" />
      <MemberSignature Language="F#" Value="static member Max : int16 * int16 -&gt; int16" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-343">Premier des deux entiers signés 16 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-343">The first of two 16-bit signed integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-344">Second des deux entiers signés 16 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-344">The second of two 16-bit signed integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-345">Retourne le plus grand de deux entiers signés 16 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-345">Returns the larger of two 16-bit signed integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-346">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus grand).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-346">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-347">L’exemple suivant montre comment utiliser le <xref:System.Math.Max%2A> méthode pour retourner et afficher la plus grande de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-347">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(int32 val1, int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Integer, val2 As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Max(int val1, int val2);" />
      <MemberSignature Language="F#" Value="static member Max : int * int -&gt; int" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-348">Premier des deux entiers signés 32 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-348">The first of two 32-bit signed integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-349">Second des deux entiers signés 32 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-349">The second of two 32-bit signed integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-350">Retourne le plus grand de deux entiers signés 32 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-350">Returns the larger of two 32-bit signed integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-351">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus grand).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-351">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-352">L’exemple suivant montre comment utiliser le <xref:System.Math.Max%2A> méthode pour retourner et afficher la plus grande de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-352">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(int64 val1, int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Long, val2 As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Max(long val1, long val2);" />
      <MemberSignature Language="F#" Value="static member Max : int64 * int64 -&gt; int64" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-353">Premier des deux entiers signés 64 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-353">The first of two 64-bit signed integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-354">Second des deux entiers signés 64 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-354">The second of two 64-bit signed integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-355">Retourne le plus grand de deux entiers signés 64 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-355">Returns the larger of two 64-bit signed integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-356">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus grand).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-356">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-357">L’exemple suivant montre comment utiliser le <xref:System.Math.Max%2A> méthode pour retourner et afficher la plus grande de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-357">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static sbyte Max (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Max(int8 val1, int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As SByte, val2 As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Max(System::SByte val1, System::SByte val2);" />
      <MemberSignature Language="F#" Value="static member Max : sbyte * sbyte -&gt; sbyte" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-358">Premier des deux entiers signés 8 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-358">The first of two 8-bit signed integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-359">Second des deux entiers signés 8 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-359">The second of two 8-bit signed integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-360">Retourne le plus grand de deux entiers signés 8 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-360">Returns the larger of two 8-bit signed integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-361">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus grand).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-361">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-362">L’exemple suivant montre comment utiliser le <xref:System.Math.Max%2A> méthode pour retourner et afficher la plus grande de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-362">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(float32 val1, float32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Single, val2 As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Max(float val1, float val2);" />
      <MemberSignature Language="F#" Value="static member Max : single * single -&gt; single" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-363">Premier des deux nombres à virgule flottante simple précision à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-363">The first of two single-precision floating-point numbers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-364">Second des deux nombres à virgule flottante simple précision à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-364">The second of two single-precision floating-point numbers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-365">Retourne le plus grand de deux nombres à virgule flottante simple précision.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-365">Returns the larger of two single-precision floating-point numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-366">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus grand).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-366">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
          <span data-ttu-id="45975-367">Si <paramref name="val1" /> ou <paramref name="val2" />, ou <paramref name="val1" /> et <paramref name="val2" /> sont égaux à <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-367">If <paramref name="val1" />, or <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-368">L’exemple suivant montre comment utiliser le <xref:System.Math.Max%2A> méthode pour retourner et afficher la plus grande de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-368">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ushort Max (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Max(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As UShort, val2 As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Max(System::UInt16 val1, System::UInt16 val2);" />
      <MemberSignature Language="F#" Value="static member Max : uint16 * uint16 -&gt; uint16" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-369">Premier des deux entiers non signés 16 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-369">The first of two 16-bit unsigned integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-370">Second des deux entiers non signés 16 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-370">The second of two 16-bit unsigned integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-371">Retourne le plus grand de deux entiers non signés 16 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-371">Returns the larger of two 16-bit unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-372">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus grand).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-372">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-373">L’exemple suivant montre comment utiliser le <xref:System.Math.Max%2A> méthode pour retourner et afficher la plus grande de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-373">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static uint Max (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Max(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As UInteger, val2 As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Max(System::UInt32 val1, System::UInt32 val2);" />
      <MemberSignature Language="F#" Value="static member Max : uint32 * uint32 -&gt; uint32" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-374">Premier des deux entiers non signés 32 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-374">The first of two 32-bit unsigned integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-375">Second des deux entiers non signés 32 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-375">The second of two 32-bit unsigned integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-376">Retourne le plus grand de deux entiers non signés 32 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-376">Returns the larger of two 32-bit unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-377">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus grand).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-377">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-378">L’exemple suivant montre comment utiliser le <xref:System.Math.Max%2A> méthode pour retourner et afficher la plus grande de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-378">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ulong Max (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Max(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As ULong, val2 As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Max(System::UInt64 val1, System::UInt64 val2);" />
      <MemberSignature Language="F#" Value="static member Max : uint64 * uint64 -&gt; uint64" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-379">Premier des deux entiers non signés 64 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-379">The first of two 64-bit unsigned integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-380">Second des deux entiers non signés 64 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-380">The second of two 64-bit unsigned integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-381">Retourne le plus grand de deux entiers non signés 64 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-381">Returns the larger of two 64-bit unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-382">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus grand).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-382">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-383">L’exemple suivant montre comment utiliser le <xref:System.Math.Max%2A> méthode pour retourner et afficher la plus grande de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-383">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Min">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="45975-384">Retourne le plus petit de deux nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-384">Returns the smaller of two numbers.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static byte Min (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Min(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Byte, val2 As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Min(System::Byte val1, System::Byte val2);" />
      <MemberSignature Language="F#" Value="static member Min : byte * byte -&gt; byte" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-385">Premier des deux entiers non signés 8 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-385">The first of two 8-bit unsigned integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-386">Second des deux entiers non signés 8 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-386">The second of two 8-bit unsigned integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-387">Retourne le plus petit de deux entiers non signés 8 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-387">Returns the smaller of two 8-bit unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-388">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus petit).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-388">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-389">L’exemple suivant montre comment utiliser le <xref:System.Math.Min%2A> méthode pour retourner et afficher la plus petite de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-389">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Decimal, val2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Min(System::Decimal val1, System::Decimal val2);" />
      <MemberSignature Language="F#" Value="static member Min : decimal * decimal -&gt; decimal" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-390">Premier des deux nombres décimaux à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-390">The first of two decimal numbers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-391">Second des deux nombres décimaux à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-391">The second of two decimal numbers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-392">Retourne le plus petit de deux nombres décimaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-392">Returns the smaller of two decimal numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-393">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus petit).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-393">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-394">L’exemple suivant montre comment utiliser le <xref:System.Math.Min%2A> méthode pour retourner et afficher la plus petite de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-394">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(float64 val1, float64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Double, val2 As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Min(double val1, double val2);" />
      <MemberSignature Language="F#" Value="static member Min : double * double -&gt; double" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-395">Premier des deux nombres à virgule flottante double précision à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-395">The first of two double-precision floating-point numbers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-396">Second des deux nombres à virgule flottante double précision à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-396">The second of two double-precision floating-point numbers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-397">Retourne le plus petit de deux nombres à virgule flottante double précision.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-397">Returns the smaller of two double-precision floating-point numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-398">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus petit).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-398">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
          <span data-ttu-id="45975-399">Si <paramref name="val1" />, <paramref name="val2" /> ou <paramref name="val1" /> et <paramref name="val2" /> sont égaux à <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-399">If <paramref name="val1" />, <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-400">L’exemple suivant montre comment utiliser le <xref:System.Math.Min%2A> méthode pour retourner et afficher la plus petite de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-400">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static short Min (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Min(int16 val1, int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Short, val2 As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Min(short val1, short val2);" />
      <MemberSignature Language="F#" Value="static member Min : int16 * int16 -&gt; int16" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-401">Premier des deux entiers signés 16 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-401">The first of two 16-bit signed integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-402">Second des deux entiers signés 16 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-402">The second of two 16-bit signed integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-403">Retourne le plus petit de deux entiers signés 16 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-403">Returns the smaller of two 16-bit signed integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-404">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus petit).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-404">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-405">L’exemple suivant montre comment utiliser le <xref:System.Math.Min%2A> méthode pour retourner et afficher la plus petite de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-405">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(int32 val1, int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Integer, val2 As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Min(int val1, int val2);" />
      <MemberSignature Language="F#" Value="static member Min : int * int -&gt; int" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-406">Premier des deux entiers signés 32 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-406">The first of two 32-bit signed integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-407">Second des deux entiers signés 32 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-407">The second of two 32-bit signed integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-408">Retourne le plus petit de deux entiers signés 32 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-408">Returns the smaller of two 32-bit signed integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-409">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus petit).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-409">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-410">L’exemple suivant montre comment utiliser le <xref:System.Math.Min%2A> méthode pour retourner et afficher la plus petite de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-410">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(int64 val1, int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Long, val2 As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Min(long val1, long val2);" />
      <MemberSignature Language="F#" Value="static member Min : int64 * int64 -&gt; int64" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-411">Premier des deux entiers signés 64 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-411">The first of two 64-bit signed integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-412">Second des deux entiers signés 64 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-412">The second of two 64-bit signed integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-413">Retourne le plus petit de deux entiers signés 64 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-413">Returns the smaller of two 64-bit signed integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-414">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus petit).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-414">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-415">L’exemple suivant montre comment utiliser le <xref:System.Math.Min%2A> méthode pour retourner et afficher la plus petite de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-415">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static sbyte Min (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Min(int8 val1, int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As SByte, val2 As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Min(System::SByte val1, System::SByte val2);" />
      <MemberSignature Language="F#" Value="static member Min : sbyte * sbyte -&gt; sbyte" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-416">Premier des deux entiers signés 8 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-416">The first of two 8-bit signed integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-417">Second des deux entiers signés 8 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-417">The second of two 8-bit signed integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-418">Retourne le plus petit de deux entiers signés 8 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-418">Returns the smaller of two 8-bit signed integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-419">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus petit).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-419">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-420">L’exemple suivant montre comment utiliser le <xref:System.Math.Min%2A> méthode pour retourner et afficher la plus petite de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-420">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(float32 val1, float32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Single, val2 As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Min(float val1, float val2);" />
      <MemberSignature Language="F#" Value="static member Min : single * single -&gt; single" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-421">Premier des deux nombres à virgule flottante simple précision à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-421">The first of two single-precision floating-point numbers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-422">Second des deux nombres à virgule flottante simple précision à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-422">The second of two single-precision floating-point numbers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-423">Retourne le plus petit de deux nombres à virgule flottante simple précision.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-423">Returns the smaller of two single-precision floating-point numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-424">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus petit).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-424">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
          <span data-ttu-id="45975-425">Si <paramref name="val1" />, <paramref name="val2" /> ou <paramref name="val1" /> et <paramref name="val2" /> sont égaux à <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-425">If <paramref name="val1" />, <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-426">L’exemple suivant montre comment utiliser le <xref:System.Math.Min%2A> méthode pour retourner et afficher la plus petite de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-426">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ushort Min (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Min(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As UShort, val2 As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Min(System::UInt16 val1, System::UInt16 val2);" />
      <MemberSignature Language="F#" Value="static member Min : uint16 * uint16 -&gt; uint16" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-427">Premier des deux entiers non signés 16 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-427">The first of two 16-bit unsigned integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-428">Second des deux entiers non signés 16 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-428">The second of two 16-bit unsigned integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-429">Retourne le plus petit de deux entiers non signés 16 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-429">Returns the smaller of two 16-bit unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-430">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus petit).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-430">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-431">L’exemple suivant montre comment utiliser le <xref:System.Math.Min%2A> méthode pour retourner et afficher la plus petite de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-431">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static uint Min (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Min(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As UInteger, val2 As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Min(System::UInt32 val1, System::UInt32 val2);" />
      <MemberSignature Language="F#" Value="static member Min : uint32 * uint32 -&gt; uint32" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-432">Premier des deux entiers non signés 32 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-432">The first of two 32-bit unsigned integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-433">Second des deux entiers non signés 32 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-433">The second of two 32-bit unsigned integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-434">Retourne le plus petit de deux entiers non signés 32 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-434">Returns the smaller of two 32-bit unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-435">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus petit).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-435">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-436">L’exemple suivant montre comment utiliser le <xref:System.Math.Min%2A> méthode pour retourner et afficher la plus petite de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-436">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ulong Min (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Min(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As ULong, val2 As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Min(System::UInt64 val1, System::UInt64 val2);" />
      <MemberSignature Language="F#" Value="static member Min : uint64 * uint64 -&gt; uint64" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="45975-437">Premier des deux entiers non signés 64 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-437">The first of two 64-bit unsigned integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="45975-438">Second des deux entiers non signés 64 bits à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-438">The second of two 64-bit unsigned integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-439">Retourne le plus petit de deux entiers non signés 64 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-439">Returns the smaller of two 64-bit unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-440">Paramètre <paramref name="val1" /> ou <paramref name="val2" /> (selon celui qui est le plus petit).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-440">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-441">L’exemple suivant montre comment utiliser le <xref:System.Math.Min%2A> méthode pour retourner et afficher la plus petite de deux variables.</span><span class="sxs-lookup"><span data-stu-id="45975-441">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PI">
      <MemberSignature Language="C#" Value="public const double PI = 3.14159265358979;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PI = (3.14159265358979)" />
      <MemberSignature Language="DocId" Value="F:System.Math.PI" />
      <MemberSignature Language="VB.NET" Value="Public Const PI As Double  = 3.14159265358979" />
      <MemberSignature Language="C++ CLI" Value="public: double PI = 3.14159265358979;" />
      <MemberSignature Language="F#" Value="val mutable PI : double" Usage="System.Math.PI" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>3.14159265358979</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="45975-442">Représente le rapport de la circonférence d’un cercle à son diamètre, spécifié par la constante π.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-442">Represents the ratio of the circumference of a circle to its diameter, specified by the constant, π.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-443">La valeur de ce champ est 3.14159265358979323846.</span><span class="sxs-lookup"><span data-stu-id="45975-443">The value of this field is 3.14159265358979323846.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-444">L’exemple suivant utilise <xref:System.Math.PI> pour calculer les angles internes d’un trapèze donné.</span><span class="sxs-lookup"><span data-stu-id="45975-444">The following example uses <xref:System.Math.PI> to assist in the computation of the inner angles of a given trapezoid.</span></span>  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static double Pow (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Pow(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Pow(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (x As Double, y As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Pow(double x, double y);" />
      <MemberSignature Language="F#" Value="static member Pow : double * double -&gt; double" Usage="System.Math.Pow (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">
          <span data-ttu-id="45975-445">Nombre à virgule flottante double précision à élever à une puissance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-445">A double-precision floating-point number to be raised to a power.</span>
          </span>
        </param>
        <param name="y">
          <span data-ttu-id="45975-446">Nombre à virgule flottante double précision. qui spécifie une puissance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-446">A double-precision floating-point number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-447">Retourne un nombre spécifié élevé à la puissance spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-447">Returns a specified number raised to the specified power.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-448">Nombre <paramref name="x" /> élevé à la puissance <paramref name="y" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-448">The number <paramref name="x" /> raised to the power <paramref name="y" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-449">Le tableau suivant indique la valeur de retour lorsque différentes valeurs ou plages de valeurs sont spécifiées pour le `x` et `y` paramètres.</span><span class="sxs-lookup"><span data-stu-id="45975-449">The following table indicates the return value when various values or ranges of values are specified for the `x` and `y` parameters.</span></span> <span data-ttu-id="45975-450">Pour plus d'informations, consultez <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> et <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45975-450">For more information, see <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="45975-451">Paramètres</span><span class="sxs-lookup"><span data-stu-id="45975-451">Parameters</span></span>|<span data-ttu-id="45975-452">Valeur de retour</span><span class="sxs-lookup"><span data-stu-id="45975-452">Return value</span></span>|  
|----------------|------------------|  
|<span data-ttu-id="45975-453">`x` ou `y`  =  `NaN`.</span><span class="sxs-lookup"><span data-stu-id="45975-453">`x` or `y` = `NaN`.</span></span>|`NaN`|  
|<span data-ttu-id="45975-454">`x` = Toute valeur sauf `NaN`; `y` = 0.</span><span class="sxs-lookup"><span data-stu-id="45975-454">`x` = Any value except `NaN`; `y` = 0.</span></span>|<span data-ttu-id="45975-455">1</span><span class="sxs-lookup"><span data-stu-id="45975-455">1</span></span>|  
|<span data-ttu-id="45975-456">`x` = `NegativeInfinity`; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="45975-456">`x` = `NegativeInfinity`; `y` < 0.</span></span>|<span data-ttu-id="45975-457">0</span><span class="sxs-lookup"><span data-stu-id="45975-457">0</span></span>|  
|<span data-ttu-id="45975-458">`x` = `NegativeInfinity`; `y` est un entier positif impair.</span><span class="sxs-lookup"><span data-stu-id="45975-458">`x` = `NegativeInfinity`; `y` is a positive odd integer.</span></span>|`NegativeInfinity`|  
|<span data-ttu-id="45975-459">`x` = `NegativeInfinity`; `y` est positif mais pas un entier impair.</span><span class="sxs-lookup"><span data-stu-id="45975-459">`x` = `NegativeInfinity`; `y` is positive but not an odd integer.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="45975-460">`x` < 0, mais pas `NegativeInfinity`; `y` n’est pas un entier, `NegativeInfinity`, ou `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="45975-460">`x` < 0 but not `NegativeInfinity`; `y` is not an integer, `NegativeInfinity`, or `PositiveInfinity`.</span></span>|`NaN`|  
|<span data-ttu-id="45975-461">`x` = -1 ; `y`  =  `NegativeInfinity` ou `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="45975-461">`x` = -1; `y` = `NegativeInfinity` or `PositiveInfinity`.</span></span>|`NaN`|  
|<span data-ttu-id="45975-462">-1 < `x` < 1 ; `y` = `NegativeInfinity`.</span><span class="sxs-lookup"><span data-stu-id="45975-462">-1 < `x` < 1; `y` = `NegativeInfinity`.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="45975-463">-1 < `x` < 1 ; `y` = `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="45975-463">-1 < `x` < 1; `y` = `PositiveInfinity`.</span></span>|<span data-ttu-id="45975-464">0</span><span class="sxs-lookup"><span data-stu-id="45975-464">0</span></span>|  
|<span data-ttu-id="45975-465">`x` < -1 ou `x` > 1 ; `y` = `NegativeInfinity`.</span><span class="sxs-lookup"><span data-stu-id="45975-465">`x` < -1 or `x` > 1; `y` = `NegativeInfinity`.</span></span>|<span data-ttu-id="45975-466">0</span><span class="sxs-lookup"><span data-stu-id="45975-466">0</span></span>|  
|<span data-ttu-id="45975-467">`x` < -1 ou `x` > 1 ; `y` = `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="45975-467">`x` < -1 or `x` > 1; `y` = `PositiveInfinity`.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="45975-468">`x` = 0; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="45975-468">`x` = 0; `y` < 0.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="45975-469">`x` = 0; `y` > 0.</span><span class="sxs-lookup"><span data-stu-id="45975-469">`x` = 0; `y` > 0.</span></span>|<span data-ttu-id="45975-470">0</span><span class="sxs-lookup"><span data-stu-id="45975-470">0</span></span>|  
|<span data-ttu-id="45975-471">`x` = 1 ; `y` est n’importe quelle valeur sauf `NaN`.</span><span class="sxs-lookup"><span data-stu-id="45975-471">`x` = 1; `y` is any value except `NaN`.</span></span>|<span data-ttu-id="45975-472">1</span><span class="sxs-lookup"><span data-stu-id="45975-472">1</span></span>|  
|<span data-ttu-id="45975-473">`x` = `PositiveInfinity`; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="45975-473">`x` = `PositiveInfinity`; `y` < 0.</span></span>|<span data-ttu-id="45975-474">0</span><span class="sxs-lookup"><span data-stu-id="45975-474">0</span></span>|  
|<span data-ttu-id="45975-475">`x` = `PositiveInfinity`; `y` > 0.</span><span class="sxs-lookup"><span data-stu-id="45975-475">`x` = `PositiveInfinity`; `y` > 0.</span></span>|`PositiveInfinity`|  
  
   
  
## Examples  
 <span data-ttu-id="45975-476">L’exemple suivant utilise la <xref:System.Math.Pow%2A> méthode pour calculer la valeur qui résulte de déclenchement de 2 à une puissance allant de 0 à 32.</span><span class="sxs-lookup"><span data-stu-id="45975-476">The following example uses the <xref:System.Math.Pow%2A> method to calculate the value that results from raising 2 to a power ranging from 0 to 32.</span></span>  
  
 [!code-csharp[System.Math.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.pow/cs/pow1.cs#1)]
 [!code-vb[System.Math.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sqrt(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Round">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="45975-477">Arrondit une valeur à l'entier le plus proche ou au nombre spécifié de chiffres fractionnaires.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-477">Rounds a value to the nearest integer or to the specified number of fractional digits.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-478">Dans cette section :</span><span class="sxs-lookup"><span data-stu-id="45975-478">In this section:</span></span>  
  
 <span data-ttu-id="45975-479">[Syntaxe de méthode surchargée](#Syntax) </span><span class="sxs-lookup"><span data-stu-id="45975-479">[Overloaded method syntax](#Syntax) </span></span>  
 <span data-ttu-id="45975-480">[Paramètres](#Params) </span><span class="sxs-lookup"><span data-stu-id="45975-480">[Parameters](#Params) </span></span>  
 <span data-ttu-id="45975-481">[Valeur de retour](#Returns) </span><span class="sxs-lookup"><span data-stu-id="45975-481">[Return value](#Returns) </span></span>  
 <span data-ttu-id="45975-482">[Exceptions](#Exceptions) </span><span class="sxs-lookup"><span data-stu-id="45975-482">[Exceptions](#Exceptions) </span></span>  
 <span data-ttu-id="45975-483">[Quelle méthode appeler ?](#Tasks) </span><span class="sxs-lookup"><span data-stu-id="45975-483">[Which method do I call?](#Tasks) </span></span>  
 <span data-ttu-id="45975-484">[Valeurs du milieu et les conventions d’arrondi](#Midpoint) </span><span class="sxs-lookup"><span data-stu-id="45975-484">[Midpoint values and rounding conventions](#Midpoint) </span></span>  
 <span data-ttu-id="45975-485">[Arrondi et la précision](#Precision) </span><span class="sxs-lookup"><span data-stu-id="45975-485">[Rounding and precision](#Precision) </span></span>  
 <span data-ttu-id="45975-486">[Arrondi et simple précision des valeurs à virgule flottante](#Single) </span><span class="sxs-lookup"><span data-stu-id="45975-486">[Rounding and single-precision floating-point values](#Single) </span></span>  
 <span data-ttu-id="45975-487">Exemples :</span><span class="sxs-lookup"><span data-stu-id="45975-487">Examples:</span></span>   
 [<span data-ttu-id="45975-488">Math.Round(Decimal)</span><span class="sxs-lookup"><span data-stu-id="45975-488">Math.Round(Decimal)</span></span>](#Round1_Example)  
 [<span data-ttu-id="45975-489">Math.Round(Double)</span><span class="sxs-lookup"><span data-stu-id="45975-489">Math.Round(Double)</span></span>](#Round2_Example)  
 [<span data-ttu-id="45975-490">Math.Round (décimale, Int32)</span><span class="sxs-lookup"><span data-stu-id="45975-490">Math.Round(Decimal, Int32)</span></span>](#Round3_Example)  
 [<span data-ttu-id="45975-491">Math.Round (décimale, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="45975-491">Math.Round(Decimal, MidpointRounding)</span></span>](#Round4_Example)  
 [<span data-ttu-id="45975-492">Math.Round (Double, Int32)</span><span class="sxs-lookup"><span data-stu-id="45975-492">Math.Round(Double, Int32)</span></span>](#Round5_Example)  
 [<span data-ttu-id="45975-493">Math.Round (Double, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="45975-493">Math.Round(Double, MidpointRounding)</span></span>](#Round6_Example)  
 [<span data-ttu-id="45975-494">Math.Round (Int32, Decimal MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="45975-494">Math.Round(Decimal, Int32, MidpointRounding)</span></span>](#Round7_Example)  
 [<span data-ttu-id="45975-495">Math.Round (Double, Int32, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="45975-495">Math.Round(Double, Int32, MidpointRounding)</span></span>](#Round8_Example)  
[<span data-ttu-id="45975-496">Informations de version</span><span class="sxs-lookup"><span data-stu-id="45975-496">Version information</span></span>](#Round_Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-method-syntax"></a><span data-ttu-id="45975-497">Syntaxe de méthode surchargée</span><span class="sxs-lookup"><span data-stu-id="45975-497">Overloaded method syntax</span></span>  
 <span data-ttu-id="45975-498">Pour plus d’informations sur le choix d’une surcharge, consultez [quelle méthode appeler ?](#Tasks)</span><span class="sxs-lookup"><span data-stu-id="45975-498">For additional guidance on choosing an overload, see [Which method do I call?](#Tasks)</span></span>  
  
 <span data-ttu-id="45975-499">`Decimal Math.Round(Decimal` `d` `)`</span><span class="sxs-lookup"><span data-stu-id="45975-499">`Decimal Math.Round(Decimal` `d` `)`</span></span>  
 <span data-ttu-id="45975-500">Arrondit une valeur décimale à l’entier le plus proche et arrondit les valeurs du milieu au nombre pair le plus proche ([exemple](#Round1_Example)).</span><span class="sxs-lookup"><span data-stu-id="45975-500">Rounds a decimal value to the nearest integer, and rounds midpoint values to the nearest even number ([example](#Round1_Example)).</span></span>  
  
 <span data-ttu-id="45975-501">`Double Math.Round(Double` `a` `)`</span><span class="sxs-lookup"><span data-stu-id="45975-501">`Double Math.Round(Double` `a` `)`</span></span>  
 <span data-ttu-id="45975-502">Arrondit une valeur à virgule flottante double précision à l’entier le plus proche et arrondit les valeurs du milieu au nombre pair le plus proche ([exemple](#Round2_Example)).</span><span class="sxs-lookup"><span data-stu-id="45975-502">Rounds a double-precision floating-point value to the nearest integer, and rounds midpoint values to the nearest even number ([example](#Round2_Example)).</span></span>  
  
 <span data-ttu-id="45975-503">`Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `)`</span><span class="sxs-lookup"><span data-stu-id="45975-503">`Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `)`</span></span>  
 <span data-ttu-id="45975-504">Arrondit une valeur décimale à un nombre spécifié de chiffres fractionnaires et arrondit les valeurs du milieu au nombre pair le plus proche ([exemple](#Round3_Example)).</span><span class="sxs-lookup"><span data-stu-id="45975-504">Rounds a decimal value to a specified number of fractional digits, and rounds midpoint values to the nearest even number ([example](#Round3_Example)).</span></span>  
  
 <span data-ttu-id="45975-505">`Double Math.Round(Double` `value` `, Int32`  `digits` `)`</span><span class="sxs-lookup"><span data-stu-id="45975-505">`Double Math.Round(Double` `value` `, Int32`  `digits` `)`</span></span>  
 <span data-ttu-id="45975-506">Arrondit une valeur à virgule flottante double précision à un nombre spécifié de chiffres fractionnaires et arrondit les valeurs du milieu au nombre pair le plus proche ([exemple](#Round4_Example)).</span><span class="sxs-lookup"><span data-stu-id="45975-506">Rounds a double-precision floating-point value to a specified number of fractional digits, and rounds midpoint values to the nearest even number ([example](#Round4_Example)).</span></span>  
  
 <span data-ttu-id="45975-507">`Decimal Math.Round(Decimal` `d` `, MidpointRounding`  `mode` `)`</span><span class="sxs-lookup"><span data-stu-id="45975-507">`Decimal Math.Round(Decimal` `d` `, MidpointRounding`  `mode` `)`</span></span>  
 <span data-ttu-id="45975-508">Arrondit une valeur décimale à l’entier le plus proche et utilise la convention d’arrondi spécifiée pour les valeurs du milieu ([exemple](#Round5_Example)).</span><span class="sxs-lookup"><span data-stu-id="45975-508">Rounds a decimal value to the nearest integer, and uses the specified rounding convention for midpoint values ([example](#Round5_Example)).</span></span>  
  
 <span data-ttu-id="45975-509">`Double Math.Round(Double` `value` `, MidpointRounding`  `mode` `)`</span><span class="sxs-lookup"><span data-stu-id="45975-509">`Double Math.Round(Double` `value` `, MidpointRounding`  `mode` `)`</span></span>  
 <span data-ttu-id="45975-510">Arrondit une valeur à virgule flottante double précision à l’entier le plus proche et utilise la convention d’arrondi spécifiée pour les valeurs du milieu ([exemple](#Round6_Example)).</span><span class="sxs-lookup"><span data-stu-id="45975-510">Rounds a double-precision floating-point value to the nearest integer, and uses the specified rounding convention for midpoint values ([example](#Round6_Example)).</span></span>  
  
 <span data-ttu-id="45975-511">`Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `, MidpointRounding`  `mode` `)`</span><span class="sxs-lookup"><span data-stu-id="45975-511">`Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `, MidpointRounding`  `mode` `)`</span></span>  
 <span data-ttu-id="45975-512">Arrondit une valeur décimale à un nombre spécifié de chiffres fractionnaires et utilise la convention d’arrondi spécifiée pour les valeurs du milieu ([exemple](#Round7_Example)).</span><span class="sxs-lookup"><span data-stu-id="45975-512">Rounds a decimal value to a specified number of fractional digits, and uses the specified rounding convention for midpoint values ([example](#Round7_Example)).</span></span>  
  
 <span data-ttu-id="45975-513">`Double Math.Round(Double` `value` `, Int32`  `digits` `, MidpointRounding`  `mode` `)`</span><span class="sxs-lookup"><span data-stu-id="45975-513">`Double Math.Round(Double` `value` `, Int32`  `digits` `, MidpointRounding`  `mode` `)`</span></span>  
 <span data-ttu-id="45975-514">Arrondit une valeur à virgule flottante double précision à un nombre spécifié de chiffres fractionnaires et utilise la convention d’arrondi spécifiée pour les valeurs du milieu ([exemple](#Round8_Example)).</span><span class="sxs-lookup"><span data-stu-id="45975-514">Rounds a double-precision floating-point value to a specified number of fractional digits, and uses the specified rounding convention for midpoint values ([example](#Round8_Example)).</span></span>  
  
<a name="Params"></a>   
## <a name="parameters"></a><span data-ttu-id="45975-515">Paramètres</span><span class="sxs-lookup"><span data-stu-id="45975-515">Parameters</span></span>  
 <span data-ttu-id="45975-516">Il s’agit d’une liste complète des paramètres pour le <xref:System.Math.Round%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="45975-516">This is a complete list of parameters for the <xref:System.Math.Round%2A> method.</span></span> <span data-ttu-id="45975-517">Pour les paramètres utilisés par chaque surcharge, consultez la syntaxe de la surcharge.</span><span class="sxs-lookup"><span data-stu-id="45975-517">For the parameters used by each overload, see the overload syntax above.</span></span>  
  
|<span data-ttu-id="45975-518">Paramètre</span><span class="sxs-lookup"><span data-stu-id="45975-518">Parameter</span></span>|<span data-ttu-id="45975-519">Type</span><span class="sxs-lookup"><span data-stu-id="45975-519">Type</span></span>|<span data-ttu-id="45975-520">Description </span><span class="sxs-lookup"><span data-stu-id="45975-520">Description</span></span>|  
|---------------|----------|-----------------|  
|`d`|<xref:System.Decimal>|<span data-ttu-id="45975-521">Un nombre à arrondir.</span><span class="sxs-lookup"><span data-stu-id="45975-521">A number to be rounded.</span></span>|  
|`a`<br /><br /> <span data-ttu-id="45975-522">- ou -</span><span class="sxs-lookup"><span data-stu-id="45975-522">-or-</span></span><br /><br /> `value`|<xref:System.Double>|<span data-ttu-id="45975-523">Nombre à virgule flottante double précision à arrondir.</span><span class="sxs-lookup"><span data-stu-id="45975-523">A double-precision floating-point number to be rounded.</span></span>|  
|`decimals`<br /><br /> <span data-ttu-id="45975-524">- ou -</span><span class="sxs-lookup"><span data-stu-id="45975-524">-or-</span></span><br /><br /> `digits`|<xref:System.Int32>|<span data-ttu-id="45975-525">Nombre de chiffres fractionnaires de la valeur de retour.</span><span class="sxs-lookup"><span data-stu-id="45975-525">The number of fractional digits in the return value.</span></span> <span data-ttu-id="45975-526">Pour <xref:System.Decimal> valeurs, il peut comprises entre 0 et 28.</span><span class="sxs-lookup"><span data-stu-id="45975-526">For <xref:System.Decimal> values, it can range from 0 to 28.</span></span> <span data-ttu-id="45975-527">Pour <xref:System.Double> valeurs, il peut comprises entre 0 et 15.</span><span class="sxs-lookup"><span data-stu-id="45975-527">For <xref:System.Double> values, it can range from 0 to 15.</span></span> <span data-ttu-id="45975-528">Notez que 15 est le nombre maximal de chiffres intégraux et fractionnaires pris en charge par le <xref:System.Double> type.</span><span class="sxs-lookup"><span data-stu-id="45975-528">Note that 15 is the maximum number of integral and fractional digits supported by the <xref:System.Double> type.</span></span><br /><br /> <span data-ttu-id="45975-529">Valeur par défaut : 0, ce qui est arrondi à un entier</span><span class="sxs-lookup"><span data-stu-id="45975-529">Default value: 0, which rounds to an integer</span></span>|  
|`mode`|<xref:System.MidpointRounding>|<span data-ttu-id="45975-530">Un indicateur qui spécifie la convention à utiliser pour l’arrondi des valeurs du milieu.</span><span class="sxs-lookup"><span data-stu-id="45975-530">A flag that specifies the convention to use for rounding midpoint values.</span></span> <span data-ttu-id="45975-531">Consultez [valeurs du milieu et conventions arrondies](#Midpoint).</span><span class="sxs-lookup"><span data-stu-id="45975-531">See [Midpoint values and rounding conventions](#Midpoint).</span></span><br /><br /> <span data-ttu-id="45975-532">Valeur par défaut : <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="45975-532">Default value: <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType></span></span>|  
  
<a name="Returns"></a>   
## <a name="return-value"></a><span data-ttu-id="45975-533">Valeur de retour</span><span class="sxs-lookup"><span data-stu-id="45975-533">Return value</span></span>  
 <span data-ttu-id="45975-534">Type : <xref:System.Decimal> ou <xref:System.Double>, selon le type de la valeur à arrondir.</span><span class="sxs-lookup"><span data-stu-id="45975-534">Type: <xref:System.Decimal> or <xref:System.Double>, depending on the type of the value to be rounded.</span></span>   
<span data-ttu-id="45975-535">Une valeur numérique du même type que `d`, `a`, ou `value`, mais est arrondi à un entier ou au nombre spécifié de chiffres décimaux.</span><span class="sxs-lookup"><span data-stu-id="45975-535">A numeric value of the same type as `d`, `a`, or `value`, but rounded either to an integer or to the specified number of decimal digits.</span></span> <span data-ttu-id="45975-536">Consultez [valeurs du milieu et conventions arrondies](#Midpoint) pour plus d’informations sur l’arrondi des nombres avec des valeurs du milieu.</span><span class="sxs-lookup"><span data-stu-id="45975-536">See [Midpoint values and rounding conventions](#Midpoint) for information about rounding numbers with midpoint values.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="45975-537">Pour arrondir les valeurs du milieu, l’algorithme arrondi effectue un test d’égalité.</span><span class="sxs-lookup"><span data-stu-id="45975-537">When rounding midpoint values, the rounding algorithm performs an equality test.</span></span> <span data-ttu-id="45975-538">En raison de problèmes de la représentation binaire et de précision dans le format à virgule flottante, la valeur retournée par la méthode peut être inattendue.</span><span class="sxs-lookup"><span data-stu-id="45975-538">Because of problems of binary representation and precision in the floating-point format, the value returned by the method can be unexpected.</span></span> <span data-ttu-id="45975-539">Pour plus d’informations, consultez [arrondi et la précision](#Precision).</span><span class="sxs-lookup"><span data-stu-id="45975-539">For more information, see [Rounding and precision](#Precision).</span></span>  
  
 <span data-ttu-id="45975-540">Si une surcharge avec un <xref:System.Double> paramètre est appelé avec <xref:System.Double.NaN?displayProperty=nameWithType>, la méthode retourne <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45975-540">If an overload with a <xref:System.Double> parameter is called with <xref:System.Double.NaN?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="45975-541">Si elle est appelée avec <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, la méthode retourne <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectivement.</span><span class="sxs-lookup"><span data-stu-id="45975-541">If it is called with <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectively.</span></span>  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a><span data-ttu-id="45975-542">Exceptions</span><span class="sxs-lookup"><span data-stu-id="45975-542">Exceptions</span></span>  
  
|<span data-ttu-id="45975-543">Exception</span><span class="sxs-lookup"><span data-stu-id="45975-543">Exception</span></span>|<span data-ttu-id="45975-544">Condition</span><span class="sxs-lookup"><span data-stu-id="45975-544">Condition</span></span>|<span data-ttu-id="45975-545">Levée par</span><span class="sxs-lookup"><span data-stu-id="45975-545">Thrown by</span></span>|  
|---------------|---------------|---------------|  
|<xref:System.OverflowException>|<span data-ttu-id="45975-546">Le résultat est en dehors de la plage de la <xref:System.Decimal> type.</span><span class="sxs-lookup"><span data-stu-id="45975-546">The result is outside the range of the <xref:System.Decimal> type.</span></span>|<xref:System.Math.Round%28System.Decimal%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="45975-547">`decimals` est inférieur à 0 ou supérieur à 28.</span><span class="sxs-lookup"><span data-stu-id="45975-547">`decimals` is less than 0 or greater than 28.</span></span><br /><br /> <span data-ttu-id="45975-548">- ou -</span><span class="sxs-lookup"><span data-stu-id="45975-548">-or-</span></span><br /><br /> <span data-ttu-id="45975-549">`digits` est inférieur à 0 ou supérieur à 15.</span><span class="sxs-lookup"><span data-stu-id="45975-549">`digits` is less than 0 or greater than 15.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|<xref:System.ArgumentException>|<span data-ttu-id="45975-550">`mode` n'est pas une valeur valide de <xref:System.MidpointRounding>.</span><span class="sxs-lookup"><span data-stu-id="45975-550">`mode` is not a valid value of <xref:System.MidpointRounding>.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a><span data-ttu-id="45975-551">Quelle méthode appeler ?</span><span class="sxs-lookup"><span data-stu-id="45975-551">Which method do I call?</span></span>  
  
|<span data-ttu-id="45975-552">À</span><span class="sxs-lookup"><span data-stu-id="45975-552">To</span></span>|<span data-ttu-id="45975-553">Call</span><span class="sxs-lookup"><span data-stu-id="45975-553">Call</span></span>|  
|--------|----------|  
|<span data-ttu-id="45975-554">Arrondit un nombre en entier à l’aide de l’arrondi à la convention le plus proche.</span><span class="sxs-lookup"><span data-stu-id="45975-554">Round a number to an integer by using the rounding to nearest convention.</span></span>|<xref:System.Math.Round%28System.Decimal%29><br /><br /> <span data-ttu-id="45975-555">- ou -</span><span class="sxs-lookup"><span data-stu-id="45975-555">-or-</span></span><br /><br /> <xref:System.Math.Round%28System.Double%29>|  
|<span data-ttu-id="45975-556">Arrondit un nombre en entier en utilisant une convention d’arrondi.</span><span class="sxs-lookup"><span data-stu-id="45975-556">Round a number to an integer by using a specified rounding convention.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> <span data-ttu-id="45975-557">- ou -</span><span class="sxs-lookup"><span data-stu-id="45975-557">-or-</span></span><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29>|  
|<span data-ttu-id="45975-558">Arrondit un nombre à un nombre spécifié de chiffres fractionnaires à l’aide de l’arrondi à la convention le plus proche.</span><span class="sxs-lookup"><span data-stu-id="45975-558">Round a number to a specified number of fractional digits by using the rounding to nearest convention.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> <span data-ttu-id="45975-559">- ou -</span><span class="sxs-lookup"><span data-stu-id="45975-559">-or-</span></span><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%29>|  
|<span data-ttu-id="45975-560">Arrondit un nombre à un nombre spécifié de chiffres de fraction en utilisant une convention d’arrondi.</span><span class="sxs-lookup"><span data-stu-id="45975-560">Round a number to a specified number of fractional digits by using a specified rounding convention.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> <span data-ttu-id="45975-561">- ou -</span><span class="sxs-lookup"><span data-stu-id="45975-561">-or-</span></span><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|<span data-ttu-id="45975-562">Round un <xref:System.Single> valeur à un nombre spécifié de chiffres fractionnaires à l’aide d’un arrondi convention et la réduction de la perte de précision spécifié.</span><span class="sxs-lookup"><span data-stu-id="45975-562">Round a <xref:System.Single> value to a specified number of fractional digits by using a specified rounding convention and minimizing the loss of precision.</span></span>|<span data-ttu-id="45975-563">Convertir le <xref:System.Single> à un <xref:System.Decimal> et appelez <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>.</span><span class="sxs-lookup"><span data-stu-id="45975-563">Convert the <xref:System.Single> to a <xref:System.Decimal> and call <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>.</span></span>|  
|<span data-ttu-id="45975-564">Arrondit un nombre à un nombre spécifié de chiffres fractionnaires tout en réduisant les problèmes de précision pour arrondir les valeurs du milieu.</span><span class="sxs-lookup"><span data-stu-id="45975-564">Round a number to a specified number of fractional digits while minimizing problems of precision in rounding midpoint values.</span></span>|<span data-ttu-id="45975-565">Appeler une méthode d’arrondi qui implémente une comparaison « supérieure ou égale à environ ».</span><span class="sxs-lookup"><span data-stu-id="45975-565">Call a rounding method that implements a "greater than or approximately equal to" comparison.</span></span> <span data-ttu-id="45975-566">Consultez [arrondi et la précision](#Precision).</span><span class="sxs-lookup"><span data-stu-id="45975-566">See [Rounding and precision](#Precision).</span></span>|  
|<span data-ttu-id="45975-567">Arrondit une valeur fractionnaire vers un entier qui est supérieur à la valeur de fraction.</span><span class="sxs-lookup"><span data-stu-id="45975-567">Round a fractional value to an integer that is greater than the fractional value.</span></span> <span data-ttu-id="45975-568">Par exemple, arrondir 3.1 à 4.</span><span class="sxs-lookup"><span data-stu-id="45975-568">For example, round 3.1 to 4.</span></span>|<xref:System.Math.Ceiling%2A>|  
|<span data-ttu-id="45975-569">Arrondit une valeur fractionnaire vers un entier qui est inférieur à la valeur de fraction.</span><span class="sxs-lookup"><span data-stu-id="45975-569">Round a fractional value to an integer that is less than the fractional value.</span></span> <span data-ttu-id="45975-570">Par exemple, arrondir 3.9 à 3.</span><span class="sxs-lookup"><span data-stu-id="45975-570">For example, round 3.9 to 3.</span></span>|<xref:System.Math.Floor%2A>|  
  
<a name="Midpoint"></a>   
## <a name="midpoint-values-and-rounding-conventions"></a><span data-ttu-id="45975-571">Valeurs du milieu et les conventions d’arrondi</span><span class="sxs-lookup"><span data-stu-id="45975-571">Midpoint values and rounding conventions</span></span>  
 <span data-ttu-id="45975-572">Arrondi implique la conversion d’une valeur numérique avec une précision spécifiée à la valeur la plus proche avec une précision inférieure.</span><span class="sxs-lookup"><span data-stu-id="45975-572">Rounding involves converting a numeric value with a specified precision to the nearest value with less precision.</span></span> <span data-ttu-id="45975-573">Par exemple, vous pouvez utiliser la <xref:System.Math.Round%28System.Double%29> méthode pour arrondir une valeur de 3.4 à 3.0 et le <xref:System.Math.Round%28System.Double%2CSystem.Int32%29> méthode pour arrondir une valeur de 3.579 à 3,58.</span><span class="sxs-lookup"><span data-stu-id="45975-573">For example, you can use the <xref:System.Math.Round%28System.Double%29> method to round a value of 3.4 to 3.0, and the <xref:System.Math.Round%28System.Double%2CSystem.Int32%29> method to round a value of 3.579 to 3.58.</span></span>  
  
 <span data-ttu-id="45975-574">Dans une valeur du milieu, la valeur après le chiffre le moins significatif dans le résultat est précisément mi-chemin entre deux nombres.</span><span class="sxs-lookup"><span data-stu-id="45975-574">In a midpoint value, the value after the least significant digit in the result is precisely half way between two numbers.</span></span> <span data-ttu-id="45975-575">Par exemple, 3.47500 est une valeur du milieu s’il doit être arrondie à deux décimales et 7.500 est une valeur du milieu, s’il doit être arrondi à un entier.</span><span class="sxs-lookup"><span data-stu-id="45975-575">For example, 3.47500 is a midpoint value if it is to be rounded two decimal places, and 7.500 is a midpoint value if it is to be rounded to an integer.</span></span> <span data-ttu-id="45975-576">Dans ce cas, la valeur la plus proche ne peut pas être facilement identifiée sans une convention d’arrondi.</span><span class="sxs-lookup"><span data-stu-id="45975-576">In these cases, the nearest value can't be easily identified without a rounding convention.</span></span>  
  
 <span data-ttu-id="45975-577">Le <xref:System.Math.Round%2A> méthode prend en charge deux conventions arrondies pour la gestion des valeurs du milieu :</span><span class="sxs-lookup"><span data-stu-id="45975-577">The <xref:System.Math.Round%2A> method supports two rounding conventions for handling midpoint values:</span></span>  
  
 <span data-ttu-id="45975-578">**Arrondissement à zéro**</span><span class="sxs-lookup"><span data-stu-id="45975-578">**Rounding away from zero**</span></span>  
 <span data-ttu-id="45975-579">Valeurs du milieu sont arrondies au nombre supérieur à zéro.</span><span class="sxs-lookup"><span data-stu-id="45975-579">Midpoint values are rounded to the next number away from zero.</span></span> <span data-ttu-id="45975-580">Par exemple, 3,75 est arrondi à 3.8, 3.85 arrondit à 3.9,-3.75 arrondit à-3.8, et-3.85 est arrondi à-3.9.</span><span class="sxs-lookup"><span data-stu-id="45975-580">For example, 3.75 rounds to 3.8, 3.85 rounds to 3.9, -3.75 rounds to -3.8, and -3.85 rounds to -3.9.</span></span> <span data-ttu-id="45975-581">Cette forme d’arrondi est représentée par le <xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType> membre d’énumération.</span><span class="sxs-lookup"><span data-stu-id="45975-581">This form of rounding is represented by the <xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType> enumeration member.</span></span>  
  
 <span data-ttu-id="45975-582">Arrondissement à zéro est la forme plus largement connue de l’arrondi.</span><span class="sxs-lookup"><span data-stu-id="45975-582">Rounding away from zero is the most widely known form of rounding.</span></span>  
  
 <span data-ttu-id="45975-583">**Principe d’arrondi au plus proche ou arrondi**</span><span class="sxs-lookup"><span data-stu-id="45975-583">**Rounding to nearest, or banker's rounding**</span></span>  
 <span data-ttu-id="45975-584">Valeurs du milieu sont arrondies au nombre pair le plus proche.</span><span class="sxs-lookup"><span data-stu-id="45975-584">Midpoint values are rounded to the nearest even number.</span></span> <span data-ttu-id="45975-585">Par exemple, 3,75 et 3.85 arrondi à 3.8, et-3.75 et-3.85 à-3.8.</span><span class="sxs-lookup"><span data-stu-id="45975-585">For example, both 3.75 and 3.85 round to 3.8, and both -3.75 and -3.85 round to -3.8.</span></span> <span data-ttu-id="45975-586">Cette forme d’arrondi est représentée par le <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType> membre d’énumération.</span><span class="sxs-lookup"><span data-stu-id="45975-586">This form of rounding is represented by the <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType> enumeration member.</span></span>  
  
 <span data-ttu-id="45975-587">Arrondi au plus près est le format standard de l’arrondi utilisés dans les opérations financières et statistiques.</span><span class="sxs-lookup"><span data-stu-id="45975-587">Rounding to nearest is the standard form of rounding used in financial and statistical operations.</span></span> <span data-ttu-id="45975-588">Il est conforme à la norme IEEE 754, section 4.</span><span class="sxs-lookup"><span data-stu-id="45975-588">It conforms to IEEE Standard 754, section 4.</span></span> <span data-ttu-id="45975-589">Lorsqu’il est utilisé dans plusieurs opérations d’arrondi, elle réduit l’erreur d’arrondi qui est provoquée par l’arrondissement cohérent des valeurs du milieu dans un seul sens.</span><span class="sxs-lookup"><span data-stu-id="45975-589">When used in multiple rounding operations, it reduces the rounding error that is caused by consistently rounding midpoint values in a single direction.</span></span> <span data-ttu-id="45975-590">Dans certains cas, cette erreur d’arrondi peut être significative.</span><span class="sxs-lookup"><span data-stu-id="45975-590">In some cases, this rounding error can be significant.</span></span>  
  
 <span data-ttu-id="45975-591">L’exemple suivant illustre l’écart peut être dû à l’arrondissement cohérent des valeurs du milieu dans un seul sens.</span><span class="sxs-lookup"><span data-stu-id="45975-591">The following example illustrates the bias that can result from consistently rounding midpoint values in a single direction.</span></span> <span data-ttu-id="45975-592">L’exemple calcule la moyenne vraie d’un tableau de <xref:System.Decimal> de valeurs et puis calcule la moyenne lorsque les valeurs du tableau sont arrondies en utilisant les conventions de deux.</span><span class="sxs-lookup"><span data-stu-id="45975-592">The example computes the true mean of an array of <xref:System.Decimal> values, and then computes the mean when the values in the array are rounded by using the two conventions.</span></span> <span data-ttu-id="45975-593">Dans cet exemple, la moyenne vraie et la moyenne se produit lorsque le principe d’arrondi au plus proche sont identiques.</span><span class="sxs-lookup"><span data-stu-id="45975-593">In this example, the true mean and the mean that results when rounding to nearest are the same.</span></span> <span data-ttu-id="45975-594">Toutefois, la moyenne se produit lorsque l’arrondissement à zéro diffère par.05 (ou en 3,6 %) à partir de la moyenne vraie.</span><span class="sxs-lookup"><span data-stu-id="45975-594">However, the mean that results when rounding away from zero differs by .05 (or by 3.6%) from the true mean.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mean1.cs#2)]
 [!code-vb[System.Math.Round.Overload#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mean1.vb#2)]  
  
 <span data-ttu-id="45975-595">Par défaut, le <xref:System.Math.Round%2A> méthode utilise l’arrondi à la convention le plus proche.</span><span class="sxs-lookup"><span data-stu-id="45975-595">By default, the <xref:System.Math.Round%2A> method uses the rounding to nearest convention.</span></span> <span data-ttu-id="45975-596">Le tableau suivant répertorie les surcharges de la <xref:System.Math.Round%2A> méthode et la convention d’arrondi que chacune utilise.</span><span class="sxs-lookup"><span data-stu-id="45975-596">The following table lists the overloads of the <xref:System.Math.Round%2A> method and the rounding convention that each uses.</span></span>  
  
|<span data-ttu-id="45975-597">Surcharge</span><span class="sxs-lookup"><span data-stu-id="45975-597">Overload</span></span>|<span data-ttu-id="45975-598">Convention d’arrondi</span><span class="sxs-lookup"><span data-stu-id="45975-598">Rounding convention</span></span>|  
|--------------|-------------------------|  
|<xref:System.Math.Round%28System.Decimal%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Double%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Double%2CSystem.Int32%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29>|<span data-ttu-id="45975-599">Déterminé par `mode` paramètre.</span><span class="sxs-lookup"><span data-stu-id="45975-599">Determined by `mode` parameter.</span></span>|  
|<xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29>|<span data-ttu-id="45975-600">Déterminé par `mode` paramètre</span><span class="sxs-lookup"><span data-stu-id="45975-600">Determined by `mode` parameter</span></span>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>|<span data-ttu-id="45975-601">Déterminé par `mode` paramètre</span><span class="sxs-lookup"><span data-stu-id="45975-601">Determined by `mode` parameter</span></span>|  
|<xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|<span data-ttu-id="45975-602">Déterminé par `mode` paramètre</span><span class="sxs-lookup"><span data-stu-id="45975-602">Determined by `mode` parameter</span></span>|  
  
<a name="Precision"></a>   
## <a name="rounding-and-precision"></a><span data-ttu-id="45975-603">Arrondi et la précision</span><span class="sxs-lookup"><span data-stu-id="45975-603">Rounding and precision</span></span>  
 <span data-ttu-id="45975-604">Afin de déterminer si une opération d’arrondi implique une valeur du milieu, le <xref:System.Math.Round%2A> méthode multiplie la valeur d’origine à arrondir par 10<sup>n</sup>, où *n* est le nombre souhaité de fractions de seconde chiffres dans la valeur de retour, puis détermine si la partie fractionnaire restante de la valeur est supérieure ou égale à.5.</span><span class="sxs-lookup"><span data-stu-id="45975-604">In order to determine whether a rounding operation involves a midpoint value, the <xref:System.Math.Round%2A> method multiplies the original value to be rounded by 10<sup>n</sup>, where *n* is the desired number of fractional digits in the return value, and then determines whether the remaining fractional portion of the value is greater than or equal to .5.</span></span> <span data-ttu-id="45975-605">Il s’agit d’une légère variation à un test d’égalité et comme nous l’avons vu dans la section « Test d’égalité » de la <xref:System.Double> rubrique de référence, teste l’égalité avec les valeurs à virgule flottante est problématiques en raison de problèmes de format à virgule flottante avec binaire représentation et la précision.</span><span class="sxs-lookup"><span data-stu-id="45975-605">This is a slight variation on a test for equality, and as discussed in the "Testing for Equality" section of the <xref:System.Double> reference topic, tests for equality with floating-point values are problematic because of the floating-point format's issues with binary representation and precision.</span></span> <span data-ttu-id="45975-606">Cela signifie que toute partie fractionnaire d’un nombre qui est légèrement inférieure à.5 (en raison d’une perte de précision) ne sera pas arrondie vers le haut.</span><span class="sxs-lookup"><span data-stu-id="45975-606">This means that any fractional portion of a number that is slightly less than .5 (because of a loss of precision) will not be rounded upward.</span></span>  
  
 <span data-ttu-id="45975-607">L'exemple de code suivant illustre le problème.</span><span class="sxs-lookup"><span data-stu-id="45975-607">The following example illustrates the problem.</span></span> <span data-ttu-id="45975-608">À plusieurs reprises, il ajoute.1 à 11.0 et arrondit le résultat à l’entier le plus proche.</span><span class="sxs-lookup"><span data-stu-id="45975-608">It repeatedly adds .1 to 11.0 and rounds the result to the nearest integer.</span></span> <span data-ttu-id="45975-609">Quelle que soit la convention d’arrondi, 11.5 doivent être arrondies à 12.</span><span class="sxs-lookup"><span data-stu-id="45975-609">Regardless of the rounding convention, 11.5 should round to 12.</span></span> <span data-ttu-id="45975-610">Toutefois, comme le montre le résultat de l’exemple, il n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="45975-610">However, as the output from the example shows, it does not.</span></span> <span data-ttu-id="45975-611">L’exemple utilise « R » [chaîne de format numérique standard](~/docs/standard/base-types/standard-numeric-format-strings.md) pour afficher la virgule flottante une précision totale de valeur et montre que la valeur doit être arrondie a perdu la précision pendant les ajouts répétées, et sa valeur est en fait 11.499999999999998.</span><span class="sxs-lookup"><span data-stu-id="45975-611">The example uses the "R" [standard numeric format string](~/docs/standard/base-types/standard-numeric-format-strings.md) to display the floating point value's full precision, and shows that the value to be rounded has lost precision during repeated additions, and its value is actually 11.499999999999998.</span></span> <span data-ttu-id="45975-612">.499999999999998 étant inférieur à.5, la valeur n’est pas arrondie à l’entier le plus élevé.</span><span class="sxs-lookup"><span data-stu-id="45975-612">Because .499999999999998 is less than .5, the value is not rounded to the next highest integer.</span></span> <span data-ttu-id="45975-613">Comme dans l’exemple également, ce problème ne survient pas si nous attribuons simplement la valeur de constante 11.5 à un <xref:System.Double> variable.</span><span class="sxs-lookup"><span data-stu-id="45975-613">As the example also shows, this problem does not occur if we simply assign the constant value 11.5 to a <xref:System.Double> variable.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/precision1.cs#7)]
 [!code-vb[System.Math.Round.Overload#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/precision1.vb#7)]  
  
 <span data-ttu-id="45975-614">Problèmes de précision pour arrondir les valeurs du milieu sont plus susceptibles de survenir dans les conditions suivantes :</span><span class="sxs-lookup"><span data-stu-id="45975-614">Problems of precision in rounding midpoint values are most likely to arise in the following conditions:</span></span>  
  
-   <span data-ttu-id="45975-615">Quand une valeur fractionnaire ne peuvent pas être exprimée avec précision dans un format binaire du type à virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="45975-615">When a fractional value cannot be expressed precisely in the floating-point type's binary format.</span></span>  
  
-   <span data-ttu-id="45975-616">Lorsque la valeur à arrondir est calculée à partir d’une ou plusieurs opérations à virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="45975-616">When the value to be rounded is calculated from one or more floating-point operations.</span></span>  
  
-   <span data-ttu-id="45975-617">Lorsque la valeur à arrondir est un <xref:System.Single> au lieu d’un <xref:System.Double> ou <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="45975-617">When the value to be rounded is a <xref:System.Single> rather than a <xref:System.Double> or <xref:System.Decimal>.</span></span> <span data-ttu-id="45975-618">Pour plus d’informations, consultez la section suivante, [arrondi et les valeurs à virgule flottante simple précision](#Single).</span><span class="sxs-lookup"><span data-stu-id="45975-618">For more information, see the next section, [Rounding and single-precision floating-point values](#Single).</span></span>  
  
 <span data-ttu-id="45975-619">Dans les cas où le manque de précision dans les opérations d’arrondi est problématique, vous pouvez procédez comme suit :</span><span class="sxs-lookup"><span data-stu-id="45975-619">In cases where the lack of precision in rounding operations is problematic, you can do the following:</span></span>  
  
-   <span data-ttu-id="45975-620">Si l’opération d’arrondi appelle une surcharge qui arrondit un <xref:System.Double> valeur, vous pouvez modifier le <xref:System.Double> à un <xref:System.Decimal> valeur et appeler une surcharge qui arrondit un <xref:System.Decimal> valeur à la place.</span><span class="sxs-lookup"><span data-stu-id="45975-620">If the rounding operation calls an overload that rounds a <xref:System.Double> value, you can change the <xref:System.Double> to a <xref:System.Decimal> value and call an overload that rounds a <xref:System.Decimal> value instead.</span></span> <span data-ttu-id="45975-621">Bien que le <xref:System.Decimal> type de données comporte également des problèmes de représentation et de perte de précision, ces problèmes sont nettement moins courants.</span><span class="sxs-lookup"><span data-stu-id="45975-621">Although the <xref:System.Decimal> data type also has problems of representation and loss of precision, these issues are far less common.</span></span>  
  
-   <span data-ttu-id="45975-622">Définir un algorithme d’arrondi personnalisé qui effectue un test « presque égal » pour déterminer si la valeur doit être arrondie est acceptable proche d’une valeur du milieu.</span><span class="sxs-lookup"><span data-stu-id="45975-622">Define a custom rounding algorithm that performs a "nearly equal" test to determine whether the value to be rounded is acceptably close to a midpoint value.</span></span> <span data-ttu-id="45975-623">L’exemple suivant définit un `RoundApproximate` méthode examine si une valeur fractionnaire est suffisamment proche une valeur du milieu soit soumis à l’arrondi du milieu.</span><span class="sxs-lookup"><span data-stu-id="45975-623">The following example defines a `RoundApproximate` method that examines whether a fractional value is sufficiently near to a midpoint value to be subject to midpoint rounding.</span></span> <span data-ttu-id="45975-624">Comme le montre la sortie de l’exemple, il corrige le problème d’arrondi indiqué dans l’exemple précédent.</span><span class="sxs-lookup"><span data-stu-id="45975-624">As the output from the example shows, it corrects the rounding problem shown in the previous example.</span></span>  
  
     [!code-csharp[System.Math.Round.Overload#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/precision2.cs#8)]
     [!code-vb[System.Math.Round.Overload#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/precision2.vb#8)]  
  
<a name="Single"></a>   
## <a name="rounding-and-single-precision-floating-point-values"></a><span data-ttu-id="45975-625">Arrondi et simple précision des valeurs à virgule flottante</span><span class="sxs-lookup"><span data-stu-id="45975-625">Rounding and single-precision floating-point values</span></span>  
 <span data-ttu-id="45975-626">Le <xref:System.Math.Round%2A> méthode inclut des surcharges qui acceptent des arguments de type <xref:System.Decimal> et <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="45975-626">The <xref:System.Math.Round%2A> method includes overloads that accept arguments of type <xref:System.Decimal> and <xref:System.Double>.</span></span> <span data-ttu-id="45975-627">Il n’existe aucune méthode qui arrondit des valeurs de type <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="45975-627">There are no methods that round values of type <xref:System.Single>.</span></span> <span data-ttu-id="45975-628">Si vous passez un <xref:System.Single> valeur à une des surcharges de la <xref:System.Math.Round%2A> (méthode), il est converti (en c#) ou convertie (en Visual Basic) en un <xref:System.Double>et correspondants <xref:System.Math.Round%2A> surcharge avec un <xref:System.Double> paramètre est appelé.</span><span class="sxs-lookup"><span data-stu-id="45975-628">If you pass a <xref:System.Single> value to one of the overloads of the <xref:System.Math.Round%2A> method, it is cast (in C#) or converted (in Visual Basic) to a <xref:System.Double>, and the corresponding <xref:System.Math.Round%2A> overload with a <xref:System.Double> parameter is called.</span></span> <span data-ttu-id="45975-629">Bien qu’il s’agit d’une conversion étendue, elle implique souvent une perte de précision, comme l’illustre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="45975-629">Although this is a widening conversion, it often involves a loss of precision, as the following example illustrates.</span></span> <span data-ttu-id="45975-630">Quand un <xref:System.Single> valeur 16.325 est transmise à la <xref:System.Math.Round%2A> (méthode) et arrondies à deux décimales à l’aide de l’arrondi à la convention le plus proche, le résultat est 16.33 et pas attendu le résultat de 16.32.</span><span class="sxs-lookup"><span data-stu-id="45975-630">When a <xref:System.Single> value of 16.325 is passed to the <xref:System.Math.Round%2A> method and rounded to two decimal places using the rounding to nearest convention, the result is 16.33 and not the expected result of 16.32.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/single1.cs#1)]
 [!code-vb[System.Math.Round.Overload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/single1.vb#1)]  
  
 <span data-ttu-id="45975-631">Ce résultat inattendu est en raison d’une perte de précision dans la conversion de la <xref:System.Single> valeur à un <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="45975-631">This unexpected result is due to a loss of precision in the conversion of the <xref:System.Single> value to a <xref:System.Double>.</span></span> <span data-ttu-id="45975-632">Étant donné que le résultat <xref:System.Double> valeur 16.325000762939453 n’est pas une valeur du milieu et est supérieure à 16.325, il est toujours arrondi vers le haut.</span><span class="sxs-lookup"><span data-stu-id="45975-632">Because the resulting <xref:System.Double> value of 16.325000762939453 is not a midpoint value and is greater than 16.325, it is always rounded upward.</span></span>  
  
 <span data-ttu-id="45975-633">Dans de nombreux cas, comme l’illustre l’exemple, la perte de précision peut être réduite ou éliminée en conversion ou en convertissant le <xref:System.Single> valeur à un <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="45975-633">In many cases, as the example illustrates, the loss of precision can be minimized or eliminated by casting or converting the <xref:System.Single> value to a <xref:System.Decimal>.</span></span> <span data-ttu-id="45975-634">Notez que, comme il s’agit d’une conversion restrictive, il nécessite à l’aide d’un opérateur de cast ou en appelant une méthode de conversion.</span><span class="sxs-lookup"><span data-stu-id="45975-634">Note that, because this is a narrowing conversion, it requires using a cast operator or calling a conversion method.</span></span>  
  
<a name="Round1_Example"></a>   
## <a name="mathrounddecimal-example"></a><span data-ttu-id="45975-635">Exemple de Math.Round(Decimal)</span><span class="sxs-lookup"><span data-stu-id="45975-635">Math.Round(Decimal) example</span></span>  
 <span data-ttu-id="45975-636">L’exemple suivant montre le <xref:System.Math.Round%28System.Decimal%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="45975-636">The following example demonstrates the <xref:System.Math.Round%28System.Decimal%29> method.</span></span> <span data-ttu-id="45975-637">Notez que le <xref:System.Decimal> valeur 4,5 est arrondi à 4 plutôt que 5, étant donné que cette surcharge utilise la valeur par défaut <xref:System.MidpointRounding.ToEven> convention.</span><span class="sxs-lookup"><span data-stu-id="45975-637">Note that the <xref:System.Decimal> value of 4.5 rounds to 4 rather than 5, because this overload uses the default <xref:System.MidpointRounding.ToEven> convention.</span></span>  
  
 [!code-csharp[System.Math.Round#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/rounddecimal1.cs#6)]
 [!code-vb[System.Math.Round#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/rounddecimal1.vb#6)]  
  
<a name="Round2_Example"></a>   
## <a name="mathrounddouble-example"></a><span data-ttu-id="45975-638">Exemple de Math.Round(Double)</span><span class="sxs-lookup"><span data-stu-id="45975-638">Math.Round(Double) example</span></span>  
 <span data-ttu-id="45975-639">L’exemple suivant montre l’arrondi au nombre entier le plus proche.</span><span class="sxs-lookup"><span data-stu-id="45975-639">The following example demonstrates rounding to the nearest integer value.</span></span>  
  
 [!code-cpp[Classic Math.Round Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Math.Round Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Math.Round Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Math.Round Example/CS/source.cs#1)]
 [!code-vb[Classic Math.Round Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Math.Round Example/VB/source.vb#1)]  
  
<a name="Round3_Example"></a>   
## <a name="mathrounddecimal-int32-example"></a><span data-ttu-id="45975-640">Exemple de Math.Round (décimale, Int32)</span><span class="sxs-lookup"><span data-stu-id="45975-640">Math.Round(Decimal, Int32) example</span></span>  
 <span data-ttu-id="45975-641">L’exemple suivant arrondit les valeurs décimales avec deux chiffres fractionnaires à des valeurs qui ont un seul chiffre fractionnaire.</span><span class="sxs-lookup"><span data-stu-id="45975-641">The following example rounds decimal values with two fractional digits to values that have a single fractional digit.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/source.cs#3)]
 [!code-vb[System.Math.Round.Overload#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/source.vb#3)]  
  
<a name="Round4_Example"></a>   
## <a name="mathrounddouble-int32-example"></a><span data-ttu-id="45975-642">Math.Round (Double, Int32) exemple</span><span class="sxs-lookup"><span data-stu-id="45975-642">Math.Round(Double, Int32) example</span></span>  
 <span data-ttu-id="45975-643">L’exemple suivant arrondit les valeurs double avec deux chiffres fractionnaires en doubles qui ont un seul chiffre fractionnaire.</span><span class="sxs-lookup"><span data-stu-id="45975-643">The following example rounds double values with two fractional digits to doubles that have a single fractional digit.</span></span>  
  
 [!code-cpp[Classic Math.Round2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Math.Round2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Math.Round2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Math.Round2 Example/CS/source.cs#1)]
 [!code-vb[Classic Math.Round2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Math.Round2 Example/VB/source.vb#1)]  
  
<a name="Round5_Example"></a>   
## <a name="mathrounddecimal-midpointrounding-example"></a><span data-ttu-id="45975-644">Exemple de Math.Round (décimale, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="45975-644">Math.Round(Decimal, MidpointRounding) example</span></span>  
 <span data-ttu-id="45975-645">L’exemple suivant affiche les valeurs retournées par la <xref:System.Math.Round%28System.Decimal%29> (méthode), le <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> méthode avec un `mode` argument de <xref:System.MidpointRounding.ToEven>et le <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> méthode avec un `mode` argument de <xref:System.MidpointRounding.AwayFromZero>.</span><span class="sxs-lookup"><span data-stu-id="45975-645">The following example displays values returned by the <xref:System.Math.Round%28System.Decimal%29> method, the <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> method with a `mode` argument of <xref:System.MidpointRounding.ToEven>, and the <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> method with a `mode` argument of <xref:System.MidpointRounding.AwayFromZero>.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint1.cs#5)]
 [!code-vb[System.Math.Round.Overload#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint1.vb#5)]  
  
<a name="Round6_Example"></a>   
## <a name="mathrounddouble-midpointrounding-example"></a><span data-ttu-id="45975-646">Math.Round (Double, MidpointRounding) exemple</span><span class="sxs-lookup"><span data-stu-id="45975-646">Math.Round(Double, MidpointRounding) example</span></span>  
 <span data-ttu-id="45975-647">L’exemple suivant affiche les valeurs retournées par la <xref:System.Math.Round%28System.Double%29> (méthode), le <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> méthode avec un `mode` argument de <xref:System.MidpointRounding.ToEven>et le <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> méthode avec un `mode` argument de <xref:System.MidpointRounding.AwayFromZero>.</span><span class="sxs-lookup"><span data-stu-id="45975-647">The following example displays values returned by the <xref:System.Math.Round%28System.Double%29> method, the <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> method with a `mode` argument of <xref:System.MidpointRounding.ToEven>, and the <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> method with a `mode` argument of <xref:System.MidpointRounding.AwayFromZero>.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint2.cs#6)]
 [!code-vb[System.Math.Round.Overload#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint2.vb#6)]  
  
<a name="Round7_Example"></a>   
## <a name="mathrounddecimal-int32-midpointrounding-example"></a><span data-ttu-id="45975-648">Exemple de Math.Round (Int32, Decimal MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="45975-648">Math.Round(Decimal, Int32, MidpointRounding) example</span></span>  
 <span data-ttu-id="45975-649">L’exemple suivant montre comment utiliser le <xref:System.Math.Round%2A> méthode avec le <xref:System.MidpointRounding> énumération.</span><span class="sxs-lookup"><span data-stu-id="45975-649">The following example demonstrates how to use the <xref:System.Math.Round%2A> method with the <xref:System.MidpointRounding> enumeration.</span></span>  
  
 [!code-cpp[math.midpointrounding#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.midpointrounding/cpp/mpr.cpp#1)]
 [!code-csharp[math.midpointrounding#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.midpointrounding/CS/mpr.cs#1)]
 [!code-vb[math.midpointrounding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.midpointrounding/VB/mpr.vb#1)]  
  
<a name="Round8_Example"></a>   
## <a name="mathrounddouble-int32-midpointrounding-example"></a><span data-ttu-id="45975-650">Exemple de Math.Round (Double, Int32, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="45975-650">Math.Round(Double, Int32, MidpointRounding) example</span></span>  
 <span data-ttu-id="45975-651">L’exemple suivant montre comment utiliser le <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29> méthode avec le <xref:System.MidpointRounding> énumération.</span><span class="sxs-lookup"><span data-stu-id="45975-651">The following example demonstrates how to use the <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29> method with the <xref:System.MidpointRounding> enumeration.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mpr.cs#4)]
 [!code-vb[System.Math.Round.Overload#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mpr.vb#4)]  
  
<a name="Round_Versions"></a>   
## <a name="version-information"></a><span data-ttu-id="45975-652">Informations de version</span><span class="sxs-lookup"><span data-stu-id="45975-652">Version information</span></span>  
 <span data-ttu-id="45975-653">.NET Framework</span><span class="sxs-lookup"><span data-stu-id="45975-653">.NET Framework</span></span>  
 <span data-ttu-id="45975-654">Surcharges sans un <xref:System.MidpointRounding> paramètre sont pris en charge dans : 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</span><span class="sxs-lookup"><span data-stu-id="45975-654">Overloads without a <xref:System.MidpointRounding> parameter are supported in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</span></span>  
<span data-ttu-id="45975-655">Surcharge avec un <xref:System.MidpointRounding> paramètre sont pris en charge dans : 4.5, 4, 3.5, 3.0, 2.0</span><span class="sxs-lookup"><span data-stu-id="45975-655">Overloads with a <xref:System.MidpointRounding> parameter are supported in: 4.5, 4, 3.5, 3.0, 2.0</span></span>  
  
 <span data-ttu-id="45975-656">.NET Framework Client Profile</span><span class="sxs-lookup"><span data-stu-id="45975-656">.NET Framework Client Profile</span></span>  
 <span data-ttu-id="45975-657">Toutes les surcharges sont pris en charge dans : 4, 3.5 SP1</span><span class="sxs-lookup"><span data-stu-id="45975-657">All overloads are supported in: 4, 3.5 SP1</span></span>  
  
 <span data-ttu-id="45975-658">Bibliothèque de classes portable</span><span class="sxs-lookup"><span data-stu-id="45975-658">Portable Class Library</span></span>  
 <span data-ttu-id="45975-659">Toutes les surcharges sont pris en charge</span><span class="sxs-lookup"><span data-stu-id="45975-659">All overloads are supported</span></span>  
  
 <span data-ttu-id="45975-660">.NET pour les applications du Windows Store</span><span class="sxs-lookup"><span data-stu-id="45975-660">.NET for Windows Store apps</span></span>  
 <span data-ttu-id="45975-661">Toutes les surcharges sont pris en charge dans : Windows 8</span><span class="sxs-lookup"><span data-stu-id="45975-661">All overloads are supported in: Windows 8</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
        <altmember cref="M:System.Math.Truncate(System.Decimal)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d);" />
      <MemberSignature Language="F#" Value="static member Round : decimal -&gt; decimal" Usage="System.Math.Round d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-662">Nombre décimal à arrondir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-662">A decimal number to be rounded.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-663">Arrondit une valeur décimale à la valeur entière la plus proche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-663">Rounds a decimal value to the nearest integral value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-664">Paramètre <paramref name="d" /> de l'entier le plus proche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-664">The integer nearest parameter <paramref name="d" />.</span>
          </span>
          <span data-ttu-id="45975-665">Si le composant fractionnaire de <paramref name="d" /> se trouve à égale distance de deux entiers, l'un pair et l'autre impair, le nombre pair est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-665">If the fractional component of <paramref name="d" /> is halfway between two integers, one of which is even and the other odd, the even number is returned.</span>
          </span>
          <span data-ttu-id="45975-666">Notez que cette méthode retourne un objet <see cref="T:System.Decimal" /> plutôt qu'un type intégral.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-666">Note that this method returns a <see cref="T:System.Decimal" /> instead of an integral type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="45975-667">Pour des exemples et des informations d’utilisation complètes sur cela et d’autres surcharges de la `Round` (méthode), consultez le <xref:System.Math.Round%2A> page de référence.</span><span class="sxs-lookup"><span data-stu-id="45975-667">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="45975-668">Le résultat est à l'extérieur de la plage d'un <see cref="T:System.Decimal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-668">The result is outside the range of a <see cref="T:System.Decimal" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double a);" />
      <MemberSignature Language="F#" Value="static member Round : double -&gt; double" Usage="System.Math.Round a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="45975-669">Nombre à virgule flottante double précision à arrondir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-669">A double-precision floating-point number to be rounded.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-670">Arrondit une valeur à virgule flottante double précision à la valeur entière la plus proche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-670">Rounds a double-precision floating-point value to the nearest integral value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-671">Entier le plus proche de <paramref name="a" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-671">The integer nearest <paramref name="a" />.</span>
          </span>
          <span data-ttu-id="45975-672">Si le composant fractionnaire de <paramref name="a" /> se trouve à égale distance de deux entiers, l'un pair et l'autre impair, le nombre pair est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-672">If the fractional component of <paramref name="a" /> is halfway between two integers, one of which is even and the other odd, then the even number is returned.</span>
          </span>
          <span data-ttu-id="45975-673">Notez que cette méthode retourne un objet <see cref="T:System.Double" /> plutôt qu'un type intégral.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-673">Note that this method returns a <see cref="T:System.Double" /> instead of an integral type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="45975-674">Pour des exemples et des informations d’utilisation complètes sur cela et d’autres surcharges de la `Round` (méthode), consultez le <xref:System.Math.Round%2A> page de référence.</span><span class="sxs-lookup"><span data-stu-id="45975-674">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="45975-675">
            <para>En raison de la perte de précision qui peut être dû à la représentation de valeurs décimales sous forme de nombres à virgule flottante ou des opérations arithmétiques sur les valeurs à virgule flottante, dans certains cas le <see cref="M:System.Math.Round(System.Double)" /> méthode peut ne pas semble arrondir les valeurs du milieu pour le plus proche de l’entier pair. Dans l’exemple suivant, étant donné que la valeur à virgule flottante.1 n’a aucune représentation binaire finie, le premier appel à la <see cref="M:System.Math.Round(System.Double)" /> méthode avec une valeur de 11,5 retourne 11 au lieu de 12.  [ ! code-csharp[System.Math.Round#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round2.cs#1)] [ ! code-vb[System.Math.Round#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round2.vb#1)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-675">
              <para>Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double)" /> method may not appear to round midpoint values to the nearest even integer. In the following example, because the floating-point value .1 has no finite binary representation, the first call to the <see cref="M:System.Math.Round(System.Double)" /> method with a value of 11.5 returns 11 instead of 12.  [!code-csharp[System.Math.Round#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round2.cs#1)] [!code-vb[System.Math.Round#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round2.vb#1)]</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals);" />
      <MemberSignature Language="F#" Value="static member Round : decimal * int -&gt; decimal" Usage="System.Math.Round (d, decimals)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-676">Nombre décimal à arrondir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-676">A decimal number to be rounded.</span>
          </span>
        </param>
        <param name="decimals">
          <span data-ttu-id="45975-677">Nombre de décimales de la valeur de retour.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-677">The number of decimal places in the return value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-678">Arrondit une valeur décimale au nombre de chiffres fractionnaires spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-678">Rounds a decimal value to a specified number of fractional digits.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-679">Nombre le plus proche de <paramref name="d" /> contenant un nombre de chiffres fractionnaires égal à <paramref name="decimals" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-679">The number nearest to <paramref name="d" /> that contains a number of fractional digits equal to <paramref name="decimals" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="45975-680">Pour des exemples et des informations d’utilisation complètes sur cela et d’autres surcharges de la `Round` (méthode), consultez le <xref:System.Math.Round%2A> page de référence.</span><span class="sxs-lookup"><span data-stu-id="45975-680">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="45975-681">
            <paramref name="decimals" /> est inférieur à 0 ou supérieur à 28.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-681">
              <paramref name="decimals" /> is less than 0 or greater than 28.</span>
          </span>
        </exception>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="45975-682">Le résultat est à l'extérieur de la plage d'un <see cref="T:System.Decimal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-682">The result is outside the range of a <see cref="T:System.Decimal" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : decimal * MidpointRounding -&gt; decimal" Usage="System.Math.Round (d, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-683">Nombre décimal à arrondir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-683">A decimal number to be rounded.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="45975-684">Spécification sur la façon d’arrondir <c>d</c> s’il se trouve à mi-chemin entre deux nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-684">Specification for how to round <c>d</c> if it is midway between two other numbers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-685">Arrondit une valeur décimale à l'entier le plus proche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-685">Rounds a decimal value to the nearest integer.</span>
          </span>
          <span data-ttu-id="45975-686">Un paramètre spécifie comment arrondir la valeur qui se trouve à égale distance des deux nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-686">A parameter specifies how to round the value if it is midway between two numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-687">Entier le plus proche de <paramref name="d" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-687">The integer nearest <paramref name="d" />.</span>
          </span>
          <span data-ttu-id="45975-688">Si <paramref name="d" /> se trouve à égale distance de deux nombres, l'un pair et l'autre impair, <paramref name="mode" /> détermine le nombre qui sera retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-688">If <paramref name="d" /> is halfway between two numbers, one of which is even and the other odd, then <paramref name="mode" /> determines which of the two is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="45975-689">Pour des exemples et des informations d’utilisation complètes sur cela et d’autres surcharges de la `Round` (méthode), consultez le <xref:System.Math.Round%2A> page de référence.</span><span class="sxs-lookup"><span data-stu-id="45975-689">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="45975-690">
            <paramref name="mode" /> n'est pas une valeur valide de <see cref="T:System.MidpointRounding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-690">
              <paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span>
          </span>
        </exception>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="45975-691">Le résultat est à l'extérieur de la plage d'un <see cref="T:System.Decimal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-691">The result is outside the range of a <see cref="T:System.Decimal" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, digits As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, int digits);" />
      <MemberSignature Language="F#" Value="static member Round : double * int -&gt; double" Usage="System.Math.Round (value, digits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="digits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-692">Nombre à virgule flottante double précision à arrondir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-692">A double-precision floating-point number to be rounded.</span>
          </span>
        </param>
        <param name="digits">
          <span data-ttu-id="45975-693">Nombre de chiffres fractionnaires de la valeur de retour.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-693">The number of fractional digits in the return value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-694">Arrondit une valeur à virgule flottante double précision au nombre de chiffres fractionnaires spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-694">Rounds a double-precision floating-point value to a specified number of fractional digits.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-695">Nombre le plus proche de <paramref name="value" /> contenant un nombre de chiffres fractionnaires égal à <paramref name="digits" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-695">The number nearest to <paramref name="value" /> that contains a number of fractional digits equal to <paramref name="digits" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="45975-696">Pour des exemples et des informations d’utilisation complètes sur cela et d’autres surcharges de la `Round` (méthode), consultez le <xref:System.Math.Round%2A> page de référence.</span><span class="sxs-lookup"><span data-stu-id="45975-696">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="45975-697">
            <paramref name="digits" /> est inférieur à 0 ou supérieur à 15.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-697">
              <paramref name="digits" /> is less than 0 or greater than 15.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="45975-698">
            <para>En raison de la perte de précision qui peut être dû à la représentation de valeurs décimales sous forme de nombres à virgule flottante ou des opérations arithmétiques sur les valeurs à virgule flottante, dans certains cas le <see cref="M:System.Math.Round(System.Double,System.Int32)" /> méthode peut ne pas semble arrondir les valeurs du milieu pour le plus proche de la même valeur dans la <paramref name="digits" /> position décimale. Cela est illustré dans l’exemple suivant, où 2.135 est arrondi à 2.13 au lieu de 2.14. Cela se produit, car en interne la méthode multiplie <paramref name="value" /> par 10<sup>chiffres</sup>, et l’opération de multiplication dans ce cas souffre d’une perte de précision.  [ ! code-csharp[System.Math.Round#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round3.cs#2)] [ ! code-vb[System.Math.Round#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round3.vb#2)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-698">
              <para>Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double,System.Int32)" /> method may not appear to round midpoint values to the nearest even value in the <paramref name="digits" /> decimal position. This is illustrated in the following example, where 2.135 is rounded to 2.13 instead of 2.14. This occurs because internally the method multiplies <paramref name="value" /> by 10<sup>digits</sup>, and the multiplication operation in this case suffers from a loss of precision.  [!code-csharp[System.Math.Round#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round3.cs#2)] [!code-vb[System.Math.Round#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round3.vb#2)]</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, mode As MidpointRounding) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : double * MidpointRounding -&gt; double" Usage="System.Math.Round (value, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-699">Nombre à virgule flottante double précision à arrondir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-699">A double-precision floating-point number to be rounded.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="45975-700">Spécification sur la façon d’arrondir <c>value</c> s’il se trouve à mi-chemin entre deux nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-700">Specification for how to round <c>value</c> if it is midway between two other numbers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-701">Arrondit une valeur à virgule flottante double précision à l'entier le plus proche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-701">Rounds a double-precision floating-point value to the nearest integer.</span>
          </span>
          <span data-ttu-id="45975-702">Un paramètre spécifie comment arrondir la valeur qui se trouve à égale distance des deux nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-702">A parameter specifies how to round the value if it is midway between two numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-703">Entier le plus proche de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-703">The integer nearest <paramref name="value" />.</span>
          </span>
          <span data-ttu-id="45975-704">Si <paramref name="value" /> se trouve à égale distance de deux entiers, l'un pair et l'autre impair, <paramref name="mode" /> détermine le nombre qui sera retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-704">If <paramref name="value" /> is halfway between two integers, one of which is even and the other odd, then <paramref name="mode" /> determines which of the two is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="45975-705">Pour des exemples et des informations d’utilisation complètes sur cela et d’autres surcharges de la `Round` (méthode), consultez le <xref:System.Math.Round%2A> page de référence.</span><span class="sxs-lookup"><span data-stu-id="45975-705">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="45975-706">
            <paramref name="mode" /> n'est pas une valeur valide de <see cref="T:System.MidpointRounding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-706">
              <paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="45975-707">
            <para>En raison de la perte de précision qui peut être dû à la représentation de valeurs décimales sous forme de nombres à virgule flottante ou des opérations arithmétiques sur les valeurs à virgule flottante, dans certains cas le <see cref="M:System.Math.Round(System.Double,System.MidpointRounding)" /> méthode peut ne pas semble arrondir les valeurs du milieu pour le plus proche de l’entier pair. Dans l’exemple suivant, étant donné que la valeur à virgule flottante.1 n’a aucune représentation binaire finie, le premier appel à la <see cref="M:System.Math.Round(System.Double)" /> méthode avec une valeur de 11,5 retourne 11 au lieu de 12.  [ ! code-csharp[System.Math.Round#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round5.cs#4)] [ ! code-vb[System.Math.Round#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round5.vb#4)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-707">
              <para>Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double,System.MidpointRounding)" /> method may not appear to round midpoint values to the nearest even integer. In the following example, because the floating-point value .1 has no finite binary representation, the first call to the <see cref="M:System.Math.Round(System.Double)" /> method with a value of 11.5 returns 11 instead of 12.  [!code-csharp[System.Math.Round#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round5.cs#4)] [!code-vb[System.Math.Round#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round5.vb#4)]</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : decimal * int * MidpointRounding -&gt; decimal" Usage="System.Math.Round (d, decimals, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-708">Nombre décimal à arrondir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-708">A decimal number to be rounded.</span>
          </span>
        </param>
        <param name="decimals">
          <span data-ttu-id="45975-709">Nombre de décimales de la valeur de retour.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-709">The number of decimal places in the return value.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="45975-710">Spécification sur la façon d’arrondir <c>d</c> s’il se trouve à mi-chemin entre deux nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-710">Specification for how to round <c>d</c> if it is midway between two other numbers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-711">Arrondit une valeur décimale au nombre de chiffres fractionnaires spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-711">Rounds a decimal value to a specified number of fractional digits.</span>
          </span>
          <span data-ttu-id="45975-712">Un paramètre spécifie comment arrondir la valeur qui se trouve à égale distance des deux nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-712">A parameter specifies how to round the value if it is midway between two numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-713">Nombre le plus proche de <paramref name="d" /> contenant un nombre de chiffres fractionnaires égal à <paramref name="decimals" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-713">The number nearest to <paramref name="d" /> that contains a number of fractional digits equal to <paramref name="decimals" />.</span>
          </span>
          <span data-ttu-id="45975-714">Si <paramref name="d" /> a moins de chiffres fractionnaires que <paramref name="decimals" />, <paramref name="d" /> est retourné sans modification.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-714">If <paramref name="d" /> has fewer fractional digits than <paramref name="decimals" />, <paramref name="d" /> is returned unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="45975-715">Pour des exemples et des informations d’utilisation complètes sur cela et d’autres surcharges de la `Round` (méthode), consultez le <xref:System.Math.Round%2A> page de référence.</span><span class="sxs-lookup"><span data-stu-id="45975-715">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="45975-716">
            <paramref name="decimals" /> est inférieur à 0 ou supérieur à 28.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-716">
              <paramref name="decimals" /> is less than 0 or greater than 28.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="45975-717">
            <paramref name="mode" /> n'est pas une valeur valide de <see cref="T:System.MidpointRounding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-717">
              <paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span>
          </span>
        </exception>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="45975-718">Le résultat est à l'extérieur de la plage d'un <see cref="T:System.Decimal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-718">The result is outside the range of a <see cref="T:System.Decimal" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, digits As Integer, mode As MidpointRounding) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, int digits, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : double * int * MidpointRounding -&gt; double" Usage="System.Math.Round (value, digits, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="digits" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-719">Nombre à virgule flottante double précision à arrondir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-719">A double-precision floating-point number to be rounded.</span>
          </span>
        </param>
        <param name="digits">
          <span data-ttu-id="45975-720">Nombre de chiffres fractionnaires de la valeur de retour.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-720">The number of fractional digits in the return value.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="45975-721">Spécification sur la façon d’arrondir <c>value</c> s’il se trouve à mi-chemin entre deux nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-721">Specification for how to round <c>value</c> if it is midway between two other numbers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-722">Arrondit une valeur à virgule flottante double précision au nombre de chiffres fractionnaires spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-722">Rounds a double-precision floating-point value to a specified number of fractional digits.</span>
          </span>
          <span data-ttu-id="45975-723">Un paramètre spécifie comment arrondir la valeur qui se trouve à égale distance des deux nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-723">A parameter specifies how to round the value if it is midway between two numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-724">Nombre le plus proche de <paramref name="value" /> contenant un nombre de chiffres fractionnaires égal à <paramref name="digits" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-724">The number nearest to <paramref name="value" /> that has a number of fractional digits equal to <paramref name="digits" />.</span>
          </span>
          <span data-ttu-id="45975-725">Si <paramref name="value" /> a moins de chiffres fractionnaires que <paramref name="digits" />, <paramref name="value" /> est retourné sans modification.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-725">If <paramref name="value" /> has fewer fractional digits than <paramref name="digits" />, <paramref name="value" /> is returned unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="45975-726">Pour des exemples et des informations d’utilisation complètes sur cela et d’autres surcharges de la `Round` (méthode), consultez le <xref:System.Math.Round%2A> page de référence.</span><span class="sxs-lookup"><span data-stu-id="45975-726">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="45975-727">
            <paramref name="digits" /> est inférieur à 0 ou supérieur à 15.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-727">
              <paramref name="digits" /> is less than 0 or greater than 15.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="45975-728">
            <paramref name="mode" /> n'est pas une valeur valide de <see cref="T:System.MidpointRounding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-728">
              <paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="45975-729">
            <para>En raison de la perte de précision qui peut être dû à la représentation de valeurs décimales sous forme de nombres à virgule flottante ou des opérations arithmétiques sur les valeurs à virgule flottante, dans certains cas le <see cref="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" /> méthode peut ne pas semble arrondir les valeurs du milieu comme spécifié par la <paramref name="mode" /> paramètre. Cela est illustré dans l’exemple suivant, où 2.135 est arrondi à 2.13 au lieu de 2.14. Cela se produit, car en interne la méthode multiplie <paramref name="value" /> par 10<sup>chiffres</sup>, et l’opération de multiplication dans ce cas souffre d’une perte de précision.  [ ! code-csharp[System.Math.Round#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round4.cs#3)] [ ! code-vb[System.Math.Round#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round4.vb#3)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-729">
              <para>Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" /> method may not appear to round midpoint values as specified by the <paramref name="mode" /> parameter. This is illustrated in the following example, where 2.135 is rounded to 2.13 instead of 2.14. This occurs because internally the method multiplies <paramref name="value" /> by 10<sup>digits</sup>, and the multiplication operation in this case suffers from a loss of precision.  [!code-csharp[System.Math.Round#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round4.cs#3)] [!code-vb[System.Math.Round#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round4.vb#3)]</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sign">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="45975-730">Retourne un entier qui indique le signe d’un nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-730">Returns an integer that indicates the sign of a number.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Decimal) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member Sign : decimal -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-731">Nombre décimal signé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-731">A signed decimal number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-732">Retourne un entier qui indique le signe d’un nombre décimal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-732">Returns an integer that indicates the sign of a decimal number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-733">Nombre qui indique le signe de <paramref name="value" />, comme indiqué dans le tableau suivant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-733">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span>
          </span>
          <span data-ttu-id="45975-734">
            <list type="table">
              <listheader>
                <term> Valeur de retour  </term>
                <description> Signification  </description>
              </listheader>
              <item>
                <term> -1  </term>
                <description>
                  <paramref name="value" /> est inférieur à zéro.  </description>
              </item>
              <item>
                <term> 0  </term>
                <description>
                  <paramref name="value" /> est égal à zéro.  </description>
              </item>
              <item>
                <term> 1  </term>
                <description>
                  <paramref name="value" /> est supérieur à zéro.  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-734">
              <list type="table">
                <listheader>
                  <term> Return value  </term>
                  <description> Meaning  </description>
                </listheader>
                <item>
                  <term> -1  </term>
                  <description>
                    <paramref name="value" /> is less than zero.  </description>
                </item>
                <item>
                  <term> 0  </term>
                  <description>
                    <paramref name="value" /> is equal to zero.  </description>
                </item>
                <item>
                  <term> 1  </term>
                  <description>
                    <paramref name="value" /> is greater than zero.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-735">L’exemple suivant montre comment utiliser le <xref:System.Math.Sign%28System.Decimal%29> méthode pour déterminer le signe d’un <xref:System.Decimal> valeur et l’afficher dans la console.</span><span class="sxs-lookup"><span data-stu-id="45975-735">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Decimal%29> method to determine the sign of a <xref:System.Decimal> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(double value);" />
      <MemberSignature Language="F#" Value="static member Sign : double -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-736">Nombre signé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-736">A signed number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-737">Retourne un entier qui indique le signe d’un nombre à virgule flottante double précision.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-737">Returns an integer that indicates the sign of a double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-738">Nombre qui indique le signe de <paramref name="value" />, comme indiqué dans le tableau suivant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-738">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span>
          </span>
          <span data-ttu-id="45975-739">
            <list type="table">
              <listheader>
                <term> Valeur de retour  </term>
                <description> Signification  </description>
              </listheader>
              <item>
                <term> -1  </term>
                <description>
                  <paramref name="value" /> est inférieur à zéro.  </description>
              </item>
              <item>
                <term> 0  </term>
                <description>
                  <paramref name="value" /> est égal à zéro.  </description>
              </item>
              <item>
                <term> 1  </term>
                <description>
                  <paramref name="value" /> est supérieur à zéro.  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-739">
              <list type="table">
                <listheader>
                  <term> Return value  </term>
                  <description> Meaning  </description>
                </listheader>
                <item>
                  <term> -1  </term>
                  <description>
                    <paramref name="value" /> is less than zero.  </description>
                </item>
                <item>
                  <term> 0  </term>
                  <description>
                    <paramref name="value" /> is equal to zero.  </description>
                </item>
                <item>
                  <term> 1  </term>
                  <description>
                    <paramref name="value" /> is greater than zero.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-740">L’exemple suivant montre comment utiliser le <xref:System.Math.Sign%28System.Double%29> méthode pour déterminer le signe d’un <xref:System.Double> valeur et l’afficher dans la console.</span><span class="sxs-lookup"><span data-stu-id="45975-740">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Double%29> method to determine the sign of a <xref:System.Double> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArithmeticException">
          <span data-ttu-id="45975-741">
            <paramref name="value" /> est égal à <see cref="F:System.Double.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-741">
              <paramref name="value" /> is equal to <see cref="F:System.Double.NaN" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Short) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(short value);" />
      <MemberSignature Language="F#" Value="static member Sign : int16 -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-742">Nombre signé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-742">A signed number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-743">Retourne un entier qui indique le signe d’un entier signé 16 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-743">Returns an integer that indicates the sign of a 16-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-744">Nombre qui indique le signe de <paramref name="value" />, comme indiqué dans le tableau suivant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-744">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span>
          </span>
          <span data-ttu-id="45975-745">
            <list type="table">
              <listheader>
                <term> Valeur de retour  </term>
                <description> Signification  </description>
              </listheader>
              <item>
                <term> -1  </term>
                <description>
                  <paramref name="value" /> est inférieur à zéro.  </description>
              </item>
              <item>
                <term> 0  </term>
                <description>
                  <paramref name="value" /> est égal à zéro.  </description>
              </item>
              <item>
                <term> 1  </term>
                <description>
                  <paramref name="value" /> est supérieur à zéro.  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-745">
              <list type="table">
                <listheader>
                  <term> Return value  </term>
                  <description> Meaning  </description>
                </listheader>
                <item>
                  <term> -1  </term>
                  <description>
                    <paramref name="value" /> is less than zero.  </description>
                </item>
                <item>
                  <term> 0  </term>
                  <description>
                    <paramref name="value" /> is equal to zero.  </description>
                </item>
                <item>
                  <term> 1  </term>
                  <description>
                    <paramref name="value" /> is greater than zero.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-746">L’exemple suivant montre comment utiliser le <xref:System.Math.Sign%28System.Int16%29> méthode pour déterminer le signe d’un <xref:System.Int16> valeur et l’afficher dans la console.</span><span class="sxs-lookup"><span data-stu-id="45975-746">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Int16%29> method to determine the sign of an <xref:System.Int16> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(int value);" />
      <MemberSignature Language="F#" Value="static member Sign : int -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-747">Nombre signé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-747">A signed number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-748">Retourne un entier qui indique le signe d’un entier signé 32 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-748">Returns an integer that indicates the sign of a 32-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-749">Nombre qui indique le signe de <paramref name="value" />, comme indiqué dans le tableau suivant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-749">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span>
          </span>
          <span data-ttu-id="45975-750">
            <list type="table">
              <listheader>
                <term> Valeur de retour  </term>
                <description> Signification  </description>
              </listheader>
              <item>
                <term> -1  </term>
                <description>
                  <paramref name="value" /> est inférieur à zéro.  </description>
              </item>
              <item>
                <term> 0  </term>
                <description>
                  <paramref name="value" /> est égal à zéro.  </description>
              </item>
              <item>
                <term> 1  </term>
                <description>
                  <paramref name="value" /> est supérieur à zéro.  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-750">
              <list type="table">
                <listheader>
                  <term> Return value  </term>
                  <description> Meaning  </description>
                </listheader>
                <item>
                  <term> -1  </term>
                  <description>
                    <paramref name="value" /> is less than zero.  </description>
                </item>
                <item>
                  <term> 0  </term>
                  <description>
                    <paramref name="value" /> is equal to zero.  </description>
                </item>
                <item>
                  <term> 1  </term>
                  <description>
                    <paramref name="value" /> is greater than zero.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-751">L’exemple suivant montre comment utiliser le <xref:System.Math.Sign%28System.Int32%29> méthode pour déterminer le signe d’un <xref:System.Int32> valeur et l’afficher dans la console.</span><span class="sxs-lookup"><span data-stu-id="45975-751">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Int32%29> method to determine the sign of an <xref:System.Int32> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(long value);" />
      <MemberSignature Language="F#" Value="static member Sign : int64 -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-752">Nombre signé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-752">A signed number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-753">Retourne un entier qui indique le signe d’un entier signé 64 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-753">Returns an integer that indicates the sign of a 64-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-754">Nombre qui indique le signe de <paramref name="value" />, comme indiqué dans le tableau suivant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-754">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span>
          </span>
          <span data-ttu-id="45975-755">
            <list type="table">
              <listheader>
                <term> Valeur de retour  </term>
                <description> Signification  </description>
              </listheader>
              <item>
                <term> -1  </term>
                <description>
                  <paramref name="value" /> est inférieur à zéro.  </description>
              </item>
              <item>
                <term> 0  </term>
                <description>
                  <paramref name="value" /> est égal à zéro.  </description>
              </item>
              <item>
                <term> 1  </term>
                <description>
                  <paramref name="value" /> est supérieur à zéro.  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-755">
              <list type="table">
                <listheader>
                  <term> Return value  </term>
                  <description> Meaning  </description>
                </listheader>
                <item>
                  <term> -1  </term>
                  <description>
                    <paramref name="value" /> is less than zero.  </description>
                </item>
                <item>
                  <term> 0  </term>
                  <description>
                    <paramref name="value" /> is equal to zero.  </description>
                </item>
                <item>
                  <term> 1  </term>
                  <description>
                    <paramref name="value" /> is greater than zero.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-756">L’exemple suivant montre comment utiliser le <xref:System.Math.Sign%28System.Int64%29> méthode pour déterminer le signe d’un <xref:System.Int64> valeur et l’afficher dans la console.</span><span class="sxs-lookup"><span data-stu-id="45975-756">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Int64%29> method to determine the sign of an <xref:System.Int64> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As SByte) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member Sign : sbyte -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-757">Nombre signé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-757">A signed number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-758">Retourne un entier qui indique le signe d’un entier signé 8 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-758">Returns an integer that indicates the sign of an 8-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-759">Nombre qui indique le signe de <paramref name="value" />, comme indiqué dans le tableau suivant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-759">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span>
          </span>
          <span data-ttu-id="45975-760">
            <list type="table">
              <listheader>
                <term> Valeur de retour  </term>
                <description> Signification  </description>
              </listheader>
              <item>
                <term> -1  </term>
                <description>
                  <paramref name="value" /> est inférieur à zéro.  </description>
              </item>
              <item>
                <term> 0  </term>
                <description>
                  <paramref name="value" /> est égal à zéro.  </description>
              </item>
              <item>
                <term> 1  </term>
                <description>
                  <paramref name="value" /> est supérieur à zéro.  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-760">
              <list type="table">
                <listheader>
                  <term> Return value  </term>
                  <description> Meaning  </description>
                </listheader>
                <item>
                  <term> -1  </term>
                  <description>
                    <paramref name="value" /> is less than zero.  </description>
                </item>
                <item>
                  <term> 0  </term>
                  <description>
                    <paramref name="value" /> is equal to zero.  </description>
                </item>
                <item>
                  <term> 1  </term>
                  <description>
                    <paramref name="value" /> is greater than zero.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-761">L’exemple suivant montre comment utiliser le <xref:System.Math.Sign%28System.SByte%29> méthode pour déterminer le signe d’un <xref:System.SByte> valeur et l’afficher dans la console.</span><span class="sxs-lookup"><span data-stu-id="45975-761">The following example demonstrates how to use the <xref:System.Math.Sign%28System.SByte%29> method to determine the sign of an <xref:System.SByte> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(float value);" />
      <MemberSignature Language="F#" Value="static member Sign : single -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-762">Nombre signé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-762">A signed number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-763">Retourne un entier qui indique le signe d’un nombre à virgule flottante simple précision.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-763">Returns an integer that indicates the sign of a single-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-764">Nombre qui indique le signe de <paramref name="value" />, comme indiqué dans le tableau suivant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-764">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span>
          </span>
          <span data-ttu-id="45975-765">
            <list type="table">
              <listheader>
                <term> Valeur de retour  </term>
                <description> Signification  </description>
              </listheader>
              <item>
                <term> -1  </term>
                <description>
                  <paramref name="value" /> est inférieur à zéro.  </description>
              </item>
              <item>
                <term> 0  </term>
                <description>
                  <paramref name="value" /> est égal à zéro.  </description>
              </item>
              <item>
                <term> 1  </term>
                <description>
                  <paramref name="value" /> est supérieur à zéro.  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-765">
              <list type="table">
                <listheader>
                  <term> Return value  </term>
                  <description> Meaning  </description>
                </listheader>
                <item>
                  <term> -1  </term>
                  <description>
                    <paramref name="value" /> is less than zero.  </description>
                </item>
                <item>
                  <term> 0  </term>
                  <description>
                    <paramref name="value" /> is equal to zero.  </description>
                </item>
                <item>
                  <term> 1  </term>
                  <description>
                    <paramref name="value" /> is greater than zero.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-766">L’exemple suivant montre comment utiliser le <xref:System.Math.Sign%28System.Single%29> méthode pour déterminer le signe d’un <xref:System.Single> valeur et l’afficher dans la console.</span><span class="sxs-lookup"><span data-stu-id="45975-766">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Single%29> method to determine the sign of a <xref:System.Single> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArithmeticException">
          <span data-ttu-id="45975-767">
            <paramref name="value" /> est égal à <see cref="F:System.Single.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-767">
              <paramref name="value" /> is equal to <see cref="F:System.Single.NaN" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static double Sin (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sin(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sin(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sin(double a);" />
      <MemberSignature Language="F#" Value="static member Sin : double -&gt; double" Usage="System.Math.Sin a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="45975-768">Angle, mesuré en radians.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-768">An angle, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-769">Retourne le sinus de l'angle spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-769">Returns the sine of the specified angle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-770">Sinus de <paramref name="a" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-770">The sine of <paramref name="a" />.</span>
          </span>
          <span data-ttu-id="45975-771">Si <paramref name="a" /> est égal à <see cref="F:System.Double.NaN" />, à <see cref="F:System.Double.NegativeInfinity" /> ou à <see cref="F:System.Double.PositiveInfinity" />, cette méthode retourne <see cref="F:System.Double.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-771">If <paramref name="a" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, this method returns <see cref="F:System.Double.NaN" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-772">L’angle, `a`, doit être en radians.</span><span class="sxs-lookup"><span data-stu-id="45975-772">The angle, `a`, must be in radians.</span></span> <span data-ttu-id="45975-773">Multiplier par <xref:System.Math.PI?displayProperty=nameWithType>/180 pour convertir des degrés en radians.</span><span class="sxs-lookup"><span data-stu-id="45975-773">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 <span data-ttu-id="45975-774">Les valeurs acceptables de `a` comprises entre -9223372036854775295 et 9223372036854775295 approximativement.</span><span class="sxs-lookup"><span data-stu-id="45975-774">Acceptable values of `a` range from approximately -9223372036854775295 to approximately 9223372036854775295.</span></span> <span data-ttu-id="45975-775">Pour les valeurs en dehors de cette plage, le <xref:System.Math.Sin%2A> méthode retourne `a` inchangé au lieu de lever une exception.</span><span class="sxs-lookup"><span data-stu-id="45975-775">For values outside of this range, the <xref:System.Math.Sin%2A> method returns `a` unchanged rather than throwing an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-776">L’exemple suivant utilise <xref:System.Math.Sin%2A> pour évaluer certaines identités trigonométriques pour des angles sélectionnés.</span><span class="sxs-lookup"><span data-stu-id="45975-776">The following example uses <xref:System.Math.Sin%2A> to evaluate certain trigonometric identities for selected angles.</span></span>  
  
 [!code-cpp[System.Math.SinCos#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinCos/CPP/sincos.cpp#1)]
 [!code-csharp[System.Math.SinCos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs#1)]
 [!code-vb[System.Math.SinCos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinCos/VB/sincos.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static double Sinh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sinh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sinh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sinh(double value);" />
      <MemberSignature Language="F#" Value="static member Sinh : double -&gt; double" Usage="System.Math.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-777">Angle, mesuré en radians.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-777">An angle, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-778">Retourne le sinus hyperbolique de l'angle spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-778">Returns the hyperbolic sine of the specified angle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-779">Sinus hyperbolique de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-779">The hyperbolic sine of <paramref name="value" />.</span>
          </span>
          <span data-ttu-id="45975-780">Si <paramref name="value" /> est égal à <see cref="F:System.Double.NegativeInfinity" />, <see cref="F:System.Double.PositiveInfinity" /> ou <see cref="F:System.Double.NaN" />, cette méthode retourne un <see cref="T:System.Double" /> égal à <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-780">If <paramref name="value" /> is equal to <see cref="F:System.Double.NegativeInfinity" />, <see cref="F:System.Double.PositiveInfinity" />, or <see cref="F:System.Double.NaN" />, this method returns a <see cref="T:System.Double" /> equal to <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-781">L’angle, `value`, doit être en radians.</span><span class="sxs-lookup"><span data-stu-id="45975-781">The angle, `value`, must be in radians.</span></span> <span data-ttu-id="45975-782">Multiplier par <xref:System.Math.PI?displayProperty=nameWithType>/180 pour convertir des degrés en radians.</span><span class="sxs-lookup"><span data-stu-id="45975-782">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-783">L’exemple suivant utilise <xref:System.Math.Sinh%2A> pour évaluer certaines identités hyperboliques pour des valeurs sélectionnées.</span><span class="sxs-lookup"><span data-stu-id="45975-783">The following example uses <xref:System.Math.Sinh%2A> to evaluate certain hyperbolic identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.SinhCosh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinhCosh/CPP/sinhcosh.cpp#1)]
 [!code-csharp[System.Math.SinhCosh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinhCosh/CS/sinhcosh.cs#1)]
 [!code-vb[System.Math.SinhCosh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinhCosh/VB/sinhcosh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static double Sqrt (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sqrt(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sqrt(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sqrt(double d);" />
      <MemberSignature Language="F#" Value="static member Sqrt : double -&gt; double" Usage="System.Math.Sqrt d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-784">Nombre dont la racine carrée doit être recherchée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-784">The number whose square root is to be found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-785">Retourne la racine carrée d'un nombre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-785">Returns the square root of a specified number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-786">Une des valeurs du tableau suivant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-786">One of the values in the following table.</span>
          </span>
          <span data-ttu-id="45975-787">
            <list type="table">
              <listheader>
                <term>
                  <paramref name="d" /> paramètre  </term>
                <description> Valeur de retour  </description>
              </listheader>
              <item>
                <term> Zéro ou positif  </term>
                <description> Racine carrée positive de <paramref name="d" />.  </description>
              </item>
              <item>
                <term> Négatif  </term>
                <description>
                  <see cref="F:System.Double.NaN" />
                </description>
              </item>
              <item>
                <term> Égal à <see cref="F:System.Double.NaN" /></term>
                <description>
                  <see cref="F:System.Double.NaN" />
                </description>
              </item>
              <item>
                <term> Égal à <see cref="F:System.Double.PositiveInfinity" /></term>
                <description>
                  <see cref="F:System.Double.PositiveInfinity" />
                </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-787">
              <list type="table">
                <listheader>
                  <term>
                    <paramref name="d" /> parameter  </term>
                  <description> Return value  </description>
                </listheader>
                <item>
                  <term> Zero or positive  </term>
                  <description> The positive square root of <paramref name="d" />.  </description>
                </item>
                <item>
                  <term> Negative  </term>
                  <description>
                    <see cref="F:System.Double.NaN" />
                  </description>
                </item>
                <item>
                  <term> Equals <see cref="F:System.Double.NaN" /></term>
                  <description>
                    <see cref="F:System.Double.NaN" />
                  </description>
                </item>
                <item>
                  <term> Equals <see cref="F:System.Double.PositiveInfinity" /></term>
                  <description>
                    <see cref="F:System.Double.PositiveInfinity" />
                  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45975-788">La racine carrée de la zone d’un carré représente la longueur de n’importe quel côté du carré.</span><span class="sxs-lookup"><span data-stu-id="45975-788">The square root of the area of a square represents the length of any side of the square.</span></span> <span data-ttu-id="45975-789">L’exemple suivant affiche la zone de certaines villes aux États-Unis et donne une impression de taille de chaque ville si elle a été représentée par un carré.</span><span class="sxs-lookup"><span data-stu-id="45975-789">The following example displays the area of some cities in the United States and gives an impression of each city's size if it were represented by a square.</span></span>  
  
 [!code-csharp[System.Math.Sqrt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.sqrt/cs/sqrt1.cs#1)]
 [!code-vb[System.Math.Sqrt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.sqrt/vb/sqrt1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Pow(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static double Tan (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tan(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Tan(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Tan(double a);" />
      <MemberSignature Language="F#" Value="static member Tan : double -&gt; double" Usage="System.Math.Tan a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="45975-790">Angle, mesuré en radians.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-790">An angle, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-791">Retourne la tangente de l'angle spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-791">Returns the tangent of the specified angle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-792">Tangente de <paramref name="a" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-792">The tangent of <paramref name="a" />.</span>
          </span>
          <span data-ttu-id="45975-793">Si <paramref name="a" /> est égal à <see cref="F:System.Double.NaN" />, à <see cref="F:System.Double.NegativeInfinity" /> ou à <see cref="F:System.Double.PositiveInfinity" />, cette méthode retourne <see cref="F:System.Double.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-793">If <paramref name="a" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, this method returns <see cref="F:System.Double.NaN" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-794">L’angle, `a`, doit être en radians.</span><span class="sxs-lookup"><span data-stu-id="45975-794">The angle, `a`, must be in radians.</span></span> <span data-ttu-id="45975-795">Multiplier par <xref:System.Math.PI?displayProperty=nameWithType>/180 pour convertir des degrés en radians.</span><span class="sxs-lookup"><span data-stu-id="45975-795">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-796">L’exemple suivant montre comment calculer la tangente d’un angle et l’afficher dans la console.</span><span class="sxs-lookup"><span data-stu-id="45975-796">The following example demonstrates how to calculate the tangent of an angle and display it to the console.</span></span>  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static double Tanh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tanh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Tanh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Tanh(double value);" />
      <MemberSignature Language="F#" Value="static member Tanh : double -&gt; double" Usage="System.Math.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45975-797">Angle, mesuré en radians.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-797">An angle, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-798">Retourne la tangente hyperbolique de l'angle spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-798">Returns the hyperbolic tangent of the specified angle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-799">Tangente hyperbolique de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-799">The hyperbolic tangent of <paramref name="value" />.</span>
          </span>
          <span data-ttu-id="45975-800">Si <paramref name="value" /> est égal à <see cref="F:System.Double.NegativeInfinity" />, cette méthode retourne -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-800">If <paramref name="value" /> is equal to <see cref="F:System.Double.NegativeInfinity" />, this method returns -1.</span>
          </span>
          <span data-ttu-id="45975-801">Si la valeur est égale à <see cref="F:System.Double.PositiveInfinity" />, cette méthode retourne 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-801">If value is equal to <see cref="F:System.Double.PositiveInfinity" />, this method returns 1.</span>
          </span>
          <span data-ttu-id="45975-802">Si <paramref name="value" /> est égal à <see cref="F:System.Double.NaN" />, cette méthode retourne <see cref="F:System.Double.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-802">If <paramref name="value" /> is equal to <see cref="F:System.Double.NaN" />, this method returns <see cref="F:System.Double.NaN" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-803">L’angle, `value`, doit être en radians.</span><span class="sxs-lookup"><span data-stu-id="45975-803">The angle, `value`, must be in radians.</span></span> <span data-ttu-id="45975-804">Multiplier par <xref:System.Math.PI?displayProperty=nameWithType>/180 pour convertir des degrés en radians.</span><span class="sxs-lookup"><span data-stu-id="45975-804">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-805">L’exemple suivant utilise <xref:System.Math.Tanh%2A> pour évaluer certaines identités tangentes hyperbolique de valeurs sélectionnées.</span><span class="sxs-lookup"><span data-stu-id="45975-805">The following example uses <xref:System.Math.Tanh%2A> to evaluate certain hyperbolic tangent identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.Tanh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Tanh/CPP/tanh.cpp#1)]
 [!code-csharp[System.Math.Tanh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Tanh/CS/tanh.cs#1)]
 [!code-vb[System.Math.Tanh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Tanh/VB/tanh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Truncate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="45975-806">Calcule la partie entière d'un nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-806">Calculates the integral part of a number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-807">Le nombre est arrondi à l’entier le plus proche vers zéro.</span><span class="sxs-lookup"><span data-stu-id="45975-807">The number is rounded to the nearest integer towards zero.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static decimal Truncate (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Truncate(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Truncate(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Truncate(System::Decimal d);" />
      <MemberSignature Language="F#" Value="static member Truncate : decimal -&gt; decimal" Usage="System.Math.Truncate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-808">Nombre à tronquer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-808">A number to truncate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-809">Calcule la partie entière d'un nombre décimal spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-809">Calculates the integral part of a specified decimal number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-810">Partie entière de <paramref name="d" />, c'est-à-dire le nombre qui reste après avoir ignoré tous les chiffres fractionnaires.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-810">The integral part of <paramref name="d" />; that is, the number that remains after any fractional digits have been discarded.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-811"><xref:System.Math.Truncate%2A> Arrondit `d` à l’entier le plus proche vers zéro.</span><span class="sxs-lookup"><span data-stu-id="45975-811"><xref:System.Math.Truncate%2A> rounds `d` to the nearest integer towards zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-812">L’exemple suivant appelle la <xref:System.Math.Truncate%28System.Decimal%29> méthode tronquer un nombre positif et négatif <xref:System.Decimal> valeur.</span><span class="sxs-lookup"><span data-stu-id="45975-812">The following example calls the <xref:System.Math.Truncate%28System.Decimal%29> method to truncate both a positive and a negative <xref:System.Decimal> value.</span></span>  
  
 [!code-csharp[System.Math.Truncate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Truncate/cs/Truncate1.cs#2)]
 [!code-vb[System.Math.Truncate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Truncate/vb/Truncate1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static double Truncate (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Truncate(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Truncate(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Truncate(double d);" />
      <MemberSignature Language="F#" Value="static member Truncate : double -&gt; double" Usage="System.Math.Truncate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="45975-813">Nombre à tronquer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-813">A number to truncate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45975-814">Calcule la partie entière d'un nombre à virgule flottante double précision spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-814">Calculates the integral part of a specified double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45975-815">Partie entière de <paramref name="d" />, c'est-à-dire le nombre qui reste après avoir ignoré tous les chiffres fractionnaires, ou l'une des valeurs indiquées dans le tableau suivant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-815">The integral part of <paramref name="d" />; that is, the number that remains after any fractional digits have been discarded, or one of the values listed in the following table.</span>
          </span>
          <span data-ttu-id="45975-816">
            <list type="table">
              <listheader>
                <term>
                  <paramref name="d" />
                </term>
                <description> Valeur de retour  </description>
              </listheader>
              <item>
                <term>
                  <see cref="F:System.Double.NaN" />
                </term>
                <description>
                  <see cref="F:System.Double.NaN" />
                </description>
              </item>
              <item>
                <term>
                  <see cref="F:System.Double.NegativeInfinity" />
                </term>
                <description>
                  <see cref="F:System.Double.NegativeInfinity" />
                </description>
              </item>
              <item>
                <term>
                  <see cref="F:System.Double.PositiveInfinity" />
                </term>
                <description>
                  <see cref="F:System.Double.PositiveInfinity" />
                </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="45975-816">
              <list type="table">
                <listheader>
                  <term>
                    <paramref name="d" />
                  </term>
                  <description> Return value  </description>
                </listheader>
                <item>
                  <term>
                    <see cref="F:System.Double.NaN" />
                  </term>
                  <description>
                    <see cref="F:System.Double.NaN" />
                  </description>
                </item>
                <item>
                  <term>
                    <see cref="F:System.Double.NegativeInfinity" />
                  </term>
                  <description>
                    <see cref="F:System.Double.NegativeInfinity" />
                  </description>
                </item>
                <item>
                  <term>
                    <see cref="F:System.Double.PositiveInfinity" />
                  </term>
                  <description>
                    <see cref="F:System.Double.PositiveInfinity" />
                  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45975-817"><xref:System.Math.Truncate%2A> Arrondit `d` à l’entier le plus proche vers zéro.</span><span class="sxs-lookup"><span data-stu-id="45975-817"><xref:System.Math.Truncate%2A> rounds `d` to the nearest integer towards zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45975-818">L’exemple suivant appelle la <xref:System.Math.Truncate%28System.Double%29> méthode tronquer un nombre positif et négatif <xref:System.Double> valeur.</span><span class="sxs-lookup"><span data-stu-id="45975-818">The following example calls the <xref:System.Math.Truncate%28System.Double%29> method to truncate both a positive and a negative <xref:System.Double> value.</span></span>  
  
 [!code-csharp[System.Math.Truncate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Truncate/cs/Truncate1.cs#1)]
 [!code-vb[System.Math.Truncate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Truncate/vb/Truncate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
      </Docs>
    </Member>
  </Members>
</Type>