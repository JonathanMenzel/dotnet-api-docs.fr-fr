<Type Name="Tuple&lt;T1,T2,T3,T4,T5&gt;" FullName="System.Tuple&lt;T1,T2,T3,T4,T5&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b8892b8b77252c6857095d2956d748a93694c9df" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48757431" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Tuple&lt;T1,T2,T3,T4,T5&gt; : IComparable, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Tuple`5&lt;T1, T2, T3, T4, T5&gt; extends System.Object implements class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.IComparable" />
  <TypeSignature Language="DocId" Value="T:System.Tuple`5" />
  <TypeSignature Language="VB.NET" Value="Public Class Tuple(Of T1, T2, T3, T4, T5)&#xA;Implements IComparable, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T1, typename T2, typename T3, typename T4, typename T5&gt;&#xA;public ref class Tuple : IComparable, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5&gt; = class&#xA;    interface IStructuralEquatable&#xA;    interface IStructuralComparable&#xA;    interface IComparable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T1" />
    <TypeParameter Name="T2" />
    <TypeParameter Name="T3" />
    <TypeParameter Name="T4" />
    <TypeParameter Name="T5" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T1">Type du premier composant du tuple.</typeparam>
    <typeparam name="T2">Type du second composant du tuple.</typeparam>
    <typeparam name="T3">Type du troisième composant du tuple.</typeparam>
    <typeparam name="T4">Type du quatrième composant du tuple.</typeparam>
    <typeparam name="T5">Type du cinquième composant du tuple.</typeparam>
    <summary>Représente un objet de 5 tuples, ou quintuple.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un tuple est une structure de données qui a un nombre spécifique et une séquence de valeurs. Le <xref:System.Tuple%605> classe représente un 5-tuple, ou quintuple, qui est un tuple qui a cinq composants.  
  
 Vous pouvez instancier un <xref:System.Tuple%605> objet en appelant le <xref:System.Tuple%605.%23ctor%2A> constructeur ou la méthode statique <xref:System.Tuple.Create%60%605%28%60%600%2C%60%601%2C%60%602%2C%60%603%2C%60%604%29?displayProperty=nameWithType> (méthode). Vous pouvez récupérer la valeur des composants du tuple à l’aide en lecture seule <xref:System.Tuple%605.Item1%2A>, <xref:System.Tuple%605.Item2%2A>, <xref:System.Tuple%605.Item3%2A>, <xref:System.Tuple%605.Item4%2A>, et <xref:System.Tuple%605.Item5%2A> propriétés de l’instance.  
  
 Tuples sont fréquemment utilisées dans quatre façons différentes :  
  
-   Pour représenter un jeu unique de données. Par exemple, un tuple peut représenter un enregistrement de base de données, et ses composants peuvent représenter des champs individuels de l’enregistrement.  
  
-   Pour fournir un accès facile aux et manipulation d’un jeu de données. L’exemple suivant définit un tableau de <xref:System.Tuple%605> objets qui contiennent les noms des rappels en cours d’exécution dans le football américain, le nombre de parties dans lequel ils jouées et le nombre de, nombre total d’yards acquises et déplacements évaluées au cours de ces jeux. Le tableau est passé à la `ComputeStatistics` (méthode), qui calcule le nombre de comporte par yards jeu, moyenne par yards jeu, moyenne par carry chaque back en cours d’exécution et nombre moyen d’essais par tentative.  
  
     [!code-csharp[System.Tuple\`5.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`5.class/cs/example1.cs#1)]
     [!code-vb[System.Tuple\`5.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`5.class/vb/example1.vb#1)]  
  
-   Pour retourner plusieurs valeurs à partir d’une méthode sans utiliser de `out` paramètres (en c#) ou `ByRef` paramètres (Visual Basic). Par exemple, l’exemple précédent retourne ses statistiques calculées, ainsi que le nom de l’acteur, dans un tableau de <xref:System.Tuple%605> objets.  
  
-   Pour passer les valeurs multiples dans une méthode via un paramètre unique. Par exemple, le <xref:System.Threading.Thread.Start%28System.Object%29?displayProperty=nameWithType> méthode possède un paramètre unique qui vous permet de fournir une valeur à la méthode que le thread exécute au démarrage. Si vous fournissez un <xref:System.Tuple%605> de l’objet en tant qu’argument de méthode, vous pouvez fournir la routine de démarrage du thread avec cinq éléments de données.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Tuple" />
    <altmember cref="T:System.Tuple`1" />
    <altmember cref="T:System.Tuple`2" />
    <altmember cref="T:System.Tuple`3" />
    <altmember cref="T:System.Tuple`4" />
    <altmember cref="T:System.Tuple`6" />
    <altmember cref="T:System.Tuple`7" />
    <altmember cref="T:System.Tuple`8" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Tuple (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T1 item1, !T2 item2, !T3 item3, !T4 item4, !T5 item5) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`5.#ctor(`0,`1,`2,`3,`4)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (item1 As T1, item2 As T2, item3 As T3, item4 As T4, item5 As T5)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);" />
      <MemberSignature Language="F#" Value="new Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5&gt; : 'T1 * 'T2 * 'T3 * 'T4 * 'T5 -&gt; Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5&gt;" Usage="new System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5&gt; (item1, item2, item3, item4, item5)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
        <Parameter Name="item4" Type="T4" />
        <Parameter Name="item5" Type="T5" />
      </Parameters>
      <Docs>
        <param name="item1">Valeur du premier composant du tuple.</param>
        <param name="item2">Valeur du second composant du tuple.</param>
        <param name="item3">Valeur du troisième composant du tuple.</param>
        <param name="item4">Valeur du quatrième composant du tuple.</param>
        <param name="item5">Valeur du cinquième composant du tuple.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Tuple`5" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez également utiliser la méthode statique <xref:System.Tuple.Create%60%605%28%60%600%2C%60%601%2C%60%602%2C%60%603%2C%60%604%29?displayProperty=nameWithType> méthode pour instancier un objet de 5 tuples sans devoir spécifier explicitement les types de ses composants. L’exemple suivant utilise le <xref:System.Tuple.Create%60%605%28%60%600%2C%60%601%2C%60%602%2C%60%603%2C%60%604%29?displayProperty=nameWithType> méthode pour instancier un 5-tuple dont le premier composant est de type <xref:System.String> et ses quatre composants restants sont de type <xref:System.Int32>.  
  
 [!code-csharp[System.Tuple.Create#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/create1.cs#9)]
 [!code-vb[System.Tuple.Create#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/create1.vb#9)]  
  
 Cela équivaut à l’appel suivant à la <xref:System.Tuple%605.%23ctor%2A> constructeur de classe.  
  
 [!code-csharp[System.Tuple.Create#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/create1.cs#10)]
 [!code-vb[System.Tuple.Create#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/create1.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`5.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="tuple.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à comparer avec cette instance.</param>
        <summary>Retourne une valeur qui indique si l'objet <see cref="T:System.Tuple`5" /> actuel est égal à un objet spécifié.</summary>
        <returns>
          <see langword="true" /> si l'instance actuelle est égale à l'objet spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `obj` paramètre est considéré comme égal à l’instance actuelle dans les conditions suivantes :  
  
-   Il s’agit une <xref:System.Tuple%605> objet.  
  
-   Ses cinq composants sont des mêmes types que l’instance actuelle.  
  
-   Ses cinq composants sont égales à celles de l’instance actuelle. L'égalité est déterminée par le comparateur d'égalité d'objet par défaut pour chaque composant.  
  
   
  
## Examples  
 L’exemple suivant définit un tableau d’objets de 5 tuples qui contiennent des données sur les températures de patients dans deux groupes de test. Le premier composant du tableau fournit le numéro du groupe de test, et le deuxième, troisième et cinquième composants fournissent la température d’un patient à des intervalles horaires. Le <xref:System.Tuple%605.Equals%28System.Object%29?displayProperty=nameWithType> méthode est appelée pour comparer chaque <xref:System.Tuple%605> objet avec tous les autres <xref:System.Tuple%605> objet. La sortie montre que le <xref:System.Tuple%605.Equals%2A> retourne de la méthode `true` uniquement lorsque toutes les cinq composants de la <xref:System.Tuple%605> objets ont des valeurs égales.  
  
 [!code-csharp[System.Tuple\`5.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`5.equals/cs/equals1.cs#1)]
 [!code-vb[System.Tuple\`5.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`5.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`5.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="tuple.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage pour l'objet <see cref="T:System.Tuple`5" /> actuel.</summary>
        <returns>Code de hachage d'un entier signé 32 bits.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item1">
      <MemberSignature Language="C#" Value="public T1 Item1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T1 Item1" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`5.Item1" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item1 As T1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T1 Item1 { T1 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item1 : 'T1" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5&gt;.Item1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T1</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du premier composant de l'objet <see cref="T:System.Tuple`5" /> actif.</summary>
        <value>Valeur du premier composant de l'objet <see cref="T:System.Tuple`5" /> actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez déterminer dynamiquement le type de la <xref:System.Tuple%605.Item1%2A> composant de deux manières :  
  
-   En appelant le `GetType` méthode sur la valeur retournée par la <xref:System.Tuple%605.Item1%2A> propriété.  
  
-   En récupérant le <xref:System.Type> objet qui représente le <xref:System.Tuple%605> de l’objet et en extrayant le premier élément du tableau retourné par son <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant définit un tableau de <xref:System.Tuple%605> objets dont les composants contiennent le nom d’un état dans les États-Unis, sa population en 1990 et 2000, l’évolution de sa population dans cette période de 10 ans et le pourcentage de modification de sa population. Il effectue une itération dans le tableau, puis affiche la valeur de chaque composant dans un tuple.  
  
 [!code-csharp[System.Tuple\`5.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`5.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`5.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`5.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item2">
      <MemberSignature Language="C#" Value="public T2 Item2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T2 Item2" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`5.Item2" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item2 As T2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T2 Item2 { T2 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item2 : 'T2" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5&gt;.Item2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T2</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du deuxième composant de l'objet <see cref="T:System.Tuple`5" /> actif.</summary>
        <value>Valeur du deuxième composant de l'objet <see cref="T:System.Tuple`5" /> actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez déterminer dynamiquement le type de la <xref:System.Tuple%604.Item2%2A> composant de deux manières :  
  
-   En appelant le `GetType` méthode sur la valeur retournée par la <xref:System.Tuple%604.Item2%2A> propriété.  
  
-   En récupérant le <xref:System.Type> objet qui représente le <xref:System.Tuple%604> de l’objet et en extrayant le deuxième élément du tableau retourné par son <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant définit un tableau de <xref:System.Tuple%605> objets dont les composants contiennent le nom d’un état dans les États-Unis, sa population en 1990 et 2000, l’évolution de sa population dans cette période de 10 ans et le pourcentage de modification de sa population. Il effectue une itération dans le tableau, puis affiche la valeur de chaque composant dans un tuple.  
  
 [!code-csharp[System.Tuple\`5.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`5.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`5.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`5.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item3">
      <MemberSignature Language="C#" Value="public T3 Item3 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T3 Item3" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`5.Item3" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item3 As T3" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T3 Item3 { T3 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item3 : 'T3" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5&gt;.Item3" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T3</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du troisième composant de l'objet <see cref="T:System.Tuple`5" /> actif.</summary>
        <value>Valeur du troisième composant de l'objet <see cref="T:System.Tuple`5" /> actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez déterminer dynamiquement le type de la <xref:System.Tuple%604.Item2%2A> composant de deux manières :  
  
-   En appelant le `GetType` méthode sur la valeur retournée par la <xref:System.Tuple%604.Item2%2A> propriété.  
  
-   En récupérant le <xref:System.Type> objet qui représente le <xref:System.Tuple%604> de l’objet et en extrayant le deuxième élément du tableau retourné par son <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant définit un tableau de <xref:System.Tuple%605> objets dont les composants contiennent le nom d’un état dans les États-Unis, sa population en 1990 et 2000, l’évolution de sa population dans cette période de 10 ans et le pourcentage de modification de sa population. Il effectue une itération dans le tableau, puis affiche la valeur de chaque composant dans un tuple.  
  
 [!code-csharp[System.Tuple\`5.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`5.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`5.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`5.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item4">
      <MemberSignature Language="C#" Value="public T4 Item4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T4 Item4" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`5.Item4" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item4 As T4" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T4 Item4 { T4 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item4 : 'T4" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5&gt;.Item4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T4</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du quatrième composant de l'objet <see cref="T:System.Tuple`5" /> actif.</summary>
        <value>Valeur du quatrième composant de l'objet <see cref="T:System.Tuple`5" /> actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez déterminer dynamiquement le type de la <xref:System.Tuple%604.Item2%2A> composant de deux manières :  
  
-   En appelant le `GetType` méthode sur la valeur retournée par la <xref:System.Tuple%604.Item2%2A> propriété.  
  
-   En récupérant le <xref:System.Type> objet qui représente le <xref:System.Tuple%604> de l’objet et en extrayant le deuxième élément du tableau retourné par son <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant définit un tableau de <xref:System.Tuple%605> objets dont les composants contiennent le nom d’un état dans les États-Unis, sa population en 1990 et 2000, l’évolution de sa population dans cette période de 10 ans et le pourcentage de modification de sa population. Il effectue une itération dans le tableau, puis affiche la valeur de chaque composant dans un tuple.  
  
 [!code-csharp[System.Tuple\`5.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`5.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`5.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`5.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item5">
      <MemberSignature Language="C#" Value="public T5 Item5 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T5 Item5" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`5.Item5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item5 As T5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T5 Item5 { T5 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item5 : 'T5" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5&gt;.Item5" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T5</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du cinquième composant de l'objet <see cref="T:System.Tuple`5" /> actif.</summary>
        <value>Valeur du cinquième composant de l'objet <see cref="T:System.Tuple`5" /> actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez déterminer dynamiquement le type de la <xref:System.Tuple%604.Item2%2A> composant de deux manières :  
  
-   En appelant le `GetType` méthode sur la valeur retournée par la <xref:System.Tuple%604.Item2%2A> propriété.  
  
-   En récupérant le <xref:System.Type> objet qui représente le <xref:System.Tuple%604> de l’objet et en extrayant le deuxième élément du tableau retourné par son <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant définit un tableau de <xref:System.Tuple%605> objets dont les composants contiennent le nom d’un état américain, sa population en 1990 et 2000, l’évolution de sa population dans cette période de 10 ans et le pourcentage de modification de sa population. Il effectue une itération dans le tableau, puis affiche la valeur de chaque composant dans un tuple.  
  
 [!code-csharp[System.Tuple\`5.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`5.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`5.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`5.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`5.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">Objet à comparer à l'instance actuelle.</param>
        <param name="comparer">Un objet qui fournit des règles personnalisées pour la comparaison.</param>
        <summary>Compare l'objet <see cref="T:System.Tuple`5" /> actif à un objet spécifié à l'aide d'un comparateur spécifié et retourne un entier qui indique si l'objet actif précède, suit ou se trouve à la même position que l'objet spécifié dans l'ordre de tri.</summary>
        <returns>Entier signé qui indique la position relative de cette instance et de <paramref name="other" /> dans l’ordre de tri, comme indiqué dans le tableau suivant.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Description  
 </description></listheader><item><term> Entier négatif 
 </term><description> Cette instance précède <paramref name="other" />.  
  
 </description></item><item><term> Zéro 
 </term><description> Cette instance et <paramref name="other" /> ont la même position dans l'ordre de tri.  
  
 </description></item><item><term> Entier positif 
 </term><description> Cette instance suit <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Tuple%605> est castée en interface <xref:System.Collections.IStructuralComparable>.  
  
 Bien que cette méthode peut être appelée directement, elle est généralement appelée par tri à la collection de méthodes qui incluent <xref:System.Collections.IComparer> paramètres pour classer les membres d’une collection. Par exemple, elle est appelée par le <xref:System.Array.Sort%28System.Array%2CSystem.Collections.IComparer%29?displayProperty=nameWithType> (méthode) et le <xref:System.Collections.SortedList.Add%2A> méthode d’un <xref:System.Collections.SortedList> objet est instancié à l’aide de la <xref:System.Collections.SortedList.%23ctor%28System.Collections.IComparer%29?displayProperty=nameWithType> constructeur.  
  
> [!CAUTION]
>  Le <xref:System.Tuple%605.System%23Collections%23IStructuralComparable%23CompareTo%2A> méthode est conçue pour une utilisation dans les opérations de tri. Elle ne doit pas être utilisée lors de l’objectif principal d’une comparaison consiste à déterminer si deux objets sont égaux. Pour déterminer si deux objets sont égales, appelez le <xref:System.Tuple%605.System%23Collections%23IStructuralEquatable%23Equals%28System.Object%2CSystem.Collections.IEqualityComparer%29> (méthode).  
  
   
  
## Examples  
 L’exemple suivant crée un tableau de <xref:System.Tuple%605> les objets qui contiennent des données de statistiques de carrière pour les rappels en cours d’exécution de football américain professionnel. Du 5-tuple est composé du nom du joueur, le nombre de parties dans lequel il a joué, le nombre de tentatives, ou comporte le nombre total d’yards acquise, et le nombre d’essais. L’exemple affiche les composants de chaque tuple dans le tableau en ordre non trié, trie le tableau, puis appelle <xref:System.Tuple%605.ToString%2A> pour afficher chaque tuple dans un ordre trié. Pour trier le tableau, l’exemple définit un générique `YardsGained` classe qui implémente le <xref:System.Collections.IComparer> interface et trie le <xref:System.Tuple%605> objets dans l’ordre décroissant par la valeur de leur quatrième composant (yards acquises) plutôt que par leur premier composant. Notez que l’exemple n’appelle pas directement la <xref:System.Tuple%605.System%23Collections%23IStructuralComparable%23CompareTo%2A> (méthode). Cette méthode est appelée implicitement par la <xref:System.Array.Sort%28System.Array%2CSystem.Collections.IComparer%29?displayProperty=nameWithType> méthode pour chaque élément du tableau.  
  
 [!code-csharp[System.Tuple\`5.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`5.compareto/cs/compareto2.cs#2)]
 [!code-vb[System.Tuple\`5.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`5.compareto/vb/compareto2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="other" /> n’est pas un objet <see cref="T:System.Tuple`5" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`5.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">Objet à comparer avec cette instance.</param>
        <param name="comparer">Un objet qui définit la méthode à utiliser pour évaluer si les deux objets sont égaux.</param>
        <summary>Retourne une valeur qui indique si l'objet <see cref="T:System.Tuple`5" /> actif est égal à un objet spécifié selon une méthode de comparaison spécifiée.</summary>
        <returns>
          <see langword="true" /> si l'instance actuelle est égale à l'objet spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Tuple%605> est castée en interface <xref:System.Collections.IStructuralEquatable>.  
  
 Le <xref:System.Collections.IEqualityComparer.Equals%2A?displayProperty=nameWithType> implémentation est appelée uniquement si `other` n’est pas `null`, et si elle peut être casté (en c#) ou converti (en Visual Basic) en un <xref:System.Tuple%605> objet dont les composants sont des mêmes types que l’instance actuelle. Le <xref:System.Tuple%605.System%23Collections%23IStructuralEquatable%23Equals%28System.Object%2CSystem.Collections.IEqualityComparer%29> passe en premier (méthode) le <xref:System.Tuple%605.Item1%2A> les valeurs de la <xref:System.Tuple%605> objets à comparer à la <xref:System.Collections.IEqualityComparer.Equals%2A?displayProperty=nameWithType> implémentation. Si cet appel de méthode retourne `true`, la méthode est appelée à nouveau et passée le <xref:System.Tuple%605.Item2%2A> les valeurs des deux <xref:System.Tuple%605> objets. Ce processus se poursuit jusqu'à ce que l’appel de méthode retourne `false` lorsqu’il compare une paire spécifique de `Item` valeurs ou les deux <xref:System.Tuple%605.Item5%2A> valeurs sont passées à la méthode.  
  
   
  
## Examples  
 L'exemple suivant définit une classe `DoubleComparer` qui implémente l'interface <xref:System.Collections.IEqualityComparer>. L’exemple instancie deux <xref:System.Tuple%605> convertit des objets à l’aide d’un générateur de nombres aléatoires pour remplir leur deuxième au cinquième composants, la première instance à un <xref:System.Collections.IStructuralEquatable> interface, puis utilise un `DoubleComparer` objet à tester les deux <xref:System.Tuple%605>l’égalité approximative des objets.  
  
 [!code-csharp[System.Tuple\`5.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`5.equals/cs/equals2.cs#2)]
 [!code-vb[System.Tuple\`5.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`5.equals/vb/equals2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`5.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Objet dont la méthode <see cref="M:System.Collections.IEqualityComparer.GetHashCode(System.Object)" /> calcule le code de hachage de l'objet <see cref="T:System.Tuple`5" /> actuel.</param>
        <summary>Calcule le code de hachage pour l'objet <see cref="T:System.Tuple`5" /> actif à l'aide d'une méthode de calcul spécifiée.</summary>
        <returns>Code de hachage d'un entier signé 32 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Tuple%605> est castée en interface <xref:System.Collections.IStructuralEquatable>.  
  
 La méthode encapsule simplement un appel à la `comparer` l’objet <xref:System.Collections.IEqualityComparer.GetHashCode%2A?displayProperty=nameWithType> implémentation.  
  
 L’algorithme utilisé pour calculer le code de hachage doit retourner le même code de hachage pour deux <xref:System.Tuple%605> les objets qui sont considérées comme égales.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`5.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à comparer à l'instance actuelle.</param>
        <summary>Compare l’objet <see cref="T:System.Tuple`5" /> actuel à un objet spécifié et renvoie un entier qui indique si l’objet actuel est avant, après ou à la même position que l’objet spécifié dans l’ordre de tri.</summary>
        <returns>Entier signé qui indique la position relative de cette instance et de <paramref name="obj" /> dans l’ordre de tri, comme indiqué dans le tableau suivant.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Description  
 </description></listheader><item><term> Entier négatif 
 </term><description> Cette instance précède <paramref name="obj" />.  
  
 </description></item><item><term> Zéro 
 </term><description> Cette instance et <paramref name="obj" /> ont la même position dans l'ordre de tri.  
  
 </description></item><item><term> Entier positif 
 </term><description> Cette instance suit <paramref name="obj" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Tuple%605> est castée en interface <xref:System.IComparable>.  
  
 Cette méthode fournit le <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> implémentation pour la <xref:System.Tuple%605> classe. Bien que la méthode peut être appelée directement, elle est généralement appelée par les surcharges par défaut de tri à la collection de méthodes, telles que <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> et <xref:System.Collections.SortedList.Add%2A?displayProperty=nameWithType>, pour classer les membres d’une collection.  
  
> [!CAUTION]
>  Le <xref:System.Tuple%605.System%23IComparable%23CompareTo%2A> méthode est conçue pour une utilisation dans les opérations de tri. Elle ne doit pas être utilisée lors de l’objectif principal d’une comparaison consiste à déterminer si deux objets sont égaux. Pour déterminer si deux objets sont égales, appelez le <xref:System.Tuple%605.Equals%28System.Object%29?displayProperty=nameWithType> (méthode).  
  
 Le <xref:System.Tuple%605.System%23IComparable%23CompareTo%28System.Object%29> méthode utilise le comparateur d’objet par défaut pour comparer chaque composant.  
  
   
  
## Examples  
 L’exemple suivant crée un tableau de <xref:System.Tuple%605> les objets qui contiennent des statistiques de carrière pour les rappels en cours d’exécution de football américain professionnel. Les cinq composants se composent du nom du joueur, le nombre de parties dans lequel il a joué, le nombre de tentatives, ou comporte le nombre total d’yards acquise, et le nombre d’essais. L’exemple affiche les composants de chaque tuple dans le tableau en ordre non trié, trie le tableau, puis appelle <xref:System.Tuple%605.ToString%2A> pour afficher chaque tuple dans un ordre trié. La sortie montre que le tableau a été trié par nom, qui est le premier composant. Notez que l’exemple n’appelle pas directement la <xref:System.Tuple%605.System%23IComparable%23CompareTo%2A> (méthode). Cette méthode est appelée implicitement par la <xref:System.Array.Sort%28System.Array%29> méthode pour chaque élément du tableau.  
  
 [!code-csharp[System.Tuple\`5.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`5.compareto/cs/compareto1.cs#1)]
 [!code-vb[System.Tuple\`5.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`5.compareto/vb/compareto1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> n’est pas un objet <see cref="T:System.Tuple`5" />.</exception>
        <altmember cref="M:System.Tuple`5.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.CompilerServices.ITuple.Item">
      <MemberSignature Language="C#" Value="object System.Runtime.CompilerServices.ITuple.Item[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Runtime.CompilerServices.ITuple.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`5.System#Runtime#CompilerServices#ITuple#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Item(index As Integer) As Object Implements ITuple.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Runtime::CompilerServices::ITuple::Item[int] { System::Object ^ get(int index); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.CompilerServices.ITuple.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.CompilerServices.ITuple.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de l’élément <see langword="Tuple" /> spécifié. <c>index</c> peut être compris entre 0 et 4.</param>
        <summary>Obtient la valeur de l’élément <see langword="Tuple" /> spécifié.</summary>
        <value>Valeur de l’élément <see langword="Tuple" /> à la position spécifiée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Tuple%605.System%23Runtime%23CompilerServices%23ITuple%23Item%2A?displayProperty=nameWithType> propriété est une implémentation d’interface explicite. Pour l’appeler, vous devez effectuer un cast ou convertir le <xref:System.Tuple%605> de l’objet à un <xref:System.Runtime.CompilerServices.ITuple> objet d’interface.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> est inférieur à 0 ou supérieur à 4.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.CompilerServices.ITuple.Length">
      <MemberSignature Language="C#" Value="int System.Runtime.CompilerServices.ITuple.Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Runtime.CompilerServices.ITuple.Length" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`5.System#Runtime#CompilerServices#ITuple#Length" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Length As Integer Implements ITuple.Length" />
      <MemberSignature Language="C++ CLI" Value="property int System::Runtime::CompilerServices::ITuple::Length { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.CompilerServices.ITuple.Length" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.CompilerServices.ITuple.Length</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d’éléments dans <see langword="Tuple" />.</summary>
        <value>5, le nombre d’éléments dans un objet <see cref="T:System.Tuple`5" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Tuple%605.System%23Runtime%23CompilerServices%23ITuple%23Length%2A> propriété est une implémentation d’interface explicite. Pour l’appeler, vous devez effectuer un cast ou convertir le <xref:System.Tuple%605> de l’objet à un <xref:System.Runtime.CompilerServices.ITuple> objet d’interface.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`5.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="tuple.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une chaîne qui représente la valeur de cette instance <see cref="T:System.Tuple`5" />.</summary>
        <returns>Représentation sous forme de chaîne de cet objet <see cref="T:System.Tuple`5" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chaîne retournée par cette méthode prend la forme (*Item1*, *Item2*, *Item3*, *Item4*, `Item5`), où *Item1*, *Item2*, *Item3*, *Item4*, et `Item5` représentent les valeurs de la <xref:System.Tuple%605.Item1%2A>, <xref:System.Tuple%605.Item2%2A>, <xref:System.Tuple%605.Item3%2A>, <xref:System.Tuple%605.Item4%2A>, et <xref:System.Tuple%605.Item5%2A> propriétés, respectivement. Si une des valeurs de propriété est `null`, il est représenté en tant que <xref:System.String.Empty?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.Tuple%605.ToString%2A> (méthode). Il affiche un tableau d’objets de 5 tuples qui contiennent le nom d’un état aux États-Unis, sa population en 1990 et 2000, l’évolution de sa population dans cette période de 10 ans et le taux de modification de la population annuel.  
  
 [!code-csharp[System.Tuple\`5.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`5.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Tuple\`5.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`5.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>