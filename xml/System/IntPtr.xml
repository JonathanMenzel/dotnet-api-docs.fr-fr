<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="IntPtr.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e344e59-9d8e-481b-978a-09f2e01be86c560c7563290bc2d4237f4521628265386b3920ad.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">560c7563290bc2d4237f4521628265386b3920ad</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3295b6cc303a611a73a84c4b27f9da792ad0d</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/26/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IntPtr">
          <source>A platform-specific type that is used to represent a pointer or a handle.</source>
          <target state="translated">Type spécifique à la plateforme, utilisé pour représenter un pointeur ou un handle.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> type is designed to be an integer whose size is platform-specific.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> type est conçu pour être un entier dont la taille est spécifique à la plateforme.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>That is, an instance of this type is expected to be 32-bits on 32-bit hardware and operating systems, and 64-bits on 64-bit hardware and operating systems.</source>
          <target state="translated">Autrement dit, une instance de ce type est censée être de matériel 32 bits et les systèmes d’exploitation 32 bits et 64 bits sur les systèmes d’exploitation et du matériel 64 bits.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> type can be used by languages that support pointers, and as a common means of referring to data between languages that do and do not support pointers.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> type peut être utilisé par les langages qui prennent en charge les pointeurs et comme un moyen commun de faire référence à des données entre les langages qui et ne prennent pas en charge les pointeurs.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source><ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> objects can also be used to hold handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> objets peuvent également être utilisés pour contenir des handles.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>For example, instances of <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> are used extensively in the <ph id="ph2">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> class to hold file handles.</source>
          <target state="translated">Par exemple, les instances de <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> sont largement utilisées dans les <ph id="ph2">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> classe pour contenir les descripteurs de fichiers.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> type is CLS-compliant, while the <ph id="ph2">&lt;xref:System.UIntPtr&gt;</ph> type is not.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> type est conforme CLS, alors que le <ph id="ph2">&lt;xref:System.UIntPtr&gt;</ph> type n’est pas.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>Only the <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> type is used in the common language runtime.</source>
          <target state="translated">Uniquement les <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> type est utilisé dans le common language runtime.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The <ph id="ph1">&lt;xref:System.UIntPtr&gt;</ph> type is provided mostly to maintain architectural symmetry with the <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> type.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.UIntPtr&gt;</ph> type est fourni principalement pour assurer une symétrie architecturale avec le <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> type.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>This type implements the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface.</source>
          <target state="translated">Ce type implémente le <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The following example uses managed pointers to reverse the characters in an array.</source>
          <target state="translated">L’exemple suivant utilise des pointeurs managés à inverser les caractères dans un tableau.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>After it initializes a <ph id="ph1">&lt;xref:System.String&gt;</ph> object and gets its length, it does the following:</source>
          <target state="translated">Une fois qu’il initialise un <ph id="ph1">&lt;xref:System.String&gt;</ph> de l’objet et obtient sa longueur, il effectue les opérations suivantes :</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>Calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType&gt;</ph> method to copy the Unicode string to unmanaged memory as an ANSI (one-byte) character.</source>
          <target state="translated">Appelle la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType&gt;</ph> méthode pour copier la chaîne Unicode à la mémoire non managée comme caractère ANSI (un octet).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The method returns an <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> object that points to the beginning of the unmanaged string.</source>
          <target state="translated">La méthode retourne un <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> objet qui pointe vers le début de la chaîne non managée.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte.</source>
          <target state="translated">L’exemple Visual Basic utilise ce pointeur directement. dans les exemples C++ et c#, il est converti en un pointeur vers un octet.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>Calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType&gt;</ph> method to allocate the same number of bytes as the unmanaged string occupies.</source>
          <target state="translated">Appelle la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType&gt;</ph> méthode pour allouer le même nombre d’octets qu’occupe de la chaîne non managée.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The method returns an <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> object that points to the beginning of the unmanaged block of memory.</source>
          <target state="translated">La méthode retourne un <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> objet qui pointe vers le début du bloc de mémoire non managé.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte.</source>
          <target state="translated">L’exemple Visual Basic utilise ce pointeur directement. dans les exemples C++ et c#, il est converti en un pointeur vers un octet.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The Visual Basic example defines a variable named <ph id="ph1">`offset`</ph> that is equal to the length of the ANSI string.</source>
          <target state="translated">L’exemple Visual Basic définit une variable nommée <ph id="ph1">`offset`</ph> est égal à la longueur de la chaîne ANSI.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>It is used to determine the offset into unmanaged memory to which the next charter in the ANSI string is copied.</source>
          <target state="translated">Il est utilisé pour déterminer l’offset dans la mémoire non managée vers laquelle la charte suivante dans la chaîne ANSI est copiée.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>Because its starting value is the length of the string, the copy operation will copy a character from the start of the string to the end of the memory block.</source>
          <target state="translated">Étant donné que sa valeur de départ est la longueur de la chaîne, l’opération de copie copie un caractère à partir du début de la chaîne à la fin du bloc de mémoire.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The C# and C++ examples call the <ph id="ph1">&lt;xref:System.IntPtr.ToPointer%2A&gt;</ph> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and they add one less than the length of the string to the starting address of the ANSI string.</source>
          <target state="translated">L’appel d’exemples c# et C++ le <ph id="ph1">&lt;xref:System.IntPtr.ToPointer%2A&gt;</ph> méthode pour obtenir un pointeur non managé à l’adresse de départ de la chaîne et le bloc non managé de la mémoire, et ils ajoutent un inférieur à la longueur de la chaîne à l’adresse de départ de la chaîne ANSI.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block.</source>
          <target state="translated">Étant donné que le pointeur de chaîne non managée pointe maintenant à la fin de la chaîne, l’opération de copie copie un caractère à partir de la fin de la chaîne au début du bloc de mémoire.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>Uses a loop to copy each character from the string to the unmanaged block of memory.</source>
          <target state="translated">Utilise une boucle pour copier chaque caractère de la chaîne pour le bloc de mémoire non managée.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The Visual Basic example calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to read the byte (or one-byte character) at a specified offset from the managed pointer to the ANSI string.</source>
          <target state="translated">L’exemple Visual Basic appelle le <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> méthode pour lire les octets (ou un octet caractère) à l’offset spécifié à partir du pointeur managé à la chaîne ANSI.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The offset is incremented with each iteration of the loop.</source>
          <target state="translated">Le décalage est incrémenté à chaque itération de la boucle.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%28System.IntPtr%2CSystem.Int32%2CSystem.Byte%29?displayProperty=nameWithType&gt;</ph> method to write the byte to the memory address defined by the starting address of the unmanaged block of memory plus <ph id="ph2">`offset`</ph>.</source>
          <target state="translated">Il appelle ensuite la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%28System.IntPtr%2CSystem.Int32%2CSystem.Byte%29?displayProperty=nameWithType&gt;</ph> méthode pour écrire les octets à l’adresse mémoire défini par l’adresse de début du bloc non managé de mémoire plu <ph id="ph2">`offset`</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>It then decrements <ph id="ph1">`offset`</ph>.</source>
          <target state="translated">Décrémente ensuite <ph id="ph1">`offset`</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The C# and C++ examples perform the copy operation, then decrement the pointer to the address of the next location in the unmanaged ANSI string and increment the pointer to the next address in the unmanaged block.</source>
          <target state="translated">Les exemples c# et C++ effectuer l’opération de copie, puis décrémentent le pointeur vers l’adresse de l’emplacement suivant dans la chaîne ANSI non managée et le pointeur vers l’adresse suivante dans le bloc non managé.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>All examples call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType&gt;</ph> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated">Tous les exemples appellent la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType&gt;</ph> pour convertir le bloc de mémoire non managée qui contient la chaîne ANSI copiée Unicode managé <ph id="ph2">&lt;xref:System.String&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>After displaying the original and reversed strings, all examples call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory.</source>
          <target state="translated">Après avoir affiché les chaînes d’origine et inversées, tous les exemples appellent le <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph> méthode pour libérer la mémoire allouée pour la chaîne ANSI non managée et le bloc de mémoire non managée.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>This type is thread safe.</source>
          <target state="translated">Ce type est thread-safe.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="T:System.IntPtr">
          <source>Initializes a new instance of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</source>
          <target state="translated">Initialise une nouvelle instance de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.IntPtr.#ctor(System.Int32)">
          <source>A pointer or handle contained in a 32-bit signed integer.</source>
          <target state="translated">Pointeur ou handle contenu dans un entier 32 bits signé.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.IntPtr.#ctor(System.Int32)">
          <source>Initializes a new instance of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> using the specified 32-bit pointer or handle.</source>
          <target state="translated">Initialise une nouvelle instance de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> à l'aide du pointeur ou handle 32 bits spécifié.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.IntPtr.#ctor(System.Int64)">
          <source>A pointer or handle contained in a 64-bit signed integer.</source>
          <target state="translated">Pointeur ou handle contenu dans un entier 64 bits signé.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.IntPtr.#ctor(System.Int64)">
          <source>Initializes a new instance of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> using the specified 64-bit pointer.</source>
          <target state="translated">Initialise une nouvelle instance de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> à l'aide du pointeur 64 bits spécifié.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.#ctor(System.Int64)">
          <source>An exception is only thrown if the value of <ph id="ph1">`value`</ph> requires more bits than the current platform supports.</source>
          <target state="translated">Une exception est levée uniquement si la valeur de <ph id="ph1">`value`</ph> requiert plus de bits que le prend en charge de plateforme actuelle.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.IntPtr.#ctor(System.Int64)">
          <source>On a 32-bit platform, <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is too large or too small to represent as an <ph id="ph2">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</source>
          <target state="translated">Sur une plateforme 32 bits, <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est trop élevé ou trop bas pour être représenté en tant que <ph id="ph2">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.IntPtr.#ctor(System.Void*)">
          <source>A pointer to an unspecified type.</source>
          <target state="translated">Pointeur vers un type non spécifié.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.IntPtr.#ctor(System.Void*)">
          <source>Initializes a new instance of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> using the specified pointer to an unspecified type.</source>
          <target state="translated">Initialise une nouvelle instance de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> à l'aide du pointeur spécifié vers un type non spécifié.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.#ctor(System.Void*)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.#ctor(System.Void*)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Add(System.IntPtr,System.Int32)">
          <source>The pointer to add the offset to.</source>
          <target state="translated">Pointeur auquel ajouter l'offset.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Add(System.IntPtr,System.Int32)">
          <source>The offset to add.</source>
          <target state="translated">Offset à ajouter.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Add(System.IntPtr,System.Int32)">
          <source>Adds an offset to the value of a pointer.</source>
          <target state="translated">Ajoute un offset à la valeur d'un pointeur.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Add(System.IntPtr,System.Int32)">
          <source>A new pointer that reflects the addition of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> to <ph id="ph2">&lt;paramref name="pointer" /&gt;</ph>.</source>
          <target state="translated">Nouveau pointeur qui reflète l'ajout d'un <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> au <ph id="ph2">&lt;paramref name="pointer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.Add(System.IntPtr,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IntPtr.Add%2A&gt;</ph> method does not throw an exception if the result is too large to represent as a pointer on the specified platform.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IntPtr.Add%2A&gt;</ph> méthode ne lève pas d’exception si le résultat est trop volumineux pour être représenté comme un pointeur sur la plateforme spécifiée.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.Add(System.IntPtr,System.Int32)">
          <source>Instead, the addition operation is performed in an unchecked context.</source>
          <target state="translated">Au lieu de cela, l’opération d’addition est effectuée dans un contexte non vérifié.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.Add(System.IntPtr,System.Int32)">
          <source>Languages that do not support operator overloading or custom operators can use this method to add an offset to the value of a pointer.</source>
          <target state="translated">Les langages qui ne prennent pas en charge la surcharge d’opérateur ou les opérateurs personnalisés peuvent utiliser cette méthode pour ajouter un offset à la valeur d’un pointeur.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.Add(System.IntPtr,System.Int32)">
          <source>The following example instantiates an <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> object that points to the beginning of a ten-element array, and then calls the <ph id="ph2">&lt;xref:System.IntPtr.Add%2A&gt;</ph> method to iterate the elements in the array.</source>
          <target state="translated">L’exemple suivant instancie un <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> objet qui pointe vers le début d’un tableau de dix éléments, puis appelle la <ph id="ph2">&lt;xref:System.IntPtr.Add%2A&gt;</ph> pour parcourir les éléments du tableau.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Equals(System.Object)">
          <source>An object to compare with this instance or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objet à comparer à cette instance ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Equals(System.Object)">
          <source>Returns a value indicating whether this instance is equal to a specified object.</source>
          <target state="translated">Retourne une valeur indiquant si cette instance équivaut à un objet spécifié.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> is an instance of <ph id="ph3">&lt;see cref="T:System.IntPtr" /&gt;</ph> and equals the value of this instance; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> est une instance de <ph id="ph3">&lt;see cref="T:System.IntPtr" /&gt;</ph> et est égal à la valeur de cette instance ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.IntPtr.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Retourne le code de hachage de cette instance.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.IntPtr.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Code de hachage d'un entier signé 32 bits.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>The pointer to add the offset to.</source>
          <target state="translated">Pointeur auquel ajouter l'offset.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>The offset to add.</source>
          <target state="translated">Offset à ajouter.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>Adds an offset to the value of a pointer.</source>
          <target state="translated">Ajoute un offset à la valeur d'un pointeur.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>A new pointer that reflects the addition of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> to <ph id="ph2">&lt;paramref name="pointer" /&gt;</ph>.</source>
          <target state="translated">Nouveau pointeur qui reflète l'ajout d'un <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> au <ph id="ph2">&lt;paramref name="pointer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IntPtr.op_Addition%2A&gt;</ph> method defines the addition operation for <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> objects.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IntPtr.op_Addition%2A&gt;</ph> méthode définit l’opération d’addition pour <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>It enables code such as the following.</source>
          <target state="translated">Il permet de code semblable au suivant.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.IntPtr.Add%2A&gt;</ph> method instead.</source>
          <target state="translated">Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <ph id="ph1">&lt;xref:System.IntPtr.Add%2A&gt;</ph> méthode à la place.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>The addition operation does not throw an exception if the result is too large to represent as a pointer on the specified platform.</source>
          <target state="translated">L’opération d’addition ne lève pas une exception si le résultat est trop volumineux pour être représenté comme un pointeur sur la plateforme spécifiée.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>Instead, it is performed in an unchecked context.</source>
          <target state="translated">Au lieu de cela, elle est effectuée dans un contexte non vérifié.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.IntPtr.Add%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">La méthode équivalente pour cet opérateur est <ph id="ph1">&lt;xref:System.IntPtr.Add%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)">
          <source>The first pointer or handle to compare.</source>
          <target state="translated">Premier pointeur ou handle à comparer.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)">
          <source>The second pointer or handle to compare.</source>
          <target state="translated">Second pointeur ou handle à comparer.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)">
          <source>Determines whether two specified instances of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> are equal.</source>
          <target state="translated">Détermine si deux instances spécifiées de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> sont égales.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value1" /&gt;</ph> equals <ph id="ph3">&lt;paramref name="value2" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="value1" /&gt;</ph> est égal à <ph id="ph3">&lt;paramref name="value2" /&gt;</ph> ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">La méthode équivalente pour cet opérateur est <ph id="ph1">&lt;xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="T:System.IntPtr">
          <source>Converts a specified data type to an <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> value, or an <ph id="ph2">&lt;see cref="T:System.IntPtr" /&gt;</ph> value to a specified data type.</source>
          <target state="translated">Convertit un type de données spécifié en valeur <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> ou une valeur <ph id="ph2">&lt;see cref="T:System.IntPtr" /&gt;</ph> dans un type de données spécifié.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Int32)~System.IntPtr">
          <source>A 32-bit signed integer.</source>
          <target state="translated">Entier signé 32 bits.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Int32)~System.IntPtr">
          <source>Converts the value of a 32-bit signed integer to an <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</source>
          <target state="translated">Convertit la valeur d'un entier 32 bits signé en <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Int32)~System.IntPtr">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> initialized to <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Nouvelle instance de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> initialisée avec <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Int64)~System.IntPtr">
          <source>A 64-bit signed integer.</source>
          <target state="translated">Entier signé 64 bits.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Int64)~System.IntPtr">
          <source>Converts the value of a 64-bit signed integer to an <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</source>
          <target state="translated">Convertit la valeur d'un entier 64 bits signé en <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Int64)~System.IntPtr">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> initialized to <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Nouvelle instance de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> initialisée avec <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Int64)~System.IntPtr">
          <source>On a 32-bit platform, <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is too large to represent as an <ph id="ph2">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</source>
          <target state="translated">Sur une plateforme 32 bits, <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est trop élevé pour être représenté en tant que <ph id="ph2">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32">
          <source>The pointer or handle to convert.</source>
          <target state="translated">Pointeur ou handle à convertir.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32">
          <source>Converts the value of the specified <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> to a 32-bit signed integer.</source>
          <target state="translated">Convertit la valeur du <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> spécifié en entier 32 bits signé.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32">
          <source>The contents of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Contenu de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32">
          <source>An exception is only thrown if the value of <ph id="ph1">`value`</ph> requires more bits than the current platform supports.</source>
          <target state="translated">Une exception est levée uniquement si la valeur de <ph id="ph1">`value`</ph> requiert plus de bits que le prend en charge de plateforme actuelle.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32">
          <source>On a 64-bit platform, the value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is too large to represent as a 32-bit signed integer.</source>
          <target state="translated">Sur une plateforme 64 bits, <ph id="ph1">&lt;paramref name="value" /&gt;</ph> a une valeur trop élevée pour être représenté en tant qu'entier 32 bits signé.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int64">
          <source>The pointer or handle to convert.</source>
          <target state="translated">Pointeur ou handle à convertir.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int64">
          <source>Converts the value of the specified <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> to a 64-bit signed integer.</source>
          <target state="translated">Convertit la valeur du <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> spécifié en entier 64 bits signé.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int64">
          <source>The contents of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Contenu de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Void*">
          <source>The pointer or handle to convert.</source>
          <target state="translated">Pointeur ou handle à convertir.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Void*">
          <source>Converts the value of the specified <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> to a pointer to an unspecified type.</source>
          <target state="translated">Convertit la valeur du <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> spécifié en pointeur de type non spécifié.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Void*">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Cette API n'est pas conforme CLS.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Void*">
          <source>The contents of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Contenu de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr">
          <source>A pointer to an unspecified type.</source>
          <target state="translated">Pointeur vers un type non spécifié.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr">
          <source>Converts the specified pointer to an unspecified type to an <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</source>
          <target state="translated">Convertit le pointeur spécifié vers un type non spécifié en <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Cette API n'est pas conforme CLS.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> initialized to <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Nouvelle instance de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> initialisée avec <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)">
          <source>The first pointer or handle to compare.</source>
          <target state="translated">Premier pointeur ou handle à comparer.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)">
          <source>The second pointer or handle to compare.</source>
          <target state="translated">Second pointeur ou handle à comparer.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)">
          <source>Determines whether two specified instances of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> are not equal.</source>
          <target state="translated">Détermine si deux instances spécifiées de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> ne sont pas égales.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value1" /&gt;</ph> does not equal <ph id="ph3">&lt;paramref name="value2" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="value1" /&gt;</ph> n'est pas égal à <ph id="ph3">&lt;paramref name="value2" /&gt;</ph> ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">La méthode équivalente pour cet opérateur est <ph id="ph1">&lt;xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>The pointer to subtract the offset from.</source>
          <target state="translated">Pointeur auquel soustraire l'offset.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>The offset to subtract.</source>
          <target state="translated">Offset à soustraire.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>Subtracts an offset from the value of a pointer.</source>
          <target state="translated">Soustrait un offset de la valeur d'un pointeur.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>A new pointer that reflects the subtraction of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> from <ph id="ph2">&lt;paramref name="pointer" /&gt;</ph>.</source>
          <target state="translated">Nouveau pointeur qui reflète la soustraction de l'<ph id="ph1">&lt;paramref name="offset" /&gt;</ph> du <ph id="ph2">&lt;paramref name="pointer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IntPtr.op_Subtraction%2A&gt;</ph> method defines the subtraction operation for <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> objects.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IntPtr.op_Subtraction%2A&gt;</ph> méthode définit l’opération de soustraction pour <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>It enables code such as the following.</source>
          <target state="translated">Il permet de code semblable au suivant.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.IntPtr.Subtract%2A&gt;</ph> method instead.</source>
          <target state="translated">Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <ph id="ph1">&lt;xref:System.IntPtr.Subtract%2A&gt;</ph> méthode à la place.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>The subtraction operation does not throw an exception if the result is too small to represent as a pointer on the specified platform.</source>
          <target state="translated">L’opération de soustraction ne lève pas une exception si le résultat est trop petit pour représenter en tant que pointeur sur la plateforme spécifiée.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>Instead, it is performed in an unchecked context.</source>
          <target state="translated">Au lieu de cela, elle est effectuée dans un contexte non vérifié.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.IntPtr.Subtract%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">La méthode équivalente pour cet opérateur est <ph id="ph1">&lt;xref:System.IntPtr.Subtract%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="P:System.IntPtr.Size">
          <source>Gets the size of this instance.</source>
          <target state="translated">Obtient la taille de cette instance.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IntPtr.Size">
          <source>The size of a pointer or handle in this process, measured in bytes.</source>
          <target state="translated">Taille d'un pointeur ou d'un handle dans ce processus, mesurée en octets.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IntPtr.Size">
          <source>The value of this property is 4 in a 32-bit process, and 8 in a 64-bit process.</source>
          <target state="translated">Dans un processus 32 bits, cette propriété a la valeur 4 ; dans un processus 64 bits, elle a la valeur 8.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IntPtr.Size">
          <source>You can define the process type by setting the <ph id="ph1">&lt;see langword="/platform" /&gt;</ph> switch when you compile your code with the C# and Visual Basic compilers.</source>
          <target state="translated">Vous pouvez définir le type de processus en définissant le commutateur <ph id="ph1">&lt;see langword="/platform" /&gt;</ph> au moment où vous compilez votre code avec les compilateurs C# et Visual Basic.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)">
          <source>The pointer to subtract the offset from.</source>
          <target state="translated">Pointeur auquel soustraire l'offset.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)">
          <source>The offset to subtract.</source>
          <target state="translated">Offset à soustraire.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)">
          <source>Subtracts an offset from the value of a pointer.</source>
          <target state="translated">Soustrait un offset de la valeur d'un pointeur.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)">
          <source>A new pointer that reflects the subtraction of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> from <ph id="ph2">&lt;paramref name="pointer" /&gt;</ph>.</source>
          <target state="translated">Nouveau pointeur qui reflète la soustraction de l'<ph id="ph1">&lt;paramref name="offset" /&gt;</ph> du <ph id="ph2">&lt;paramref name="pointer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IntPtr.Subtract%2A&gt;</ph> method does not throw an exception if the result is too small to represent as a pointer on the specified platform.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IntPtr.Subtract%2A&gt;</ph> méthode ne lève pas d’exception si le résultat est trop petit pour représenter en tant que pointeur sur la plateforme spécifiée.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)">
          <source>Instead, the subtraction operation is performed in an unchecked context.</source>
          <target state="translated">Au lieu de cela, l’opération de soustraction est effectuée dans un contexte non vérifié.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)">
          <source>Languages that do not support operator overloading or custom operators can use this method to subtract an offset from the value of a pointer.</source>
          <target state="translated">Les langages qui ne prennent pas en charge la surcharge d’opérateur ou les opérateurs personnalisés peuvent utiliser cette méthode pour soustraire un offset à partir de la valeur d’un pointeur.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)">
          <source>The following example instantiates an <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> object that points to the end of a ten-element array, and then calls the <ph id="ph2">&lt;xref:System.IntPtr.Subtract%2A&gt;</ph> method to iterate the elements in the array in reverse order.</source>
          <target state="translated">L’exemple suivant instancie un <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> objet qui pointe vers la fin d’un tableau de dix éléments, puis appelle la <ph id="ph2">&lt;xref:System.IntPtr.Subtract%2A&gt;</ph> pour parcourir les éléments du tableau dans l’ordre inverse.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object to populate with data.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> à remplir avec des données.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The destination for this serialization.</source>
          <target state="translated">Destination de cette sérialisation.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>(This parameter is not used; specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.)</source>
          <target state="translated">(Ce paramètre n'est pas utilisé ; spécifiez <ph id="ph1">&lt;see langword="null" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Populates a <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object with the data needed to serialize the current <ph id="ph2">&lt;see cref="T:System.IntPtr" /&gt;</ph> object.</source>
          <target state="translated">Remplit un objet <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> des données nécessaires à la sérialisation de l'objet <ph id="ph2">&lt;see cref="T:System.IntPtr" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This method populates the <ph id="ph1">`info`</ph> parameter with the value of the current <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> object.</source>
          <target state="translated">Cette méthode remplit la <ph id="ph1">`info`</ph> paramètre avec la valeur de la <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToInt32">
          <source>Converts the value of this instance to a 32-bit signed integer.</source>
          <target state="translated">Convertit la valeur de cette instance en entier 32 bits signé.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToInt32">
          <source>A 32-bit signed integer equal to the value of this instance.</source>
          <target state="translated">Entier 32 bits signé équivalant à la valeur de cette instance.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToInt32">
          <source>On a 64-bit platform, the value of this instance is too large or too small to represent as a 32-bit signed integer.</source>
          <target state="translated">Sur une plateforme 64 bits, cette instance a une valeur trop élevée ou trop basse pour être représentée en tant qu'entier 32 bits signé.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToInt64">
          <source>Converts the value of this instance to a 64-bit signed integer.</source>
          <target state="translated">Convertit la valeur de cette instance en entier 64 bits signé.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToInt64">
          <source>A 64-bit signed integer equal to the value of this instance.</source>
          <target state="translated">Entier 64 bits signé équivalant à la valeur de cette instance.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToPointer">
          <source>Converts the value of this instance to a pointer to an unspecified type.</source>
          <target state="translated">Convertit la valeur de cette instance en pointeur vers un type non spécifié.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToPointer">
          <source>A pointer to <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph>; that is, a pointer to memory containing data of an unspecified type.</source>
          <target state="translated">Pointeur vers <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> ; c'est-à-dire, un pointeur vers une mémoire contenant des données de type non spécifié.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>The following example uses managed pointers to reverse the characters in an array.</source>
          <target state="translated">L’exemple suivant utilise des pointeurs managés à inverser les caractères dans un tableau.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>After it initializes a <ph id="ph1">&lt;xref:System.String&gt;</ph> object and gets its length, it does the following:</source>
          <target state="translated">Une fois qu’il initialise un <ph id="ph1">&lt;xref:System.String&gt;</ph> de l’objet et obtient sa longueur, il effectue les opérations suivantes :</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>Calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType&gt;</ph> method to copy the Unicode string to unmanaged memory as ANSI (one-byte) characters.</source>
          <target state="translated">Appelle la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType&gt;</ph> méthode pour copier la chaîne Unicode à la mémoire non managée comme des caractères ANSI (un octet).</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>The method returns an <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> object that points to the beginning of the unmanaged string.</source>
          <target state="translated">La méthode retourne un <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> objet qui pointe vers le début de la chaîne non managée.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>Calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType&gt;</ph> method to allocate the same number of bytes as the unmanaged string occupies.</source>
          <target state="translated">Appelle la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType&gt;</ph> méthode pour allouer le même nombre d’octets qu’occupe de la chaîne non managée.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>The method returns an <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> object that points to the beginning of the unmanaged block of memory.</source>
          <target state="translated">La méthode retourne un <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> objet qui pointe vers le début du bloc de mémoire non managé.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>Calls the <ph id="ph1">&lt;xref:System.IntPtr.ToPointer%2A&gt;</ph> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and adds one less than the length of the string to the starting address of the ANSI string.</source>
          <target state="translated">Appelle la <ph id="ph1">&lt;xref:System.IntPtr.ToPointer%2A&gt;</ph> méthode pour obtenir un pointeur non managé à l’adresse de départ de la chaîne et le bloc non managé de la mémoire et ajoute une inférieur à la longueur de la chaîne à l’adresse de départ de la chaîne ANSI.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block.</source>
          <target state="translated">Étant donné que le pointeur de chaîne non managée pointe maintenant à la fin de la chaîne, l’opération de copie copie un caractère à partir de la fin de la chaîne au début du bloc de mémoire.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>Uses a loop to copy each character from the string to the unmanaged block of memory.</source>
          <target state="translated">Utilise une boucle pour copier chaque caractère de la chaîne pour le bloc de mémoire non managée.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>After each copy operation, it decrements the pointer to the address of the next location in the unmanaged ANSI string and increments the pointer to the next address in the unmanaged block.</source>
          <target state="translated">Après chaque opération de copie, il décrémente le pointeur vers l’adresse de l’emplacement suivant dans la chaîne ANSI non managée et incrémente le pointeur vers l’adresse suivante dans le bloc non managé.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>Calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType&gt;</ph> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated">Appelle le <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType&gt;</ph> pour convertir le bloc de mémoire non managée qui contient la chaîne ANSI copiée Unicode managé <ph id="ph2">&lt;xref:System.String&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>After displaying the original and reversed strings, calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType&gt;</ph> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory.</source>
          <target state="translated">Après avoir affiché les chaînes d’origine et inversées, appelle le <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType&gt;</ph> méthode pour libérer la mémoire allouée pour la chaîne ANSI non managée et le bloc de mémoire non managée.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="T:System.IntPtr">
          <source>Converts the numeric value of the current <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> object to its equivalent string representation.</source>
          <target state="translated">Convertit la valeur numérique de l'objet <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> actuel dans sa représentation sous forme chaîne équivalente.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToString">
          <source>Converts the numeric value of the current <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> object to its equivalent string representation.</source>
          <target state="translated">Convertit la valeur numérique de l'objet <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> actuel dans sa représentation sous forme chaîne équivalente.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToString">
          <source>The string representation of the value of this instance.</source>
          <target state="translated">Représentation sous forme de chaîne de la valeur de cette instance.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToString">
          <source>If the value of the <ph id="ph1">&lt;xref:System.IntPtr.Size%2A&gt;</ph> property for this instance is 4, then this method is equivalent to <ph id="ph2">&lt;xref:System.Int32.ToString%2A?displayProperty=nameWithType&gt;</ph>; otherwise, this method is equivalent to <ph id="ph3">&lt;xref:System.Int64.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si la valeur de la <ph id="ph1">&lt;xref:System.IntPtr.Size%2A&gt;</ph> pour cette instance de la propriété est 4, cette méthode est équivalente à <ph id="ph2">&lt;xref:System.Int32.ToString%2A?displayProperty=nameWithType&gt;</ph>; sinon, cette méthode est équivalente à <ph id="ph3">&lt;xref:System.Int64.ToString%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToString(System.String)">
          <source>A format specification that governs how the current <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> object is converted.</source>
          <target state="translated">Spécification de format qui régit la façon dont l'objet <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> actuel est converti.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToString(System.String)">
          <source>Converts the numeric value of the current <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> object to its equivalent string representation.</source>
          <target state="translated">Convertit la valeur numérique de l'objet <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> actuel dans sa représentation sous forme chaîne équivalente.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToString(System.String)">
          <source>The string representation of the value of the current <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> object.</source>
          <target state="translated">Représentation sous forme de chaîne de la valeur de l'objet <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToString(System.String)">
          <source>If the <ph id="ph1">`format`</ph> parameter is <ph id="ph2">`null`</ph> or an empty string (""), the return value is formatted with the general format specifier ("G").</source>
          <target state="translated">Si le <ph id="ph1">`format`</ph> paramètre est <ph id="ph2">`null`</ph> ou une chaîne vide (" »), la valeur de retour est mis en forme avec le spécificateur de format général (« G »).</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToString(System.String)">
          <source>For more information about numeric format specifiers, see the <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> topic.</source>
          <target state="translated">Pour plus d’informations sur les spécificateurs de format numérique, consultez la <bpt id="p1">[</bpt>des chaînes de Format numériques Standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> rubrique.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToString(System.String)">
          <source>The return value is formatted using the invariant culture.</source>
          <target state="translated">La valeur de retour est mis en forme à l’aide de la culture dite indifférente.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="F:System.IntPtr.Zero">
          <source>A read-only field that represents a pointer or handle that has been initialized to zero.</source>
          <target state="translated">Champ en lecture seule qui représente un pointeur ou un handle remis à zéro.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>The value of this field is not equivalent to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">La valeur de ce champ n’est pas équivalente à <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>Use this field to efficiently determine whether an instance of <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> has been set to a value other than zero.</source>
          <target state="translated">Ce champ permet de déterminer efficacement si une instance de <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> a été défini sur une valeur différente de zéro.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>For example, assume the variable, ip, is an instance of <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph>.</source>
          <target state="translated">Par exemple, supposons que la variable ip est une instance de <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>You can determine if it has been set by comparing it to the value returned by a constructor, for example: " <ph id="ph1">`if ip != new IntPtr(0)...`</ph> ".</source>
          <target state="translated">Vous pouvez déterminer si elle a été définie en la comparant à la valeur retournée par un constructeur, par exemple : « <ph id="ph1">`if ip != new IntPtr(0)...`</ph> ».</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>However, invoking a constructor to get an unintialized pointer is inefficient.</source>
          <target state="translated">Toutefois, il est inefficace d’appeler un constructeur pour obtenir un pointeur non initialisé.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>It is better to code either " <ph id="ph1">`if ip != IntPtr.Zero...`</ph> ", or " <ph id="ph2">`if !IntPtr.Zero.Equals(ip)...`</ph> ".</source>
          <target state="translated">Il est préférable de code, « <ph id="ph1">`if ip != IntPtr.Zero...`</ph> », ou « <ph id="ph2">`if !IntPtr.Zero.Equals(ip)...`</ph> ».</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>When calling the Windows API from managed code, you can pass <ph id="ph1">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph> instead of <ph id="ph2">`null`</ph> if an argument is expected to be either a pointer or a <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Lorsque vous appelez l’API Windows à partir du code managé, vous pouvez passer <ph id="ph1">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph> au lieu de <ph id="ph2">`null`</ph> si un argument doit être soit un pointeur ou un <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>For example, the following call to the Windows <ph id="ph1">`CreateFile`</ph> function supplies <ph id="ph2">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph> for the <ph id="ph3">`pSecurityAttributes`</ph> and <ph id="ph4">`hTemplateFile`</ph> argument values.</source>
          <target state="translated">Par exemple, l’appel suivant à Windows <ph id="ph1">`CreateFile`</ph> fonction fournitures <ph id="ph2">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph> pour le <ph id="ph3">`pSecurityAttributes`</ph> et <ph id="ph4">`hTemplateFile`</ph> valeurs d’argument.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>Although <ph id="ph1">&lt;xref:System.IntPtr.Zero&gt;</ph> is equivalent to <ph id="ph2">`null`</ph> for Windows API functions with parameters or return values that can be either pointers or <ph id="ph3">`null`</ph>, <ph id="ph4">&lt;xref:System.IntPtr.Zero&gt;</ph> is not equivalent to <ph id="ph5">`null`</ph>.</source>
          <target state="translated">Bien que <ph id="ph1">&lt;xref:System.IntPtr.Zero&gt;</ph> équivaut à <ph id="ph2">`null`</ph> pour les fonctions API Windows avec des paramètres ou valeurs de retour qui peuvent être soit des pointeurs ou <ph id="ph3">`null`</ph>, <ph id="ph4">&lt;xref:System.IntPtr.Zero&gt;</ph> n’est pas équivalent à <ph id="ph5">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>Passing <ph id="ph1">`null`</ph> to the <ph id="ph2">`IntPtr.Zero.Equals`</ph> method always returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Passage <ph id="ph1">`null`</ph> à la <ph id="ph2">`IntPtr.Zero.Equals`</ph> méthode retourne toujours <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>You can also test for a <ph id="ph1">`null`</ph> return value from Windows API function calls that return either a pointer or a <ph id="ph2">`null`</ph> by comparing the returned value with <ph id="ph3">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Vous pouvez également tester un <ph id="ph1">`null`</ph> valeur de retour d’appels de fonction API Windows qui retournent soit un pointeur ou un <ph id="ph2">`null`</ph> en comparant la valeur retournée avec <ph id="ph3">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>For example, the call to the <ph id="ph1">`GetWindow`</ph> function in the following example tries to retrieve the handle of a non-existent window.</source>
          <target state="translated">Par exemple, l’appel à la <ph id="ph1">`GetWindow`</ph> fonction dans l’exemple suivant tente de récupérer le handle d’une fenêtre inexistante.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>If it were called from unmanaged code, the function would return <ph id="ph1">`null`</ph>, but when it is called from managed code, it returns <ph id="ph2">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si elle a été appelée à partir de code non managé, la fonction retourne <ph id="ph1">`null`</ph>, mais lorsqu’elle est appelée à partir du code managé, il retourne <ph id="ph2">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>