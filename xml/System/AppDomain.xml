<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="AppDomain.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c3ab234edad8a65f7b4b6688da32990c9642f79d.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c3ab234edad8a65f7b4b6688da32990c9642f79d</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Represents an application domain, which is an isolated environment where applications execute.</source>
          <target state="translated">Représente un domaine d'application qui est un environnement isolé dans lequel s'exécutent les applications.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>This class cannot be inherited.</source>
          <target state="translated">Cette classe ne peut pas être héritée.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Application domains, which are represented by <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> objects, help provide isolation, unloading, and security boundaries for executing managed code.</source>
          <target state="translated">Domaines d’application, qui sont représentées par <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> objets, aide à fournir des limites d’isolation, de déchargement et de sécurité pour l’exécution de code managé.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Use application domains to isolate tasks that might bring down a process.</source>
          <target state="translated">Utiliser des domaines d’application pour isoler les tâches qui peuvent interrompre à un processus.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>If the state of the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> that's executing a task becomes unstable, the <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph> can be unloaded without affecting the process.</source>
          <target state="translated">Si l’état de la <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> qui exécute une tâche devient instable, le <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph> peut être déchargé sans affecter le processus.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>This is important when a process must run for long periods without restarting.</source>
          <target state="translated">Ceci est important lorsqu’un processus doit s’exécuter pendant de longues périodes sans redémarrer.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>You can also use application domains to isolate tasks that should not share data.</source>
          <target state="translated">Vous pouvez également utiliser des domaines d’application pour isoler les tâches qui ne doivent pas partager de données.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>If an assembly is loaded into the default application domain, it cannot be unloaded from memory while the process is running.</source>
          <target state="translated">Si un assembly est chargé dans le domaine d’application par défaut, il ne peut pas être déchargé de la mémoire pendant le processus est en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>However, if you open a second application domain to load and execute the assembly, the assembly is unloaded when that application domain is unloaded.</source>
          <target state="translated">Toutefois, si vous ouvrez un deuxième domaine d’application pour charger et exécuter l’assembly, l’assembly est déchargé lorsque ce domaine d’application est déchargé.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Use this technique to minimize the working set of long-running processes that occasionally use large DLLs.</source>
          <target state="translated">Cette technique permet de réduire la plage de travail de longs processus qui utilisent parfois des DLL volumineuses.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Multiple application domains can run in a single process; however, there is not a one-to-one correlation between application domains and threads.</source>
          <target state="translated">Plusieurs domaines d’application peuvent s’exécuter dans un processus unique. Toutefois, il n'est pas une corrélation entre les domaines d’application et les threads.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Several threads can belong to a single application domain, and while a given thread is not confined to a single application domain, at any given time, a thread executes in a single application domain.</source>
          <target state="translated">Plusieurs threads peuvent appartenir à un seul domaine d’application, et lors d’un thread donné ne se limite pas à un domaine d’application unique à un moment donné, un thread s’exécute dans un seul domaine d’application.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Application domains are created using the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> method.</source>
          <target state="translated">Domaines d’application sont créés à l’aide de la <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> instances are used to load and execute assemblies (<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> les instances sont utilisées pour charger et exécuter des assemblys (<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>When an <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> is no longer in use, it can be unloaded.</source>
          <target state="translated">Lorsqu’un <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> est n’est plus en cours d’utilisation, il peut être déchargé.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> class implements a set of events that enable applications to respond when an assembly is loaded, when an application domain will be unloaded, or when an unhandled exception is thrown.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> classe implémente un jeu d’événements qui permettent aux applications de répondre lorsqu’un assembly est chargé, un domaine d’application est déchargé ou quand une exception non gérée est levée.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>For more information on using application domains, see <bpt id="p1">[</bpt>Application Domains<ept id="p1">](~/docs/framework/app-domains/application-domains.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation de domaines d’application, consultez <bpt id="p1">[</bpt>domaines d’Application<ept id="p1">](~/docs/framework/app-domains/application-domains.md)</ept>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>This class implements the <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph>, <ph id="ph2">&lt;xref:System._AppDomain&gt;</ph>, and <ph id="ph3">&lt;xref:System.Security.IEvidenceFactory&gt;</ph> interfaces.</source>
          <target state="translated">Cette classe implémente la <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph>, <ph id="ph2">&lt;xref:System._AppDomain&gt;</ph>, et <ph id="ph3">&lt;xref:System.Security.IEvidenceFactory&gt;</ph> interfaces.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>You should never create a remotable wrapper for an <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> object.</source>
          <target state="translated">Vous ne devez jamais créer un wrapper accessible à distance pour un <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Doing so could publish a remote reference to that <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, exposing methods such as <ph id="ph2">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> to remote access and effectively destroying code access security for that <ph id="ph3">&lt;xref:System.AppDomain&gt;</ph>.</source>
          <target state="translated">Cela peut publier une référence à distance à cet <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, exposer des méthodes telles que <ph id="ph2">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> accès à distance et en détruisant ainsi la sécurité d’accès du code pour ce <ph id="ph3">&lt;xref:System.AppDomain&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Malicious clients connecting to the remoted <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> could obtain access to any resource the <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph> itself has access to.</source>
          <target state="translated">Des clients malveillants qui se connectent à la distance <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> peut obtenir l’accès à n’importe quelle ressource le <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph> lui-même a accès à.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Do not create remotable wrappers for any type that extends <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph> and that implements methods that could be used by malicious clients to bypass the security system.</source>
          <target state="translated">Ne pas créer de wrappers accessibles à distance pour tout type qui étend <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph> et qui implémente des méthodes utilisables par des clients malveillants de contourner le système de sécurité.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>The default value for the <ph id="ph1">&lt;xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType&gt;</ph> property is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">La valeur par défaut pour le <ph id="ph1">&lt;xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType&gt;</ph> propriété est <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>This setting is unsafe for services.</source>
          <target state="translated">Ce paramètre est déconseillé pour les services.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>To prevent services from downloading partially trusted code, set this property to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Pour empêcher les services de télécharger du code partiellement fiable, définissez cette propriété sur <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>This example shows how to create a new <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, instantiate a type in that new <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph>, and communicate with that type’s object.</source>
          <target state="translated">Cet exemple montre comment créer un nouveau <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, instancier un type dans ce nouveau <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph>et de communiquer avec l’objet de ce type.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>In addition, this example shows how to unload the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> causing the object to be garbage collected.</source>
          <target state="translated">En outre, cet exemple montre comment décharger le <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> à l’origine de l’objet à l’opération garbage collecté.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="P:System.AppDomain.ActivationContext">
          <source>Gets the activation context for the current application domain.</source>
          <target state="translated">Obtient le contexte d'activation du domaine d'application actuel.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ActivationContext">
          <source>An object that represents the activation context for the current application domain, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the domain has no activation context.</source>
          <target state="translated">Objet qui représente le contexte d'activation du domaine d'application actuel, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si le domaine n'a aucun contexte d'activation.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ActivationContext">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ActivationContext">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>The name of the directory to be appended to the private path.</source>
          <target state="translated">Nom du répertoire à ajouter au chemin d’accès privé.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>Appends the specified directory name to the private path list.</source>
          <target state="translated">Ajoute le nom de répertoire spécifié à la liste des chemins d’accès privée.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>The use of this property is not recommended, because it might change the probing path for assemblies after they have already been loaded.</source>
          <target state="translated">L’utilisation de cette propriété n’est pas recommandée, car elle peut modifier le chemin d’accès de détection pour les assemblys après que qu’ils ont déjà été chargés.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>Use the <ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph> property instead.</source>
          <target state="translated">Utilisez la propriété <ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph> à la place.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>The private path, or relative search path, is the path relative to the base directory where the assembly resolver probes for private assemblies.</source>
          <target state="translated">Le chemin d’accès privé, ou le chemin de recherche relatif, est le chemin d’accès relatif au répertoire de base où le programme de résolution d’assembly détecte les assemblys privés.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="P:System.AppDomain.ApplicationIdentity">
          <source>Gets the identity of the application in the application domain.</source>
          <target state="translated">Obtient l'identité de l'application dans le domaine d'application.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationIdentity">
          <source>An object that identifies the application in the application domain.</source>
          <target state="translated">Objet qui identifie l'application dans le domaine d'application.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationIdentity">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationIdentity">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="P:System.AppDomain.ApplicationTrust">
          <source>Gets information describing permissions granted to an application and whether the application has a trust level that allows it to run.</source>
          <target state="translated">Obtient des informations qui décrivent les autorisations accordées à une application et indiquent si l'application possède un niveau de confiance qui lui permet de s'exécuter.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationTrust">
          <source>An object that encapsulates permission and trust information for the application in the application domain.</source>
          <target state="translated">Objet qui encapsule les autorisations et les informations d'approbation pour l'application dans le domaine d'application.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationTrust">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationTrust">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ApplyPolicy(System.String)">
          <source>The assembly display name, in the form provided by the <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom complet d'assembly, sous la forme fournie par la propriété <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ApplyPolicy(System.String)">
          <source>Returns the assembly display name after policy has been applied.</source>
          <target state="translated">Retourne le nom complet d'assembly une fois que la stratégie a été appliquée.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ApplyPolicy(System.String)">
          <source>A string containing the assembly display name after policy has been applied.</source>
          <target state="translated">Chaîne qui contient le nom complet d'assembly une fois que la stratégie a été appliquée.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ApplyPolicy(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ApplyPolicy%2A&gt;</ph> method takes an assembly display name and returns the post-policy display name.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.ApplyPolicy%2A&gt;</ph> afficher le nom de méthode prend un assembly et retourne le nom complet de post-stratégie.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ApplyPolicy(System.String)">
          <source>This is useful if you need to load an assembly using policy, because the reflection-only context does not apply policy.</source>
          <target state="translated">Cela est utile si vous devez charger un assembly à l’aide de la stratégie, car le contexte de réflexion uniquement ne s’applique pas de stratégie.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="E:System.AppDomain.AssemblyLoad">
          <source>Occurs when an assembly is loaded.</source>
          <target state="translated">Se produit quand un assembly est chargé.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>The <ph id="ph1">&lt;xref:System.AssemblyLoadEventHandler&gt;</ph> delegate for this event indicates what assembly was loaded.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AssemblyLoadEventHandler&gt;</ph> délégué de cet événement indique que l’assembly a été chargé.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>To register an event handler for this event, you must have the required permissions, or a <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown.</source>
          <target state="translated">Pour inscrire un gestionnaire d’événements pour cet événement, vous devez disposer des autorisations requises, ou un <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des événements, consultez <bpt id="p1">[</bpt>gestion et déclenchement d’événements<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.AssemblyLoad&gt;</ph> event.</source>
          <target state="translated">L’exemple suivant montre comment la <ph id="ph1">&lt;xref:System.AppDomain.AssemblyLoad&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez <bpt id="p1">[</bpt>les noms d’assemblys<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="E:System.AppDomain.AssemblyResolve">
          <source>Occurs when the resolution of an assembly fails.</source>
          <target state="translated">Se produit quand la résolution d'un assembly échoue.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>It is the responsibility of the <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> for this event to return the assembly that is specified by the <ph id="ph2">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> property, or to return null if the assembly is not recognized.</source>
          <target state="translated">Il incombe à le <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> pour cet événement retourner l’assembly spécifié par le <ph id="ph2">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> propriété, ou pour retourner une valeur null si l’assembly n’est pas reconnu.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>The assembly must be loaded into an execution context; if it is loaded into the reflection-only context, the load that caused this event to be raised fails.</source>
          <target state="translated">L’assembly doit être chargé dans un contexte d’exécution ; s’il est chargé dans le contexte de réflexion uniquement, la charge qui a provoqué cet événement à déclencher échoue.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For guidance on the use of this event, see <bpt id="p1">[</bpt>Resolving Assembly Loads<ept id="p1">](~/docs/framework/app-domains/resolve-assembly-loads.md)</ept>.</source>
          <target state="translated">Pour obtenir des conseils sur l’utilisation de cet événement, consultez <bpt id="p1">[</bpt>résoudre les chargements d’assemblys<ept id="p1">](~/docs/framework/app-domains/resolve-assembly-loads.md)</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> property returns the assembly that requested the assembly load that could not be resolved.</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, le <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> propriété retourne l’assembly qui a demandé le chargement d’assembly qui ne peut pas être résolu.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For example, the loader might be unable to load a dependency of the requesting assembly because the requesting assembly and its dependency are not in the probing path.</source>
          <target state="translated">Par exemple, le chargeur peut être impossible de charger une dépendance de l’assembly demandeur car ce dernier et sa dépendance ne se trouvent pas dans le chemin d’accès de détection.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>Knowing the identity of the requesting assembly might be useful in locating the dependency or in identifying the correct version, if more than one version of the dependency is available.</source>
          <target state="translated">Connaître l’identité de l’assembly demandeur peut être utile pour la localisation de la dépendance ou à identifier la version correcte, si plusieurs versions de la dépendance n’est disponible.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For more information, see <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.ResolveEventHandler&gt;</ph> event is raised for all assemblies, including resource assemblies.</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, le <ph id="ph2">&lt;xref:System.ResolveEventHandler&gt;</ph> événement est déclenché pour tous les assemblys, y compris les assemblys de ressources.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>In earlier versions, the event was not raised for resource assemblies.</source>
          <target state="translated">Dans les versions antérieures, l’événement a été pas déclenché pour les assemblys de ressources.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>If the operating system is localized, the handler might be called multiple times: once for each culture in the fallback chain.</source>
          <target state="translated">Si le système d’exploitation est localisé, le gestionnaire peut être appelé plusieurs fois : une fois pour chaque culture dans la chaîne de secours.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For this event, the <ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> property returns the assembly name before policy is applied.</source>
          <target state="translated">Pour cet événement, le <ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> propriété retourne le nom de l’assembly avant de la stratégie est appliquée.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>If more than one event handler is registered for this event, the event handlersarecalled in order until an event handler returns a value that isn't <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Si plus d’un gestionnaire d’événements est inscrit pour cet événement, l’événement handlersarecalled dans l’ordre jusqu'à ce qu’un gestionnaire d’événements retourne une valeur qui n’est <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>Subsequent event handlers are ignored.</source>
          <target state="translated">Gestionnaires d’événements suivants sont ignorés.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des événements, consultez <bpt id="p1">[</bpt>gestion et déclenchement d’événements<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">L’exemple suivant montre comment la <ph id="ph1">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez <bpt id="p1">[</bpt>les noms d’assemblys<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="P:System.AppDomain.BaseDirectory">
          <source>Gets the base directory that the assembly resolver uses to probe for assemblies.</source>
          <target state="translated">Obtient le répertoire de base qu'utilise le programme de résolution d'assembly pour détecter les assemblys.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>The base directory that the assembly resolver uses to probe for assemblies.</source>
          <target state="translated">Répertoire de base utilisé par le programme de résolution d'assembly pour détecter les assemblys.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>This property corresponds to the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Cette propriété correspond à la <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>It can also be retrieved using the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method with the string "APPBASE".</source>
          <target state="translated">Il peut également être récupérée à l’aide de la <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> méthode avec la chaîne « APPBASE ».</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain.</source>
          <target state="translated">L’exemple de code suivant crée un nouveau domaine d’application, en spécifiant un répertoire de base à utiliser lors de la recherche d’assemblys à charger dans le domaine.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>The example then uses the <ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph> property to obtain the base directory path, for display to the console.</source>
          <target state="translated">L’exemple utilise ensuite la <ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph> propriété pour obtenir le chemin d’accès du répertoire de base, pour les afficher sur la console.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="P:System.AppDomain.BaseDirectory">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>for access to the information in the path itself, including if the path is in the form "file://" or <ph id="ph1">\\</ph>\UNC\dir or "c:<ph id="ph2">\\</ph>".</source>
          <target state="translated">Pour accéder aux informations dans le chemin d’accès lui-même, notamment si le chemin d’accès est sous la forme « file:// » ou <ph id="ph1">\\</ph>\UNC\dir ou « c:<ph id="ph2">\\</ph>».</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ClearPrivatePath">
          <source>Resets the path that specifies the location of private assemblies to the empty string ("").</source>
          <target state="translated">Rétablit la chaîne vide ("") comme valeur du chemin d’accès qui spécifie l’emplacement des assemblys privés.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>The private path is a path relative to the base directory that the common language runtime searches to locate private assemblies.</source>
          <target state="translated">Le chemin d’accès privé est un chemin d’accès relatif au répertoire de base que le common language runtime recherche pour localiser des assemblys privés.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>For more information, see <ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.AppDomain.ClearPrivatePath%2A&gt;</ph> method to remove all entries from the list of private paths to search when assemblies are loaded.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser la <ph id="ph1">&lt;xref:System.AppDomain.ClearPrivatePath%2A&gt;</ph> méthode pour supprimer toutes les entrées dans la liste des chemins d’accès privés à rechercher lorsque les assemblys sont chargés.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>This method is now obsolete, and should not be used for new development.</source>
          <target state="translated">Cette méthode est désormais obsolète et ne doit pas être utilisée pour tout nouveau développement.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ClearPrivatePath">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>Resets the list of directories containing shadow copied assemblies to the empty string ("").</source>
          <target state="translated">Rétablit la chaîne vide ("") comme valeur de la liste des répertoires contenant des clichés instantanés d'assemblys.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>The shadow copy path is a list of directories where shadow copied assemblies are stored.</source>
          <target state="translated">Le chemin d’accès de copie de clichés instantanés est une liste de répertoires où clichés instantanés d’assemblys sont stockés.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>For more information, see <ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType&gt;</ph> and <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType&gt;</ph> et <bpt id="p1">[</bpt>clichés instantanés d’assemblys<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new instance of a specified COM type.</source>
          <target state="translated">Crée une instance d'un type COM spécifié.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The name of a file containing an assembly that defines the requested type.</source>
          <target state="translated">Nom d'un fichier qui contient un assembly définissant le type demandé.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The name of the requested type.</source>
          <target state="translated">Nom du type demandé.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>Creates a new instance of a specified COM type.</source>
          <target state="translated">Crée une instance d'un type COM spécifié.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</source>
          <target state="translated">Les paramètres spécifient le nom d'un fichier qui contient un assembly contenant le type et le nom du type.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Objet qui est un wrapper de la nouvelle instance spécifiée par <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>Use this method to create objects remotely without having to load the type locally.</source>
          <target state="translated">Utilisez cette méthode pour créer des objets à distance sans avoir à charger le type localement.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The return value must to be unwrapped to access the real object.</source>
          <target state="translated">La valeur de retour doit pour être désencapsulée pour accéder à l’objet réel.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>A <ph id="ph1">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType&gt;</ph> attribute with a value of <ph id="ph2">`true`</ph> must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> is thrown.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType&gt;</ph> attribut avec une valeur de <ph id="ph2">`true`</ph> doit être appliqué soit explicitement, soit par défaut au type COM pour cette méthode pour créer une instance de ce type ; sinon, <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The following sample demonstrates</source>
          <target state="translated">L’exemple suivant montre comment</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The type cannot be loaded.</source>
          <target state="translated">Impossible de charger le type.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>No public parameterless constructor was found.</source>
          <target state="translated">Aucun constructeur sans paramètre public n'a été trouvé.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is an abstract class.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est une classe abstraite.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>This member was invoked with a late-binding mechanism.</source>
          <target state="translated">Ce membre a été appelé avec un mécanisme de liaison tardive.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is an empty string ("").</source>
          <target state="translated">Le <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est une chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The COM object that is being referred to is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'objet COM auquel il est fait référence est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Pour pouvoir lire le fichier contenant le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name of a file containing an assembly that defines the requested type.</source>
          <target state="translated">Nom d'un fichier qui contient un assembly définissant le type demandé.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name of the requested type.</source>
          <target state="translated">Nom du type demandé.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the value of the computed hash code.</source>
          <target state="translated">Représente la valeur du code de hachage calculé.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the hash algorithm used by the assembly manifest.</source>
          <target state="translated">Représente l'algorithme de hachage utilisé par le manifeste d'assembly.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Creates a new instance of a specified COM type.</source>
          <target state="translated">Crée une instance d'un type COM spécifié.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</source>
          <target state="translated">Les paramètres spécifient le nom d'un fichier qui contient un assembly contenant le type et le nom du type.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Objet qui est un wrapper de la nouvelle instance spécifiée par <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Use this method to create objects remotely without having to load the type locally.</source>
          <target state="translated">Utilisez cette méthode pour créer des objets à distance sans avoir à charger le type localement.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The return value must to be unwrapped to access the real object.</source>
          <target state="translated">La valeur de retour doit pour être désencapsulée pour accéder à l’objet réel.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>A <ph id="ph1">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType&gt;</ph> attribute with a value of <ph id="ph2">`true`</ph> must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> is thrown.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType&gt;</ph> attribut avec une valeur de <ph id="ph2">`true`</ph> doit être appliqué soit explicitement, soit par défaut au type COM pour cette méthode pour créer une instance de ce type ; sinon, <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The type cannot be loaded.</source>
          <target state="translated">Impossible de charger le type.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>No public parameterless constructor was found.</source>
          <target state="translated">Aucun constructeur sans paramètre public n'a été trouvé.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is an abstract class.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est une classe abstraite.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This member was invoked with a late-binding mechanism.</source>
          <target state="translated">Ce membre a été appelé avec un mécanisme de liaison tardive.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est la chaîne vide ("").</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The COM object that is being referred to is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'objet COM auquel il est fait référence est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Pour pouvoir lire le fichier contenant le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new application domain.</source>
          <target state="translated">Crée un nouveau domaine d'application.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>The friendly name of the domain.</source>
          <target state="translated">Nom convivial du domaine.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>Creates a new application domain with the specified name.</source>
          <target state="translated">Crée un domaine d'application portant le nom spécifié.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>The newly created application domain.</source>
          <target state="translated">Domaine d'application nouvellement créé.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>The <ph id="ph1">`friendlyName`</ph> parameter is intended to identify the domain in a manner that is meaningful to humans.</source>
          <target state="translated">Le <ph id="ph1">`friendlyName`</ph> paramètre est destiné à identifier le domaine de manière significative pour les utilisateurs.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>This string should be suitable for display in user interfaces.</source>
          <target state="translated">Cette chaîne doit être appropriée pour l’affichage dans les interfaces utilisateur.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>This method overload uses the <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> information from the default application domain.</source>
          <target state="translated">Cette surcharge de méthode utilise le <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> informations du domaine d’application par défaut.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>The following sample demonstrates, in general, how to create a domain using one of the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> overloads.</source>
          <target state="translated">L’exemple suivant montre comment, en général, la création d’un domaine à l’aide d’un de le <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> surcharges.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>to provide evidence.</source>
          <target state="translated">pour fournir la preuve.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>The friendly name of the domain.</source>
          <target state="translated">Nom convivial du domaine.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>This friendly name can be displayed in user interfaces to identify the domain.</source>
          <target state="translated">Ce nom convivial peut être affiché dans les interfaces utilisateur pour identifier le domaine.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Evidence that establishes the identity of the code that runs in the application domain.</source>
          <target state="translated">Preuve qui établit l'identité du code exécuté dans le domaine d'application.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Pass <ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the evidence of the current application domain.</source>
          <target state="translated">Passez <ph id="ph1">&lt;see langword="null" /&gt;</ph> pour utiliser la preuve du domaine d'application actuel.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Creates a new application domain with the given name using the supplied evidence.</source>
          <target state="translated">Crée un domaine d'application portant le nom spécifié à l'aide de la preuve fournie.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>The newly created application domain.</source>
          <target state="translated">Domaine d'application nouvellement créé.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>This method overload uses the <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> information from the default application domain.</source>
          <target state="translated">Cette surcharge de méthode utilise le <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> informations du domaine d’application par défaut.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>If <ph id="ph1">`securityInfo`</ph> is not supplied, the evidence from the current application domain is used.</source>
          <target state="translated">Si <ph id="ph1">`securityInfo`</ph> est ne pas fourni, la preuve du domaine d’application actuel est utilisée.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Do not use this method overload to create sandboxed application domains.</source>
          <target state="translated">N’utilisez pas cette surcharge de méthode pour créer des domaines d’application sandbox.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the evidence that is supplied for <ph id="ph2">`securityInfo`</ph> no longer affects the grant set of the application domain.</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, la preuve fournie pour <ph id="ph2">`securityInfo`</ph> n’affecte plus le jeu d’autorisations du domaine d’application.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Use the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> method overload to create sandboxed application domains.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> surcharge de méthode pour créer des domaines d’application sandbox.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>The following sample demonstrates, in general, how to create a domain using one of the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> overloads.</source>
          <target state="translated">L’exemple suivant montre comment, en général, la création d’un domaine à l’aide d’un de le <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> surcharges.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>to provide evidence.</source>
          <target state="translated">pour fournir la preuve.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>The friendly name of the domain.</source>
          <target state="translated">Nom convivial du domaine.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>This friendly name can be displayed in user interfaces to identify the domain.</source>
          <target state="translated">Ce nom convivial peut être affiché dans les interfaces utilisateur pour identifier le domaine.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Evidence that establishes the identity of the code that runs in the application domain.</source>
          <target state="translated">Preuve qui établit l'identité du code exécuté dans le domaine d'application.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Pass <ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the evidence of the current application domain.</source>
          <target state="translated">Passez <ph id="ph1">&lt;see langword="null" /&gt;</ph> pour utiliser la preuve du domaine d'application actuel.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>An object that contains application domain initialization information.</source>
          <target state="translated">Objet contenant les informations d'initialisation du domaine d'application.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Creates a new application domain using the specified name, evidence, and application domain setup information.</source>
          <target state="translated">Crée un domaine d'application à l'aide du nom, de la preuve et des informations de configuration du domaine d'application spécifiés.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>The newly created application domain.</source>
          <target state="translated">Domaine d'application nouvellement créé.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>If <ph id="ph1">`info`</ph> is not supplied, this method overload uses the <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> information from the default application domain.</source>
          <target state="translated">Si <ph id="ph1">`info`</ph> est ne pas fourni, cette surcharge de méthode utilise le <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> informations du domaine d’application par défaut.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>If <ph id="ph1">`securityInfo`</ph> is not supplied, the evidence from the current application domain is used.</source>
          <target state="translated">Si <ph id="ph1">`securityInfo`</ph> est ne pas fourni, la preuve du domaine d’application actuel est utilisée.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Do not use this method overload to create sandboxed application domains.</source>
          <target state="translated">N’utilisez pas cette surcharge de méthode pour créer des domaines d’application sandbox.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the evidence that is supplied for <ph id="ph2">`securityInfo`</ph> no longer affects the grant set of the application domain.</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, la preuve fournie pour <ph id="ph2">`securityInfo`</ph> n’affecte plus le jeu d’autorisations du domaine d’application.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Use the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> method overload to create sandboxed application domains.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> surcharge de méthode pour créer des domaines d’application sandbox.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>The following sample demonstrates, in general, how to create a domain using one of the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> overloads.</source>
          <target state="translated">L’exemple suivant montre comment, en général, la création d’un domaine à l’aide d’un de le <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> surcharges.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>to provide evidence.</source>
          <target state="translated">pour fournir la preuve.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>The friendly name of the domain.</source>
          <target state="translated">Nom convivial du domaine.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>This friendly name can be displayed in user interfaces to identify the domain.</source>
          <target state="translated">Ce nom convivial peut être affiché dans les interfaces utilisateur pour identifier le domaine.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>For more information, see the description of <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, voir la description de <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Evidence that establishes the identity of the code that runs in the application domain.</source>
          <target state="translated">Preuve qui établit l'identité du code exécuté dans le domaine d'application.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Pass <ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the evidence of the current application domain.</source>
          <target state="translated">Passez <ph id="ph1">&lt;see langword="null" /&gt;</ph> pour utiliser la preuve du domaine d'application actuel.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>An object that contains application domain initialization information.</source>
          <target state="translated">Objet contenant les informations d'initialisation du domaine d'application.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>A default permission set that is granted to all assemblies loaded into the new application domain that do not have specific grants.</source>
          <target state="translated">Jeu d'autorisations par défaut qui est accordé à tous les assemblys chargés dans le nouveau domaine d'application qui n'ont pas d'attributions spécifiques.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>An array of strong names representing assemblies to be considered fully trusted in the new application domain.</source>
          <target state="translated">Tableau des noms forts représentant les assemblys à considérer comme ayant un niveau de confiance suffisant dans le nouveau domaine d'application.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Creates a new application domain using the specified name, evidence, application domain setup information, default permission set, and array of fully trusted assemblies.</source>
          <target state="translated">Crée un domaine d'application à l'aide du nom, de la preuve, des informations de configuration du domaine d'application, du jeu d'autorisations par défaut et du tableau d'assemblys ayant un niveau de confiance suffisant.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>The newly created application domain.</source>
          <target state="translated">Domaine d'application nouvellement créé.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>You must set the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> object that you supply for <ph id="ph3">`info`</ph>.</source>
          <target state="translated">Vous devez définir le <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> propriété de la <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> objet que vous fournissez pour <ph id="ph3">`info`</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Otherwise, an exception is thrown.</source>
          <target state="translated">Sinon, une exception est levée.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>If <ph id="ph1">`securityInfo`</ph> is not supplied, the evidence from the current application domain is used.</source>
          <target state="translated">Si <ph id="ph1">`securityInfo`</ph> est ne pas fourni, la preuve du domaine d’application actuel est utilisée.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>The information provided for <ph id="ph1">`grantSet`</ph> and <ph id="ph2">`fullTrustAssemblies`</ph> is used to create an <ph id="ph3">&lt;xref:System.Security.Policy.ApplicationTrust&gt;</ph> object for the new application domain.</source>
          <target state="translated">Les informations fournies pour <ph id="ph1">`grantSet`</ph> et <ph id="ph2">`fullTrustAssemblies`</ph> est utilisé pour créer un <ph id="ph3">&lt;xref:System.Security.Policy.ApplicationTrust&gt;</ph> objet pour le nouveau domaine d’application.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>The application domain is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le domaine d'application est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>The <ph id="ph1">&lt;see cref="P:System.AppDomainSetup.ApplicationBase" /&gt;</ph> property is not set on the <ph id="ph2">&lt;see cref="T:System.AppDomainSetup" /&gt;</ph> object that is supplied for <ph id="ph3">&lt;paramref name="info" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see cref="P:System.AppDomainSetup.ApplicationBase" /&gt;</ph> n'est pas définie sur l'objet <ph id="ph2">&lt;see cref="T:System.AppDomainSetup" /&gt;</ph> fourni pour <ph id="ph3">&lt;paramref name="info" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>for the ability to create and manipulate an application domain.</source>
          <target state="translated">Pour pouvoir créer et manipuler un domaine d’application.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>The friendly name of the domain.</source>
          <target state="translated">Nom convivial du domaine.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>This friendly name can be displayed in user interfaces to identify the domain.</source>
          <target state="translated">Ce nom convivial peut être affiché dans les interfaces utilisateur pour identifier le domaine.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Evidence that establishes the identity of the code that runs in the application domain.</source>
          <target state="translated">Preuve qui établit l'identité du code exécuté dans le domaine d'application.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Pass <ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the evidence of the current application domain.</source>
          <target state="translated">Passez <ph id="ph1">&lt;see langword="null" /&gt;</ph> pour utiliser la preuve du domaine d'application actuel.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>The base directory that the assembly resolver uses to probe for assemblies.</source>
          <target state="translated">Répertoire de base utilisé par le programme de résolution d'assembly pour détecter les assemblys.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.BaseDirectory" /&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;see cref="P:System.AppDomain.BaseDirectory" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>The path relative to the base directory where the assembly resolver should probe for private assemblies.</source>
          <target state="translated">Chemin d'accès par rapport au répertoire de base où le programme de résolution d'assembly doit détecter les assemblys privés.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.RelativeSearchPath" /&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;see cref="P:System.AppDomain.RelativeSearchPath" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, a shadow copy of an assembly is loaded into this application domain.</source>
          <target state="translated">Si la valeur est <ph id="ph1">&lt;see langword="true" /&gt;</ph>, un cliché instantané d'un assembly est chargé dans ce domaine d'application.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</source>
          <target state="translated">Crée un domaine d'application portant le nom donné, à l'aide de la preuve, du chemin d'accès de base de l'application, du chemin de recherche relatif et d'un paramètre spécifiant si un cliché instantané d'un assembly doit être chargé dans le domaine d'application.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>The newly created application domain.</source>
          <target state="translated">Domaine d'application nouvellement créé.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>If <ph id="ph1">`securityInfo`</ph> is not supplied, the evidence from the current application domain is used.</source>
          <target state="translated">Si <ph id="ph1">`securityInfo`</ph> est ne pas fourni, la preuve du domaine d’application actuel est utilisée.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>For more information about shadow copying, see <ph id="ph1">&lt;xref:System.AppDomain.ShadowCopyFiles%2A&gt;</ph> and <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les clichés instantanés, consultez <ph id="ph1">&lt;xref:System.AppDomain.ShadowCopyFiles%2A&gt;</ph> et <bpt id="p1">[</bpt>clichés instantanés d’assemblys<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Do not use this method overload to create sandboxed application domains.</source>
          <target state="translated">N’utilisez pas cette surcharge de méthode pour créer des domaines d’application sandbox.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the evidence that is supplied for <ph id="ph2">`securityInfo`</ph> no longer affects the grant set of the application domain.</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, la preuve fournie pour <ph id="ph2">`securityInfo`</ph> n’affecte plus le jeu d’autorisations du domaine d’application.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Use the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> method overload to create sandboxed application domains.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> surcharge de méthode pour créer des domaines d’application sandbox.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>The following sample demonstrates, in general, how to create a domain using one of the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> overloads.</source>
          <target state="translated">L’exemple suivant montre comment, en général, la création d’un domaine à l’aide d’un de le <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> surcharges.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>to provide evidence.</source>
          <target state="translated">pour fournir la preuve.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>The friendly name of the domain.</source>
          <target state="translated">Nom convivial du domaine.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>This friendly name can be displayed in user interfaces to identify the domain.</source>
          <target state="translated">Ce nom convivial peut être affiché dans les interfaces utilisateur pour identifier le domaine.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Evidence that establishes the identity of the code that runs in the application domain.</source>
          <target state="translated">Preuve qui établit l'identité du code exécuté dans le domaine d'application.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Pass <ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the evidence of the current application domain.</source>
          <target state="translated">Passez <ph id="ph1">&lt;see langword="null" /&gt;</ph> pour utiliser la preuve du domaine d'application actuel.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>The base directory that the assembly resolver uses to probe for assemblies.</source>
          <target state="translated">Répertoire de base utilisé par le programme de résolution d'assembly pour détecter les assemblys.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.BaseDirectory" /&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;see cref="P:System.AppDomain.BaseDirectory" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>The path relative to the base directory where the assembly resolver should probe for private assemblies.</source>
          <target state="translated">Chemin d'accès par rapport au répertoire de base où le programme de résolution d'assembly doit détecter les assemblys privés.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.RelativeSearchPath" /&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;see cref="P:System.AppDomain.RelativeSearchPath" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to load a shadow copy of an assembly into the application domain.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour charger un cliché instantané d'un assembly dans le domaine d'application.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.AppDomainInitializer" /&gt;</ph> delegate that represents a callback method to invoke when the new <ph id="ph2">&lt;see cref="T:System.AppDomain" /&gt;</ph> object is initialized.</source>
          <target state="translated">Un délégué <ph id="ph1">&lt;see cref="T:System.AppDomainInitializer" /&gt;</ph> qui représente une méthode de rappel à appeler quand le nouvel objet <ph id="ph2">&lt;see cref="T:System.AppDomain" /&gt;</ph> est initialisé.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>An array of string arguments to be passed to the callback represented by <bpt id="p1">&lt;c&gt;</bpt>adInit<ept id="p1">&lt;/c&gt;</ept>, when the new <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> object is initialized.</source>
          <target state="translated">Un tableau d’arguments de type chaîne à passer au rappel représenté par <bpt id="p1">&lt;c&gt;</bpt>adInit<ept id="p1">&lt;/c&gt;</ept>, quand le nouvel objet <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> est initialisé.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</source>
          <target state="translated">Crée un domaine d'application portant le nom donné, à l'aide de la preuve, du chemin d'accès de base de l'application, du chemin de recherche relatif et d'un paramètre spécifiant si un cliché instantané d'un assembly doit être chargé dans le domaine d'application.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Specifies a callback method that is invoked when the application domain is initialized, and an array of string arguments to pass the callback method.</source>
          <target state="translated">Spécifie une méthode de rappel qui est appelée quand le domaine d'application est initialisé, et un tableau d'arguments de type chaîne à passer à la méthode de rappel.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>The newly created application domain.</source>
          <target state="translated">Domaine d'application nouvellement créé.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>The method represented by <ph id="ph1">`adInit`</ph> is executed in the context of the newly created application domain.</source>
          <target state="translated">La méthode représentée par <ph id="ph1">`adInit`</ph> est exécutée dans le contexte du domaine d’application nouvellement créé.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>If <ph id="ph1">`securityInfo`</ph> is not supplied, the evidence from the current application domain is used.</source>
          <target state="translated">Si <ph id="ph1">`securityInfo`</ph> est ne pas fourni, la preuve du domaine d’application actuel est utilisée.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>For more information about shadow copying, see <ph id="ph1">&lt;xref:System.AppDomain.ShadowCopyFiles%2A&gt;</ph> and <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les clichés instantanés, consultez <ph id="ph1">&lt;xref:System.AppDomain.ShadowCopyFiles%2A&gt;</ph> et <bpt id="p1">[</bpt>clichés instantanés d’assemblys<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Do not use this method overload to create sandboxed application domains.</source>
          <target state="translated">N’utilisez pas cette surcharge de méthode pour créer des domaines d’application sandbox.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the evidence that is supplied for <ph id="ph2">`securityInfo`</ph> no longer affects the grant set of the application domain.</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, la preuve fournie pour <ph id="ph2">`securityInfo`</ph> n’affecte plus le jeu d’autorisations du domaine d’application.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Use the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> method overload to create sandboxed application domains.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> surcharge de méthode pour créer des domaines d’application sandbox.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>to provide evidence.</source>
          <target state="translated">pour fournir la preuve.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new instance of a specified type defined in a specified assembly.</source>
          <target state="translated">Crée une instance d'un type spécifié défini dans un assembly déterminé.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>Creates a new instance of the specified type defined in the specified assembly.</source>
          <target state="translated">Crée une instance du type spécifié défini dans l'assembly déterminé.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Objet qui est un wrapper de la nouvelle instance spécifiée par <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">Cette méthode appelle le constructeur par défaut <ph id="ph1">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> pour le format de <ph id="ph2">`assemblyName`</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</source>
          <target state="translated">Toute tentative d’appel <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> sur une cible de domaine d’application qui n’est pas le domaine d’application actuel entraîne un chargement réussi de l’assembly dans le domaine d’application cible.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>Since an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is not <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, when this method attempts to return the <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</source>
          <target state="translated">Dans la mesure où un <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> n’est pas <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, lorsque cette méthode tente de retourner le <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> pour l’assembly chargé au domaine d’application actuel, le common language runtime essaie de charger l’assembly dans le domaine d’application actuel et le chargement peut échouer.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</source>
          <target state="translated">L’assembly est chargé dans le domaine d’application actuel peut être différent de l’assembly a été chargé en premier si les paramètres de chemin d’accès pour les deux domaines d’application sont différents.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">L’appelant n’est pas autorisé à appeler ce constructeur.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>No matching public constructor was found.</source>
          <target state="translated">Aucun constructeur public correspondant n’a été trouvé.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> est introuvable dans <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L’instance est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>for the ability to call unmanaged code when creating an instance of a delegate.</source>
          <target state="translated">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Tableau à un ou plusieurs attributs pouvant participer à l'activation.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">En général, tableau contenant un seul objet <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> qui spécifie l'URL nécessaire pour activer un objet distant.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">Ce paramètre concerne les objets activés par le client. L’activation par le client est une technologie héritée qui a été conservée pour la compatibilité descendante. Toutefois, elle n’est pas recommandée pour les nouveaux développements.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly.</source>
          <target state="translated">Crée une instance du type spécifié défini dans l'assembly déterminé.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>A parameter specifies an array of activation attributes.</source>
          <target state="translated">Un paramètre spécifie un tableau d'attributs d'activation.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Objet qui est un wrapper de la nouvelle instance spécifiée par <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">Cette méthode appelle le constructeur par défaut <ph id="ph1">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> pour le format de <ph id="ph2">`assemblyName`</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</source>
          <target state="translated">Toute tentative d’appel <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> sur une cible de domaine d’application qui n’est pas le domaine d’application actuel entraîne un chargement réussi de l’assembly dans le domaine d’application cible.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Since an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is not <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, when this method attempts to return the <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</source>
          <target state="translated">Dans la mesure où un <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> n’est pas <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, lorsque cette méthode tente de retourner le <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> pour l’assembly chargé au domaine d’application actuel, le common language runtime essaie de charger l’assembly dans le domaine d’application actuel et le chargement peut échouer.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</source>
          <target state="translated">L’assembly est chargé dans le domaine d’application actuel peut être différent de l’assembly a été chargé en premier si les paramètres de chemin d’accès pour les deux domaines d’application sont différents.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">L’appelant n’est pas autorisé à appeler ce constructeur.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>No matching public constructor was found.</source>
          <target state="translated">Aucun constructeur public correspondant n’a été trouvé.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> est introuvable dans <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L’instance est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Pour pouvoir lire le fichier contenant le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>for the ability to call unmanaged code when creating an instance of a delegate.</source>
          <target state="translated">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">Pour pouvoir appeler des opérations sur tous les membres de type.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">Valeur bouléenne spécifiant s'il convient d'effectuer ou non une recherche qui respecte la casse.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> par le biais de la réflexion.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> a la valeur null, le Binder par défaut est utilisé.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">Arguments à passer au constructeur.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">Ce tableau d'arguments doit posséder les mêmes nombre, ordre et type que les paramètres du constructeur à appeler.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">Si vous préférez utiliser le constructeur par défaut, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> doit être un tableau vide ou null.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Informations propres à la culture qui définissent la contrainte de <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> pour les types formels déclarés du constructeur <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> du thread actuel est utilisé.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Tableau à un ou plusieurs attributs pouvant participer à l'activation.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">En général, tableau contenant un seul objet <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> qui spécifie l'URL nécessaire pour activer un objet distant.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">Ce paramètre est lié aux objets activés par le client.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly.</source>
          <target state="translated">Crée une instance du type spécifié défini dans l'assembly déterminé.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, and optional activation attributes.</source>
          <target state="translated">Les paramètres spécifient un binder, des indicateurs de liaisons, des arguments de constructeur, les informations spécifiques à la culture utilisées pour interpréter les arguments et des attributs d'activation facultatifs.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Objet qui est un wrapper de la nouvelle instance spécifiée par <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> pour le format de <ph id="ph2">`assemblyName`</ph>.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</source>
          <target state="translated">Toute tentative d’appel <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> sur une cible de domaine d’application qui n’est pas le domaine d’application actuel entraîne un chargement réussi de l’assembly dans le domaine d’application cible.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Since an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is not <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, when this method attempts to return the <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</source>
          <target state="translated">Dans la mesure où un <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> n’est pas <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, lorsque cette méthode tente de retourner le <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> pour l’assembly chargé au domaine d’application actuel, le common language runtime essaie de charger l’assembly dans le domaine d’application actuel et le chargement peut échouer.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</source>
          <target state="translated">L’assembly est chargé dans le domaine d’application actuel peut être différent de l’assembly a été chargé en premier si les paramètres de chemin d’accès pour les deux domaines d’application sont différents.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">L’appelant n’est pas autorisé à appeler ce constructeur.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>No matching constructor was found.</source>
          <target state="translated">Aucun constructeur correspondant n’a été trouvé.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> est introuvable dans <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L’instance est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Pour pouvoir lire le fichier contenant le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to call unmanaged code when creating an instance of a delegate.</source>
          <target state="translated">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">Pour pouvoir appeler des opérations sur tous les membres de type.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">Valeur bouléenne spécifiant s'il convient d'effectuer ou non une recherche qui respecte la casse.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> par le biais de la réflexion.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> a la valeur null, le Binder par défaut est utilisé.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">Arguments à passer au constructeur.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">Ce tableau d'arguments doit posséder les mêmes nombre, ordre et type que les paramètres du constructeur à appeler.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">Si vous préférez utiliser le constructeur par défaut, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> doit être un tableau vide ou null.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Informations propres à la culture qui définissent la contrainte de <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> pour les types formels déclarés du constructeur <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> du thread actuel est utilisé.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Tableau à un ou plusieurs attributs pouvant participer à l'activation.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">En général, tableau contenant un seul objet <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> qui spécifie l'URL nécessaire pour activer un objet distant.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">Ce paramètre concerne les objets activés par le client. L’activation par le client est une technologie héritée qui a été conservée pour la compatibilité descendante. Toutefois, elle n’est pas recommandée pour les nouveaux développements.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Information used to authorize creation of <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Informations utilisées pour autoriser la création de <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Creates a new instance of the specified type defined in the specified assembly.</source>
          <target state="translated">Crée une instance du type spécifié défini dans l'assembly déterminé.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, activation attributes, and authorization to create the type.</source>
          <target state="translated">Les paramètres spécifient un binder, des indicateurs de liaisons, des arguments de constructeur, des informations propres à la culture utilisées pour interpréter les arguments, des attributs d’activation et l’autorisation de créer le type.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Objet qui est un wrapper de la nouvelle instance spécifiée par <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> pour le format de <ph id="ph2">`assemblyName`</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</source>
          <target state="translated">Toute tentative d’appel <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> sur une cible de domaine d’application qui n’est pas le domaine d’application actuel entraîne un chargement réussi de l’assembly dans le domaine d’application cible.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Since an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is not <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, when this method attempts to return the <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</source>
          <target state="translated">Dans la mesure où un <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> n’est pas <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, lorsque cette méthode tente de retourner le <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> pour l’assembly chargé au domaine d’application actuel, le common language runtime essaie de charger l’assembly dans le domaine d’application actuel et le chargement peut échouer.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</source>
          <target state="translated">L’assembly est chargé dans le domaine d’application actuel peut être différent de l’assembly a été chargé en premier si les paramètres de chemin d’accès pour les deux domaines d’application sont différents.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">L’appelant n’est pas autorisé à appeler ce constructeur.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>No matching constructor was found.</source>
          <target state="translated">Aucun constructeur correspondant n’a été trouvé.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> n’est pas un <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null." /&gt;</ph></source>
          <target state="translated">Lorsque la stratégie CAS héritée n'est pas activée, <ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> doit être <ph id="ph2">&lt;see langword="null." /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> est introuvable dans <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L’instance est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Pour pouvoir lire le fichier contenant le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>to provide evidence.</source>
          <target state="translated">pour fournir la preuve.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">Pour pouvoir appeler des opérations sur tous les membres de type.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new instance of a specified type.</source>
          <target state="translated">Crée une instance d'un type spécifié.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>Creates a new instance of the specified type.</source>
          <target state="translated">Crée une instance du type spécifié.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>Parameters specify the assembly where the type is defined, and the name of the type.</source>
          <target state="translated">Les paramètres spécifient l'assembly dans lequel le type est défini et le nom du type.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>An instance of the object specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Instance de l'objet spécifié par <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Il s’agit d’une méthode pratique qui combine <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">Cette méthode appelle le constructeur par défaut <ph id="ph1">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> pour le format de <ph id="ph2">`assemblyName`</ph>.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>See the <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> property for the format of <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated">Consultez le <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> propriété pour le format de <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>If you make an early-bound call to a method <ph id="ph1">`M`</ph> of an object of type <ph id="ph2">`T1`</ph> that was returned by <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, and that method makes an early-bound call to a method of an object of type <ph id="ph4">`T2`</ph> in an assembly <ph id="ph5">`C`</ph> other than the current assembly or the assembly containing <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> is loaded into the current application domain.</source>
          <target state="translated">Si vous effectuez un appel à liaison anticipée à une méthode <ph id="ph1">`M`</ph> d’un objet de type <ph id="ph2">`T1`</ph> qui a été retourné par <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, et que le méthode effectue un appel à liaison anticipée à une méthode d’un objet de type <ph id="ph4">`T2`</ph> dans un assembly <ph id="ph5">`C`</ph> autre que le assembly actuel ou l’assembly contenant <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> est chargé dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>This loading occurs even if the early-bound call to <ph id="ph1">`T1.M()`</ph> was made in the body of a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, or in other dynamically generated code.</source>
          <target state="translated">Ce chargement se produit même si l’appel à liaison anticipée à <ph id="ph1">`T1.M()`</ph> a été effectuée dans le corps d’un <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, ou dans un autre code généré dynamiquement.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>If the current domain is the default domain, assembly <ph id="ph1">`C`</ph> cannot be unloaded until the process ends.</source>
          <target state="translated">Si le domaine actuel est le domaine par défaut, assembly <ph id="ph1">`C`</ph> ne peut pas être déchargé jusqu'à ce que le processus se termine.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>If the current domain later attempts to load assembly <ph id="ph1">`C`</ph>, the load might fail.</source>
          <target state="translated">Si le domaine actuel ultérieurement tente de charger l’assembly <ph id="ph1">`C`</ph>, le chargement peut échouer.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The following code example shows the simplest way to execute code in another application domain.</source>
          <target state="translated">L’exemple de code suivant montre la façon la plus simple d’exécuter du code dans un autre domaine d’application.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The example defines a class named <ph id="ph1">`Worker`</ph> that inherits from <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>.</source>
          <target state="translated">L’exemple définit une classe nommée <ph id="ph1">`Worker`</ph> qui hérite de <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The <ph id="ph1">`Worker`</ph> class defines a method that displays the name of the application domain in which it is executing.</source>
          <target state="translated">La <ph id="ph1">`Worker`</ph> classe définit une méthode qui affiche le nom du domaine d’application dans lequel elle s’exécute.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The example creates instances of <ph id="ph1">`Worker`</ph> in the default application domain and in a new application domain.</source>
          <target state="translated">L’exemple crée des instances de <ph id="ph1">`Worker`</ph> dans le domaine d’application par défaut et dans un domaine d’application.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The assembly that contains <ph id="ph1">`Worker`</ph> must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.</source>
          <target state="translated">L’assembly qui contient <ph id="ph1">`Worker`</ph> doit être chargé dans les deux domaines d’application, mais il peut charger d’autres assemblys qui existent uniquement dans le nouveau domaine d’application.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>No matching public constructor was found.</source>
          <target state="translated">Aucun constructeur public correspondant n’a été trouvé.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> est introuvable dans <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">L’appelant n’est pas autorisé à appeler ce constructeur.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>for the ability to read the file containing the assembly manifest, or if you are creating a type from a module other than the manifest file.</source>
          <target state="translated">pour la possibilité de lire le fichier contenant le manifeste d’assembly, ou si vous créez un type à partir d’un module autre que le fichier manifest.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Tableau à un ou plusieurs attributs pouvant participer à l'activation.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">En général, tableau contenant un seul objet <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> qui spécifie l'URL nécessaire pour activer un objet distant.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">Ce paramètre concerne les objets activés par le client. L’activation par le client est une technologie héritée qui a été conservée pour la compatibilité descendante. Toutefois, elle n’est pas recommandée pour les nouveaux développements.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Creates a new instance of the specified type.</source>
          <target state="translated">Crée une instance du type spécifié.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Parameters specify the assembly where the type is defined, the name of the type, and an array of activation attributes.</source>
          <target state="translated">Les paramètres spécifient l'assembly dans lequel le type est défini, le nom du type et un tableau d'attributs d'activation.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>An instance of the object specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Instance de l'objet spécifié par <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Il s’agit d’une méthode pratique qui combine <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">Cette méthode appelle le constructeur par défaut <ph id="ph1">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> pour le format de <ph id="ph2">`assemblyName`</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>See the <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> property for the format of <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated">Consultez le <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> propriété pour le format de <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>If you make an early-bound call to a method <ph id="ph1">`M`</ph> of an object of type <ph id="ph2">`T1`</ph> that was returned by <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, and that method makes an early-bound call to a method of an object of type <ph id="ph4">`T2`</ph> in an assembly <ph id="ph5">`C`</ph> other than the current assembly or the assembly containing <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> is loaded into the current application domain.</source>
          <target state="translated">Si vous effectuez un appel à liaison anticipée à une méthode <ph id="ph1">`M`</ph> d’un objet de type <ph id="ph2">`T1`</ph> qui a été retourné par <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, et que le méthode effectue un appel à liaison anticipée à une méthode d’un objet de type <ph id="ph4">`T2`</ph> dans un assembly <ph id="ph5">`C`</ph> autre que le assembly actuel ou l’assembly contenant <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> est chargé dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>This loading occurs even if the early-bound call to <ph id="ph1">`T1.M()`</ph> was made in the body of a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, or in other dynamically generated code.</source>
          <target state="translated">Ce chargement se produit même si l’appel à liaison anticipée à <ph id="ph1">`T1.M()`</ph> a été effectuée dans le corps d’un <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, ou dans un autre code généré dynamiquement.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>If the current domain is the default domain, assembly <ph id="ph1">`C`</ph> cannot be unloaded until the process ends.</source>
          <target state="translated">Si le domaine actuel est le domaine par défaut, assembly <ph id="ph1">`C`</ph> ne peut pas être déchargé jusqu'à ce que le processus se termine.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>If the current domain later attempts to load assembly <ph id="ph1">`C`</ph>, the load might fail.</source>
          <target state="translated">Si le domaine actuel ultérieurement tente de charger l’assembly <ph id="ph1">`C`</ph>, le chargement peut échouer.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>No matching public constructor was found.</source>
          <target state="translated">Aucun constructeur public correspondant n’a été trouvé.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> est introuvable dans <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">L’appelant n’est pas autorisé à appeler ce constructeur.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Pour pouvoir lire le fichier contenant le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to call unmanaged code when creating an instance of a delegate.</source>
          <target state="translated">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">Pour pouvoir appeler des opérations sur tous les membres de type.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">Valeur bouléenne spécifiant s'il convient d'effectuer ou non une recherche qui respecte la casse.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> par le biais de la réflexion.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> a la valeur null, le Binder par défaut est utilisé.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">Arguments à passer au constructeur.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">Ce tableau d'arguments doit posséder les mêmes nombre, ordre et type que les paramètres du constructeur à appeler.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">Si vous préférez utiliser le constructeur par défaut, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> doit être un tableau vide ou null.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A culture-specific object used to govern the coercion of types.</source>
          <target state="translated">Objet propre à la culture utilisé pour régir la contrainte de types.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> du thread actuel est utilisé.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Tableau à un ou plusieurs attributs pouvant participer à l'activation.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object.</source>
          <target state="translated">Généralement, tableau qui contient un seul objet <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">qui spécifie l'URL nécessaire pour activer un objet distant.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">Ce paramètre est lié aux objets activés par le client.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</source>
          <target state="translated">Crée une instance du type spécifié défini dans l’assembly spécifié, en indiquant si la casse du nom de type est ignorée ; les attributs de liaison et le binder utilisés pour sélectionner le type à créer ; les arguments du constructeur ; la culture et les attributs d’activation.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An instance of the object specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Instance de l'objet spécifié par <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Il s’agit d’une méthode pratique qui combine <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> pour le format de <ph id="ph2">`assemblyName`</ph>.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>See the <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> property for the format of <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated">Consultez le <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> propriété pour le format de <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If you make an early-bound call to a method <ph id="ph1">`M`</ph> of an object of type <ph id="ph2">`T1`</ph> that was returned by <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, and that method makes an early-bound call to a method of an object of type <ph id="ph4">`T2`</ph> in an assembly <ph id="ph5">`C`</ph> other than the current assembly or the assembly containing <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> is loaded into the current application domain.</source>
          <target state="translated">Si vous effectuez un appel à liaison anticipée à une méthode <ph id="ph1">`M`</ph> d’un objet de type <ph id="ph2">`T1`</ph> qui a été retourné par <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, et que le méthode effectue un appel à liaison anticipée à une méthode d’un objet de type <ph id="ph4">`T2`</ph> dans un assembly <ph id="ph5">`C`</ph> autre que le assembly actuel ou l’assembly contenant <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> est chargé dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This loading occurs even if the early-bound call to <ph id="ph1">`T1.M()`</ph> was made in the body of a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, or in other dynamically generated code.</source>
          <target state="translated">Ce chargement se produit même si l’appel à liaison anticipée à <ph id="ph1">`T1.M()`</ph> a été effectuée dans le corps d’un <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, ou dans un autre code généré dynamiquement.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the current domain is the default domain, assembly <ph id="ph1">`C`</ph> cannot be unloaded until the process ends.</source>
          <target state="translated">Si le domaine actuel est le domaine par défaut, assembly <ph id="ph1">`C`</ph> ne peut pas être déchargé jusqu'à ce que le processus se termine.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the current domain later attempts to load assembly <ph id="ph1">`C`</ph>, the load might fail.</source>
          <target state="translated">Si le domaine actuel ultérieurement tente de charger l’assembly <ph id="ph1">`C`</ph>, le chargement peut échouer.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The following sample demonstrates the use of the <ph id="ph1">`ignoreCase`</ph> parameter.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de le <ph id="ph1">`ignoreCase`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>No matching constructor was found.</source>
          <target state="translated">Aucun constructeur correspondant n’a été trouvé.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> est introuvable dans <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">L’appelant n’est pas autorisé à appeler ce constructeur.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Pour pouvoir lire le fichier contenant le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to call unmanaged code when creating an instance of a delegate.</source>
          <target state="translated">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">Pour pouvoir appeler des opérations sur tous les membres de type.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">Valeur bouléenne spécifiant s'il convient d'effectuer ou non une recherche qui respecte la casse.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> par le biais de la réflexion.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> a la valeur null, le Binder par défaut est utilisé.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">Arguments à passer au constructeur.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">Ce tableau d'arguments doit posséder les mêmes nombre, ordre et type que les paramètres du constructeur à appeler.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">Si vous préférez utiliser le constructeur par défaut, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> doit être un tableau vide ou null.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A culture-specific object used to govern the coercion of types.</source>
          <target state="translated">Objet propre à la culture utilisé pour régir la contrainte de types.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> du thread actuel est utilisé.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Tableau à un ou plusieurs attributs pouvant participer à l'activation.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">En général, tableau contenant un seul objet <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> qui spécifie l'URL nécessaire pour activer un objet distant.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">Ce paramètre est lié aux objets activés par le client.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Information used to authorize creation of <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Informations utilisées pour autoriser la création de <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Creates a new instance of the specified type.</source>
          <target state="translated">Crée une instance du type spécifié.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Parameters specify the name of the type, and how it is found and created.</source>
          <target state="translated">Les paramètres spécifient le nom du type et la manière dont il est recherché et créé.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An instance of the object specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Instance de l'objet spécifié par <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Il s’agit d’une méthode pratique qui combine <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> pour le format de <ph id="ph2">`assemblyName`</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>See the <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> property for the format of <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated">Consultez le <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> propriété pour le format de <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If you make an early-bound call to a method <ph id="ph1">`M`</ph> of an object of type <ph id="ph2">`T1`</ph> that was returned by <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, and that method makes an early-bound call to a method of an object of type <ph id="ph4">`T2`</ph> in an assembly <ph id="ph5">`C`</ph> other than the current assembly or the assembly containing <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> is loaded into the current application domain.</source>
          <target state="translated">Si vous effectuez un appel à liaison anticipée à une méthode <ph id="ph1">`M`</ph> d’un objet de type <ph id="ph2">`T1`</ph> qui a été retourné par <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, et que le méthode effectue un appel à liaison anticipée à une méthode d’un objet de type <ph id="ph4">`T2`</ph> dans un assembly <ph id="ph5">`C`</ph> autre que le assembly actuel ou l’assembly contenant <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> est chargé dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This loading occurs even if the early-bound call to <ph id="ph1">`T1.M()`</ph> was made in the body of a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, or in other dynamically generated code.</source>
          <target state="translated">Ce chargement se produit même si l’appel à liaison anticipée à <ph id="ph1">`T1.M()`</ph> a été effectuée dans le corps d’un <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, ou dans un autre code généré dynamiquement.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the current domain is the default domain, assembly <ph id="ph1">`C`</ph> cannot be unloaded until the process ends.</source>
          <target state="translated">Si le domaine actuel est le domaine par défaut, assembly <ph id="ph1">`C`</ph> ne peut pas être déchargé jusqu'à ce que le processus se termine.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the current domain later attempts to load assembly <ph id="ph1">`C`</ph>, the load might fail.</source>
          <target state="translated">Si le domaine actuel ultérieurement tente de charger l’assembly <ph id="ph1">`C`</ph>, le chargement peut échouer.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The following sample demonstrates the use of the <ph id="ph1">`ignoreCase`</ph> parameter.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de le <ph id="ph1">`ignoreCase`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>No matching constructor was found.</source>
          <target state="translated">Aucun constructeur correspondant n’a été trouvé.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> est introuvable dans <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">L’appelant n’est pas autorisé à appeler ce constructeur.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Pour pouvoir lire le fichier contenant le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">Pour pouvoir appeler des opérations sur tous les membres de type.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new instance of a specified type defined in the specified assembly file.</source>
          <target state="translated">Crée une instance d'un type spécifié défini dans le fichier d'assembly déterminé.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The name, including the path, of a file that contains an assembly that defines the requested type.</source>
          <target state="translated">Nom, y compris le chemin d'accès, d'un fichier qui contient un assembly définissant le type demandé.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The assembly is loaded using the <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> method.</source>
          <target state="translated">L'assembly est chargé à l'aide de la méthode <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">Crée une instance du type spécifié défini dans le fichier d'assembly déterminé.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>An object that is a wrapper for the new instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Objet qui est un wrapper de la nouvelle instance, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The default constructor for <ph id="ph1">`typeName`</ph> is invoked.</source>
          <target state="translated">Le constructeur par défaut <ph id="ph1">`typeName`</ph> est appelé.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour plus d'informations, voir la méthode <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>When the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</source>
          <target state="translated">Lorsque la <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> méthode est utilisée pour créer une instance dans un domaine d’application cible autre que le domaine d’application à partir de laquelle l’appel est effectué, l’assembly est chargé dans le domaine d’application cible.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</source>
          <target state="translated">Toutefois, si l’instance est désencapsulée dans le domaine d’application appelant, à l’aide de cette instance de certaines façons peut entraîner l’assembly doit être chargé dans le domaine d’application appelant.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</source>
          <target state="translated">Par exemple, une fois que l’instance est désencapsulée, ses informations de type peuvent être demandées, afin d’appeler ses méthodes à liaison tardive.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>When the assembly is loaded into the calling application domain, exceptions can occur.</source>
          <target state="translated">Lorsque l’assembly est chargé dans le domaine d’application appelant, des exceptions peuvent se produire.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> can occur.</source>
          <target state="translated">Si une autre version du même assembly a été précédemment chargée dans le domaine d’application appelant, ou si le chemin de chargement du domaine d’application appelant est différent de celui du domaine d’application cible, exceptions, tel que <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> peut se produire.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>If the calling application domain makes early-bound calls to the instance type, <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> can be thrown when an attempt is made to cast the instance.</source>
          <target state="translated">Si le domaine d’application appelant effectue des appels à liaison anticipée au type d’instance, <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> peut être levée lorsqu’une tentative est faite pour effectuer un cast de l’instance.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29&gt;</ph> method overload to create an instance of an object in a target application domain and call its methods.</source>
          <target state="translated">L’exemple suivant montre comment utiliser le <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29&gt;</ph> surcharge de méthode pour créer une instance d’un objet dans un domaine d’application cible et appeler ses méthodes.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The example defines the <ph id="ph1">`MarshallableExample`</ph> class, which can be marshaled across application domain boundaries.</source>
          <target state="translated">L’exemple définit le <ph id="ph1">`MarshallableExample`</ph> (classe), qui peut être marshalée au-delà des limites du domaine d’application.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The example builds a path to the currently executing assembly, creates a target application domain, and uses the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29&gt;</ph> method overload to load the example assembly into the target application domain and create an instance of <ph id="ph2">`MarshallableExample`</ph>.</source>
          <target state="translated">L’exemple génère un chemin d’accès à l’assembly en cours d’exécution, crée un domaine d’application cible et utilise le <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29&gt;</ph> surcharge de méthode pour charger l’assembly de l’exemple dans le domaine d’application cible et créer une instance de <ph id="ph2">`MarshallableExample`</ph>.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The path is absolute in this example, but a relative path would also work because the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph> method is used to load the assembly.</source>
          <target state="translated">Le chemin d’accès est absolu dans cet exemple, mais un chemin d’accès relatif fonctionne également, car le <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph> méthode est utilisée pour charger l’assembly.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:</source>
          <target state="translated">Après avoir Désencapsulation le handle d’objet, l’exemple illustre trois façons d’utiliser un objet dans un domaine d’application cible :</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Invoking a method with late binding, using reflection.</source>
          <target state="translated">Appel d’une méthode avec liaison tardive, à l’aide de la réflexion.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>This requires type information, which causes the assembly to be loaded into the application domain of the caller.</source>
          <target state="translated">Cela nécessite des informations de type, ce qui entraîne l’assembly doit être chargé dans le domaine d’application de l’appelant.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>(In this example, it is already loaded.)</source>
          <target state="translated">(Dans cet exemple, il est déjà chargé.)</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Casting the object to an interface known to both the caller and the callee.</source>
          <target state="translated">Effectuer un cast de l’objet en une interface connue à l’appelant et l’appelé.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.</source>
          <target state="translated">Si l’interface est définie dans l’assembly appelant ou dans un assembly tiers référencé par l’appelant et l’appelé, l’assembly appelé n’est pas chargé dans le domaine d’application de l’appelant.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Using the object directly when its type is known to the caller.</source>
          <target state="translated">À l’aide de l’objet directement lorsque son type est connu à l’appelant.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The assembly must be loaded into the application domain of the caller.</source>
          <target state="translated">L’assembly doit être chargé dans le domaine d’application de l’appelant.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph> class and to define a method that can be run in the target application domain.</source>
          <target state="translated">Une autre consiste à éviter de charger l’assembly appelé dans le domaine d’application de l’appelant à l’appelant de dériver le <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph> classe et pour définir une méthode qui peut être exécutée dans le domaine d’application cible.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain.</source>
          <target state="translated">Cette méthode peut utiliser la réflexion pour examiner un assembly cible, car l’assembly cible est déjà chargé dans le domaine d’application cible.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>See the example for the <ph id="ph1">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph> property.</source>
          <target state="translated">Consultez l’exemple de la <ph id="ph1">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est introuvable dans <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>No parameterless public constructor was found.</source>
          <target state="translated">Aucun constructeur sans paramètre public n'a été trouvé.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">L’appelant n’a pas les autorisations suffisantes pour appeler ce constructeur.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L’instance est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Pour pouvoir lire le fichier contenant le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The name, including the path, of a file that contains an assembly that defines the requested type.</source>
          <target state="translated">Nom, y compris le chemin d'accès, d'un fichier qui contient un assembly définissant le type demandé.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The assembly is loaded using the <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> method.</source>
          <target state="translated">L'assembly est chargé à l'aide de la méthode <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Tableau à un ou plusieurs attributs pouvant participer à l'activation.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">En général, tableau contenant un seul objet <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> qui spécifie l'URL nécessaire pour activer un objet distant.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">Ce paramètre concerne les objets activés par le client. L’activation par le client est une technologie héritée qui a été conservée pour la compatibilité descendante. Toutefois, elle n’est pas recommandée pour les nouveaux développements.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">Crée une instance du type spécifié défini dans le fichier d'assembly déterminé.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>An object that is a wrapper for the new instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Objet qui est un wrapper de la nouvelle instance, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The default constructor for <ph id="ph1">`typeName`</ph> is invoked.</source>
          <target state="translated">Le constructeur par défaut <ph id="ph1">`typeName`</ph> est appelé.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>For more information about this method, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour plus d’informations sur cette méthode, consultez la <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>When the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</source>
          <target state="translated">Lorsque la <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> méthode est utilisée pour créer une instance dans un domaine d’application cible autre que le domaine d’application à partir de laquelle l’appel est effectué, l’assembly est chargé dans le domaine d’application cible.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</source>
          <target state="translated">Toutefois, si l’instance est désencapsulée dans le domaine d’application appelant, à l’aide de cette instance de certaines façons peut entraîner l’assembly doit être chargé dans le domaine d’application appelant.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</source>
          <target state="translated">Par exemple, une fois que l’instance est désencapsulée, ses informations de type peuvent être demandées, afin d’appeler ses méthodes à liaison tardive.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>When the assembly is loaded into the calling application domain, exceptions can occur.</source>
          <target state="translated">Lorsque l’assembly est chargé dans le domaine d’application appelant, des exceptions peuvent se produire.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> can occur.</source>
          <target state="translated">Si une autre version du même assembly a été précédemment chargée dans le domaine d’application appelant, ou si le chemin de chargement du domaine d’application appelant est différent de celui du domaine d’application cible, exceptions, tel que <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> peut se produire.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>If the calling application domain makes early-bound calls to the instance type, <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> can be thrown when an attempt is made to cast the instance.</source>
          <target state="translated">Si le domaine d’application appelant effectue des appels à liaison anticipée au type d’instance, <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> peut être levée lorsqu’une tentative est faite pour effectuer un cast de l’instance.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est introuvable dans <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">L’appelant n’a pas les autorisations suffisantes pour appeler ce constructeur.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>No matching public constructor was found.</source>
          <target state="translated">Aucun constructeur public correspondant n’a été trouvé.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L’instance est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Pour pouvoir lire le fichier contenant le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The name, including the path, of a file that contains an assembly that defines the requested type.</source>
          <target state="translated">Nom, y compris le chemin d'accès, d'un fichier qui contient un assembly définissant le type demandé.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The assembly is loaded using the <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> method.</source>
          <target state="translated">L'assembly est chargé à l'aide de la méthode <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">Valeur bouléenne spécifiant s'il convient d'effectuer ou non une recherche qui respecte la casse.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects through reflection.</source>
          <target state="translated">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> par la réflexion.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> a la valeur null, le Binder par défaut est utilisé.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">Arguments à passer au constructeur.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">Ce tableau d'arguments doit posséder les mêmes nombre, ordre et type que les paramètres du constructeur à appeler.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">Si vous préférez utiliser le constructeur par défaut, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> doit être un tableau vide ou null.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Informations propres à la culture qui définissent la contrainte de <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> pour les types formels déclarés du constructeur <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> du thread actuel est utilisé.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Tableau à un ou plusieurs attributs pouvant participer à l'activation.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">En général, tableau contenant un seul objet <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> qui spécifie l'URL nécessaire pour activer un objet distant.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">Ce paramètre est lié aux objets activés par le client.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">Crée une instance du type spécifié défini dans le fichier d'assembly déterminé.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that is a wrapper for the new instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Objet qui est un wrapper de la nouvelle instance, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour plus d'informations, voir la méthode <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>When the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</source>
          <target state="translated">Lorsque la <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> méthode est utilisée pour créer une instance dans un domaine d’application cible autre que le domaine d’application à partir de laquelle l’appel est effectué, l’assembly est chargé dans le domaine d’application cible.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</source>
          <target state="translated">Toutefois, si l’instance est désencapsulée dans le domaine d’application appelant, à l’aide de cette instance de certaines façons peut entraîner l’assembly doit être chargé dans le domaine d’application appelant.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</source>
          <target state="translated">Par exemple, une fois que l’instance est désencapsulée, ses informations de type peuvent être demandées, afin d’appeler ses méthodes à liaison tardive.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>When the assembly is loaded into the calling application domain, exceptions can occur.</source>
          <target state="translated">Lorsque l’assembly est chargé dans le domaine d’application appelant, des exceptions peuvent se produire.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> can occur.</source>
          <target state="translated">Si une autre version du même assembly a été précédemment chargée dans le domaine d’application appelant, ou si le chemin de chargement du domaine d’application appelant est différent de celui du domaine d’application cible, exceptions, tel que <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> peut se produire.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the calling application domain makes early-bound calls to the instance type, <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> can be thrown when an attempt is made to cast the instance.</source>
          <target state="translated">Si le domaine d’application appelant effectue des appels à liaison anticipée au type d’instance, <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> peut être levée lorsqu’une tentative est faite pour effectuer un cast de l’instance.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est introuvable dans <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>No matching public constructor was found.</source>
          <target state="translated">Aucun constructeur public correspondant n’a été trouvé.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">L’appelant n’a pas les autorisations suffisantes pour appeler ce constructeur.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L’instance est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Pour pouvoir lire le fichier contenant le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The name, including the path, of a file that contains an assembly that defines the requested type.</source>
          <target state="translated">Nom, y compris le chemin d'accès, d'un fichier qui contient un assembly définissant le type demandé.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The assembly is loaded using the <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> method.</source>
          <target state="translated">L'assembly est chargé à l'aide de la méthode <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">Valeur bouléenne spécifiant s'il convient d'effectuer ou non une recherche qui respecte la casse.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects through reflection.</source>
          <target state="translated">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> par la réflexion.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> a la valeur null, le Binder par défaut est utilisé.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">Arguments à passer au constructeur.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">Ce tableau d'arguments doit posséder les mêmes nombre, ordre et type que les paramètres du constructeur à appeler.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">Si vous préférez utiliser le constructeur par défaut, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> doit être un tableau vide ou null.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Informations propres à la culture qui définissent la contrainte de <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> pour les types formels déclarés du constructeur <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> du thread actuel est utilisé.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Tableau à un ou plusieurs attributs pouvant participer à l'activation.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">En général, tableau contenant un seul objet <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> qui spécifie l'URL nécessaire pour activer un objet distant.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">Ce paramètre est lié aux objets activés par le client.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Information used to authorize creation of <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Informations utilisées pour autoriser la création de <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">Crée une instance du type spécifié défini dans le fichier d'assembly déterminé.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that is a wrapper for the new instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Objet qui est un wrapper de la nouvelle instance, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>For more information about this method, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour plus d’informations sur cette méthode, consultez la <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>When the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</source>
          <target state="translated">Lorsque la <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> méthode est utilisée pour créer une instance dans un domaine d’application cible autre que le domaine d’application à partir de laquelle l’appel est effectué, l’assembly est chargé dans le domaine d’application cible.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</source>
          <target state="translated">Toutefois, si l’instance est désencapsulée dans le domaine d’application appelant, à l’aide de cette instance de certaines façons peut entraîner l’assembly doit être chargé dans le domaine d’application appelant.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</source>
          <target state="translated">Par exemple, une fois que l’instance est désencapsulée, ses informations de type peuvent être demandées, afin d’appeler ses méthodes à liaison tardive.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>When the assembly is loaded into the calling application domain, exceptions can occur.</source>
          <target state="translated">Lorsque l’assembly est chargé dans le domaine d’application appelant, des exceptions peuvent se produire.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> can occur.</source>
          <target state="translated">Si une autre version du même assembly a été précédemment chargée dans le domaine d’application appelant, ou si le chemin de chargement du domaine d’application appelant est différent de celui du domaine d’application cible, exceptions, tel que <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> peut se produire.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the calling application domain makes early-bound calls to the instance type, <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> can be thrown when an attempt is made to cast the instance.</source>
          <target state="translated">Si le domaine d’application appelant effectue des appels à liaison anticipée au type d’instance, <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> peut être levée lorsqu’une tentative est faite pour effectuer un cast de l’instance.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> n’est pas un <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Quand la stratégie CAS héritée n’est pas activée, <ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> doit être <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est introuvable dans <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>No matching public constructor was found.</source>
          <target state="translated">Aucun constructeur public correspondant n’a été trouvé.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">L’appelant n’a pas les autorisations suffisantes pour appeler ce constructeur.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L’instance est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Pour pouvoir lire le fichier contenant le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>to provide evidence.</source>
          <target state="translated">pour fournir la preuve.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new instance of a specified type defined in the specified assembly file.</source>
          <target state="translated">Crée une instance d'un type spécifié défini dans le fichier d'assembly déterminé.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>The file name and path of the assembly that defines the requested type.</source>
          <target state="translated">Nom de fichier et chemin d’accès à l’assembly qui définit le type demandé.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">Crée une instance du type spécifié défini dans le fichier d'assembly déterminé.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>The requested object, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">L'objet demandé, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Il s’agit d’une méthode pratique qui combine <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">Cette méthode appelle le constructeur par défaut <ph id="ph1">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour plus d'informations, voir la méthode <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est introuvable dans <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>No parameterless public constructor was found.</source>
          <target state="translated">Aucun constructeur sans paramètre public n'a été trouvé.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">L’appelant n’a pas les autorisations suffisantes pour appeler ce constructeur.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Pour pouvoir lire le fichier contenant le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The file name and path of the assembly that defines the requested type.</source>
          <target state="translated">Nom de fichier et chemin d’accès à l’assembly qui définit le type demandé.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly (see the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property).</source>
          <target state="translated">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly (consultez la propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Tableau à un ou plusieurs attributs pouvant participer à l'activation.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">En général, tableau contenant un seul objet <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> qui spécifie l'URL nécessaire pour activer un objet distant.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">Ce paramètre concerne les objets activés par le client. L’activation par le client est une technologie héritée qui a été conservée pour la compatibilité descendante. Toutefois, elle n’est pas recommandée pour les nouveaux développements.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">Crée une instance du type spécifié défini dans le fichier d'assembly déterminé.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The requested object, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">L'objet demandé, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Il s’agit d’une méthode pratique qui combine <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">Cette méthode appelle le constructeur par défaut <ph id="ph1">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>For more information about this method, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour plus d’informations sur cette méthode, consultez la <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est introuvable dans <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>No parameterless public constructor was found.</source>
          <target state="translated">Aucun constructeur sans paramètre public n'a été trouvé.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">L’appelant n’a pas les autorisations suffisantes pour appeler ce constructeur.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Pour pouvoir lire le fichier contenant le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The file name and path of the assembly that defines the requested type.</source>
          <target state="translated">Nom de fichier et chemin d’accès à l’assembly qui définit le type demandé.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">Valeur bouléenne spécifiant s'il convient d'effectuer ou non une recherche qui respecte la casse.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects through reflection.</source>
          <target state="translated">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> par la réflexion.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> a la valeur null, le Binder par défaut est utilisé.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">Arguments à passer au constructeur.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">Ce tableau d'arguments doit posséder les mêmes nombre, ordre et type que les paramètres du constructeur à appeler.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">Si vous préférez utiliser le constructeur par défaut, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> doit être un tableau vide ou null.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Informations propres à la culture qui définissent la contrainte de <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> pour les types formels déclarés du constructeur <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> du thread actuel est utilisé.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Tableau à un ou plusieurs attributs pouvant participer à l'activation.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">En général, tableau contenant un seul objet <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> qui spécifie l'URL nécessaire pour activer un objet distant.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">Ce paramètre est lié aux objets activés par le client.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly file, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</source>
          <target state="translated">Crée une instance du type spécifié défini dans le fichier d’assembly spécifié, en indiquant si la casse du nom de type est ignorée ; les attributs de liaison et le binder utilisés pour sélectionner le type à créer ; les arguments du constructeur ; la culture et les attributs d’activation.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The requested object, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">L'objet demandé, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Il s’agit d’une méthode pratique qui combine <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>For more information about this method, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour plus d’informations sur cette méthode, consultez la <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est introuvable dans <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>No matching public constructor was found.</source>
          <target state="translated">Aucun constructeur public correspondant n’a été trouvé.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">L’appelant n’a pas les autorisations suffisantes pour appeler ce constructeur.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version of the common language runtime that the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Pour pouvoir lire le fichier contenant le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The file name and path of the assembly that defines the requested type.</source>
          <target state="translated">Nom de fichier et chemin d’accès à l’assembly qui définit le type demandé.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">Valeur bouléenne spécifiant s'il convient d'effectuer ou non une recherche qui respecte la casse.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects through reflection.</source>
          <target state="translated">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> par la réflexion.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> a la valeur null, le Binder par défaut est utilisé.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">Arguments à passer au constructeur.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">Ce tableau d'arguments doit posséder les mêmes nombre, ordre et type que les paramètres du constructeur à appeler.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">Si vous préférez utiliser le constructeur par défaut, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> doit être un tableau vide ou null.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Informations propres à la culture qui définissent la contrainte de <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> pour les types formels déclarés du constructeur <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> du thread actuel est utilisé.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Tableau à un ou plusieurs attributs pouvant participer à l'activation.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">En général, tableau contenant un seul objet <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> qui spécifie l'URL nécessaire pour activer un objet distant.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">Ce paramètre est lié aux objets activés par le client.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Information used to authorize creation of <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Informations utilisées pour autoriser la création de <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">Crée une instance du type spécifié défini dans le fichier d'assembly déterminé.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The requested object, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">L'objet demandé, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Il s’agit d’une méthode pratique qui combine <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>For more information about this method, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour plus d’informations sur cette méthode, consultez la <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> est introuvable dans <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>No matching public constructor was found.</source>
          <target state="translated">Aucun constructeur public correspondant n’a été trouvé.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">L’appelant n’a pas les autorisations suffisantes pour appeler ce constructeur.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Pour pouvoir lire le fichier contenant le manifeste d’assembly.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="P:System.AppDomain.CurrentDomain">
          <source>Gets the current application domain for the current <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>.</source>
          <target state="translated">Obtient le domaine d'application actuel pour le <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.CurrentDomain">
          <source>The current application domain.</source>
          <target state="translated">Domaine d'application actuel.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.CurrentDomain">
          <source>The following code example creates a new application domain.</source>
          <target state="translated">L’exemple de code suivant crée un nouveau domaine d’application.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.CurrentDomain">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.CurrentDomain%2A&gt;</ph> property is used to obtain an <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph> object that represents the current application domain.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.CurrentDomain%2A&gt;</ph> propriété est utilisée pour obtenir un <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph> objet qui représente le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.CurrentDomain">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.FriendlyName%2A&gt;</ph> property provides the name of the current application domain, which is then displayed at the command line.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.FriendlyName%2A&gt;</ph> fournit le nom du domaine d’application actuel, qui est ensuite affiché sur la ligne de commande.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Defines a dynamic assembly in the current application domain.</source>
          <target state="translated">Définit un assembly dynamique dans le domaine d'application actuel.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identité unique de l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The access mode for the dynamic assembly.</source>
          <target state="translated">Mode d'accès de l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>Defines a dynamic assembly with the specified name and access mode.</source>
          <target state="translated">Définit un assembly dynamique avec le nom et le mode d'accès spécifiés.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>A dynamic assembly with the specified name and access mode.</source>
          <target state="translated">un assembly dynamique avec le nom et le mode d'accès spécifiés.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Cette méthode doit uniquement être utilisée pour définir un assembly dynamique dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé d’utiliser une surcharge de la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode qui spécifie la preuve et les autorisations, fournissez la preuve que vous souhaitez que l’assembly dynamique et d’inclure <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> dans <ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Y compris <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> dans le <ph id="ph2">`refusedPermissions`</ph> paramètre garantit que le langage MSIL est vérifié.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Une limitation de cette technique est qu’elle entraîne également <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> levée lorsqu’il est utilisé avec le code qui demande une confiance totale.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">L’exemple suivant montre comment la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode et <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez <bpt id="p1">[</bpt>les noms d’assemblys<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identité unique de l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The access mode for the dynamic assembly.</source>
          <target state="translated">Mode d'accès de l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>An enumerable list of attributes to be applied to the assembly, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if there are no attributes.</source>
          <target state="translated">Une liste enumérable d'attributs à appliquer à l'assembly, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> s'il n'y a pas d'attributs.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Defines a dynamic assembly with the specified name, access mode, and custom attributes.</source>
          <target state="translated">Définit un assembly dynamique avec le nom, le mode d'accès et les attributs personnalisés spécifiés.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dynamique avec le nom et les fonctionnalités spécifiés.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</source>
          <target state="translated">Utilisez cette surcharge de méthode pour spécifier les attributs qui ne fonctionnent pas correctement, sauf si elles sont appliquées lors de la création d’un assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>For example, security attributes such as <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> do not work correctly if they are added after a dynamic assembly has been created.</source>
          <target state="translated">Par exemple, sécurité des attributs tels que <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> et <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> ne fonctionnent pas correctement s’ils sont ajoutés après la création d’un assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>This method should be used only to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Cette méthode doit être utilisée uniquement pour définir un assembly dynamique dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>For more information about this restriction, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations sur cette restriction, consultez la <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>This method overload is introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>.</source>
          <target state="translated">Cette surcharge de méthode a été introduite dans le <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The following code sample shows how to create a dynamic assembly that has the <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment créer un assembly dynamique qui a le <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The attribute must be specified as an element of an array of <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objects.</source>
          <target state="translated">L’attribut doit être spécifié en tant qu’élément d’un tableau de <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The first step in creating the <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> is to obtain a constructor for the attribute.</source>
          <target state="translated">La première étape de création de la <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> pour obtenir un constructeur de l’attribut.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The constructor has no parameters, so the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method is called with an empty array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects to represent the types of the parameters.</source>
          <target state="translated">Le constructeur n’a aucun paramètre, donc la <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> méthode est appelée avec un tableau vide de <ph id="ph2">&lt;xref:System.Type&gt;</ph> objets pour représenter les types des paramètres.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The second step is to pass the resulting <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object to the constructor for the <ph id="ph2">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> class, together with an empty array of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> to represent the arguments.</source>
          <target state="translated">La deuxième étape consiste à passer résultant <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objet au constructeur pour le <ph id="ph2">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> (classe), ainsi que d’un tableau vide de type <ph id="ph3">&lt;xref:System.Object&gt;</ph> pour représenter les arguments.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The resulting <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> is then passed to the <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method as the only element of an array.</source>
          <target state="translated">Résultant <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> est ensuite transmise à la <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode comme étant le seul élément d’un tableau.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.</source>
          <target state="translated">L’exemple de code définit un module et un type dans le nouvel assembly dynamique, puis affiche les attributs de l’assembly.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> starts with white space, or contains a forward or backward slash.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> commence par un espace blanc ou bien contient une barre oblique ou une barre oblique inverse.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identité unique de l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Mode d'accès à l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The evidence supplied for the dynamic assembly.</source>
          <target state="translated">Preuve fournie pour l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">La preuve est utilisée non modifiée en tant qu’ensemble de preuves final pour la résolution de stratégie.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>Defines a dynamic assembly using the specified name, access mode, and evidence.</source>
          <target state="translated">Définit un assembly dynamique avec le nom, le mode d'accès et la preuve spécifiés.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dynamique avec le nom et les fonctionnalités spécifiés.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>Only fully trusted callers can supply their <ph id="ph1">`evidence`</ph> when defining a dynamic <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">Uniquement entièrement fiable les appelants peuvent fournir leurs <ph id="ph1">`evidence`</ph> lorsque vous définissez un dynamique <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The runtime will map the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">Le runtime mappe la <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> via la stratégie de sécurité pour déterminer les autorisations accordées.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>Partially trusted callers must supply a null <ph id="ph1">`evidence`</ph>.</source>
          <target state="translated">Les appelants doivent fournir une valeur null de confiance partielle <ph id="ph1">`evidence`</ph>.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> to the dynamic <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> being defined and marks policy as resolved.</source>
          <target state="translated">Si <ph id="ph1">`evidence`</ph> est <ph id="ph2">`null`</ph>, le runtime copie les jeux d’autorisations, autrement dit, en cours grant et deny des jeux, à partir de l’appelant <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> la dynamique <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> actuellement défini et marque la stratégie comme résolue.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>If the dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> was saved.</source>
          <target state="translated">Si la dynamique <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> est enregistré sur le disque, les chargements suivants obtiennent des autorisations en fonction des stratégies associées à l’emplacement où le <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> a été enregistré.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Cette méthode doit uniquement être utilisée pour définir un assembly dynamique dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé d’utiliser une surcharge de la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode qui spécifie la preuve et les autorisations, fournissez la preuve que vous souhaitez que l’assembly dynamique et d’inclure <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> dans <ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Y compris <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> dans le <ph id="ph2">`refusedPermissions`</ph> paramètre garantit que le langage MSIL est vérifié.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Une limitation de cette technique est qu’elle entraîne également <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> levée lorsqu’il est utilisé avec le code qui demande une confiance totale.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">L’exemple suivant montre comment la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> (méthode) et le <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>First, the code example tries to create an instance of <ph id="ph1">`MyDynamicType`</ph> by calling the <ph id="ph2">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> method with an invalid assembly name, and catches the resulting exception.</source>
          <target state="translated">Tout d’abord, l’exemple de code essaie de créer une instance de <ph id="ph1">`MyDynamicType`</ph> en appelant le <ph id="ph2">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> méthode avec un nom d’assembly non valide et intercepte l’exception résultante.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The code example then adds an event handler for the <ph id="ph1">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event, and again tries to create an instance of<ph id="ph2">`MyDynamicType`</ph>.</source>
          <target state="translated">L’exemple de code ajoute ensuite un gestionnaire d’événements pour le <ph id="ph1">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> événement et réessaie de créer une instance de<ph id="ph2">`MyDynamicType`</ph>.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>During the call to <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event is raised for the invalid assembly.</source>
          <target state="translated">Lors de l’appel à <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>, le <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> événement est déclenché pour l’assembly non valide.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The event handler creates a dynamic assembly that contains a type named <ph id="ph1">`MyDynamicType`</ph>, gives the type a parameterless constructor, and returns the new dynamic assembly.</source>
          <target state="translated">Le Gestionnaire d’événements crée un assembly dynamique qui contient un type nommé <ph id="ph1">`MyDynamicType`</ph>, lui donne un constructeur sans paramètre et retourne le nouvel assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The call to <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> then finishes successfully, and the constructor for <ph id="ph2">`MyDynamicType`</ph> displays a message at the console.</source>
          <target state="translated">L’appel à <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> puis se termine avec succès et le constructeur de <ph id="ph2">`MyDynamicType`</ph> affiche un message à la console.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identité unique de l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Mode d'accès à l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The name of the directory where the assembly will be saved.</source>
          <target state="translated">Nom du répertoire dans lequel l'assembly doit être enregistré.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the directory defaults to the current directory.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le répertoire actif est utilisé comme répertoire par défaut.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>Defines a dynamic assembly using the specified name, access mode, and storage directory.</source>
          <target state="translated">Définit un assembly dynamique avec le nom, le mode d'accès et le répertoire de stockage spécifiés.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dynamique avec le nom et les fonctionnalités spécifiés.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Cette méthode doit uniquement être utilisée pour définir un assembly dynamique dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé d’utiliser une surcharge de la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode qui spécifie la preuve et les autorisations, fournissez la preuve que vous souhaitez que l’assembly dynamique et d’inclure <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> dans <ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Y compris <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> dans le <ph id="ph2">`refusedPermissions`</ph> paramètre garantit que le langage MSIL est vérifié.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Une limitation de cette technique est qu’elle entraîne également <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> levée lorsqu’il est utilisé avec le code qui demande une confiance totale.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">L’exemple suivant montre comment la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode et <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez <bpt id="p1">[</bpt>les noms d’assemblys<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identité unique de l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The access mode for the dynamic assembly.</source>
          <target state="translated">Mode d'accès de l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>An enumerable list of attributes to be applied to the assembly, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if there are no attributes.</source>
          <target state="translated">Une liste enumérable d'attributs à appliquer à l'assembly, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> s'il n'y a pas d'attributs.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The source of the security context.</source>
          <target state="translated">Source du contexte de sécurité.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>Defines a dynamic assembly with the specified name, access mode, and custom attributes, and using the specified source for its security context.</source>
          <target state="translated">Définit un assembly dynamique avec le nom, le mode d'accès et les attributs personnalisés spécifiés, à l'aide de la source indiquée pour son contexte de sécurité.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dynamique avec le nom et les fonctionnalités spécifiés.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</source>
          <target state="translated">Utilisez cette surcharge de méthode pour spécifier les attributs qui ne fonctionnent pas correctement, sauf si elles sont appliquées lors de la création d’un assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>For example, security attributes such as <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> do not work correctly if they are added after a dynamic assembly has been created.</source>
          <target state="translated">Par exemple, sécurité des attributs tels que <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> et <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> ne fonctionnent pas correctement s’ils sont ajoutés après la création d’un assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>This method should be used only to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Cette méthode doit être utilisée uniquement pour définir un assembly dynamique dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>For more information about this restriction, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations sur cette restriction, consultez la <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> starts with white space, or contains a forward or backward slash.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> commence par un espace blanc ou bien contient une barre oblique ou une barre oblique inverse.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The value of <ph id="ph1">&lt;paramref name="securityContextSource" /&gt;</ph> was not one of the enumeration values.</source>
          <target state="translated">La valeur de <ph id="ph1">&lt;paramref name="securityContextSource" /&gt;</ph> ne correspondait pas à une des valeurs d'énumération.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identité unique de l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Mode d'accès à l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The name of the directory where the assembly will be saved.</source>
          <target state="translated">Nom du répertoire dans lequel l'assembly doit être enregistré.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the directory defaults to the current directory.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le répertoire actif est utilisé comme répertoire par défaut.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The evidence supplied for the dynamic assembly.</source>
          <target state="translated">Preuve fournie pour l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">La preuve est utilisée non modifiée en tant qu’ensemble de preuves final pour la résolution de stratégie.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>Defines a dynamic assembly using the specified name, access mode, storage directory, and evidence.</source>
          <target state="translated">Définit un assembly dynamique avec le nom, le mode d'accès, le répertoire de stockage et la preuve spécifiés.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dynamique avec le nom et les fonctionnalités spécifiés.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>Only fully trusted callers can supply their <ph id="ph1">`evidence`</ph> when defining a dynamic <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">Uniquement entièrement fiable les appelants peuvent fournir leurs <ph id="ph1">`evidence`</ph> lorsque vous définissez un dynamique <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The runtime will map the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">Le runtime mappe la <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> via la stratégie de sécurité pour déterminer les autorisations accordées.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>Partially trusted callers must supply a null <ph id="ph1">`evidence`</ph>.</source>
          <target state="translated">Les appelants doivent fournir une valeur null de confiance partielle <ph id="ph1">`evidence`</ph>.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> to the dynamic <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> being defined and marks policy as resolved.</source>
          <target state="translated">Si <ph id="ph1">`evidence`</ph> est <ph id="ph2">`null`</ph>, le runtime copie les jeux d’autorisations, autrement dit, en cours grant et deny des jeux, à partir de l’appelant <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> la dynamique <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> actuellement défini et marque la stratégie comme résolue.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>If the dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> was saved.</source>
          <target state="translated">Si la dynamique <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> est enregistré sur le disque, les chargements suivants obtiennent des autorisations en fonction des stratégies associées à l’emplacement où le <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> a été enregistré.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Cette méthode doit uniquement être utilisée pour définir un assembly dynamique dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé d’utiliser une surcharge de la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode qui spécifie la preuve et les autorisations, fournissez la preuve que vous souhaitez que l’assembly dynamique et d’inclure <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> dans <ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Y compris <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> dans le <ph id="ph2">`refusedPermissions`</ph> paramètre garantit que le langage MSIL est vérifié.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Une limitation de cette technique est qu’elle entraîne également <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> levée lorsqu’il est utilisé avec le code qui demande une confiance totale.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">L’exemple suivant montre comment la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode et <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez <bpt id="p1">[</bpt>les noms d’assemblys<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identité unique de l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Mode d'accès à l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The required permissions request.</source>
          <target state="translated">Demande d'autorisations requises.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The optional permissions request.</source>
          <target state="translated">Demande d'autorisations facultatives.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The refused permissions request.</source>
          <target state="translated">Demande d'autorisations refusées.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Defines a dynamic assembly using the specified name, access mode, and permission requests.</source>
          <target state="translated">Définit un assembly dynamique avec le nom, le mode d'accès et les demandes d'autorisations spécifiés.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dynamique avec le nom et les fonctionnalités spécifiés.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The permission requests specified for <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> are not used unless the dynamic assembly has been saved and reloaded into memory.</source>
          <target state="translated">Les demandes d’autorisations spécifiés pour <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, et <ph id="ph3">`refusedPermissions`</ph> ne sont pas utilisés, sauf si l’assembly dynamique a été enregistré et rechargé en mémoire.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence as well as requested permissions, and supply an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> object.</source>
          <target state="translated">Pour spécifier des demandes d’autorisation pour un assembly transitoire qui n’est jamais enregistré sur le disque, utilisez une surcharge de la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode qui spécifie la preuve ainsi que demandées autorisations et fournir une <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé d’utiliser une surcharge de la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode qui spécifie la preuve et les autorisations, fournissez la preuve que vous souhaitez que l’assembly dynamique et d’inclure <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> dans <ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Y compris <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> dans le <ph id="ph2">`refusedPermissions`</ph> paramètre garantit que le langage MSIL est vérifié.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Une limitation de cette technique est qu’elle entraîne également <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> levée lorsqu’il est utilisé avec le code qui demande une confiance totale.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Cette méthode doit uniquement être utilisée pour définir un assembly dynamique dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload .</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">L’exemple suivant montre comment la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode et <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez <bpt id="p1">[</bpt>les noms d’assemblys<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identité unique de l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Mode d'accès à l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The name of the directory where the dynamic assembly will be saved.</source>
          <target state="translated">Nom du répertoire dans lequel l'assembly dynamique doit être enregistré.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the current directory is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> est <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le répertoire actif est utilisé.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour synchroniser la création de modules, de types et de membres dans l'assembly dynamique ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>An enumerable list of attributes to be applied to the assembly, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if there are no attributes.</source>
          <target state="translated">Une liste enumérable d'attributs à appliquer à l'assembly, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> s'il n'y a pas d'attributs.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Defines a dynamic assembly using the specified name, access mode, storage directory, and synchronization option.</source>
          <target state="translated">Définit un assembly dynamique avec le nom, le mode d’accès, le répertoire de stockage et l’option de synchronisation spécifiés.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dynamique avec le nom et les fonctionnalités spécifiés.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</source>
          <target state="translated">Utilisez cette surcharge de méthode pour spécifier les attributs qui ne fonctionnent pas correctement, sauf si elles sont appliquées lors de la création d’un assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>For example, security attributes such as <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> do not work correctly if they are added after a dynamic assembly has been created.</source>
          <target state="translated">Par exemple, sécurité des attributs tels que <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> et <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> ne fonctionnent pas correctement s’ils sont ajoutés après la création d’un assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If <ph id="ph1">`isSynchronized`</ph> is <ph id="ph2">`true`</ph>, the following methods of the resulting <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> will be synchronized: <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>, and <ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`isSynchronized`</ph> est <ph id="ph2">`true`</ph>, les méthodes suivantes de la <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> seront synchronisés : <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>, et <ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If two of these methods are called on different threads, one will block until the other is completed.</source>
          <target state="translated">Si deux de ces méthodes sont appelées sur des threads différents, une demeure bloquée jusqu'à ce que l’autre est terminée.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> starts with white space, or contains a forward or backward slash.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> commence par un espace blanc ou bien contient une barre oblique ou une barre oblique inverse.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identité unique de l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Mode d'accès à l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The evidence supplied for the dynamic assembly.</source>
          <target state="translated">Preuve fournie pour l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">La preuve est utilisée non modifiée en tant qu’ensemble de preuves final pour la résolution de stratégie.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The required permissions request.</source>
          <target state="translated">Demande d'autorisations requises.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The optional permissions request.</source>
          <target state="translated">Demande d'autorisations facultatives.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The refused permissions request.</source>
          <target state="translated">Demande d'autorisations refusées.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Defines a dynamic assembly using the specified name, access mode, evidence, and permission requests.</source>
          <target state="translated">Définit un assembly dynamique avec le nom, le mode d'accès, la preuve et les demandes d'autorisations spécifiés.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dynamique avec le nom et les fonctionnalités spécifiés.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The permission requests specified for <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> are used only if <ph id="ph4">`evidence`</ph> is also supplied, or if the dynamic assembly is saved and reloaded into memory.</source>
          <target state="translated">Les demandes d’autorisations spécifiés pour <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, et <ph id="ph3">`refusedPermissions`</ph> sont utilisés uniquement si <ph id="ph4">`evidence`</ph> est également fourni, ou si l’assembly dynamique est enregistré et rechargé en mémoire.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you include <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph2">`refusedPermissions`</ph>.</source>
          <target state="translated">Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé d’inclure <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> dans <ph id="ph2">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Y compris <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> dans le <ph id="ph2">`refusedPermissions`</ph> paramètre garantit que le langage MSIL est vérifié.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Une limitation de cette technique est qu’elle entraîne également <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> levée lorsqu’il est utilisé avec le code qui demande une confiance totale.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Only fully trusted callers can supply their <ph id="ph1">`evidence`</ph> when defining a dynamic <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">Uniquement entièrement fiable les appelants peuvent fournir leurs <ph id="ph1">`evidence`</ph> lorsque vous définissez un dynamique <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The runtime will map the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">Le runtime mappe la <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> via la stratégie de sécurité pour déterminer les autorisations accordées.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Partially trusted callers must supply a null <ph id="ph1">`evidence`</ph>.</source>
          <target state="translated">Les appelants doivent fournir une valeur null de confiance partielle <ph id="ph1">`evidence`</ph>.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> to the dynamic <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> being defined and marks policy as resolved.</source>
          <target state="translated">Si <ph id="ph1">`evidence`</ph> est <ph id="ph2">`null`</ph>, le runtime copie les jeux d’autorisations, autrement dit, en cours grant et deny des jeux, à partir de l’appelant <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> la dynamique <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> actuellement défini et marque la stratégie comme résolue.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If the dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> was saved.</source>
          <target state="translated">Si la dynamique <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> est enregistré sur le disque, les chargements suivants obtiennent des autorisations en fonction des stratégies associées à l’emplacement où le <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> a été enregistré.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Cette méthode doit uniquement être utilisée pour définir un assembly dynamique dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">L’exemple suivant montre comment la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode et <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez <bpt id="p1">[</bpt>les noms d’assemblys<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identité unique de l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Mode d'accès à l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The name of the directory where the assembly will be saved.</source>
          <target state="translated">Nom du répertoire dans lequel l'assembly doit être enregistré.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the directory defaults to the current directory.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le répertoire actif est utilisé comme répertoire par défaut.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The required permissions request.</source>
          <target state="translated">Demande d'autorisations requises.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The optional permissions request.</source>
          <target state="translated">Demande d'autorisations facultatives.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The refused permissions request.</source>
          <target state="translated">Demande d'autorisations refusées.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Defines a dynamic assembly using the specified name, access mode, storage directory, and permission requests.</source>
          <target state="translated">Définit un assembly dynamique avec le nom, le mode d'accès, le répertoire de stockage et les demandes d'autorisations spécifiés.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dynamique avec le nom et les fonctionnalités spécifiés.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The permission requests specified for <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> are not used unless the dynamic assembly has been saved and reloaded into memory.</source>
          <target state="translated">Les demandes d’autorisations spécifiés pour <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, et <ph id="ph3">`refusedPermissions`</ph> ne sont pas utilisés, sauf si l’assembly dynamique a été enregistré et rechargé en mémoire.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence as well as requested permissions, and supply an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> object.</source>
          <target state="translated">Pour spécifier des demandes d’autorisation pour un assembly transitoire qui n’est jamais enregistré sur le disque, utilisez une surcharge de la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode qui spécifie la preuve ainsi que demandées autorisations et fournir une <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé d’utiliser une surcharge de la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode qui spécifie la preuve et les autorisations, fournissez la preuve que vous souhaitez que l’assembly dynamique et d’inclure <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> dans <ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Y compris <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> dans le <ph id="ph2">`refusedPermissions`</ph> paramètre garantit que le langage MSIL est vérifié.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Une limitation de cette technique est qu’elle entraîne également <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> levée lorsqu’il est utilisé avec le code qui demande une confiance totale.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Cette méthode doit uniquement être utilisée pour définir un assembly dynamique dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">L’exemple suivant montre comment la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode et <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez <bpt id="p1">[</bpt>les noms d’assemblys<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identité unique de l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Mode d'accès à l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The name of the directory where the assembly will be saved.</source>
          <target state="translated">Nom du répertoire dans lequel l'assembly doit être enregistré.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the directory defaults to the current directory.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le répertoire actif est utilisé comme répertoire par défaut.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The evidence supplied for the dynamic assembly.</source>
          <target state="translated">Preuve fournie pour l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">La preuve est utilisée non modifiée en tant qu’ensemble de preuves final pour la résolution de stratégie.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The required permissions request.</source>
          <target state="translated">Demande d'autorisations requises.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The optional permissions request.</source>
          <target state="translated">Demande d'autorisations facultatives.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The refused permissions request.</source>
          <target state="translated">Demande d'autorisations refusées.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, and permission requests.</source>
          <target state="translated">Définit un assembly dynamique avec le nom, le mode d'accès, le répertoire de stockage, la preuve et les demandes d'autorisations spécifiés.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dynamique avec le nom et les fonctionnalités spécifiés.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The permission requests specified for <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> are used only if <ph id="ph4">`evidence`</ph> is also supplied, or if the dynamic assembly is saved and reloaded into memory.</source>
          <target state="translated">Les demandes d’autorisations spécifiés pour <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, et <ph id="ph3">`refusedPermissions`</ph> sont utilisés uniquement si <ph id="ph4">`evidence`</ph> est également fourni, ou si l’assembly dynamique est enregistré et rechargé en mémoire.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you include <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph2">`refusedPermissions`</ph>.</source>
          <target state="translated">Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé d’inclure <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> dans <ph id="ph2">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Y compris <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> dans le <ph id="ph2">`refusedPermissions`</ph> paramètre garantit que le langage MSIL est vérifié.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Une limitation de cette technique est qu’elle entraîne également <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> levée lorsqu’il est utilisé avec le code qui demande une confiance totale.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Only fully trusted callers can supply their <ph id="ph1">`evidence`</ph> when defining a dynamic <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">Uniquement entièrement fiable les appelants peuvent fournir leurs <ph id="ph1">`evidence`</ph> lorsque vous définissez un dynamique <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The runtime will map the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">Le runtime mappe la <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> via la stratégie de sécurité pour déterminer les autorisations accordées.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Partially trusted callers must supply a null <ph id="ph1">`evidence`</ph>.</source>
          <target state="translated">Les appelants doivent fournir une valeur null de confiance partielle <ph id="ph1">`evidence`</ph>.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> to the dynamic <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> being defined and marks policy as resolved.</source>
          <target state="translated">Si <ph id="ph1">`evidence`</ph> est <ph id="ph2">`null`</ph>, le runtime copie les jeux d’autorisations, autrement dit, en cours grant et deny des jeux, à partir de l’appelant <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> la dynamique <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> actuellement défini et marque la stratégie comme résolue.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If the dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> was saved.</source>
          <target state="translated">Si la dynamique <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> est enregistré sur le disque, les chargements suivants obtiennent des autorisations en fonction des stratégies associées à l’emplacement où le <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> a été enregistré.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Cette méthode doit uniquement être utilisée pour définir un assembly dynamique dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">L’exemple suivant montre comment la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode et <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez <bpt id="p1">[</bpt>les noms d’assemblys<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identité unique de l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Mode d'accès à l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The name of the directory where the dynamic assembly will be saved.</source>
          <target state="translated">Nom du répertoire dans lequel l'assembly dynamique doit être enregistré.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the directory defaults to the current directory.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> a la valeur <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le répertoire actif est utilisé comme répertoire par défaut.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The evidence supplied for the dynamic assembly.</source>
          <target state="translated">Preuve fournie pour l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">La preuve est utilisée non modifiée en tant qu’ensemble de preuves final pour la résolution de stratégie.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The required permissions request.</source>
          <target state="translated">Demande d'autorisations requises.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The optional permissions request.</source>
          <target state="translated">Demande d'autorisations facultatives.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The refused permissions request.</source>
          <target state="translated">Demande d'autorisations refusées.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour synchroniser la création de modules, de types et de membres dans l'assembly dynamique ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, permission requests, and synchronization option.</source>
          <target state="translated">Définit un assembly dynamique avec le nom, le mode d’accès, le répertoire de stockage, la preuve, les demandes d’autorisations et l’option de synchronisation spécifiés.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dynamique avec le nom et les fonctionnalités spécifiés.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The permission requests specified for <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> are used only if <ph id="ph4">`evidence`</ph> is also supplied, or if the dynamic assembly is saved and reloaded into memory.</source>
          <target state="translated">Les demandes d’autorisations spécifiés pour <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, et <ph id="ph3">`refusedPermissions`</ph> sont utilisés uniquement si <ph id="ph4">`evidence`</ph> est également fourni, ou si l’assembly dynamique est enregistré et rechargé en mémoire.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you include <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph2">`refusedPermissions`</ph>.</source>
          <target state="translated">Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé d’inclure <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> dans <ph id="ph2">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Y compris <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> dans le <ph id="ph2">`refusedPermissions`</ph> paramètre garantit que le langage MSIL est vérifié.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Une limitation de cette technique est qu’elle entraîne également <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> levée lorsqu’il est utilisé avec le code qui demande une confiance totale.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>Only fully trusted callers can supply their evidence when defining a dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">Seuls les appelants de confiance totale peuvent fournir leur preuve lors de la définition d’un dynamique <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The runtime will map the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">Le runtime mappe la <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> via la stratégie de sécurité pour déterminer les autorisations accordées.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>Partially trusted callers must supply <ph id="ph1">`null`</ph> for the <ph id="ph2">`evidence`</ph> parameter.</source>
          <target state="translated">Doivent fournir des appelants de confiance partielle <ph id="ph1">`null`</ph> pour la <ph id="ph2">`evidence`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> to the dynamic <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> being defined and marks policy as resolved.</source>
          <target state="translated">Si <ph id="ph1">`evidence`</ph> est <ph id="ph2">`null`</ph>, le runtime copie les jeux d’autorisations, autrement dit, en cours grant et deny des jeux, à partir de l’appelant <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> la dynamique <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> actuellement défini et marque la stratégie comme résolue.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>If the dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> was saved.</source>
          <target state="translated">Si la dynamique <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> est enregistré sur le disque, les chargements suivants obtiennent des autorisations en fonction des stratégies associées à l’emplacement où le <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> a été enregistré.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>If <ph id="ph1">`isSynchronized`</ph> is <ph id="ph2">`true`</ph>, the following methods of the resulting <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> will be synchronized: <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>, and <ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`isSynchronized`</ph> est <ph id="ph2">`true`</ph>, les méthodes suivantes de la <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> seront synchronisés : <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>, et <ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>If two of these methods are called on different threads, one will block until the other completes.</source>
          <target state="translated">Si deux de ces méthodes sont appelées sur des threads différents, une demeure bloquée jusqu'à ce que l’autre se termine.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">L’exemple suivant montre comment la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> méthode et <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez <bpt id="p1">[</bpt>les noms d’assemblys<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identité unique de l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Mode d'accès à l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The name of the directory where the dynamic assembly will be saved.</source>
          <target state="translated">Nom du répertoire dans lequel l'assembly dynamique doit être enregistré.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the current directory is used.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> est <ph id="ph1">&lt;see langword="null" /&gt;</ph>, le répertoire actif est utilisé.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The evidence that is supplied for the dynamic assembly.</source>
          <target state="translated">Preuve fournie pour l'assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">La preuve est utilisée non modifiée en tant qu’ensemble de preuves final pour la résolution de stratégie.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The required permissions request.</source>
          <target state="translated">Demande d'autorisations requises.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The optional permissions request.</source>
          <target state="translated">Demande d'autorisations facultatives.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The refused permissions request.</source>
          <target state="translated">Demande d'autorisations refusées.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour synchroniser la création de modules, de types et de membres dans l'assembly dynamique ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>An enumerable list of attributes to be applied to the assembly, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if there are no attributes.</source>
          <target state="translated">Une liste enumérable d'attributs à appliquer à l'assembly, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> s'il n'y a pas d'attributs.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Defines a dynamic assembly with the specified name, access mode, storage directory, evidence, permission requests, synchronization option, and custom attributes.</source>
          <target state="translated">Définit un assembly dynamique avec le nom, le mode d’accès, le répertoire de stockage, la preuve, les demandes d’autorisations, l’option de synchronisation et les attributs personnalisés spécifiés.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dynamique avec le nom et les fonctionnalités spécifiés.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</source>
          <target state="translated">Utilisez cette surcharge de méthode pour spécifier les attributs qui ne fonctionnent pas correctement, sauf si elles sont appliquées lors de la création d’un assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>For example, security attributes such as <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> do not work correctly if they are added after a dynamic assembly has been created.</source>
          <target state="translated">Par exemple, sécurité des attributs tels que <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> et <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> ne fonctionnent pas correctement s’ils sont ajoutés après la création d’un assembly dynamique.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The permission requests specified for the <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> parameters are used only if the <ph id="ph4">`evidence`</ph> parameter is also supplied, or if the dynamic assembly is saved and reloaded into memory.</source>
          <target state="translated">Les demandes d’autorisations spécifiés pour le <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, et <ph id="ph3">`refusedPermissions`</ph> paramètres sont utilisés uniquement si le <ph id="ph4">`evidence`</ph> paramètre est également fourni, ou si l’assembly dynamique est enregistré et rechargé en mémoire.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>When you develop code that emits dynamic assemblies, we recommend that you include the <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> flag in the <ph id="ph2">`refusedPermissions`</ph> parameter.</source>
          <target state="translated">Lorsque vous développez du code qui émet des assemblys dynamiques, nous vous conseillons d’inclure le <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> indicateur dans le <ph id="ph2">`refusedPermissions`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The inclusion of this flag ensures that the Microsoft intermediate language (MSIL) will be verified.</source>
          <target state="translated">L’inclusion de cet indicateur garantit que le Microsoft intermediate language (MSIL) est vérifiée.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>This technique will detect the unintentional generation of unverifiable code, which otherwise is very difficult to detect.</source>
          <target state="translated">Cette technique détecte la génération involontaire de code non vérifiable, ce qui est très difficile à détecter.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when it is used with code that demands full trust.</source>
          <target state="translated">Une limitation de cette technique est qu’elle entraîne également <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> levée lorsqu’il est utilisé avec le code qui demande une confiance totale.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Only fully trusted callers can supply evidence when defining a dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">Seuls les appelants de confiance totale peuvent fournir une preuve lors de la définition d’un dynamique <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The runtime maps the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">Le runtime mappe la <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> via la stratégie de sécurité pour déterminer les autorisations accordées.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Partially trusted callers must supply <ph id="ph1">`null`</ph> for the <ph id="ph2">`evidence`</ph> parameter.</source>
          <target state="translated">Doivent fournir des appelants de confiance partielle <ph id="ph1">`null`</ph> pour la <ph id="ph2">`evidence`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets (that is, the current grant and deny sets) from the caller's assembly to the dynamic assembly that is being defined, and marks the policy as resolved.</source>
          <target state="translated">Si <ph id="ph1">`evidence`</ph> est <ph id="ph2">`null`</ph>, le runtime copie les jeux d’autorisations (c'est-à-dire, l’allocation actuelle et refuser des jeux) à partir de l’assembly de l’appelant à l’assembly dynamique qui est défini et marque la stratégie comme résolue.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If the dynamic assembly is saved to disk, subsequent loads will get grants based on policies that are associated with the location where the dynamic assembly was saved.</source>
          <target state="translated">Si l’assembly dynamique est enregistré sur le disque, ultérieur charges obtiennent des autorisations en fonction des stratégies qui sont associés à l’emplacement où l’assembly dynamique a été enregistré.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If <ph id="ph1">`isSynchronized`</ph> is <ph id="ph2">`true`</ph>, the following methods of the resulting <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> will be synchronized: <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>, and <ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`isSynchronized`</ph> est <ph id="ph2">`true`</ph>, les méthodes suivantes de la <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> seront synchronisés : <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>, et <ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If two of these methods are called on different threads, one will block until the other is completed.</source>
          <target state="translated">Si deux de ces méthodes sont appelées sur des threads différents, une demeure bloquée jusqu'à ce que l’autre est terminée.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>This method overload is introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>.</source>
          <target state="translated">Cette surcharge de méthode a été introduite dans le <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> starts with white space, or contains a forward or backward slash.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see langword="Name" /&gt;</ph> de <ph id="ph2">&lt;paramref name="name" /&gt;</ph> commence par un espace blanc ou bien contient une barre oblique ou une barre oblique inverse.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source>A delegate that specifies a method to call.</source>
          <target state="translated">Délégué qui spécifie une méthode à appeler.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source>Executes the code in another application domain that is identified by the specified delegate.</source>
          <target state="translated">Exécute le code dans un autre domaine d'application identifié par le délégué spécifié.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source><ph id="ph1">`callBackDelegate`</ph> can specify a marshal-by-value, <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, or <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`callBackDelegate`</ph> peut spécifier une marshalée-par-valeur, <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, ou <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source>The following sample demonstrates using a static <ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de statique <ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source>The following sample demonstrates using the <ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph> method by value.</source>
          <target state="translated">L’exemple suivant montre comment utiliser la <ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph> méthode par valeur.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source>The following sample demonstrates using the <ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph> method by reference.</source>
          <target state="translated">L’exemple suivant montre comment utiliser la <ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph> méthode par référence.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source><ph id="ph1">&lt;paramref name="callBackDelegate" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="callBackDelegate" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="P:System.AppDomain.DomainManager">
          <source>Gets the domain manager that was provided by the host when the application domain was initialized.</source>
          <target state="translated">Obtient le gestionnaire de domaine qui a été fourni par l'hôte quand le domaine d'application a été initialisé.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DomainManager">
          <source>An object that represents the domain manager provided by the host when the application domain was initialized, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no domain manager was provided.</source>
          <target state="translated">Objet qui représente le gestionnaire de domaine fourni par l'hôte quand le domaine d'application a été initialisé, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si aucun gestionnaire de domaine n'a été fourni.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DomainManager">
          <source>An unmanaged host of the common language runtime (CLR) can provide a domain manager.</source>
          <target state="translated">Un hôte non managé du common language runtime (CLR) peut fournir un gestionnaire de domaine.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DomainManager">
          <source>The domain manager can participate in initializing the new application domain and supply other managers, such as a <ph id="ph1">&lt;xref:System.Security.HostSecurityManager&gt;</ph>, that participate in the operations of the application domain.</source>
          <target state="translated">Le Gestionnaire de domaine peut participer à l’initialisation du domaine d’application et fournir des autres gestionnaires, par exemple un <ph id="ph1">&lt;xref:System.Security.HostSecurityManager&gt;</ph>, qui participent aux opérations du domaine d’application.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DomainManager">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DomainManager">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" uid="E:System.AppDomain.DomainUnload">
          <source>Occurs when an <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> is about to be unloaded.</source>
          <target state="translated">Se produit quand <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> est sur le point d'être déchargé.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>The <ph id="ph1">&lt;xref:System.EventHandler&gt;</ph> delegate for this event can perform any termination activities before the application domain is unloaded.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.EventHandler&gt;</ph> délégué de cet événement peut effectuer toutes les activités d’arrêt avant que le domaine d’application soit déchargé.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>Each application domain that needs to perform processing when it is unloaded should register an event handler for this event.</source>
          <target state="translated">Chaque domaine d’application qui doit effectuer un traitement lorsqu’il est déchargé doit enregistrer un gestionnaire d’événements pour cet événement.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>A shared event handler should not be used, because the <ph id="ph1">&lt;xref:System.EventHandler&gt;</ph> delegate does not identify the domain that is being unloaded.</source>
          <target state="translated">Un gestionnaire d’événements partagé ne doit pas être utilisé, car le <ph id="ph1">&lt;xref:System.EventHandler&gt;</ph> délégué n’identifie pas le domaine est en cours de déchargement.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>This event is never raised in the default application domain.</source>
          <target state="translated">Cet événement n’est jamais déclenché dans le domaine d’application par défaut.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>Do not make assumptions about the thread the event is raised on.</source>
          <target state="translated">Ne faites pas de suppositions sur le thread de sur que l’événement est déclenché.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>The event can be raised on a different thread than the one that called the <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> method.</source>
          <target state="translated">L’événement peut être déclenché sur un thread différent de celui qui a appelé le <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des événements, consultez <bpt id="p1">[</bpt>gestion et déclenchement d’événements<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="P:System.AppDomain.DynamicDirectory">
          <source>Gets the directory that the assembly resolver uses to probe for dynamically created assemblies.</source>
          <target state="translated">Obtient le répertoire utilisé par le programme de résolution d'assembly pour détecter les assemblys créés de manière dynamique.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The directory that the assembly resolver uses to probe for dynamically created assemblies.</source>
          <target state="translated">Répertoire utilisé par le programme de résolution d'assembly pour détecter les assemblys créés de manière dynamique.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>To set the dynamic directory, assign a base directory path to the <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph> property of the <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> object that will be used to create the new application domain.</source>
          <target state="translated">Pour définir le répertoire dynamique, affectez un chemin d’accès du répertoire de base pour le <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph> propriété de la <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> objet permettant de créer le nouveau domaine d’application.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The base directory path you assign to the property is modified by the addition of a subdirectory whose simple name is the hash code of the string you assign to the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType&gt;</ph> property, so the format of the base directory is <bpt id="p1">*</bpt>original path<ept id="p1">*</ept><ph id="ph2">\\</ph><bpt id="p2">*</bpt>hash code<ept id="p2">*</ept>.</source>
          <target state="translated">Le chemin d’accès de répertoire de base que vous affectez à la propriété est modifiée par l’ajout d’un sous-répertoire dont le nom simple est le code de hachage de la chaîne que vous affectez à la <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType&gt;</ph> propriété, par conséquent, le format du répertoire de base est <bpt id="p1">*</bpt>chemin d’accès d’origine<ept id="p1">*</ept> <ph id="ph2">\\</ph> <bpt id="p2">*</bpt>le code de hachage<ept id="p2">*</ept>.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The dynamic directory is a subdirectory of this base directory.</source>
          <target state="translated">Le répertoire dynamique est un sous-répertoire du répertoire de cet base.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>Its simple name is the value of the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType&gt;</ph> property, so its format is <bpt id="p1">*</bpt>original path<ept id="p1">*</ept><ph id="ph2">\\</ph><bpt id="p2">*</bpt>hash code<ept id="p2">*</ept><ph id="ph3">\\</ph><bpt id="p3">*</bpt>application name<ept id="p3">*</ept>.</source>
          <target state="translated">Son nom simple est la valeur de la <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType&gt;</ph> propriété, donc son format est <bpt id="p1">*</bpt>chemin d’accès d’origine<ept id="p1">*</ept><ph id="ph2">\\</ph><bpt id="p2">*</bpt>le code de hachage<ept id="p2">*</ept><ph id="ph3">\\</ph><bpt id="p3">*</bpt>nom de l’application<ept id="p3">*</ept>.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.</source>
          <target state="translated">L’exemple suivant crée un domaine d’application avec un répertoire pour les assemblys dynamiques, émet un assembly dynamique et les stocke dans le répertoire dynamique, charge l’assembly dans le domaine d’application et l’utilise.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The example creates an <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> object and sets its <ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationName%2A&gt;</ph> property to "Example" and its <ph id="ph3">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph> property to "C:\DynamicAssemblyDir".</source>
          <target state="translated">L’exemple crée un <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> objet et définit son <ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationName%2A&gt;</ph> propriété « Exemple » et ses <ph id="ph3">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph> propriété « C:\DynamicAssemblyDir ».</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The example then displays the <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.</source>
          <target state="translated">L’exemple affiche ensuite le <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph> propriété, pour montrer que le code de hachage du nom de l’application a été ajouté comme un sous-répertoire du chemin d’accès qui a été affectée à l’origine.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The base directory in this example is intended to be outside the probing path for the example application.</source>
          <target state="translated">Le répertoire de base dans cet exemple est destiné à être à l’extérieur du chemin d’accès de détection pour l’exemple d’application.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>Be sure to compile the example in a different location.</source>
          <target state="translated">Veillez à compiler l’exemple dans un autre emplacement.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>Delete the base directory and all its subdirectories each time you run the example.</source>
          <target state="translated">Supprimer le répertoire de base et tous ses sous-répertoires chaque fois que vous exécutez l’exemple.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The example creates a new application domain, using the <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> object.</source>
          <target state="translated">L’exemple crée un nouveau domaine d’application, à l’aide de la <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The example uses the <ph id="ph1">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph> property to retrieve the name of the directory, so it can create the directory.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph> propriété à récupérer le nom du répertoire, donc il peut créer le répertoire.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>(The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)</source>
          <target state="translated">(L’exemple pourrait tout aussi facilement créer le répertoire au préalable en concaténant le chemin d’accès d’origine, le code de hachage du nom de l’application et le nom de l’application.)</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The example has a <ph id="ph1">`GenerateDynamicAssembly`</ph> method that emits an assembly named <ph id="ph2">`DynamicHelloWorld.dll`</ph> and stores it in the new application domain's dynamic directory.</source>
          <target state="translated">L’exemple a un <ph id="ph1">`GenerateDynamicAssembly`</ph> (méthode) qui émet un assembly nommé <ph id="ph2">`DynamicHelloWorld.dll`</ph> et le stocke dans le répertoire dynamique de nouveau domaine d’application.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The dynamic assembly contains one type, <ph id="ph1">`HelloWorld`</ph>, that has a static method (<ph id="ph2">`Shared`</ph> method in Visual Basic) named <ph id="ph3">`HelloFromAD`</ph>.</source>
          <target state="translated">L’assembly dynamique contient un seul type, <ph id="ph1">`HelloWorld`</ph>, qui a une méthode statique (<ph id="ph2">`Shared`</ph> méthode dans Visual Basic) nommée <ph id="ph3">`HelloFromAD`</ph>.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>Calling this method displays the name of the application domain.</source>
          <target state="translated">Appel de cette méthode affiche le nom du domaine d’application.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The <ph id="ph1">`Example`</ph> class derives from <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, so the example can create an instance of the class in the new application domain and call its <ph id="ph3">`Test`</ph> method.</source>
          <target state="translated">Le <ph id="ph1">`Example`</ph> dérive de la classe <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, de sorte que l’exemple peut créer une instance de la classe dans le nouveau domaine d’application et appelez sa <ph id="ph3">`Test`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The <ph id="ph1">`Test`</ph> method loads the dynamic assembly by its display name and calls the static <ph id="ph2">`HelloFromAD`</ph> method.</source>
          <target state="translated">Le <ph id="ph1">`Test`</ph> méthode charge l’assembly dynamique par son nom d’affichage et appelle la méthode statique <ph id="ph2">`HelloFromAD`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named <ph id="ph1">`DynamicHelloWorld.dll`</ph> and compiling it in the same directory as this example.</source>
          <target state="translated">Vous pouvez afficher recherché dans le répertoire dynamique après les chemins d’accès de détection normaux en écrivant du code pour un assembly nommé <ph id="ph1">`DynamicHelloWorld.dll`</ph> puis en le compilant dans le même répertoire que cet exemple.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The assembly must have a class named <ph id="ph1">`HelloWorld`</ph> with a static method named <ph id="ph2">`HelloFromAD`</ph>.</source>
          <target state="translated">L’assembly doit avoir une classe nommée <ph id="ph1">`HelloWorld`</ph> avec une méthode statique nommée <ph id="ph2">`HelloFromAD`</ph>.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>This method does not have to have the same functionality as the one in the example; it can simply display a string to the console.</source>
          <target state="translated">Cette méthode n’a pas d’avoir les mêmes fonctionnalités que celui de l’exemple ; Il peut simplement afficher une chaîne dans la console.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The assembly must also have an <ph id="ph1">&lt;xref:System.Reflection.AssemblyVersionAttribute&gt;</ph> attribute that sets its version to 1.0.0.0.</source>
          <target state="translated">L’assembly doit également avoir un <ph id="ph1">&lt;xref:System.Reflection.AssemblyVersionAttribute&gt;</ph> attribut qui définit sa version 1.0.0.0.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.</source>
          <target state="translated">Lorsque vous exécutez l’exemple, l’assembly que vous avez compilé dans le répertoire actif se trouve avant le répertoire dynamique est recherché.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="P:System.AppDomain.DynamicDirectory">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>for access to the path information.</source>
          <target state="translated">Pour accéder aux informations de chemin d’accès.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="P:System.AppDomain.Evidence">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Security.Policy.Evidence" /&gt;</ph> associated with this application domain.</source>
          <target state="translated">Obtient le <ph id="ph1">&lt;see cref="T:System.Security.Policy.Evidence" /&gt;</ph> associé à ce domaine d'application.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Evidence">
          <source>The evidence associated with this application domain.</source>
          <target state="translated">La preuve associée à ce domaine d'application.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" uid="P:System.AppDomain.Evidence">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Evidence">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Evidence">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Evidence">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Executes the assembly contained in the specified file.</source>
          <target state="translated">Exécute l'assembly contenu dans le fichier spécifié.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">Nom du fichier contenant l'assembly à exécuter.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>Executes the assembly contained in the specified file.</source>
          <target state="translated">Exécute l'assembly contenu dans le fichier spécifié.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">Valeur retournée par le point d'entrée de l'assembly.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L’assembly commence au point d’entrée spécifié dans l’en-tête de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et elle n’exécute pas de la méthode de point d’entrée sur un nouveau thread.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Cette méthode charge des assemblys à l’aide de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également exécuter des assemblys à l’aide de la <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> (méthode), qui charge les assemblys à l’aide de la <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>To create the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> to load and execute, use the <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> method.</source>
          <target state="translated">Pour créer le <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> pour charger et exécuter, vous devez utiliser le <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The following sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">L’exemple suivant montre à l’aide d’une des surcharges de <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> sur deux domaines différents.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L’assembly spécifié n’a aucun point d’entrée.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">pour lire un URI qui ne commence pas par « file:// ».</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>to execute a console application.</source>
          <target state="translated">Pour exécuter une application console.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">Nom du fichier contenant l'assembly à exécuter.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Preuve de chargement de l'assembly.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Executes the assembly contained in the specified file, using the specified evidence.</source>
          <target state="translated">Exécute l'assembly contenu dans le fichier spécifié à l'aide de la preuve spécifiée.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">Valeur retournée par le point d'entrée de l'assembly.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L’assembly commence au point d’entrée spécifié dans l’en-tête de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> méthode ne crée pas un nouveau processus ou le domaine d’application, et elle n’exécute pas de la méthode de point d’entrée sur un nouveau thread.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Cette méthode charge des assemblys à l’aide de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également exécuter des assemblys à l’aide de la <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> (méthode), qui charge les assemblys à l’aide de la <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The following sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">L’exemple suivant montre à l’aide d’une des surcharges de <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> sur deux domaines différents.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L’assembly spécifié n’a aucun point d’entrée.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">pour lire un URI qui ne commence pas par « file:// ».</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>to execute a console application.</source>
          <target state="translated">Pour exécuter une application console.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">Nom du fichier contenant l'assembly à exécuter.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The arguments to the entry point of the assembly.</source>
          <target state="translated">Arguments pour le point d’entrée de l’assembly.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>Executes the assembly contained in the specified file, using the specified arguments.</source>
          <target state="translated">Exécute l’assembly contenu dans le fichier spécifié à l’aide des arguments spécifiés.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The value that is returned by the entry point of the assembly.</source>
          <target state="translated">Valeur qui est retournée par le point d'entrée de l'assembly.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L’assembly commence au point d’entrée spécifié dans l’en-tête de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et elle n’exécute pas de la méthode de point d’entrée sur un nouveau thread.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Cette méthode charge des assemblys à l’aide de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également exécuter des assemblys à l’aide de la <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> (méthode), qui charge les assemblys à l’aide de la <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The following sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">L’exemple suivant montre à l’aide d’une des surcharges de <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> sur deux domaines différents.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L’assembly spécifié n’a aucun point d’entrée.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">pour lire un URI qui ne commence pas par « file:// ».</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">Pour exécuter une application console.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">Nom du fichier contenant l'assembly à exécuter.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The supplied evidence for the assembly.</source>
          <target state="translated">Preuve fournie pour l'assembly.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The arguments to the entry point of the assembly.</source>
          <target state="translated">Arguments pour le point d’entrée de l’assembly.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Executes the assembly contained in the specified file, using the specified evidence and arguments.</source>
          <target state="translated">Exécute l’assembly contenu dans le fichier spécifié à l’aide de la preuve et des arguments spécifiés.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">Valeur retournée par le point d'entrée de l'assembly.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L’assembly commence au point d’entrée spécifié dans l’en-tête de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et elle n’exécute pas de la méthode de point d’entrée sur un nouveau thread.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Cette méthode charge des assemblys à l’aide de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également exécuter des assemblys à l’aide de la <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> (méthode), qui charge les assemblys à l’aide de la <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The following sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">L’exemple suivant montre à l’aide d’une des surcharges de <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> sur deux domaines différents.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> n’est pas un <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Quand la stratégie CAS héritée n’est pas activée, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> doit être <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L’assembly spécifié n’a aucun point d’entrée.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">pour lire un URI qui ne commence pas par « file:// ».</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">Pour exécuter une application console.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">Nom du fichier contenant l'assembly à exécuter.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The arguments to the entry point of the assembly.</source>
          <target state="translated">Arguments pour le point d’entrée de l’assembly.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the value of the computed hash code.</source>
          <target state="translated">Représente la valeur du code de hachage calculé.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the hash algorithm used by the assembly manifest.</source>
          <target state="translated">Représente l'algorithme de hachage utilisé par le manifeste d'assembly.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Executes the assembly contained in the specified file, using the specified arguments, hash value, and hash algorithm.</source>
          <target state="translated">Exécute l’assembly contenu dans le fichier spécifié à l’aide des arguments, de la valeur et de l’algorithme de hachage spécifiés.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The value that is returned by the entry point of the assembly.</source>
          <target state="translated">Valeur qui est retournée par le point d'entrée de l'assembly.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L’assembly commence au point d’entrée spécifié dans l’en-tête de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et elle n’exécute pas de la méthode de point d’entrée sur un nouveau thread.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Cette méthode charge des assemblys à l’aide de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également exécuter des assemblys à l’aide de la <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> (méthode), qui charge les assemblys à l’aide de la <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The following sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">L’exemple suivant montre à l’aide d’une des surcharges de <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> sur deux domaines différents.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L’assembly spécifié n’a aucun point d’entrée.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">pour lire un URI qui ne commence pas par « file:// ».</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>to execute a console application.</source>
          <target state="translated">Pour exécuter une application console.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">Nom du fichier contenant l'assembly à exécuter.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The supplied evidence for the assembly.</source>
          <target state="translated">Preuve fournie pour l'assembly.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The arguments to the entry point of the assembly.</source>
          <target state="translated">Arguments pour le point d’entrée de l’assembly.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the value of the computed hash code.</source>
          <target state="translated">Représente la valeur du code de hachage calculé.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the hash algorithm used by the assembly manifest.</source>
          <target state="translated">Représente l'algorithme de hachage utilisé par le manifeste d'assembly.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Executes the assembly contained in the specified file, using the specified evidence, arguments, hash value, and hash algorithm.</source>
          <target state="translated">Exécute l’assembly contenu dans le fichier spécifié à l’aide de la preuve, des arguments, de la valeur et de l’algorithme de hachage spécifiés.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">Valeur retournée par le point d'entrée de l'assembly.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L’assembly commence au point d’entrée spécifié dans l’en-tête de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et elle n’exécute pas de la méthode de point d’entrée sur un nouveau thread.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Cette méthode charge des assemblys à l’aide de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également exécuter des assemblys à l’aide de la <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> (méthode), qui charge les assemblys à l’aide de la <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Thefollowing sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">Exemple de réticules du centre montre comment utiliser une des surcharges de <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> sur deux domaines différents.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> n’est pas un <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Quand la stratégie CAS héritée n’est pas activée, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> doit être <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L’assembly spécifié n’a aucun point d’entrée.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">pour lire un URI qui ne commence pas par « file:// ».</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>to execute a console application.</source>
          <target state="translated">Pour exécuter une application console.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Executes an assembly.</source>
          <target state="translated">Exécute un assembly.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>Executes an assembly given its display name.</source>
          <target state="translated">Charge un assembly en fonction de son nom complet.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">Valeur retournée par le point d'entrée de l'assembly.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> méthode fournit une fonctionnalité similaire à la <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> (méthode), mais spécifie l’assembly par nom d’affichage ou <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> plutôt que par l’emplacement du fichier.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Par conséquent, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> charge les assemblys avec le <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode plutôt qu’avec la <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L’assembly commence au point d’entrée spécifié dans l’en-tête de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et elle n’exécute pas de la méthode de point d’entrée sur un nouveau thread.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>To create the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> to load and execute, use the <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> method.</source>
          <target state="translated">Pour créer le <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> pour charger et exécuter, vous devez utiliser le <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été trouvé, mais ne peut pas être chargé.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L’assembly spécifié n’a aucun point d’entrée.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou répertoire, pour l’accès aux informations dans le chemin d’accès lui-même et pour rediriger un nom d’affichage pour un chemin d’accès.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">Pour accéder à un site Web, lorsqu’un nom d’affichage est redirigé vers une URL.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>to execute a console application.</source>
          <target state="translated">Pour exécuter une application console.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object representing the name of the assembly.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> représentant le nom de l'assembly.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>Command-line arguments to pass when starting the process.</source>
          <target state="translated">Arguments de ligne de commande à passer au moment du démarrage du processus.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>Executes the assembly given an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>, using the specified arguments.</source>
          <target state="translated">Exécute l'assembly à partir d'un <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>, à l'aide des arguments spécifiés.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The value that is returned by the entry point of the assembly.</source>
          <target state="translated">Valeur qui est retournée par le point d'entrée de l'assembly.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> méthode fournit une fonctionnalité similaire à la <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> (méthode), mais spécifie l’assembly par nom d’affichage ou <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> plutôt que par l’emplacement du fichier.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Par conséquent, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> charge les assemblys avec le <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode plutôt qu’avec la <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L’assembly commence au point d’entrée spécifié dans l’en-tête de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et elle n’exécute pas de la méthode de point d’entrée sur un nouveau thread.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été trouvé, mais ne peut pas être chargé.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L’assembly spécifié n’a aucun point d’entrée.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou répertoire, pour l’accès aux informations dans le chemin d’accès lui-même et pour rediriger un nom d’affichage pour un chemin d’accès.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">Pour accéder à un site Web, lorsqu’un nom d’affichage est redirigé vers une URL.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">Pour exécuter une application console.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Preuve de chargement de l'assembly.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Executes an assembly given its display name, using the specified evidence.</source>
          <target state="translated">Exécute un assembly en fonction de son nom complet, à l'aide de la preuve spécifiée.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">Valeur retournée par le point d'entrée de l'assembly.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> méthode fournit une fonctionnalité similaire à la <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> (méthode), mais spécifie l’assembly par nom d’affichage ou <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> plutôt que par l’emplacement du fichier.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Par conséquent, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> charge les assemblys avec le <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode plutôt qu’avec la <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L’assembly commence au point d’entrée spécifié dans l’en-tête de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> méthode ne crée pas un nouveau processus ou le domaine d’application, et elle n’exécute pas de la méthode de point d’entrée sur un nouveau thread.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>When you use the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Lorsque vous utilisez la <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> méthode avec un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, les preuves sont fusionnées.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Preuves fournies en tant qu’argument à la <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> méthode annulent et remplacent les preuves fournies par le chargeur.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été trouvé, mais ne peut pas être chargé.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L’assembly spécifié n’a aucun point d’entrée.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou répertoire, pour l’accès aux informations dans le chemin d’accès lui-même et pour rediriger un nom d’affichage pour un chemin d’accès.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">Pour accéder à un site Web, lorsqu’un nom d’affichage est redirigé vers une URL.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>to execute a console application.</source>
          <target state="translated">Pour exécuter une application console.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>Command-line arguments to pass when starting the process.</source>
          <target state="translated">Arguments de ligne de commande à passer au moment du démarrage du processus.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>Executes the assembly given its display name, using the specified arguments.</source>
          <target state="translated">Exécute l’assembly en fonction de son nom complet, à l’aide des arguments spécifiés.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The value that is returned by the entry point of the assembly.</source>
          <target state="translated">Valeur qui est retournée par le point d'entrée de l'assembly.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> méthode fournit une fonctionnalité similaire à la <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> (méthode), mais spécifie l’assembly par nom d’affichage ou <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> plutôt que par l’emplacement du fichier.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Par conséquent, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> charge les assemblys avec le <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode plutôt qu’avec la <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L’assembly commence au point d’entrée spécifié dans l’en-tête de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et elle n’exécute pas de la méthode de point d’entrée sur un nouveau thread.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été trouvé, mais ne peut pas être chargé.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L’assembly spécifié n’a aucun point d’entrée.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou répertoire, pour l’accès aux informations dans le chemin d’accès lui-même et pour rediriger un nom d’affichage pour un chemin d’accès.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">Pour accéder à un site Web, lorsqu’un nom d’affichage est redirigé vers une URL.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">Pour exécuter une application console.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object representing the name of the assembly.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> représentant le nom de l'assembly.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Preuve de chargement de l'assembly.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Command-line arguments to pass when starting the process.</source>
          <target state="translated">Arguments de ligne de commande à passer au moment du démarrage du processus.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Executes the assembly given an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>, using the specified evidence and arguments.</source>
          <target state="translated">Exécute l'assembly à partir d'un <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>, à l'aide de la preuve et des arguments spécifiés.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">Valeur retournée par le point d'entrée de l'assembly.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> méthode fournit une fonctionnalité similaire à la <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> (méthode), mais spécifie l’assembly par nom d’affichage ou <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> plutôt que par l’emplacement du fichier.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Par conséquent, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> charge les assemblys avec le <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode plutôt qu’avec la <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L’assembly commence au point d’entrée spécifié dans l’en-tête de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et elle n’exécute pas de la méthode de point d’entrée sur un nouveau thread.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>When you use the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Lorsque vous utilisez la <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> méthode avec un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, les preuves sont fusionnées.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Preuves fournies en tant qu’argument à la <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> méthode annulent et remplacent les preuves fournies par le chargeur.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été trouvé, mais ne peut pas être chargé.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> n’est pas un <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Quand la stratégie CAS héritée n’est pas activée, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> doit être <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L’assembly spécifié n’a aucun point d’entrée.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou répertoire, pour l’accès aux informations dans le chemin d’accès lui-même et pour rediriger un nom d’affichage pour un chemin d’accès.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">Pour accéder à un site Web, lorsqu’un nom d’affichage est redirigé vers une URL.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">Pour exécuter une application console.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Preuve de chargement de l'assembly.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Command-line arguments to pass when starting the process.</source>
          <target state="translated">Arguments de ligne de commande à passer au moment du démarrage du processus.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Executes the assembly given its display name, using the specified evidence and arguments.</source>
          <target state="translated">Exécute l’assembly en fonction de son nom complet, à l’aide de la preuve et des arguments spécifiés.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">Valeur retournée par le point d'entrée de l'assembly.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> méthode fournit une fonctionnalité similaire à la <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> (méthode), mais spécifie l’assembly par nom d’affichage ou <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> plutôt que par l’emplacement du fichier.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Par conséquent, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> charge les assemblys avec le <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> méthode plutôt qu’avec la <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L’assembly commence au point d’entrée spécifié dans l’en-tête de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et elle n’exécute pas de la méthode de point d’entrée sur un nouveau thread.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>When you use the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Lorsque vous utilisez la <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> méthode avec un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> paramètre, les preuves sont fusionnées.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Preuves fournies en tant qu’argument à la <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> méthode annulent et remplacent les preuves fournies par le chargeur.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été trouvé, mais ne peut pas être chargé.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">L’assembly spécifié par <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> n’est pas un <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Quand la stratégie CAS héritée n’est pas activée, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> doit être <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L’assembly spécifié n’a aucun point d’entrée.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou répertoire, pour l’accès aux informations dans le chemin d’accès lui-même et pour rediriger un nom d’affichage pour un chemin d’accès.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">Pour accéder à un site Web, lorsqu’un nom d’affichage est redirigé vers une URL.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">Pour exécuter une application console.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" uid="E:System.AppDomain.FirstChanceException">
          <source>Occurs when an exception is thrown in managed code, before the runtime searches the call stack for an exception handler in the application domain.</source>
          <target state="translated">Se produit quand une exception est levée dans le code managé, avant que l'exécution ne recherche un gestionnaire d'exceptions dans la pile des appels du domaine d'application.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>This event is only a notification.</source>
          <target state="translated">Cet événement est uniquement une notification.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Handling this event does not handle the exception or affect subsequent exception handling in any way.</source>
          <target state="translated">Gestion de cet événement ne pas gérer l’exception ou affectent les exceptions suivantes en aucune façon.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>After the event has been raised and event handlers have been invoked, the common language runtime (CLR) begins to search for a handler for the exception.</source>
          <target state="translated">Une fois que l’événement a été déclenché et gestionnaires d’événements ont été appelées, le common language runtime (CLR) commence à rechercher un gestionnaire pour l’exception.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source><ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> provides the application domain with a first chance to examine any managed exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> fournit le domaine d’application une première opportunité d’examiner les exceptions gérées.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>The event can be handled per application domain.</source>
          <target state="translated">L’événement peut être géré par domaine d’application.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>If a thread passes through multiple application domains while executing a call, the event is raised in each application domain that has registered an event handler, before the CLR begins searching for a matching exception handler in that application domain.</source>
          <target state="translated">Si un thread passe par plusieurs domaines d’application lors de l’exécution d’un appel, l’événement est déclenché dans chaque domaine d’application qui a inscrit un gestionnaire d’événements, avant que le CLR commence à rechercher un gestionnaire d’exceptions correspondant dans ce domaine d’application.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>After the event has been handled, a search is made for a matching exception handler in that application domain.</source>
          <target state="translated">Une fois que l’événement a été géré, une recherche est effectuée pour un gestionnaire d’exceptions correspondant dans ce domaine d’application.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>If none is found, the event is raised in the next application domain.</source>
          <target state="translated">Si aucun n’est trouvé, l’événement est déclenché dans le domaine d’application suivant.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>You must handle all exceptions that occur in the event handler for the <ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> event.</source>
          <target state="translated">Vous devez gérer toutes les exceptions qui se produisent dans l’événement gestionnaire pour le <ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Otherwise, <ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> is raised recursively.</source>
          <target state="translated">Sinon, <ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> est déclenché de manière récursive.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>This could result in a stack overflow and termination of the application.</source>
          <target state="translated">Cela peut entraîner un débordement de pile et l’arrêt de l’application.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>We recommend that you implement event handlers for this event as constrained execution regions (CERs), to keep infrastructure-related exceptions such as out-of-memory or stack overflow from affecting the virtual machine while the exception notification is being processed.</source>
          <target state="translated">Nous vous recommandons d’implémenter des gestionnaires d’événements pour cet événement comme régions d’exécution limitée (CER), pour conserver les exceptions liées à infrastructure telles que de dépassement de capacité de mémoire insuffisante ou de la pile d’affecter l’ordinateur virtuel pendant que la notification d’exception est en cours de traitement.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>This event is not raised for exceptions that indicate corruption of process state, such as access violations, unless the event handler is security-critical and has the <ph id="ph1">&lt;xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute&gt;</ph> attribute.</source>
          <target state="translated">Cet événement n’est pas déclenché pour les exceptions qui indiquent une altération de l’état du processus, telles que des violations d’accès, à moins que le Gestionnaire d’événements est critique de sécurité et a la <ph id="ph1">&lt;xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute&gt;</ph> attribut.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>The common language runtime suspends thread aborts while this notification event is being handled.</source>
          <target state="translated">Le common language runtime interrompt les abandons de thread pendant que cet événement de notification est géré.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>The following example creates a series of application domains named <ph id="ph1">`AD0`</ph> through <ph id="ph2">`AD3`</ph>, with a <ph id="ph3">`Worker`</ph> object in each application domain.</source>
          <target state="translated">L’exemple suivant crée une série de domaines d’application nommé <ph id="ph1">`AD0`</ph> via <ph id="ph2">`AD3`</ph>, avec un <ph id="ph3">`Worker`</ph> objet dans chaque domaine d’application.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Each <ph id="ph1">`Worker`</ph> object has a reference to the <ph id="ph2">`Worker`</ph> object in the next application domain, except for the <ph id="ph3">`Worker`</ph> in the last application domain.</source>
          <target state="translated">Chaque <ph id="ph1">`Worker`</ph> objet a une référence à la <ph id="ph2">`Worker`</ph> de l’objet dans le domaine d’application suivant, à l’exception de la <ph id="ph3">`Worker`</ph> dans le dernier domaine d’application.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> event is handled in all application domains except <ph id="ph2">`AD1`</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> événement est géré dans tous les domaines d’application à l’exception de <ph id="ph2">`AD1`</ph>.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in <bpt id="p1">[</bpt>How to: Receive First-Chance Exception Notifications<ept id="p1">](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)</ept>.</source>
          <target state="translated">En plus de cet exemple, qui présente des notifications d’exceptions de première chance dans plusieurs domaines d’application, vous pouvez trouver des cas d’usage simples dans <bpt id="p1">[</bpt>Comment : recevoir des Notifications d’exceptions de première Chance<ept id="p1">](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>When the application domains have been created, the default application domain calls the <ph id="ph1">`TestException`</ph> method for the first application domain.</source>
          <target state="translated">Lorsque les domaines d’application ont été créés, le domaine d’application par défaut appelle la <ph id="ph1">`TestException`</ph> méthode pour le premier domaine d’application.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Each <ph id="ph1">`Worker`</ph> object calls the <ph id="ph2">`TestException`</ph> method for the next application domain, until the last <ph id="ph3">`Worker`</ph> throws an exception that is either handled or unhandled.</source>
          <target state="translated">Chaque <ph id="ph1">`Worker`</ph> de l’objet appelle la <ph id="ph2">`TestException`</ph> méthode pour le domaine d’application suivant, jusqu'à ce que le dernier <ph id="ph3">`Worker`</ph> lève une exception qui est gérée ou non gérée.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Thus, the current thread passes through all the application domains, and <ph id="ph1">`TestException`</ph> is added to the stack in each application domain.</source>
          <target state="translated">Par conséquent, le thread actuel passe par tous les domaines d’application, et <ph id="ph1">`TestException`</ph> est ajouté à la pile dans chaque domaine d’application.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>When the last <ph id="ph1">`Worker`</ph> object handles the exception, the <ph id="ph2">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> event is raised only in the last application domain.</source>
          <target state="translated">Lors de la dernière <ph id="ph1">`Worker`</ph> objet gère l’exception, le <ph id="ph2">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> événement est déclenché uniquement dans le dernier domaine d’application.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>The other application domains never get a chance to handle the exception, so the event is not raised.</source>
          <target state="translated">Les autres domaines d’application obtiennent jamais la possibilité de gérer l’exception, donc l’événement n’est pas déclenché.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>When the last <ph id="ph1">`Worker`</ph> object does not handle the exception, the <ph id="ph2">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> event is raised in each application domain that has an event handler.</source>
          <target state="translated">Lors de la dernière <ph id="ph1">`Worker`</ph> objet ne gère pas l’exception, le <ph id="ph2">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> événement est déclenché dans chaque domaine d’application qui a un gestionnaire d’événements.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.</source>
          <target state="translated">À l’issue de chaque gestionnaire d’événements, la pile continue à dérouler jusqu'à ce que l’exception est interceptée par le domaine d’application par défaut.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>To see how the stack display grows as the event is raised closer and closer to the default application domain, change <ph id="ph1">`e.Exception.Message`</ph> to <ph id="ph2">`e.Exception`</ph> in the <ph id="ph3">`FirstChanceHandler`</ph> event handlers.</source>
          <target state="translated">Pour voir comment l’affichage de la pile augmente à mesure que l’événement est déclenché plus proche et une valeur plus proche pour le domaine d’application par défaut, modifiez <ph id="ph1">`e.Exception.Message`</ph> à <ph id="ph2">`e.Exception`</ph> dans le <ph id="ph3">`FirstChanceHandler`</ph> gestionnaires d’événements.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Notice that when <ph id="ph1">`TestException`</ph> is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.</source>
          <target state="translated">Notez que lorsque <ph id="ph1">`TestException`</ph> est appelée sur des limites de domaine d’application, il apparaît deux fois : une fois pour le proxy et qu’une seule fois pour le stub.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" uid="P:System.AppDomain.FriendlyName">
          <source>Gets the friendly name of this application domain.</source>
          <target state="translated">Obtient le nom convivial de ce domaine d'application.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>The friendly name of this application domain.</source>
          <target state="translated">Nom convivial de ce domaine d'application.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>The friendly name of the default application domain is the file name of the process executable.</source>
          <target state="translated">Le nom convivial du domaine d’application par défaut est le nom de fichier de l’exécutable du processus.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>For example, if the executable used to start the process is <ph id="ph1">`"c:\MyAppDirectory\MyAssembly.exe"`</ph>, the friendly name of the default application domain is <ph id="ph2">`"MyAssembly.exe"`</ph>.</source>
          <target state="translated">Par exemple, si l’exécutable utilisé pour démarrer le processus est <ph id="ph1">`"c:\MyAppDirectory\MyAssembly.exe"`</ph>, le nom convivial du domaine d’application par défaut est <ph id="ph2">`"MyAssembly.exe"`</ph>.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.AppDomain.FriendlyName%2A&gt;</ph> property to get the friendly name of the current application domain.</source>
          <target state="translated">Le code suivant exemple utilise le <ph id="ph1">&lt;xref:System.AppDomain.FriendlyName%2A&gt;</ph> propriété à obtenir le nom convivial du domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>For the default application domain, the friendly name is the name of the application's executable file.</source>
          <target state="translated">Pour le domaine d’application par défaut, le nom convivial est le nom du fichier exécutable de l’application.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>The code example also displays additional information about the application domain.</source>
          <target state="translated">L’exemple de code affiche également des informations supplémentaires sur le domaine d’application.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" uid="P:System.AppDomain.FriendlyName">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetAssemblies">
          <source>Gets the assemblies that have been loaded into the execution context of this application domain.</source>
          <target state="translated">Obtient les assemblys qui ont été chargés dans le contexte d'exécution de ce domaine d'application.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetAssemblies">
          <source>An array of assemblies in this application domain.</source>
          <target state="translated">Tableau d'assemblys de ce domaine d'application.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetAssemblies">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> method to get a list of all assemblies that have been loaded into the application domain.</source>
          <target state="translated">Le code suivant exemple utilise le <ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> méthode pour obtenir une liste de tous les assemblys qui ont été chargés dans le domaine d’application.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetAssemblies">
          <source>The assemblies are then displayed to the console.</source>
          <target state="translated">Les assemblys sont ensuite affichés sur la console.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetAssemblies">
          <source>To run this code example, you need to create an assembly named <ph id="ph1">`CustomLibrary.dll`</ph>, or change the assembly name that is passed to the <ph id="ph2">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> method.</source>
          <target state="translated">Pour exécuter cet exemple de code, vous devez créer un assembly nommé <ph id="ph1">`CustomLibrary.dll`</ph>, ou modifiez le nom de l’assembly qui est passé à la <ph id="ph2">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetAssemblies">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>Gets the current thread identifier.</source>
          <target state="translated">Obtient l'identificateur du thread actuel.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>A 32-bit signed integer that is the identifier of the current thread.</source>
          <target state="translated">Entier signé 32 bits qui correspond à l'identificateur du thread actuel.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> property, which is stable even when the .NET Framework is hosted by an environment that supports fibers (that is, lightweight threads).</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> propriété, qui est stable même lorsque le .NET Framework est hébergé par un environnement qui prend en charge les fibres (autrement dit, les threads légers).</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>to call this method.</source>
          <target state="translated">pour appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetData(System.String)">
          <source>The name of a predefined application domain property, or the name of an application domain property you have defined.</source>
          <target state="translated">Nom d'une propriété de domaine d'application prédéfinie ou nom d'une propriété de domaine d'application que vous avez définie.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetData(System.String)">
          <source>Gets the value stored in the current application domain for the specified name.</source>
          <target state="translated">Obtient la valeur stockée dans le domaine d'application actuel pour le nom spécifié.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetData(System.String)">
          <source>The value of the <ph id="ph1">&lt;paramref name="name" /&gt;</ph> property, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the property does not exist.</source>
          <target state="translated">Valeur de la propriété <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si elle n'existe pas.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Use this method to retrieve the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>.</source>
          <target state="translated">Utilisez cette méthode pour récupérer la valeur d’une entrée dans un cache interne de paires nom / données qui décrivent les propriétés de cette instance de <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Note that the comparison of <ph id="ph1">`name`</ph> with the name of key-value pairs is case-sensitive.</source>
          <target state="translated">Notez que la comparaison de <ph id="ph1">`name`</ph> avec le nom de paires clé-valeur respecte la casse.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>The cache automatically contains predefined system entries that are inserted when the application domain is created.</source>
          <target state="translated">Le cache contient automatiquement des entrées de système prédéfinis sont insérées lorsque le domaine d’application est créé.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>You can inspect their values with the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method, or the equivalent <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> properties.</source>
          <target state="translated">Vous pouvez vérifier leurs valeurs à la <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> (méthode), ou l’équivalent <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> propriétés.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>You can insert or modify your own user defined name-data pairs with the <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A&gt;</ph> method and inspect their values with the <ph id="ph2">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez insérer ou modifier vos propres paires de nom / données définies par l’utilisateur avec le <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A&gt;</ph> méthode et vérifier leurs valeurs à le <ph id="ph2">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>The following table describes the <ph id="ph1">`name`</ph> of each predefined system entry and its corresponding <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> property.</source>
          <target state="translated">Le tableau suivant décrit les <ph id="ph1">`name`</ph> de chaque prédéfinies entrée système et son <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Value of 'name'</source>
          <target state="translated">Valeur de 'name'</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Property</source>
          <target state="translated">Property</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"APPBASE"</source>
          <target state="translated">"APPBASE"</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"APP_CONFIG_FILE"</source>
          <target state="translated">"APP_CONFIG_FILE"</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"APP_LAUNCH_URL"</source>
          <target state="translated">"APP_LAUNCH_URL"</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>(no property)</source>
          <target state="translated">(aucune propriété)</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"APP_LAUNCH_URL" represents the URL originally requested by the user, before any redirection.</source>
          <target state="translated">« APP_LAUNCH_URL » représente l’URL initialement demandée par l’utilisateur, avant toute redirection.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>It is available only when the application has been launched with a browser such as Internet Explorer.</source>
          <target state="translated">Il est disponible uniquement lorsque l’application a été lancée avec un navigateur tel qu’Internet Explorer.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Not all browsers provide this value.</source>
          <target state="translated">Certains navigateurs ne prennent cette valeur.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"APP_NAME"</source>
          <target state="translated">"APP_NAME"</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"BINPATH_PROBE_ONLY"</source>
          <target state="translated">"BINPATH_PROBE_ONLY"</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"CACHE_BASE"</source>
          <target state="translated">"CACHE_BASE"</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"CODE_DOWNLOAD_DISABLED"</source>
          <target state="translated">"CODE_DOWNLOAD_DISABLED"</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"DEV_PATH"</source>
          <target state="translated">"DEV_PATH"</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>(no property)</source>
          <target state="translated">(aucune propriété)</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"DISALLOW_APP"</source>
          <target state="translated">"DISALLOW_APP"</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"DISALLOW_APP_BASE_PROBING"</source>
          <target state="translated">"DISALLOW_APP_BASE_PROBING"</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"DISALLOW_APP_REDIRECTS"</source>
          <target state="translated">"DISALLOW_APP_REDIRECTS"</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"DYNAMIC_BASE"</source>
          <target state="translated">"DYNAMIC_BASE"</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"FORCE_CACHE_INSTALL"</source>
          <target state="translated">"FORCE_CACHE_INSTALL"</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"LICENSE_FILE", or an application-specific string</source>
          <target state="translated">« LICENSE_FILE », ou une chaîne spécifique à l’application</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"LOADER_OPTIMIZATION"</source>
          <target state="translated">"LOADER_OPTIMIZATION"</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"LOCATION_URI"</source>
          <target state="translated">"LOCATION_URI"</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>(no property)</source>
          <target state="translated">(aucune propriété)</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"PRIVATE_BINPATH"</source>
          <target state="translated">« PRIVATE_BINPATH »</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"REGEX_DEFAULT_MATCH_TIMEOUT"</source>
          <target state="translated">"REGEX_DEFAULT_MATCH_TIMEOUT"</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"REGEX_DEFAULT_MATCH_TIMEOUT" is not a system entry, and its value can be set by calling the <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A&gt;</ph> method.</source>
          <target state="translated">« REGEX_DEFAULT_MATCH_TIMEOUT » n’est pas une entrée de système, et sa valeur peut être définie en appelant le <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"SHADOW_COPY_DIRS"</source>
          <target state="translated">"SHADOW_COPY_DIRS"</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain.</source>
          <target state="translated">L’exemple suivant crée un nouveau domaine d’application, définit une valeur fournie par le système pour le domaine et ajoute une nouvelle paire de valeur pour le domaine.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>The example then demonstrates how to use the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method to retrieve the data from these value pairs and display them to the console.</source>
          <target state="translated">L’exemple montre ensuite comment utiliser le <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> méthode pour récupérer les données de ces paires de valeur et de les afficher dans la console.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetData(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetData(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>for access to the information in the path itself, if the property applies to a path.</source>
          <target state="translated">Pour accéder aux informations dans le chemin d’accès proprement dit, si la propriété s’applique à un chemin d’accès.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetType">
          <source>Gets the type of the current instance.</source>
          <target state="translated">Obtient le type de l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetType">
          <source>The type of the current instance.</source>
          <target state="translated">Type de l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" uid="P:System.AppDomain.Id">
          <source>Gets an integer that uniquely identifies the application domain within the process.</source>
          <target state="translated">Obtient un entier qui identifie de façon unique le domaine d'application au sein du processus.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Id">
          <source>An integer that identifies the application domain.</source>
          <target state="translated">Entier qui identifie le domaine d'application.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Id">
          <source>The following code example creates a second application domain and displays information about the default domain and the new domain.</source>
          <target state="translated">L’exemple de code suivant crée un deuxième domaine d’application et affiche des informations sur le domaine par défaut et le nouveau domaine.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" uid="M:System.AppDomain.InitializeLifetimeService">
          <source>Gives the <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> an infinite lifetime by preventing a lease from being created.</source>
          <target state="translated">Donne à <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> une durée de vie infinie en empêchant toute création de bail.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" uid="M:System.AppDomain.InitializeLifetimeService">
          <source>Always <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Toujours <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" uid="M:System.AppDomain.InitializeLifetimeService">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.InitializeLifetimeService">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.InitializeLifetimeService">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>The compatibility switch to test.</source>
          <target state="translated">Commutateur de compatibilité à tester.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Gets a nullable Boolean value that indicates whether any compatibility switches are set, and if so, whether the specified compatibility switch is set.</source>
          <target state="translated">Obtient une valeur booléenne Nullable qui indique si les commutateurs de compatibilité sont définis, et si tel est le cas, si le commutateur de compatibilité spécifié est défini.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) if no compatibility switches are set; otherwise, a Boolean value that indicates whether the compatibility switch that is specified by <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is set.</source>
          <target state="translated">Une référence null (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic) si aucun commutateur de compatibilité n'est défini ; sinon, une valeur booléenne qui indique si le commutateur de compatibilité spécifié par <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est défini.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>This method tests whether the specified compatibility switch has been set for the current application domain.</source>
          <target state="translated">Cette méthode vérifie si le commutateur de compatibilité spécifié a été défini pour le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.</source>
          <target state="translated">Commutateurs de compatibilité généralement de restaurer un comportement (tels que les façon dont les chaînes sont triées) qui a été modifié entre les versions du .NET Framework.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>They are set by calling the <ph id="ph1">&lt;xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType&gt;</ph> method before creating an application domain.</source>
          <target state="translated">Ils sont définis en appelant le <ph id="ph1">&lt;xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType&gt;</ph> méthode avant de créer un domaine d’application.</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.</source>
          <target state="translated">Le tableau suivant fournit des exemples de commutateurs de compatibilité qui peuvent être définies pour restaurer le comportement des versions antérieures du .NET Framework.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Switch</source>
          <target state="translated">Basculer</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Meaning</source>
          <target state="translated">Signification</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>"NetFx40_LegacySecurityPolicy"</source>
          <target state="translated">"NetFx40_LegacySecurityPolicy"</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Code access security (CAS) for the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> is enabled in this application domain.</source>
          <target state="translated">Sécurité accès du code (CAS) pour le <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> est activé dans ce domaine d’application.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>See <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>NetFx40_LegacySecurityPolicy<ph id="ph2">&amp;gt;</ph> Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt> <ph id="ph1">&amp;lt;</ph>NetFx40_LegacySecurityPolicy<ph id="ph2">&amp;gt;</ph> élément<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>"NetFx40_Legacy20SortingBehavior"</source>
          <target state="translated">"NetFx40_Legacy20SortingBehavior"</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>String sorting defaults for the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> are enabled in this application domain.</source>
          <target state="translated">Chaîne de tri des valeurs par défaut pour le <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> sont activées dans ce domaine d’application.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Its success requires sort00001000.dll to be installed.</source>
          <target state="translated">Son succès requiert sort00001000.dll soit installé.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>See <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>CompatSortNLSVersion<ph id="ph2">&amp;gt;</ph> Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt> <ph id="ph1">&amp;lt;</ph>CompatSortNLSVersion<ph id="ph2">&amp;gt;</ph> élément<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>"NetFx40_Legacy40SortingBehavior"</source>
          <target state="translated">"NetFx40_Legacy40SortingBehavior"</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>String sorting defaults for the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>and Unicode 5.0 are enabled in this application domain.</source>
          <target state="translated">Chaîne de tri des valeurs par défaut pour le <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>et Unicode 5.0 sont activés dans ce domaine d’application.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Its success requires sort00060101.dll to be installed.</source>
          <target state="translated">Son succès nécessite sort00060101.dll pour être installé.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>"NetFx40_TimeSpanLegacyFormatMode"</source>
          <target state="translated">"NetFx40_TimeSpanLegacyFormatMode"</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source><ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> formatting behavior for the <ph id="ph2">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> is enabled in this application domain.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> mise en forme de comportement pour le <ph id="ph2">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> est activé dans ce domaine d’application.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>See <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>TimeSpan_LegacyFormatMode<ph id="ph2">&amp;gt;</ph> Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)</ept> and the "Restoring Legacy TimeSpan Formatting" section of the <ph id="ph3">&lt;xref:System.TimeSpan&gt;</ph> topic.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt> <ph id="ph1">&amp;lt;</ph>TimeSpan_LegacyFormatMode<ph id="ph2">&amp;gt;</ph> élément<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)</ept> et la section « Restauration hérité TimeSpan mise en forme » de la <ph id="ph3">&lt;xref:System.TimeSpan&gt;</ph> rubrique.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>"UseRandomizedStringHashAlgorithm"</source>
          <target state="translated">"UseRandomizedStringHashAlgorithm"</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains.</source>
          <target state="translated">Le runtime calcule les codes de hachage de chaînes sur un par domaine d’application au lieu d’utiliser un seul algorithme de hachage qui génère un code de hachage cohérent entre domaines d’application.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>See <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>UseRandomizedStringHashAlgorithm<ph id="ph2">&amp;gt;</ph> Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept>.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt> <ph id="ph1">&amp;lt;</ph>UseRandomizedStringHashAlgorithm<ph id="ph2">&amp;gt;</ph> élément<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsDefaultAppDomain">
          <source>Returns a value that indicates whether the application domain is the default application domain for the process.</source>
          <target state="translated">Retourne une valeur qui indique si le domaine d'application est le domaine d'application par défaut du processus.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsDefaultAppDomain">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.AppDomain" /&gt;</ph> object represents the default application domain for the process; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'objet <ph id="ph2">&lt;see cref="T:System.AppDomain" /&gt;</ph> en cours représente le domaine d'application par défaut du processus ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsDefaultAppDomain">
          <source>Every managed process has a default application domain.</source>
          <target state="translated">Chaque processus managé a un domaine d’application par défaut.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsDefaultAppDomain">
          <source>Execution begins in the default domain.</source>
          <target state="translated">Début de l’exécution dans le domaine par défaut.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsDefaultAppDomain">
          <source>The following code example creates a second application domain and displays information about the default domain and the new domain.</source>
          <target state="translated">L’exemple de code suivant crée un deuxième domaine d’application et affiche des informations sur le domaine par défaut et le nouveau domaine.</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>Indicates whether this application domain is unloading, and the objects it contains are being finalized by the common language runtime.</source>
          <target state="translated">Indique si le déchargement de ce domaine d'application est en cours et si les objets qu'il contient sont en cours de finalisation par le Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this application domain is unloading and the common language runtime has started invoking finalizers; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le déchargement du domaine d'application est en cours et que le Common Language Runtime a commencé à appeler les finaliseurs ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>The finalization method for an object provides you an opportunity to perform any necessary cleanup operations before the object is garbage collected.</source>
          <target state="translated">La méthode de finalisation d’un objet vous permet d’effectuer toutes les opérations de nettoyage nécessaires avant que l’objet soit par le garbage collecté.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>After finalization, the object is accessible but in an invalid state and therefore unusable.</source>
          <target state="translated">Après la finalisation, l’objet est accessible, mais dans un état non valide et est donc inutilisable.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>Eventually, garbage collection completes and reclaims the object.</source>
          <target state="translated">Finalement, le garbage collection se termine et libère l’objet.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>An object's finalization method is called in one of the following situations: during garbage collection, when the common language runtime is shutting down, or when the application domain that contains the object is unloaded.</source>
          <target state="translated">Méthode de finalisation d’un objet est appelée de l’une des situations suivantes : pendant le garbage collection, lorsque le common language runtime s’arrête ou quand le domaine d’application qui contient l’objet est déchargé.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.IsFinalizingForUnload%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> only in the last case; it does not return <ph id="ph3">`true`</ph> if finalization results from routine garbage collection or from CLR shutdown.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.IsFinalizingForUnload%2A&gt;</ph> méthode retourne <ph id="ph2">`true`</ph> uniquement dans le dernier cas ; elle ne retourne pas <ph id="ph3">`true`</ph> si la finalisation des résultats à partir de la routine de nettoyage ou d’arrêt CLR.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>To determine whether finalization is due to CLR shutdown, use the <ph id="ph1">&lt;xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Pour déterminer si la finalisation est en raison de l’arrêt CLR, utilisez le <ph id="ph1">&lt;xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>It returns <ph id="ph1">`true`</ph> if finalization is due to an application domain being unloaded or to the CLR shutting down.</source>
          <target state="translated">Elle retourne <ph id="ph1">`true`</ph> si la finalisation est en raison d’un domaine d’application en cours de déchargement ou au cours d’arrêt CLR.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>While executing in your finalization method during domain unloading, you might want to access another object that is referenced by a static field and has a finalization method.</source>
          <target state="translated">Lors de l’exécution de la méthode de finalisation durant le déchargement du domaine, vous pouvez souhaiter accéder à un autre objet qui est référencé par un champ statique et a une méthode de finalisation.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>However, you cannot reliably do so because the accessed object might already have been finalized.</source>
          <target state="translated">Toutefois, vous ne peut pas fiable faire car l’objet auquel vous accédez peut déjà avoir été finalisé.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>An exception to this rule is the <ph id="ph1">&lt;xref:System.Console&gt;</ph> class, which contains static fields that reference stream objects, but is implemented specially so you can always write to the system console, even during domain unloading or system shutdown.</source>
          <target state="translated">Une exception à cette règle est le <ph id="ph1">&lt;xref:System.Console&gt;</ph> (classe), qui contient des champs statiques qui font référence à des objets de flux de données, mais est implémenté spécialement donc vous pouvez toujours écrire dans la console système, même pendant un arrêt système ou de déchargement du domaine.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>Use this method in an object's finalization method to determine whether the application domain that contains the object is unloading.</source>
          <target state="translated">Utilisez cette méthode dans la méthode de finalisation d’un objet pour déterminer si le domaine d’application qui contient l’objet déchargement est en cours.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>If that is the case, you cannot reliably access any object that has a finalization method and is referenced by a static field.</source>
          <target state="translated">Si tel est le cas, vous ne pouvez pas accéder de manière fiable tout objet qui a une méthode de finalisation et est référencé par un champ statique.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="P:System.AppDomain.IsFullyTrusted">
          <source>Gets a value that indicates whether assemblies that are loaded into the current application domain execute with full trust.</source>
          <target state="translated">Obtient une valeur qui indique si les assemblys chargés dans le domaine d'application actuel s'exécutent avec la confiance totale.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if assemblies that are loaded into the current application domain execute with full trust; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si les assemblys chargés dans le domaine d'application actuel s'exécutent avec la confiance totale ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>This method always returns <ph id="ph1">`true`</ph> for the default application domain of an application that runs on the desktop.</source>
          <target state="translated">Cette méthode retourne toujours <ph id="ph1">`true`</ph> pour le domaine d’application par défaut d’une application qui s’exécute sur le bureau.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>It returns <ph id="ph1">`false`</ph> for a sandboxed application domain that was created by using the <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> method overload, unless the permissions that are granted to the application domain are equivalent to full trust.</source>
          <target state="translated">Elle retourne <ph id="ph1">`false`</ph> pour un domaine d’application sandbox a été créé à l’aide de la <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> surcharge de méthode, à moins que les autorisations sont accordées au domaine d’application sont équivalentes à la confiance totale.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.IsFullyTrusted%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> property with fully trusted and partially trusted application domains.</source>
          <target state="translated">L’exemple suivant illustre la <ph id="ph1">&lt;xref:System.AppDomain.IsFullyTrusted%2A&gt;</ph> propriété et le <ph id="ph2">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> propriété avec les domaines d’application de confiance totale et confiance partielle.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The fully trusted application domain is the default application domain for the application.</source>
          <target state="translated">Le domaine d’application de confiance totale est le domaine d’application par défaut pour l’application.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The partially trusted application domain is created by using the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Le domaine d’application de niveau de confiance partiel est créé à l’aide de la <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> la surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The example uses a <ph id="ph1">`Worker`</ph> class that derives from <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, so it can be marshaled across application domain boundaries.</source>
          <target state="translated">L’exemple utilise un <ph id="ph1">`Worker`</ph> classe qui dérive de <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, donc il peut être marshalé entre des limites de domaine d’application.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The example creates a <ph id="ph1">`Worker`</ph> object in the default application domain.</source>
          <target state="translated">L’exemple crée un <ph id="ph1">`Worker`</ph> objet dans le domaine d’application par défaut.</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>It then calls the <ph id="ph1">`TestIsFullyTrusted`</ph> method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly.</source>
          <target state="translated">Il appelle ensuite la <ph id="ph1">`TestIsFullyTrusted`</ph> méthode pour afficher la valeur de propriété pour le domaine d’application et pour les deux assemblys sont chargés dans le domaine d’application : mscorlib, qui fait partie du .NET Framework et l’assembly de l’exemple.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The application domain is fully trusted, so both assemblies are fully trusted.</source>
          <target state="translated">Le domaine d’application étant entièrement fiable, les deux assemblys sont entièrement fiables.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The example creates another <ph id="ph1">`Worker`</ph> object in a sandboxed application domain and again calls the <ph id="ph2">`TestIsFullyTrusted`</ph> method.</source>
          <target state="translated">L’exemple crée un autre <ph id="ph1">`Worker`</ph> objet dans un domaine d’application sandbox et appelle de nouveau la <ph id="ph2">`TestIsFullyTrusted`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.</source>
          <target state="translated">Mscorlib est toujours approuvé, même dans un domaine d’application de confiance partielle, mais l’exemple d’assembly est partiellement approuvé.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" uid="P:System.AppDomain.IsHomogenous">
          <source>Gets a value that indicates whether the current application domain has a set of permissions that is granted to all assemblies that are loaded into the application domain.</source>
          <target state="translated">Obtient une valeur qui indique si le domaine d'application actuel dispose d'un jeu d'autorisations accordé à tous les assemblys chargés dans le domaine d'application.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current application domain has a homogenous set of permissions; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le domaine d'application actuel dispose d'un jeu d'autorisations homogène ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source>This property returns <ph id="ph1">`true`</ph> for sandboxed application domains that were created by using the <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Cette propriété retourne <ph id="ph1">`true`</ph> pour les domaines d’application sandbox qui ont été créés à l’aide de la <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> la surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source>Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</source>
          <target state="translated">Domaines d’application sandbox ont un jeu homogène d’autorisations ; Autrement dit, le même jeu d’autorisations est accordé à tous les assemblys de confiance partiel qui sont chargés dans le domaine d’application.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source>A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</source>
          <target state="translated">Un domaine d’application sandbox possède éventuellement une liste d’assemblys avec nom fort qui sont exempts de cette autorisation définie et exécutées avec une confiance totale.</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source>Fully trusted code can use the <ph id="ph1">&lt;xref:System.AppDomain.PermissionSet%2A&gt;</ph> property to determine the homogenous grant set of a sandboxed application domain.</source>
          <target state="translated">Confiance totale code peut utiliser le <ph id="ph1">&lt;xref:System.AppDomain.PermissionSet%2A&gt;</ph> propriété pour déterminer le jeu d’autorisations homogène d’un domaine d’application sandbox.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source>This property also returns <ph id="ph1">`true`</ph> for the default application domain of a desktop application, because that application domain grants full trust to all assemblies.</source>
          <target state="translated">Cette propriété retourne également <ph id="ph1">`true`</ph> pour le domaine d’application par défaut d’une application de bureau, car ce domaine d’application accorde une confiance totale à tous les assemblys.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> into this application domain.</source>
          <target state="translated">Charge <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> dans ce domaine d'application.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> qui est une image au format COFF contenant un assembly émis.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>Loads the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> with a common object file format (COFF) based image containing an emitted <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</source>
          <target state="translated">Charge <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> avec l'image au format COFF (Common Object File Format) contenant un <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> émis.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, le niveau de confiance d’un assembly est chargé à l’aide de cette méthode est le même que le niveau de confiance du domaine d’application.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">Cette méthode doit être utilisée uniquement pour charger un assembly dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Cette méthode est fournie par commodité pour les appelants d’interopérabilité qui ne peuvent pas appeler la méthode statique <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">Pour charger des assemblys dans les autres domaines d’application, utilisez une méthode telle que <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations qui sont communes à toutes les surcharges de cette méthode, consultez la <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>The following sample demonstrates the use of loading a raw assembly.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation du chargement d’un assembly brut.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez <bpt id="p1">[</bpt>les noms d’assemblys<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>An object that describes the assembly to load.</source>
          <target state="translated">Objet qui décrit l'assembly à charger.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> given its <ph id="ph2">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</source>
          <target state="translated">Charge <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> en fonction de son <ph id="ph2">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">Cette méthode doit être utilisée uniquement pour charger un assembly dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Cette méthode est fournie par commodité pour les appelants d’interopérabilité qui ne peuvent pas appeler la méthode statique <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">Pour charger des assemblys dans les autres domaines d’application, utilisez une méthode telle que <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If a version of the requested assembly is already loaded, this method returns the loaded assembly, even if a different version is requested.</source>
          <target state="translated">Si une version de l’assembly demandé est déjà chargée, cette méthode retourne l’assembly chargé, même si une version différente est demandée.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>Supplying a partial assembly name for <ph id="ph1">`assemblyRef`</ph> is not recommended.</source>
          <target state="translated">Fournir un nom d’assembly partielles pour <ph id="ph1">`assemblyRef`</ph> n’est pas recommandée.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>(A partial name omits one or more of culture, version, or public key token.</source>
          <target state="translated">(Un nom partiel omet un ou plusieurs de culture, version ou jeton de clé publique.</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>For overloads that take a string instead of an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object, "MyAssembly, Version=1.0.0.0" is an example of a partial name and "MyAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=18ab3442da84b47" is an example of a full name.) Using partial names has a negative effect on performance.</source>
          <target state="translated">Pour les surcharges qui prennent une chaîne au lieu d’un <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> objet, « MyAssembly, Version = 1.0.0.0 » est un exemple d’un nom partiel et « MyAssembly, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = 18ab3442da84b47 » est un exemple d’un nom complet.) À l’aide de noms partiels a un effet négatif sur les performances.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>In addition, a partial assembly name can load an assembly from the global assembly cache only if there is an exact copy of the assembly in the application base directory (<ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">En outre, un nom d’assembly partiel peut charger un assembly dans le global assembly cache uniquement s’il existe une copie exacte de l’assembly dans le répertoire de base d’application (<ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If the current <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> object represents application domain <ph id="ph2">`A`</ph>, and the <ph id="ph3">&lt;xref:System.AppDomain.Load%2A&gt;</ph> method is called from application domain <ph id="ph4">`B`</ph>, the assembly is loaded into both application domains.</source>
          <target state="translated">Si le courant <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> objet représente le domaine d’application <ph id="ph2">`A`</ph>et le <ph id="ph3">&lt;xref:System.AppDomain.Load%2A&gt;</ph> méthode est appelée à partir du domaine d’application <ph id="ph4">`B`</ph>, l’assembly est chargé dans les deux domaines d’application.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>For example, the following code loads <ph id="ph1">`MyAssembly`</ph> into the new application domain <ph id="ph2">`ChildDomain`</ph> and also into the application domain where the code executes:</source>
          <target state="translated">Par exemple, le code suivant charge <ph id="ph1">`MyAssembly`</ph> dans le nouveau domaine d’application <ph id="ph2">`ChildDomain`</ph> et également dans le domaine d’application où le code s’exécute :</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>The assembly is loaded into both domains because <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> does not derive from <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, and therefore the return value of the <ph id="ph3">&lt;xref:System.AppDomain.Load%2A&gt;</ph> method cannot be marshaled.</source>
          <target state="translated">L’assembly est chargé dans les deux domaines car <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> ne dérive pas de <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>et par conséquent, la valeur de retour de la <ph id="ph3">&lt;xref:System.AppDomain.Load%2A&gt;</ph> méthode ne peut pas être marshalée.</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>Instead, the common language runtime tries to load the assembly into the calling application domain.</source>
          <target state="translated">Au lieu de cela, le common language runtime tente de charger l’assembly dans le domaine d’application appelant.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>The assemblies that are loaded into the two application domains might be different if the path settings for the two application domains are different.</source>
          <target state="translated">Les assemblys sont chargés dans les deux domaines d’application peuvent être différents si les paramètres de chemin d’accès pour les deux domaines d’application sont différents.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If both the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> property).</source>
          <target state="translated">Si les deux le <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> propriété et la <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph> sont définies, la première tentative de charger l’assembly utilise le nom complet (y compris la version, culture et ainsi de suite, tel que retourné par le <ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> propriété).</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If the file is not found, the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> property is used to search for the assembly.</source>
          <target state="translated">Si le fichier est introuvable, la <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> propriété est utilisée pour rechercher l’assembly.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If the assembly is found using <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>, the display name is matched against the assembly.</source>
          <target state="translated">Si l’assembly se trouve à l’aide de <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>, le nom complet est comparé à l’assembly.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If the match fails, a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown.</source>
          <target state="translated">Si la correspondance échoue, un <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> given its display name.</source>
          <target state="translated">Charge <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> en fonction de son nom complet.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">Cette méthode doit être utilisée uniquement pour charger un assembly dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Cette méthode est fournie par commodité pour les appelants d’interopérabilité qui ne peuvent pas appeler la méthode statique <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">Pour charger des assemblys dans les autres domaines d’application, utilisez une méthode telle que <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations qui sont communes à toutes les surcharges de cette méthode, consultez la <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> qui est une image au format COFF contenant un assembly émis.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> containing the raw bytes representing the symbols for the assembly.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> contenant les octets bruts représentant les symboles de l'assembly.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>Loads the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> with a common object file format (COFF) based image containing an emitted <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</source>
          <target state="translated">Charge <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> avec l'image au format COFF (Common Object File Format) contenant un <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> émis.</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>The raw bytes representing the symbols for the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> are also loaded.</source>
          <target state="translated">Les octets bruts représentant les symboles de <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> sont également chargés.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, le niveau de confiance d’un assembly est chargé à l’aide de cette méthode est le même que le niveau de confiance du domaine d’application.</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">Cette méthode doit être utilisée uniquement pour charger un assembly dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Cette méthode est fournie par commodité pour les appelants d’interopérabilité qui ne peuvent pas appeler la méthode statique <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">Pour charger des assemblys dans les autres domaines d’application, utilisez une méthode telle que <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations qui sont communes à toutes les surcharges de cette méthode, consultez la <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>The following sample demonstrates the use of loading a raw assembly.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation du chargement d’un assembly brut.</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez <bpt id="p1">[</bpt>les noms d’assemblys<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">pour lire un URI qui ne commence pas par « file:// ».</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>An object that describes the assembly to load.</source>
          <target state="translated">Objet qui décrit l'assembly à charger.</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Preuve de chargement de l'assembly.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> given its <ph id="ph2">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</source>
          <target state="translated">Charge <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> en fonction de son <ph id="ph2">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">Cette méthode doit être utilisée uniquement pour charger un assembly dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Cette méthode est fournie par commodité pour les appelants d’interopérabilité qui ne peuvent pas appeler la méthode statique <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">Pour charger des assemblys dans les autres domaines d’application, utilisez une méthode telle que <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations qui sont communes à toutes les surcharges de cette méthode, consultez la <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>for reading a path that is not in the form "file://" or "<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>" or "c:<ph id="ph3">\\</ph>".</source>
          <target state="translated">pour la lecture d’un chemin d’accès qui n’est pas sous la forme « file:// » ou «<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>» ou « c:<ph id="ph3">\\</ph>».</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nom complet de l'assembly.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Preuve de chargement de l'assembly.</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> given its display name.</source>
          <target state="translated">Charge <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> en fonction de son nom complet.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">Cette méthode doit être utilisée uniquement pour charger un assembly dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Cette méthode est fournie par commodité pour les appelants d’interopérabilité qui ne peuvent pas appeler la méthode statique <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">Pour charger des assemblys dans les autres domaines d’application, utilisez une méthode telle que <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations qui sont communes à toutes les surcharges de cette méthode, consultez la <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">pour charger un assembly avec la preuve.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>for reading a path that is not in the form "file://" or "<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>" or "c:<ph id="ph3">\\</ph>".</source>
          <target state="translated">pour la lecture d’un chemin d’accès qui n’est pas sous la forme « file:// » ou «<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>» ou « c:<ph id="ph3">\\</ph>».</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>An array of type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> qui est une image au format COFF contenant un assembly émis.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>An array of type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> containing the raw bytes representing the symbols for the assembly.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> contenant les octets bruts représentant les symboles de l'assembly.</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Preuve de chargement de l'assembly.</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Loads the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> with a common object file format (COFF) based image containing an emitted <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</source>
          <target state="translated">Charge <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> avec l'image au format COFF (Common Object File Format) contenant un <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> émis.</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The raw bytes representing the symbols for the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> are also loaded.</source>
          <target state="translated">Les octets bruts représentant les symboles de <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> sont également chargés.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly chargé.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, le niveau de confiance d’un assembly est chargé à l’aide de cette méthode est le même que le niveau de confiance du domaine d’application.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">Cette méthode doit être utilisée uniquement pour charger un assembly dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Cette méthode est fournie par commodité pour les appelants d’interopérabilité qui ne peuvent pas appeler la méthode statique <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">Pour charger des assemblys dans les autres domaines d’application, utilisez une méthode telle que <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Pour plus d’informations qui sont communes à toutes les surcharges de cette méthode, consultez la <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The following sample demonstrates the use of loading a raw assembly.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation du chargement d’un assembly brut.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez <bpt id="p1">[</bpt>les noms d’assemblys<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> n’est pas un assembly valide.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> a été compilé avec une version ultérieure.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> n’est pas un <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Quand la stratégie CAS héritée n’est pas activée, <ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> doit être <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>to provide evidence.</source>
          <target state="translated">pour fournir la preuve.</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">Pour accéder en lecture à partir d’un fichier ou un répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>for reading a path that is not in the form "file://" or "<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>" or "c:<ph id="ph3">\\</ph>".</source>
          <target state="translated">pour la lecture d’un chemin d’accès qui n’est pas sous la forme « file:// » ou «<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>» ou « c:<ph id="ph3">\\</ph>».</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>Gets or sets a value that indicates whether CPU and memory monitoring of application domains is enabled for the current process.</source>
          <target state="translated">Obtient ou définit une valeur qui indique si l'analyse de la mémoire et du processeur des domaines d'application est activée pour le processus actuel.</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>Once monitoring is enabled for a process, it cannot be disabled.</source>
          <target state="translated">Quand l'analyse a été activée pour un processus, elle ne peut plus être désactivée.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if monitoring is enabled; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'analyse est activée ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>This <ph id="ph1">`static`</ph> property (<ph id="ph2">`Shared`</ph> property in Visual Basic) controls CPU and memory monitoring of all the application domains in the process.</source>
          <target state="translated">Cela <ph id="ph1">`static`</ph> propriété (<ph id="ph2">`Shared`</ph> propriété en Visual Basic) contrôle la mémoire analyse tous les domaines d’application dans le processus et du processeur.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>If you attempt to set this property to <ph id="ph1">`false`</ph>, a <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> exception is thrown, even if the current value of the property is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Si vous essayez de définir cette propriété sur <ph id="ph1">`false`</ph>, un <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> exception est levée, même si la valeur actuelle de la propriété est <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>Once monitoring is enabled, you can use the <ph id="ph1">&lt;xref:System.AppDomain.MonitoringSurvivedMemorySize%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.AppDomain.MonitoringTotalProcessorTime%2A&gt;</ph> instance properties to monitor CPU and memory use of individual application domains.</source>
          <target state="translated">Une fois que l’analyse est activée, vous pouvez utiliser la <ph id="ph1">&lt;xref:System.AppDomain.MonitoringSurvivedMemorySize%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A&gt;</ph>, et <ph id="ph4">&lt;xref:System.AppDomain.MonitoringTotalProcessorTime%2A&gt;</ph> propriétés pour surveiller l’utilisation du processeur et de la mémoire des domaines d’application de l’instance.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>The current process attempted to assign the value <ph id="ph1">&lt;see langword="false" /&gt;</ph> to this property.</source>
          <target state="translated">Le processus actuel a essayé d'assigner la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph> à cette propriété.</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>Gets the number of bytes that survived the last collection and that are known to be referenced by the current application domain.</source>
          <target state="translated">Obtient le nombre d’octets qui ont survécu à la dernière collection et qui sont référencés par le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>The number of surviving bytes.</source>
          <target state="translated">Nombre d'octets survivants.</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>The statistics are updated with each garbage collection.</source>
          <target state="translated">Les statistiques sont mises à jour à chaque garbage collection.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>However, they are guaranteed to be accurate only after a full, blocking collection; that is, a collection that includes all generations and that stops the application while collection occurs.</source>
          <target state="translated">Toutefois, ils sont garanties exacte uniquement après un collection ; de blocage complet Autrement dit, une collection qui inclut toutes les générations et qui arrête l’application lors de la collection se produit.</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>For example, the <ph id="ph1">&lt;xref:System.GC.Collect?displayProperty=nameWithType&gt;</ph> method overload performs a full, blocking collection.</source>
          <target state="translated">Par exemple, le <ph id="ph1">&lt;xref:System.GC.Collect?displayProperty=nameWithType&gt;</ph> surcharge de méthode effectue un collection de blocage complet.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>(Concurrent collection occurs in the background and does not block the application.)</source>
          <target state="translated">(Collection simultanée se produit en arrière-plan et ne bloque pas l’application).</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>The <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> property is set to <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> en Visual Basic) a la valeur <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>Gets the total bytes that survived from the last collection for all application domains in the process.</source>
          <target state="translated">Obtient le nombre total d’octets qui ont survécu à la dernière collection pour tous les domaines d’application dans le processus.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>The total number of surviving bytes for the process.</source>
          <target state="translated">Nombre total d'octets survivants pour le processus.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>After a full, blocking collection, this number represents the number of bytes currently held live on managed heaps.</source>
          <target state="translated">Après une collection complète, de blocage, ce nombre représente le nombre d’octets actuellement actif sur géré de segments de mémoire.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>It should be close to the number reported by the <ph id="ph1">&lt;xref:System.GC.GetTotalMemory%2A&gt;</ph> method.</source>
          <target state="translated">Il doit être proche du nombre signalé par le <ph id="ph1">&lt;xref:System.GC.GetTotalMemory%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>After an ephemeral collection, this number represents the number of bytes currently held live in ephemeral generations.</source>
          <target state="translated">Après une collection éphémère, ce nombre représente le nombre d’octets actuellement maintenus actifs dans les générations éphémères.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>The <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> property is set to <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> en Visual Basic) a la valeur <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringTotalAllocatedMemorySize">
          <source>Gets the total size, in bytes, of all memory allocations that have been made by the application domain since it was created, without subtracting memory that has been collected.</source>
          <target state="translated">Obtient la taille totale, en octets, de toutes les allocations de mémoire effectuées par le domaine d'application depuis sa création, sans soustraire la mémoire collectée.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalAllocatedMemorySize">
          <source>The total size of all memory allocations.</source>
          <target state="translated">Taille totale de toutes les allocations de mémoire.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringTotalAllocatedMemorySize">
          <source>The <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> property is set to <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> en Visual Basic) a la valeur <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalAllocatedMemorySize">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalAllocatedMemorySize">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>Gets the total processor time that has been used by all threads while executing in the current application domain, since the process started.</source>
          <target state="translated">Obtient le temps processeur total utilisé par tous les threads pendant leur exécution dans le domaine d'application actuel, depuis le démarrage du processus.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>Total processor time for the current application domain.</source>
          <target state="translated">Temps processeur total pour le domaine d'application actuel.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>The total time that is reported for an application domain includes the time each thread in the process spent executing in that application domain.</source>
          <target state="translated">La durée totale qui est signalée pour un domaine d’application comprend la durée de chaque thread dans le processus de l’exécution dans ce domaine d’application.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>A thread that calls into unmanaged code is still associated with an application domain, and the processor time spent executing the unmanaged code is reported for the application domain where the call was made.</source>
          <target state="translated">Un thread qui appelle dans du code non managé est toujours associé à un domaine d’application, et le temps processeur passé à l’exécution que du code non managé est signalé pour le domaine d’application où l’appel a été effectué.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>When a thread is blocked or sleeping, it does not consume processor time.</source>
          <target state="translated">Lorsqu’un thread est bloqué ou en veille, il ne consomme pas de temps processeur.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>The <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> property is set to <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> en Visual Basic) a la valeur <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" uid="P:System.AppDomain.PermissionSet">
          <source>Gets the permission set of a sandboxed application domain.</source>
          <target state="translated">Obtient le jeu d'autorisations d'un domaine d'application en mode bac à sable (sandbox).</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.PermissionSet">
          <source>The permission set of the sandboxed application domain.</source>
          <target state="translated">Jeu d'autorisations du domaine d'application en mode bac à sable (sandbox).</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.PermissionSet">
          <source>Sandboxed application domains that were created by using the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> method overload have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</source>
          <target state="translated">Domaines d’application sandbox qui ont été créés à l’aide de la <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> la surcharge de méthode a un jeu d’autorisations homogène ; autrement dit, le même jeu d’autorisations est accordé à tous les assemblys de confiance partiel qui sont chargés dans le domaine d’application.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.PermissionSet">
          <source>A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</source>
          <target state="translated">Un domaine d’application sandbox possède éventuellement une liste d’assemblys avec nom fort qui sont exempts de cette autorisation définie et exécutées avec une confiance totale.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.PermissionSet">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.PermissionSet">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" uid="E:System.AppDomain.ProcessExit">
          <source>Occurs when the default application domain's parent process exits.</source>
          <target state="translated">Se produit quand le processus parent du domaine d'application par défaut s'arrête.</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>The <ph id="ph1">&lt;xref:System.EventHandler&gt;</ph> for this event can perform termination activities, such as closing files, releasing storage and so on, before the process ends.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.EventHandler&gt;</ph> de cet événement peut effectuer des activités d’arrêt, telles que la fermeture de fichiers, libération de stockage, et ainsi de suite, avant la fin du processus.</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>Beginning with the .NET Framework version 2.0, this event is raised in each application domain that registers an event handler.</source>
          <target state="translated">À compter de .NET Framework version 2.0, cet événement est déclenché dans chaque domaine d’application qui inscrit un gestionnaire d’événements.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>The total execution time of all <ph id="ph1">&lt;xref:System.AppDomain.ProcessExit&gt;</ph> event handlers is limited, just as the total execution time of all finalizers is limited at process shutdown.</source>
          <target state="translated">La durée totale d’exécution de tous les <ph id="ph1">&lt;xref:System.AppDomain.ProcessExit&gt;</ph> gestionnaires d’événements est limité, tout comme la durée totale d’exécution de tous les finaliseurs est limitée à l’arrêt du processus.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>The default is two seconds.</source>
          <target state="translated">La valeur par défaut est de deux secondes.</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>An unmanaged host can change this execution time by calling the <bpt id="p1">[</bpt>ICLRPolicyManager::SetTimeout<ept id="p1">](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md)</ept> method with the <bpt id="p2">[</bpt>OPR_ProcessExit<ept id="p2">](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md)</ept> enumeration value.</source>
          <target state="translated">Un hôte non managé peut modifier cette durée d’exécution en appelant le <bpt id="p1">[</bpt>ICLRPolicyManager::SetTimeout<ept id="p1">](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md)</ept> méthode avec la <bpt id="p2">[</bpt>OPR_ProcessExit<ept id="p2">](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md)</ept> valeur d’énumération.</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>In the .NET Framework versions 1.0 and 1.1, this event is raised only in the default application domain, and only if an event handler is registered in the default application domain.</source>
          <target state="translated">Dans les versions 1.0 et 1.1 du .NET Framework, cet événement est déclenché uniquement dans le domaine d’application par défaut et uniquement si un gestionnaire d’événements est inscrite dans le domaine d’application par défaut.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>To register an event handler for this event, you must have the required permissions, or a <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown.</source>
          <target state="translated">Pour inscrire un gestionnaire d’événements pour cet événement, vous devez disposer des autorisations requises, ou un <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des événements, consultez <bpt id="p1">[</bpt>gestion et déclenchement d’événements<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>Occurs when the resolution of an assembly fails in the reflection-only context.</source>
          <target state="translated">Se produit quand la résolution d’un assembly échoue dans le contexte de réflexion uniquement.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>In the reflection-only context, dependencies are not resolved automatically.</source>
          <target state="translated">Dans le contexte de réflexion uniquement, les dépendances ne sont pas résolues automatiquement.</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>They must be preloaded or returned by the handler for this event.</source>
          <target state="translated">Ils doivent être préchargés ou retournés par le gestionnaire pour cet événement.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>This event is raised when an assembly has a dependency that is not already loaded into the reflection-only context.</source>
          <target state="translated">Cet événement est déclenché lorsqu’un assembly a une dépendance qui n’est pas déjà chargée dans le contexte de réflexion uniquement.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>The missing dependency is specified by the <ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">La dépendance manquante est spécifiée par le <ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>The <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> for this event must return an assembly that satisfies the dependency.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> pour cet événement doit retourner un assembly qui satisfait la dépendance.</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>The assembly that is returned must be loaded into the reflection-only context.</source>
          <target state="translated">L’assembly retourné doit être chargé dans le contexte de réflexion uniquement.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>This event is raised only for missing dependencies of the assembly that you are loading into the reflection-only context (for example, by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType&gt;</ph> method).</source>
          <target state="translated">Cet événement est déclenché uniquement pour les dépendances manquantes de l’assembly que vous chargez dans le contexte de réflexion uniquement (par exemple, à l’aide de la <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType&gt;</ph> méthode).</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>It is not raised if the assembly that you are loading cannot be found.</source>
          <target state="translated">Il n’est pas déclenché si l’assembly que vous chargez est introuvable.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> property returns the assembly that requested the assembly load that could not be resolved.</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, le <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> propriété retourne l’assembly qui a demandé le chargement d’assembly qui ne peut pas être résolu.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>Knowing the identity of the requesting assembly might be useful in identifying the correct version of the dependency, if more than one version is available.</source>
          <target state="translated">Connaître l’identité de l’assembly demandeur peut être utile pour identifier la version correcte de la dépendance, si plus d’une version est disponible.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>For more information, see <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>For this event, the <ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> property returns the assembly name before policy is applied.</source>
          <target state="translated">Pour cet événement, le <ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> propriété retourne le nom de l’assembly avant de la stratégie est appliquée.</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des événements, consultez <bpt id="p1">[</bpt>gestion et déclenchement d’événements<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>Returns the assemblies that have been loaded into the reflection-only context of the application domain.</source>
          <target state="translated">Retourne les assemblys qui ont été chargés dans le contexte de réflexion uniquement du domaine d'application.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> objects that represent the assemblies loaded into the reflection-only context of the application domain.</source>
          <target state="translated">Tableau d'objets <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> qui représentent les assemblys chargés dans le contexte de réflexion uniquement du domaine d'application.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>This method returns the assemblies that have been loaded into the reflection-only context.</source>
          <target state="translated">Cette méthode retourne les assemblys qui ont été chargés dans le contexte de réflexion uniquement.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>To get the assemblies that have been loaded for execution, use the <ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> method.</source>
          <target state="translated">Pour obtenir les assemblys qui ont été chargés pour l’exécution, utilisez la <ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>The following code example loads the System.dll assembly into the execution context and then into the reflection-only context.</source>
          <target state="translated">L’exemple de code suivant charge l’assembly System.dll dans le contexte d’exécution, puis dans le contexte de réflexion uniquement.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A&gt;</ph> methods are used to display the assemblies loaded into each context.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A&gt;</ph> méthodes sont utilisées pour afficher les assemblys chargés dans chaque contexte.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>An operation is attempted on an unloaded application domain.</source>
          <target state="translated">Une tentative d'opération est en cours sur un domaine d'application non chargé.</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" uid="P:System.AppDomain.RelativeSearchPath">
          <source>Gets the path under the base directory where the assembly resolver should probe for private assemblies.</source>
          <target state="translated">Obtient le chemin d’accès sous le répertoire de base où le programme de résolution d’assembly doit détecter les assemblys privés.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>The path under the base directory where the assembly resolver should probe for private assemblies.</source>
          <target state="translated">Chemin d’accès sous le répertoire de base où le programme de résolution d’assembly doit détecter les assemblys privés.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>Private assemblies are deployed in the same directory structure as the application.</source>
          <target state="translated">Les assemblys privés sont déployés dans la même structure de répertoire que l’application.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>If the path specified by the <ph id="ph1">&lt;xref:System.AppDomain.RelativeSearchPath%2A&gt;</ph> property is not under <ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph>, it is ignored.</source>
          <target state="translated">Si le chemin d’accès spécifié par le <ph id="ph1">&lt;xref:System.AppDomain.RelativeSearchPath%2A&gt;</ph> propriété n’est pas sous <ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph>, elle est ignorée.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>This property returns the value set using <ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Cette propriété retourne la valeur définie à l’aide de <ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" uid="P:System.AppDomain.RelativeSearchPath">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>for access to the path information.</source>
          <target state="translated">Pour accéder aux informations de chemin d’accès.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" uid="E:System.AppDomain.ResourceResolve">
          <source>Occurs when the resolution of a resource fails because the resource is not a valid linked or embedded resource in the assembly.</source>
          <target state="translated">Se produit quand la résolution d’une ressource échoue car la ressource n’est pas une ressource liée ou incorporée valide de l’assembly.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>The <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> for this event can attempt to locate the assembly containing the resource and return it.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> pour cet événement peut tenter de localiser l’assembly contenant la ressource et renvoyez-le.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>This event is not raised if resolution fails because no file can be found for a valid linked resource.</source>
          <target state="translated">Cet événement n’est pas déclenché si la résolution échoue, car aucun fichier peut être trouvé pour une ressource liée valide.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>It is raised if a manifest resource stream cannot be found, but it is not raised if an individual resource key cannot be found.</source>
          <target state="translated">Il est déclenché si un flux de données de ressource de manifeste ne peut pas être trouvé, mais il n’est pas déclenché si une clé de ressource est introuvable.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> property contains the assembly that requested the resource.</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, le <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> propriété contient l’assembly qui a demandé la ressource.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>For more information, see <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>To register an event handler for this event, you must have the required permissions, or a <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown.</source>
          <target state="translated">Pour inscrire un gestionnaire d’événements pour cet événement, vous devez disposer des autorisations requises, ou un <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des événements, consultez <bpt id="p1">[</bpt>gestion et déclenchement d’événements<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>The security policy level.</source>
          <target state="translated">Niveau de stratégie de sécurité.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>Establishes the security policy level for this application domain.</source>
          <target state="translated">Définit le niveau de stratégie de sécurité pour ce domaine d'application.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>Call this method before an assembly is loaded into the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> in order for the security policy to have effect.</source>
          <target state="translated">Appelez cette méthode avant un assembly est chargé dans le <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> afin que la stratégie de sécurité d’avoir l’effet.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.AppDomain.SetAppDomainPolicy%2A&gt;</ph> method to set the security policy level of an application domain.</source>
          <target state="translated">L’exemple suivant montre comment utiliser la <ph id="ph1">&lt;xref:System.AppDomain.SetAppDomainPolicy%2A&gt;</ph> pour définir le niveau de stratégie de sécurité d’un domaine d’application.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source><ph id="ph1">&lt;paramref name="domainPolicy" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="domainPolicy" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>The security policy level has already been set.</source>
          <target state="translated">Le niveau de stratégie de sécurité a déjà été défini.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>The fully qualified path to the shadow copy location.</source>
          <target state="translated">Chemin d’accès qualifié complet à l’emplacement des clichés instantanés.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>Establishes the specified directory path as the location where assemblies are shadow copied.</source>
          <target state="translated">Définit le chemin d’accès du répertoire spécifié comme emplacement pour les clichés instantanés des assemblys.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>The cache path is ignored if the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A&gt;</ph> property is not set.</source>
          <target state="translated">Le chemin d’accès du cache est ignoré si le <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A&gt;</ph> propriété n’est pas définie.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>See the <ph id="ph1">&lt;xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Voir la propriété <ph id="ph1">&lt;xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>For more information on shadow copying see <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les clichés instantanés, consultez <bpt id="p1">[</bpt>clichés instantanés d’assemblys<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Assigns a value to an application domain property.</source>
          <target state="translated">Assigne une valeur à une propriété de domaine d'application.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The name of a user-defined application domain property to create or change.</source>
          <target state="translated">Nom d'une propriété de domaine d'application définie par l'utilisateur à créer ou à changer.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The value of the property.</source>
          <target state="translated">Valeur de la propriété.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>Assigns the specified value to the specified application domain property.</source>
          <target state="translated">Assigne la valeur spécifiée à la propriété du domaine d'application spécifié.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>Use this method to insert an entry, or modify the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>.</source>
          <target state="translated">Utilisez cette méthode pour insérer une entrée, ou modifier la valeur d’une entrée dans un cache interne de paires nom / données qui décrivent les propriétés de cette instance de <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The cache automatically contains predefined system entries that are inserted when the application domain is created.</source>
          <target state="translated">Le cache contient automatiquement des entrées de système prédéfinis sont insérées lorsque le domaine d’application est créé.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>You cannot insert or modify system entries with this method.</source>
          <target state="translated">Vous ne pouvez pas insérer ou modifier des entrées de système avec cette méthode.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</source>
          <target state="translated">Un appel de méthode qui tente de modifier une entrée de système n’a aucun effet ; la méthode ne lève pas d’exception.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>You can inspect the values of system entries with the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method, or the equivalent <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> properties described in <ph id="ph3">&lt;xref:System.AppDomain.GetData%2A&gt;</ph>.</source>
          <target state="translated">Vous pouvez inspecter les valeurs des entrées du système avec le <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> (méthode), ou l’équivalent <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> décrit les propriétés <ph id="ph3">&lt;xref:System.AppDomain.GetData%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>You can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the <ph id="ph1">`name`</ph> argument and a <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> value that represents the timeout interval as the value of the <ph id="ph3">`data`</ph> argument.</source>
          <target state="translated">Vous pouvez appeler cette méthode pour définir la valeur de l’intervalle de délai d’attente par défaut pour l’évaluation des modèles d’expressions régulières par la fourniture « REGEX_DEFAULT_MATCH_TIMEOUT » comme valeur de la <ph id="ph1">`name`</ph> argument et un <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> valeur qui représente le délai d’attente la valeur de l’intervalle du <ph id="ph3">`data`</ph> argument.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>You can also insert or modify your own user defined name-data pairs with this method and inspect their values with the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également insérer ou modifier vos propres paires de nom / données définies par l’utilisateur avec cette méthode et vérifier leurs valeurs à le <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29&gt;</ph> method to create a new value pair.</source>
          <target state="translated">L’exemple suivant montre comment utiliser la <ph id="ph1">&lt;xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29&gt;</ph> méthode pour créer une nouvelle paire de valeur.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The example then uses the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method to retrieve the value, and displays it to the console.</source>
          <target state="translated">L’exemple utilise ensuite la <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> méthode pour récupérer la valeur et l’affiche dans la console.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>The name of a user-defined application domain property to create or change.</source>
          <target state="translated">Nom d'une propriété de domaine d'application définie par l'utilisateur à créer ou à changer.</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>The value of the property.</source>
          <target state="translated">Valeur de la propriété.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>The permission to demand of the caller when the property is retrieved.</source>
          <target state="translated">Autorisation à exiger de l'appelant quand la propriété est récupérée.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>Assigns the specified value to the specified application domain property, with a specified permission to demand of the caller when the property is retrieved.</source>
          <target state="translated">Assigne la valeur spécifiée à la propriété du domaine d'application spécifiée, avec une autorisation spécifiée à exiger de l'appelant quand la propriété est récupérée.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>Use this method to insert or modify your own user-defined entries in an internal cache of name/data pairs that describe properties of the application domain.</source>
          <target state="translated">Utilisez cette méthode pour insérer ou modifier vos propres entrées définies par l’utilisateur dans un cache interne de paires nom/données qui décrivent les propriétés du domaine d’application.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>When you insert an entry, you can specify a permission demand to enforce when the entry is retrieved.In addition, you can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the <ph id="ph1">`name`</ph> argument and a <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> value that represents the timeout interval as the value of the <ph id="ph3">`data`</ph> argument.</source>
          <target state="translated">Lorsque vous insérez une entrée, vous pouvez spécifier une demande d’autorisation à appliquer lors de l’entrée est récupérée. En outre, vous pouvez appeler cette méthode pour définir la valeur de l’intervalle de délai d’attente par défaut pour l’évaluation des modèles d’expressions régulières par la fourniture « REGEX_DEFAULT_MATCH_TIMEOUT » comme valeur de la <ph id="ph1">`name`</ph> argument et un <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> valeur qui représente la intervalle de délai d’attente en tant que la valeur de la <ph id="ph3">`data`</ph> argument.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>You cannot use this method to assign a security demand to a system-defined property string.</source>
          <target state="translated">Vous ne pouvez pas utiliser cette méthode pour attribuer une demande de sécurité à une chaîne définie par le système de propriété.</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>The cache automatically contains predefined system entries that are inserted when the application domain is created.</source>
          <target state="translated">Le cache contient automatiquement des entrées de système prédéfinis sont insérées lorsque le domaine d’application est créé.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>You cannot insert or modify system entries with this method.</source>
          <target state="translated">Vous ne pouvez pas insérer ou modifier des entrées de système avec cette méthode.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</source>
          <target state="translated">Un appel de méthode qui tente de modifier une entrée de système n’a aucun effet ; la méthode ne lève pas d’exception.</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>You can inspect the values of system entries with the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method or the equivalent <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> properties described in the Remarks section for the <ph id="ph3">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez inspecter les valeurs des entrées du système avec le <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> méthode ou l’équivalent <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> propriétés décrites dans la section Notes pour le <ph id="ph3">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> specifies a system-defined property string and <ph id="ph2">&lt;paramref name="permission" /&gt;</ph> is not <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> spécifie une chaîne de propriété définie par le système et <ph id="ph2">&lt;paramref name="permission" /&gt;</ph> n'est pas <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>The fully qualified path that is the base directory for subdirectories where dynamic assemblies are stored.</source>
          <target state="translated">Chemin qualifié complet qui est le répertoire de base des sous-répertoires où sont stockés les assemblys dynamiques.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>Establishes the specified directory path as the base directory for subdirectories where dynamically generated files are stored and accessed.</source>
          <target state="translated">Définit le chemin de répertoire spécifié comme répertoire de base des sous-répertoires dans lesquels sont stockés les fichiers générés de manière dynamique et à partir desquels ils sont accessibles.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>This method sets the <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph> property of the internal <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> associated with this instance.</source>
          <target state="translated">Cette méthode définit le <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph> propriété interne <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> associé à cette instance.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>This method is now obsolete, and should not be used for new development.</source>
          <target state="translated">Cette méthode est désormais obsolète et ne doit pas être utilisée pour tout nouveau développement.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>The following example shows how to use the non-obsolete alternative, the <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">L’exemple suivant montre comment utiliser l’alternative non obsolète, la <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>For an explanation of this example, see the <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph> property or the <ph id="ph2">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph> property.</source>
          <target state="translated">Pour obtenir une explication de cet exemple, consultez la <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph> propriété ou le <ph id="ph2">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Security.Principal.PrincipalPolicy" /&gt;</ph> values that specifies the type of the principal object to attach to threads.</source>
          <target state="translated">L'une des valeurs de <ph id="ph1">&lt;see cref="T:System.Security.Principal.PrincipalPolicy" /&gt;</ph> qui spécifie le type de l'objet principal à joindre aux threads.</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>Specifies how principal and identity objects should be attached to a thread if the thread attempts to bind to a principal while executing in this application domain.</source>
          <target state="translated">Spécifie la façon dont les objets Principal et Identity doivent être attachés à un thread si celui-ci tente d'établir une liaison vers un principal au moment de l'exécution dans ce domaine d'application.</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>Setting this value will only be effective if you set it before using the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Définition de cette valeur sera effective que si vous définissez avant d’utiliser le <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>For example, if you set <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType&gt;</ph> to a given principal (for example, a generic principal) and then use the <ph id="ph2">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph> method to set the <ph id="ph3">&lt;xref:System.Security.Principal.PrincipalPolicy&gt;</ph> to <ph id="ph4">&lt;xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal&gt;</ph>, the current principal will remain the generic principal.</source>
          <target state="translated">Par exemple, si vous définissez <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType&gt;</ph> à une entité de sécurité donnée (par exemple, un principal générique) puis utiliser le <ph id="ph2">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph> pour définir le <ph id="ph3">&lt;xref:System.Security.Principal.PrincipalPolicy&gt;</ph> à <ph id="ph4">&lt;xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal&gt;</ph>, le principal actuel reste le principal générique.</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>The following example shows the effect on threads of using the <ph id="ph1">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph> method to change the principal policy of the application domain.</source>
          <target state="translated">L’exemple suivant montre l’effet sur les threads de l’utilisation de la <ph id="ph1">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph> méthode pour modifier la stratégie de principal du domaine d’application.</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>It also shows the effect of using the <ph id="ph1">&lt;xref:System.AppDomain.SetThreadPrincipal%2A&gt;</ph> method to change the principal that is available for attaching to threads in the application domain.</source>
          <target state="translated">Il montre également l’effet de l’utilisation de la <ph id="ph1">&lt;xref:System.AppDomain.SetThreadPrincipal%2A&gt;</ph> méthode pour modifier l’entité de sécurité qui est disponible pour attacher à des threads dans le domaine d’application.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>for ability to manipulate the principal object.</source>
          <target state="translated">pour la possibilité de manipuler l’objet principal.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>Turns on shadow copying.</source>
          <target state="translated">Active les clichés instantanés.</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>For more information on shadow copying, see <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les clichés instantanés, consultez <bpt id="p1">[</bpt>clichés instantanés d’assemblys<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>This method is now obsolete, and should not be used for new development.</source>
          <target state="translated">Cette méthode est désormais obsolète et ne doit pas être utilisée pour tout nouveau développement.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>A list of directory names, where each name is separated by a semicolon.</source>
          <target state="translated">Liste de noms de répertoires, où chaque nom est séparé par un point-virgule.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>Establishes the specified directory path as the location of assemblies to be shadow copied.</source>
          <target state="translated">Définit le chemin d’accès du répertoire spécifié comme emplacement pour les clichés instantanés des assemblys.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>By default, a shadow copy includes all assemblies found through probing.</source>
          <target state="translated">Par défaut, un cliché instantané inclut tous les assemblys trouvés par détection.</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph> method restricts the shadow copy to the assemblies in the directories specified by <ph id="ph2">`path`</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph> méthode restreint le cliché instantané aux assemblys dans les répertoires spécifiés par <ph id="ph2">`path`</ph>.</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph> method does not specify additional directories to be searched for assemblies.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph> méthode ne spécifie pas de répertoires supplémentaires dans lesquels rechercher les assemblys.</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>Assemblies to be shadow-copied must already be located in the search path, for example under <ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph>.</source>
          <target state="translated">Assemblys à cliché instantané doivent déjà se trouver dans le chemin de recherche, par exemple sous <ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph> method specifies which search paths are eligible to be shadow-copied.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph> méthode spécifie les chemins de recherche peut être cliché instantané.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>This method sets the <ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyDirectories%2A&gt;</ph> property of the internal <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> associated with this instance.</source>
          <target state="translated">Cette méthode définit le <ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyDirectories%2A&gt;</ph> propriété interne <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> associé à cette instance.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>For more information on shadow copying, see <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les clichés instantanés, consultez <bpt id="p1">[</bpt>clichés instantanés d’assemblys<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>This method is now obsolete, and should not be used for new development.</source>
          <target state="translated">Cette méthode est désormais obsolète et ne doit pas être utilisée pour tout nouveau développement.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>The principal object to attach to threads.</source>
          <target state="translated">Objet Principal à attacher aux threads.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>Sets the default principal object to be attached to threads if they attempt to bind to a principal while executing in this application domain.</source>
          <target state="translated">Définit l'objet Principal par défaut à attacher aux threads si ceux-ci tentent d'établir une liaison vers un principal au moment de l'exécution dans ce domaine d'application.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>The following example shows the effect of using the <ph id="ph1">&lt;xref:System.AppDomain.SetThreadPrincipal%2A&gt;</ph> method to change the principal that is available for attaching to threads that are executing in the application domain.</source>
          <target state="translated">L’exemple suivant montre l’effet de l’utilisation de la <ph id="ph1">&lt;xref:System.AppDomain.SetThreadPrincipal%2A&gt;</ph> méthode pour modifier l’entité de sécurité qui est disponible pour attacher à des threads qui sont exécutent dans le domaine d’application.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>It also shows the effect on threads of using the <ph id="ph1">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph> method to change the principal policy of the application domain.</source>
          <target state="translated">Il montre également l’effet sur les threads de l’utilisation de la <ph id="ph1">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph> méthode pour modifier la stratégie de principal du domaine d’application.</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source><ph id="ph1">&lt;paramref name="principal" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="principal" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>The thread principal has already been set.</source>
          <target state="translated">L'entité de sécurité du thread a déjà été définie.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>for ability to manipulate the principal object.</source>
          <target state="translated">pour la possibilité de manipuler l’objet principal.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" uid="P:System.AppDomain.SetupInformation">
          <source>Gets the application domain configuration information for this instance.</source>
          <target state="translated">Obtient les informations de configuration du domaine d'application pour cette instance.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.SetupInformation">
          <source>The application domain initialization information.</source>
          <target state="translated">Informations d'initialisation du domaine d'application.</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" uid="P:System.AppDomain.SetupInformation">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" uid="P:System.AppDomain.ShadowCopyFiles">
          <source>Gets an indication whether the application domain is configured to shadow copy files.</source>
          <target state="translated">Obtient une indication précisant si le domaine d'application est configuré pour effectuer un cliché instantané des fichiers.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ShadowCopyFiles">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the application domain is configured to shadow copy files; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le domaine d'application est configuré pour effectuer un cliché instantané des fichiers ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ShadowCopyFiles">
          <source>For more information, see <ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType&gt;</ph> and <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType&gt;</ph> et <bpt id="p1">[</bpt>clichés instantanés d’assemblys<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" uid="P:System.AppDomain.ShadowCopyFiles">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L’opération est tentée sur un domaine d’application non chargé.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Réservé à un usage ultérieur.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Doit être IID_NULL.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Tableau passé des noms à mapper.</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Compte des noms à mapper.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Contexte des paramètres régionaux dans lequel interpréter les noms.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Tableau alloué par l'appelant et recevant les ID qui correspondent aux noms.</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Mappe un jeu de noms avec un jeu correspondant d'identificateurs de dispatch.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, consultez MSDN Library.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L’accès à liaison tardive à l’aide de l’interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Informations de type à retourner.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Identificateur des paramètres régionaux pour les informations de type.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Reçoit un pointeur vers l'objet d'informations de type demandé.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Récupère les informations de type pour un objet, qui peuvent être utilisées ensuite pour obtenir les informations de type d'une interface.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, consultez MSDN Library.</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L’accès à liaison tardive à l’aide de l’interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Pointe vers un emplacement qui reçoit le nombre d'interfaces d'informations de type fourni par l'objet.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Récupère le nombre d'interfaces d'informations de type fourni par un objet (0 ou 1).</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, consultez MSDN Library.</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L’accès à liaison tardive à l’aide de l’interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifie le membre.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Réservé à un usage ultérieur.</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Doit être IID_NULL.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Contexte des paramètres régionaux dans lequel interpréter les arguments.</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Indicateurs décrivant le contexte de l'appel.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Pointeur vers une structure qui contient un tableau d’arguments, un tableau d’arguments DISPID pour les arguments nommés et le nombre d’éléments de chaque tableau.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Pointeur vers l'emplacement où le résultat doit être stocké.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Pointeur vers une structure qui contient les informations sur les exceptions.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Index du premier argument comportant une erreur.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Fournit l'accès aux propriétés et aux méthodes exposées par un objet.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Pour plus d’informations sur <ph id="ph1">`IDispatch::Invoke`</ph>, consultez MSDN Library.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L’accès à liaison tardive à l’aide de l’interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ToString">
          <source>Obtains a string representation that includes the friendly name of the application domain and any context policies.</source>
          <target state="translated">Obtient une représentation sous forme de chaîne qui inclut le nom convivial du domaine d'application et les stratégies de contexte.</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ToString">
          <source>A string formed by concatenating the literal string "Name:", the friendly name of the application domain, and either string representations of the context policies or the string "There are no context policies."</source>
          <target state="translated">Chaîne formée en concaténant la chaîne littérale « Nom : », le nom convivial du domaine d'application, et les représentations sous forme de chaîne des stratégies de contexte ou la chaîne « Aucune stratégie de contexte ».</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ToString">
          <source>The following code example displays the return value of the <ph id="ph1">&lt;xref:System.AppDomain.ToString%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant affiche la valeur de retour de la <ph id="ph1">&lt;xref:System.AppDomain.ToString%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ToString">
          <source>The application domain represented by the current <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> has been unloaded.</source>
          <target state="translated">Le domaine d'application représenté par le <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> en cours a été déchargé.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" uid="E:System.AppDomain.TypeResolve">
          <source>Occurs when the resolution of a type fails.</source>
          <target state="translated">Se produit quand la résolution d’un type échoue.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> event occurs when the common language runtime is unable to determine the assembly that can create the requested type.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> événement se produit lorsque le common language runtime ne parvient pas à déterminer l’assembly capable de créer le type demandé.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>This can occur if the type is defined in a dynamic assembly, or the type is not defined in a dynamic assembly but the runtime does not know which assembly the type is defined in.</source>
          <target state="translated">Cela peut se produire si le type est défini dans un assembly dynamique, ou le type n’est pas défini dans un assembly dynamique, mais que le runtime ne sait pas quel assembly le type est défini dans.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>The latter situation can occur when <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> is called with a type name that is not qualified with the assembly name.</source>
          <target state="translated">Dans ce dernier cas peut se produire lorsque <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> est appelée avec un nom de type qui n’est pas qualifié avec le nom de l’assembly.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>The <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> for this event can attempt to locate and create the type.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> pour cet événement peut tenter de localiser et de créer le type.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>However, the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> event does not occur if the runtime knows it is not possible to find a type in certain assemblies.</source>
          <target state="translated">Toutefois, le <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> événement ne survient pas si le runtime sait qu’il n’est pas possible de trouver un type dans certains assemblys.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>For example, this event does not occur if the type is not found in a static assembly because the runtime knows types cannot be added dynamically to static assemblies.</source>
          <target state="translated">Par exemple, cet événement n’a pas lieu si le type est introuvable dans un assembly statique, car le runtime sait types ne peuvent pas être ajoutés dynamiquement à des assemblys statiques.</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> property contains the assembly that requested the type.</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, le <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> propriété contient l’assembly qui a demandé le type.</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>For more information, see <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>To register an event handler for this event, you must have the required permissions, or a <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown.</source>
          <target state="translated">Pour inscrire un gestionnaire d’événements pour cet événement, vous devez disposer des autorisations requises, ou un <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des événements, consultez <bpt id="p1">[</bpt>gestion et déclenchement d’événements<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> event.</source>
          <target state="translated">L’exemple suivant montre comment la <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet.</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez <bpt id="p1">[</bpt>les noms d’assemblys<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" uid="E:System.AppDomain.UnhandledException">
          <source>Occurs when an exception is not caught.</source>
          <target state="translated">Se produit quand une exception n'est pas interceptée.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This event provides notification of uncaught exceptions.</source>
          <target state="translated">Cet événement fournit une notification d’exceptions non interceptées.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>It allows the application to log information about the exception before the system default handler reports the exception to the user and terminates the application.</source>
          <target state="translated">Il permet à l’application enregistrer des informations relatives à l’exception avant que le gestionnaire par défaut du système signale l’exception à l’utilisateur et met fin à l’application.</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If sufficient information about the state of the application is available, other actions may be undertaken — such as saving program data for later recovery.</source>
          <target state="translated">Si suffisamment d’informations sur l’état de l’application est disponible, les autres actions peuvent être entreprises, telles que l’enregistrement des données de programme pour une récupération ultérieure.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Caution is advised, because program data can become corrupted when exceptions are not handled.</source>
          <target state="translated">Procédez avec prudence, car les données de programme peuvent être endommagées lorsque les exceptions ne sont pas gérées.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In the .NET Framework versions 1.0 and 1.1, application termination and debugging options are reported to the user before this event is raised, rather than after.</source>
          <target state="translated">Dans les versions 1.0 et 1.1 du .NET Framework, l’arrêt de l’application et les options de débogage sont signalés à l’utilisateur avant que cet événement est déclenché, et non après.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This event can be handled in any application domain.</source>
          <target state="translated">Cet événement peut être géré dans n’importe quel domaine d’application.</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>However, the event is not necessarily raised in the application domain where the exception occurred.</source>
          <target state="translated">Toutefois, l’événement n’est pas nécessairement déclenché dans le domaine d’application où l’exception s’est produite.</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>An exception is unhandled only if the entire stack for the thread has been unwound without finding an applicable exception handler, so the first place the event can be raised is in the application domain where the thread originated.</source>
          <target state="translated">Est une exception non prise en charge uniquement si la pile entière pour le thread a été déroulée sans qu’un gestionnaire d’exceptions applicable, par conséquent, le premier emplacement dans que l’événement peut être déclenché est dans le domaine d’application d'où provient le thread.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In the .NET Framework versions 1.0 and 1.1, this event occurs only for the default application domain that is created by the system when an application is started.</source>
          <target state="translated">Dans les versions 1.0 et 1.1 du .NET Framework, cet événement se produit uniquement pour le domaine d’application par défaut qui est créé par le système lorsqu’une application est démarrée.</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If an application creates additional application domains, specifying a delegate for this event in those applications domains has no effect.</source>
          <target state="translated">Si une application crée des domaines d’application supplémentaires, en spécifiant un délégué de cet événement dans ces domaines d’application n’a aucun effet.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event is handled in the default application domain, it is raised there for any unhandled exception in any thread, no matter what application domain the thread started in.</source>
          <target state="translated">Si la <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> est géré dans le domaine d’application par défaut, il est déclenché à cet emplacement pour toute exception non gérée dans n’importe quel thread, quel que soit le domaine d’application le thread a démarré.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If the thread started in an application domain that has an event handler for <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph>, the event is raised in that application domain.</source>
          <target state="translated">Si le thread est démarré dans un domaine d’application qui a un gestionnaire d’événements <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph>, l’événement est déclenché dans ce domaine d’application.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If that application domain is not the default application domain, and there is also an event handler in the default application domain, the event is raised in both application domains.</source>
          <target state="translated">Si ce domaine d’application n’est pas le domaine d’application par défaut, et il existe également un gestionnaire d’événements dans le domaine d’application par défaut, l’événement est déclenché dans les deux domaines d’application.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>For example, suppose a thread starts in application domain "AD1", calls a method in application domain "AD2", and from there calls a method in application domain "AD3", where it throws an exception.</source>
          <target state="translated">Par exemple, supposons qu’un thread démarre dans « AD1 », domaine d’application appelle une méthode dans le domaine d’application « AD2 » et à partir de là appelle une méthode dans le domaine d’application « AD3 », où elle lève une exception.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The first application domain in which the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event can be raised is "AD1".</source>
          <target state="translated">Le premier domaine d’application dans lequel le <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> peut être déclenché est « AD1 ».</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If that application domain is not the default application domain, the event can also be raised in the default application domain.</source>
          <target state="translated">Si ce domaine d’application n’est pas le domaine d’application par défaut, l’événement peut également être déclenché dans le domaine d’application par défaut.</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The common language runtime suspends thread aborts while event handlers for the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event are executing.</source>
          <target state="translated">Le common language runtime interrompt les abandons de thread lors de gestionnaires d’événements pour le <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> événement en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If the event handler has a <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute with the appropriate flags, the event handler is treated as a constrained execution region.</source>
          <target state="translated">Si le Gestionnaire d’événements a un <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribut avec les indicateurs appropriés, le Gestionnaire d’événements est traité comme une région d’exécution limitée.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, this event is not raised for exceptions that corrupt the state of the process, such as stack overflows or access violations, unless the event handler is security-critical and has the <ph id="ph2">&lt;xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute&gt;</ph> attribute.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, cet événement n’est pas déclenché pour les exceptions qui endommagent l’état du processus, tels que les dépassements de capacité de pile ou de violations d’accès, à moins que le Gestionnaire d’événements est critique de sécurité et a la <ph id="ph2">&lt;xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute&gt;</ph> attribut.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In the .NET Framework versions 1.0 and 1.1, an unhandled exception that occurs in a thread other than the main application thread is caught by the runtime and therefore does not cause the application to terminate.</source>
          <target state="translated">Dans les versions 1.0 et 1.1 du .NET Framework, une exception non gérée se produit dans un thread autre que le thread d’application principal est interceptée par le runtime et n’entraîne donc pas l’arrêt de l’application.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Thus, it is possible for the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event to be raised without the application terminating.</source>
          <target state="translated">Par conséquent, il est possible pour le <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> événement soit déclenché sans la fin de l’application.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Starting with the .NET Framework version 2.0, this backstop for unhandled exceptions in child threads was removed, because the cumulative effect of such silent failures included performance degradation, corrupted data, and lockups, all of which were difficult to debug.</source>
          <target state="translated">À compter de .NET Framework version 2.0, cette protection pour les exceptions non gérées dans les threads enfants a été supprimée, car l’effet cumulatif de tels échecs silencieux inclus blocages, qui étaient difficiles à une dégradation des performances et des données endommagées déboguer.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>For more information, including a list of cases in which the runtime does not terminate, see <bpt id="p1">[</bpt>Exceptions in Managed Threads<ept id="p1">](~/docs/standard/threading/exceptions-in-managed-threads.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, y compris une liste de cas dans lesquels le runtime n’arrête pas, consultez <bpt id="p1">[</bpt>Exceptions dans les Threads managés<ept id="p1">](~/docs/standard/threading/exceptions-in-managed-threads.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>To register an event handler for this event, you must have the required permissions, or a <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown.</source>
          <target state="translated">Pour inscrire un gestionnaire d’événements pour cet événement, vous devez disposer des autorisations requises, ou un <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des événements, consultez <bpt id="p1">[</bpt>gestion et déclenchement d’événements<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Other Events for Unhandled Exceptions</source>
          <target state="translated">Autres événements pour les Exceptions non gérées</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>For certain application models, the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event can be preempted by other events if the unhandled exception occurs in the main application thread.</source>
          <target state="translated">Pour certains modèles d’application, le <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> événement peut être interrompu par d’autres événements si l’exception non gérée se produit dans le thread d’application principal.</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In applications that use Windows Forms, unhandled exceptions in the main application thread cause the <ph id="ph1">&lt;xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType&gt;</ph> event to be raised.</source>
          <target state="translated">Dans les applications qui utilisent des Windows Forms, exceptions non gérées dans la cause de thread d’application principal le <ph id="ph1">&lt;xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType&gt;</ph> événement soit déclenché.</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If this event is handled, the default behavior is that the unhandled exception does not terminate the application, although the application is left in an unknown state.</source>
          <target state="translated">Si cet événement est géré, le comportement par défaut est que l’exception non gérée n’arrête pas l’application, bien que l’application est laissée dans un état inconnu.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In that case, the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event is not raised.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> événement n’est pas déclenché.</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This behavior can be changed by using the application configuration file, or by using the <ph id="ph1">&lt;xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType&gt;</ph> method to change the mode to <ph id="ph2">&lt;xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType&gt;</ph> before the <ph id="ph3">&lt;xref:System.Windows.Forms.Application.ThreadException&gt;</ph> event handler is hooked up.</source>
          <target state="translated">Ce comportement peut être modifié en utilisant le fichier de configuration d’application, ou en utilisant le <ph id="ph1">&lt;xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType&gt;</ph> méthode pour modifier le mode de <ph id="ph2">&lt;xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType&gt;</ph> avant la <ph id="ph3">&lt;xref:System.Windows.Forms.Application.ThreadException&gt;</ph> Gestionnaire d’événements est rattachée.</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This applies only to the main application thread.</source>
          <target state="translated">Cela s’applique uniquement à un thread d’application principal.</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event is raised for unhandled exceptions thrown in other threads.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> événement est déclenché pour les exceptions non gérées levées dans d’autres threads.</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Starting with Microsoft Visual Studio 2005, the Visual Basic application framework provides another event for unhandled exceptions in the main application thread.</source>
          <target state="translated">À compter de Microsoft Visual Studio 2005, l’infrastructure d’application Visual Basic fournit un autre événement pour les exceptions non gérées dans le thread d’application principal.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>See the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Consultez le <ph id="ph1">&lt;xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This event has an event arguments object with the same name as the event arguments object used by <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph>, but with different properties.</source>
          <target state="translated">Cet événement a un objet avec le même nom que l’objet arguments d’événement utilisé par les arguments d’événement <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph>, mais avec des propriétés différentes.</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In particular, this event arguments object has an <ph id="ph1">&lt;xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A&gt;</ph> property that allows the application to continue running, ignoring the unhandled exception (and leaving the application in an unknown state).</source>
          <target state="translated">En particulier, cet objet arguments d’événement a un <ph id="ph1">&lt;xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A&gt;</ph> propriété qui permet à l’application à se poursuivre en cours d’exécution, en ignorant l’exception non gérée (et laissant l’application dans un état inconnu).</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In that case, the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph> event is not raised.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph> événement n’est pas déclenché.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The followingexample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event.</source>
          <target state="translated">L’exemple suivant illustre la <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>It defines an event handler, <ph id="ph1">`MyHandler`</ph>, that is invoked whenever an unhandled exception is thrown in the default application domain.</source>
          <target state="translated">Il définit un gestionnaire d’événements, <ph id="ph1">`MyHandler`</ph>, qui est appelé chaque fois qu’une exception non gérée est levée dans le domaine d’application par défaut.</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>It then throws two exceptions.</source>
          <target state="translated">Elle lève ensuite deux exceptions.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The first is handled by a <bpt id="p1">**</bpt>try/catch<ept id="p1">**</ept> block.</source>
          <target state="translated">La première est gérée par un <bpt id="p1">**</bpt>try/catch<ept id="p1">**</ept> bloc.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The second is unhandled and invokes the <ph id="ph1">`MyHandle`</ph> routine before the application terminates.</source>
          <target state="translated">La seconde n’est pas gérée et appelle le <ph id="ph1">`MyHandle`</ph> routine avant l’arrêt de l’application.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>An application domain to unload.</source>
          <target state="translated">Domaine d'application à décharger.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Unloads the specified application domain.</source>
          <target state="translated">Décharge le domaine d'application spécifié.</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>In the .NET Framework version 2.0 there is a thread dedicated to unloading application domains.</source>
          <target state="translated">Dans le .NET Framework version 2.0 est un thread dédié pour décharger des domaines d’application.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>This improves reliability, especially when the .NET Framework is hosted.</source>
          <target state="translated">Cela permet d’améliorer la fiabilité, en particulier lorsque le .NET Framework est hébergé.</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>When a thread calls <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>, the target domain is marked for unloading.</source>
          <target state="translated">Lorsqu’un thread appelle <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>, le domaine cible est marqué pour le déchargement.</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>The dedicated thread attempts to unload the domain, and all threads in the domain are aborted.</source>
          <target state="translated">Le thread dédié essaie de décharger le domaine, et tous les threads dans le domaine sont abandonnées.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>If a thread does not abort, for example because it is executing unmanaged code, or because it is executing a <ph id="ph1">`finally`</ph> block, then after a period of time a <ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph> is thrown in the thread that originally called <ph id="ph3">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>.</source>
          <target state="translated">Si un thread ne s’interrompt pas, par exemple, car il exécute du code non managé, ou parce qu’il exécute une <ph id="ph1">`finally`</ph> bloc, puis après une période de temps un <ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph> est levée dans le thread qui a appelé <ph id="ph3">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>If the thread that could not be aborted eventually ends, the target domain is not unloaded.</source>
          <target state="translated">Si le thread ne peut pas être interrompu finit par se termine, le domaine cible n’est pas déchargé.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Thus, in the .NET Framework version 2.0 <ph id="ph1">`domain`</ph> is not guaranteed to unload, because it might not be possible to terminate executing threads.</source>
          <target state="translated">Par conséquent, dans le .NET Framework version 2.0 <ph id="ph1">`domain`</ph> n’est pas garanti pour décharger, car il n’est peut-être pas possible de mettre fin à l’exécution de threads.</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>In some cases, calling <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> causes an immediate <ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph>, for example if it is called in a finalizer.</source>
          <target state="translated">Dans certains cas, l’appel <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> entraîne une exécution <ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph>, par exemple si elle est appelée dans un finaliseur.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>The threads in <ph id="ph1">`domain`</ph> are terminated using the <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> method, which throws a <ph id="ph3">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> in the thread.</source>
          <target state="translated">Les threads de <ph id="ph1">`domain`</ph> sont terminées à l’aide de la <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> méthode qui lève un <ph id="ph3">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> dans le thread.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Although the thread should terminate promptly, it can continue executing for an unpredictable amount of time in a <ph id="ph1">`finally`</ph> clause.</source>
          <target state="translated">Bien que le thread se termine rapidement, il peut continuer à exécuter pour une durée indéterminée dans un <ph id="ph1">`finally`</ph> clause.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Version Compatibility</source>
          <target state="translated">Compatibilité des versions</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>In the .NET Framework version 1.0 and 1.1 if the thread that calls <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> is running in <ph id="ph2">`domain`</ph>, another thread is started to perform the unload operation.</source>
          <target state="translated">Dans le .NET Framework version 1.0 et 1.1 si le thread qui appelle <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> est en cours d’exécution <ph id="ph2">`domain`</ph>, un autre thread est démarré pour effectuer l’opération de déchargement.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>If <ph id="ph1">`domain`</ph> cannot be unloaded, a <ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph> is thrown in that thread, not in the original thread that called <ph id="ph3">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`domain`</ph> ne peut pas être déchargé, une <ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph> est levée dans ce thread, pas dans le thread d’origine qui a appelé <ph id="ph3">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>However, if the thread that calls <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> is running outside <ph id="ph2">`domain`</ph>, that thread receives the exception.</source>
          <target state="translated">Toutefois, si le thread qui appelle <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> est en cours d’exécution en dehors de <ph id="ph2">`domain`</ph>, que le thread reçoit l’exception.</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>The following code example shows how to unload an application domain.</source>
          <target state="translated">L’exemple de code suivant montre comment décharger un domaine d’application.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source><ph id="ph1">&lt;paramref name="domain" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="domain" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source><ph id="ph1">&lt;paramref name="domain" /&gt;</ph> could not be unloaded.</source>
          <target state="translated">Le <ph id="ph1">&lt;paramref name="domain" /&gt;</ph> n'a pas pu être déchargé.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>An error occurred during the unload process.</source>
          <target state="translated">Une erreur s'est produite pendant le processus de déchargement.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>to add an event handler for this event.</source>
          <target state="translated">Pour ajouter un gestionnaire d’événements pour cet événement.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>