<Type Name="Type" FullName="System.Type">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a40925048dd06746d1e1cda2a76aa4ecaae1b916" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731513" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="09f45-101">Représente les déclarations de types : types classe, types interface, types tableau, types valeur, types énumération, paramètres de type, définitions de type générique et types génériques construits ouverts ou fermés.</span>
      <span class="sxs-lookup">
        <span data-stu-id="09f45-101">Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-102">`Type` est la racine de la <xref:System.Reflection> fonctionnalité et est le principal moyen d’accéder aux métadonnées.</span><span class="sxs-lookup"><span data-stu-id="09f45-102">`Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata.</span></span> <span data-ttu-id="09f45-103">Utilisez les membres de <xref:System.Type> pour obtenir des informations sur une déclaration de type, sur les membres d’un type (par exemple, les constructeurs, méthodes, champs, propriétés et événements d’une classe), ainsi que le module et l’assembly dans lequel la classe est déployée.</span><span class="sxs-lookup"><span data-stu-id="09f45-103">Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</span></span>  
  
 <span data-ttu-id="09f45-104">Aucune autorisation n’est requise pour utiliser la réflexion pour obtenir des informations sur les types et leurs membres, indépendamment de leurs niveaux d’accès de code.</span><span class="sxs-lookup"><span data-stu-id="09f45-104">No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</span></span> <span data-ttu-id="09f45-105">Aucune autorisation n’est requise pour le code pour utiliser la réflexion pour accéder aux membres publics ou autres membres dont les niveaux d’accès les rendre visibles pendant la compilation normale.</span><span class="sxs-lookup"><span data-stu-id="09f45-105">No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</span></span> <span data-ttu-id="09f45-106">Toutefois, votre code peut utiliser la réflexion pour accéder aux membres qui seraient normalement inaccessibles, tels que les méthodes privées ou internes ou les champs protégés d’un type de votre classe n’hérite pas, votre code doit avoir <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="09f45-106">However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="09f45-107">Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="09f45-107">See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span>  
  
 <span data-ttu-id="09f45-108">`Type` est une classe de base abstraite qui permet des implémentations multiples.</span><span class="sxs-lookup"><span data-stu-id="09f45-108">`Type` is an abstract base class that allows multiple implementations.</span></span> <span data-ttu-id="09f45-109">Le système fournit toujours la classe dérivée `RuntimeType`.</span><span class="sxs-lookup"><span data-stu-id="09f45-109">The system will always provide the derived class `RuntimeType`.</span></span> <span data-ttu-id="09f45-110">Dans la réflexion, toutes les classes commençant par le mot Runtime sont créés une seule fois par objet dans les opérations de comparaison système et la prise en charge.</span><span class="sxs-lookup"><span data-stu-id="09f45-110">In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-111">Dans les scénarios multithread, ne verrouillent pas <xref:System.Type> objets afin de synchroniser l’accès à `static` données.</span><span class="sxs-lookup"><span data-stu-id="09f45-111">In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data.</span></span> <span data-ttu-id="09f45-112">Tout autre code, sur lequel vous n’avez aucun contrôle, pourrait également verrouiller votre type de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-112">Other code, over which you have no control, might also lock your class type.</span></span> <span data-ttu-id="09f45-113">Cela peut entraîner un blocage.</span><span class="sxs-lookup"><span data-stu-id="09f45-113">This might result in a deadlock.</span></span> <span data-ttu-id="09f45-114">Au lieu de cela, synchroniser l’accès aux données statiques en verrouillant privé `static` objet.</span><span class="sxs-lookup"><span data-stu-id="09f45-114">Instead, synchronize access to static data by locking a private `static` object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-115">Une classe dérivée peut accéder à des membres protégés des classes de base du code appelant.</span><span class="sxs-lookup"><span data-stu-id="09f45-115">A derived class can access protected members of the calling code's base classes.</span></span> <span data-ttu-id="09f45-116">En outre, l’accès est autorisé pour les membres de l’assembly de l’assembly du code appelant.</span><span class="sxs-lookup"><span data-stu-id="09f45-116">Also, access is allowed to assembly members of the calling code's assembly.</span></span> <span data-ttu-id="09f45-117">En règle générale, si vous êtes autorisé à accéder dans le code à liaison anticipée, puis vous sont également autorisé à accéder dans le code à liaison tardive.</span><span class="sxs-lookup"><span data-stu-id="09f45-117">As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-118">Les interfaces qui étendent les autres interfaces n’héritent pas les méthodes définies dans les interfaces étendues.</span><span class="sxs-lookup"><span data-stu-id="09f45-118">Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</span></span>  
  
 <span data-ttu-id="09f45-119">Dans cette section :</span><span class="sxs-lookup"><span data-stu-id="09f45-119">In this section:</span></span>  
  
 <span data-ttu-id="09f45-120">[Quels types de représenter par un objet de Type ?](#WhatTypes) </span><span class="sxs-lookup"><span data-stu-id="09f45-120">[What types does a Type object represent?](#WhatTypes) </span></span>  
 <span data-ttu-id="09f45-121">[Récupération d’un objet de Type](#Retrieve) </span><span class="sxs-lookup"><span data-stu-id="09f45-121">[Retrieving a Type object](#Retrieve) </span></span>  
 [<span data-ttu-id="09f45-122">Comparaison d’égalité des objets de type</span><span class="sxs-lookup"><span data-stu-id="09f45-122">Comparing type objects for equality</span></span>](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a><span data-ttu-id="09f45-123">Quels types de représenter par un objet de Type ?</span><span class="sxs-lookup"><span data-stu-id="09f45-123">What types does a Type object represent?</span></span>  
 <span data-ttu-id="09f45-124">Cette classe est thread-safe ; plusieurs threads peuvent lire simultanément à partir d’une instance de ce type.</span><span class="sxs-lookup"><span data-stu-id="09f45-124">This class is thread safe; multiple threads can concurrently read from an instance of this type.</span></span> <span data-ttu-id="09f45-125">Une instance de la <xref:System.Type> classe peut représenter l’un des types suivants :</span><span class="sxs-lookup"><span data-stu-id="09f45-125">An instance of the <xref:System.Type> class can represent any of the following types:</span></span>  
  
-   <span data-ttu-id="09f45-126">Classes</span><span class="sxs-lookup"><span data-stu-id="09f45-126">Classes</span></span>  
  
-   <span data-ttu-id="09f45-127">Types de valeur</span><span class="sxs-lookup"><span data-stu-id="09f45-127">Value types</span></span>  
  
-   <span data-ttu-id="09f45-128">Tableaux</span><span class="sxs-lookup"><span data-stu-id="09f45-128">Arrays</span></span>  
  
-   <span data-ttu-id="09f45-129">Interfaces</span><span class="sxs-lookup"><span data-stu-id="09f45-129">Interfaces</span></span>  
  
-   <span data-ttu-id="09f45-130">Énumérations</span><span class="sxs-lookup"><span data-stu-id="09f45-130">Enumerations</span></span>  
  
-   <span data-ttu-id="09f45-131">Délégués</span><span class="sxs-lookup"><span data-stu-id="09f45-131">Delegates</span></span>  
  
-   <span data-ttu-id="09f45-132">Types génériques construits et définitions de type générique</span><span class="sxs-lookup"><span data-stu-id="09f45-132">Constructed generic types and generic type definitions</span></span>  
  
-   <span data-ttu-id="09f45-133">Arguments de type et les paramètres de type des types génériques construits, définitions de type générique et des définitions de méthode générique</span><span class="sxs-lookup"><span data-stu-id="09f45-133">Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</span></span>  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a><span data-ttu-id="09f45-134">Récupération d’un objet de Type</span><span class="sxs-lookup"><span data-stu-id="09f45-134">Retrieving a Type object</span></span>  
 <span data-ttu-id="09f45-135">Le <xref:System.Type> objet associé à un type particulier peut être obtenu de plusieurs manières :</span><span class="sxs-lookup"><span data-stu-id="09f45-135">The <xref:System.Type> object associated with a particular type can be obtained in the following ways:</span></span>  
  
-   <span data-ttu-id="09f45-136">L’instance <xref:System.Object.GetType%2A?displayProperty=nameWithType> méthode retourne un <xref:System.Type> objet qui représente le type d’une instance.</span><span class="sxs-lookup"><span data-stu-id="09f45-136">The instance <xref:System.Object.GetType%2A?displayProperty=nameWithType> method returns a <xref:System.Type> object that represents the type of an instance.</span></span> <span data-ttu-id="09f45-137">Étant donné que tous les types managés dérivent <xref:System.Object>, le <xref:System.Object.GetType%2A> méthode peut être appelée sur une instance de n’importe quel type.</span><span class="sxs-lookup"><span data-stu-id="09f45-137">Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.</span></span>  
  
     <span data-ttu-id="09f45-138">L’exemple suivant appelle la <xref:System.Object.GetType%2A?displayProperty=nameWithType> méthode pour déterminer le type d’exécution de chaque objet dans un tableau d’objets.</span><span class="sxs-lookup"><span data-stu-id="09f45-138">The following example calls the <xref:System.Object.GetType%2A?displayProperty=nameWithType> method to determine the runtime type of each object in an object array.</span></span>  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   <span data-ttu-id="09f45-139">La méthode statique <xref:System.Type.GetType%2A?displayProperty=nameWithType> méthodes retournent un <xref:System.Type> objet qui représente un type spécifié par son nom complet.</span><span class="sxs-lookup"><span data-stu-id="09f45-139">The static <xref:System.Type.GetType%2A?displayProperty=nameWithType> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name.</span></span>  
  
-   <span data-ttu-id="09f45-140">Le <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, et <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> méthodes retournent `Type` objets qui représentent les types définis dans un module.</span><span class="sxs-lookup"><span data-stu-id="09f45-140">The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> methods return `Type` objects that represent the types defined in a module.</span></span> <span data-ttu-id="09f45-141">La première méthode peut être utilisée pour obtenir un tableau de <xref:System.Type> objets pour tous les types publics et privés définis dans un module.</span><span class="sxs-lookup"><span data-stu-id="09f45-141">The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module.</span></span> <span data-ttu-id="09f45-142">(Vous pouvez obtenir une instance de `Module` via la <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> (méthode), ou via le <xref:System.Type.Module%2A?displayProperty=nameWithType> propriété.)</span><span class="sxs-lookup"><span data-stu-id="09f45-142">(You can obtain an instance of `Module` through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> method, or through the <xref:System.Type.Module%2A?displayProperty=nameWithType> property.)</span></span>  
  
-   <span data-ttu-id="09f45-143">Le <xref:System.Reflection.Assembly?displayProperty=nameWithType> objet contient un nombre de méthodes pour extraire les classes définies dans un assembly, y compris <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, et <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-143">The <xref:System.Reflection.Assembly?displayProperty=nameWithType> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="09f45-144">Le <xref:System.Type.FindInterfaces%2A> méthode retourne une liste filtrée de types d’interfaces prises en charge par un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-144">The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="09f45-145">Le <xref:System.Type.GetElementType%2A> méthode retourne un `Type` objet qui représente l’élément.</span><span class="sxs-lookup"><span data-stu-id="09f45-145">The <xref:System.Type.GetElementType%2A> method returns a `Type` object that represents the element.</span></span>  
  
-   <span data-ttu-id="09f45-146">Le <xref:System.Type.GetInterfaces%2A> et <xref:System.Type.GetInterface%2A> méthodes retournent <xref:System.Type> objets représentant les types interface pris en charge par un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-146">The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="09f45-147">Le <xref:System.Type.GetTypeArray%2A> méthode retourne un tableau de <xref:System.Type> objets représentant les types spécifiés par un ensemble arbitraire d’objets.</span><span class="sxs-lookup"><span data-stu-id="09f45-147">The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects.</span></span> <span data-ttu-id="09f45-148">Les objets sont spécifiés avec un tableau de type <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="09f45-148">The objects are specified with an array of type <xref:System.Object>.</span></span>  
  
-   <span data-ttu-id="09f45-149">Le <xref:System.Type.GetTypeFromProgID%2A> et <xref:System.Type.GetTypeFromCLSID%2A> méthodes sont fournies pour l’interopérabilité COM.</span><span class="sxs-lookup"><span data-stu-id="09f45-149">The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability.</span></span> <span data-ttu-id="09f45-150">Elles retournent un <xref:System.Type> objet qui représente le type spécifié par un `ProgID` ou `CLSID`.</span><span class="sxs-lookup"><span data-stu-id="09f45-150">They return a <xref:System.Type> object that represents the type specified by a `ProgID` or `CLSID`.</span></span>  
  
-   <span data-ttu-id="09f45-151">Le <xref:System.Type.GetTypeFromHandle%2A> méthode est fournie pour l’interopérabilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-151">The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability.</span></span> <span data-ttu-id="09f45-152">Elle retourne un `Type` objet qui représente le type spécifié par un handle de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-152">It returns a `Type` object that represents the type specified by a class handle.</span></span>  
  
-   <span data-ttu-id="09f45-153">C# `typeof` opérateur, C++ `typeid` (opérateur) et Visual Basic `GetType` opérateur obtenir la `Type` objet pour un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-153">The C# `typeof` operator, the C++ `typeid` operator, and the Visual Basic `GetType` operator obtain the `Type` object for a type.</span></span>  
  
-   <span data-ttu-id="09f45-154">Le <xref:System.Type.MakeGenericType%2A> méthode retourne un <xref:System.Type> objet représentant un type générique construit, qui est un type construit ouvert si sa <xref:System.Type.ContainsGenericParameters%2A> propriété renvoie `true`, et un fermé type créée, dans le cas contraire.</span><span class="sxs-lookup"><span data-stu-id="09f45-154">The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, and a closed constructed type otherwise.</span></span> <span data-ttu-id="09f45-155">Un type générique peut être instancié uniquement s’il est fermé.</span><span class="sxs-lookup"><span data-stu-id="09f45-155">A generic type can be instantiated only if it is closed.</span></span>  
  
-   <span data-ttu-id="09f45-156">Le <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, et <xref:System.Type.MakeByRefType%2A> méthodes retournent <xref:System.Type> les objets qui représentent, respectivement, un tableau d’un type spécifié, un pointeur vers un type spécifié et le type de paramètre de référence (`ref` en c#, `ByRef`en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-156">The <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, and <xref:System.Type.MakeByRefType%2A> methods return <xref:System.Type> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (`ref` in C#, `ByRef` in Visual Basic).</span></span>  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a><span data-ttu-id="09f45-157">Comparaison d’égalité des objets de type</span><span class="sxs-lookup"><span data-stu-id="09f45-157">Comparing type objects for equality</span></span>  
 <span data-ttu-id="09f45-158">A <xref:System.Type> objet que représente un type est unique ; autrement dit, deux <xref:System.Type> références d’objet font référence au même objet si et seulement si elles représentent le même type.</span><span class="sxs-lookup"><span data-stu-id="09f45-158">A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type.</span></span> <span data-ttu-id="09f45-159">Ainsi, pour la comparaison de <xref:System.Type> objets à l’aide de l’égalité des références.</span><span class="sxs-lookup"><span data-stu-id="09f45-159">This allows for comparison of <xref:System.Type> objects using reference equality.</span></span> <span data-ttu-id="09f45-160">L’exemple suivant compare la <xref:System.Type> objets qui représentent un nombre de valeurs entières pour déterminer s’ils sont du même type.</span><span class="sxs-lookup"><span data-stu-id="09f45-160">The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.</span></span>  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="09f45-161">L’exemple suivant montre quelques fonctionnalités représentatives de <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="09f45-161">The following  example shows a few representative features of <xref:System.Type>.</span></span> <span data-ttu-id="09f45-162">C# `typeof` (opérateur) (`GetType` opérateur en Visual Basic, `typeid` opérateur dans Visual C++) est utilisée pour obtenir un <xref:System.Type> objet représentant <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="09f45-162">The C# `typeof` operator (`GetType` operator in Visual Basic, `typeid` operator in Visual C++) is used to get a <xref:System.Type> object representing <xref:System.String>.</span></span> <span data-ttu-id="09f45-163">À partir de ce <xref:System.Type> objet, le <xref:System.Type.GetMethod%2A> méthode est utilisée pour obtenir un <xref:System.Reflection.MethodInfo> représentant le <xref:System.String.Substring%2A> surcharge qui prend un emplacement de départ et une longueur.</span><span class="sxs-lookup"><span data-stu-id="09f45-163">From this <xref:System.Type> object, the <xref:System.Type.GetMethod%2A> method is used to get a <xref:System.Reflection.MethodInfo> representing the <xref:System.String.Substring%2A> overload that takes a starting location and a length.</span></span>  
  
 <span data-ttu-id="09f45-164">Pour identifier la signature de surcharge, l’exemple de code crée un tableau temporaire contenant deux <xref:System.Type> représentant des objets `int` (`Integer` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-164">To identify the overload signature, the code example creates a temporary array containing two <xref:System.Type> objects representing `int` (`Integer` in Visual Basic).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-165">Pour être précis, le tableau contient deux références à l’instance de <xref:System.Type> qui représente `int` dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="09f45-165">To be precise, the array contains two references to the instance of <xref:System.Type> that represents `int` in the current application domain.</span></span> <span data-ttu-id="09f45-166">Pour n’importe quel type, il existe une seule instance de <xref:System.Type> par domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="09f45-166">For any type, there is only one instance of <xref:System.Type> per application domain.</span></span>  
  
 <span data-ttu-id="09f45-167">L’exemple de code utilise le <xref:System.Reflection.MethodInfo> pour appeler le <xref:System.String.Substring%2A> méthode sur la chaîne « Hello, World ! » et affiche le résultat.</span><span class="sxs-lookup"><span data-stu-id="09f45-167">The code example uses the <xref:System.Reflection.MethodInfo> to invoke the <xref:System.String.Substring%2A> method on the string "Hello, World!", and displays the result.</span></span>  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="09f45-168">Ce type est thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="09f45-168">This type is thread safe.</span>
      </span>
    </threadsafe>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="09f45-169">Lorsque vous héritez de <see langword="Type" />, vous devez substituer les membres suivants : </span>
        <span class="sxs-lookup">
          <span data-stu-id="09f45-169">When you inherit from <see langword="Type" />, you must override the following members:</span>
        </span>  
  
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <span data-ttu-id="09f45-170"><see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,</span><span class="sxs-lookup"><span data-stu-id="09f45-170"><see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,</span></span>  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-171">Initialise une nouvelle instance de la classe <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-171">Initializes a new instance of the <see cref="T:System.Type" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-172">Ce constructeur est appelé par les classes dérivées lors de la construction d’objets de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-172">This constructor is invoked by derived classes during the construction of type objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-173">Obtient le <see cref="T:System.Reflection.Assembly" /> dans lequel le type est déclaré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-173">Gets the <see cref="T:System.Reflection.Assembly" /> in which the type is declared.</span>
          </span>
          <span data-ttu-id="09f45-174">Pour les types génériques, obtient le <see cref="T:System.Reflection.Assembly" /> dans lequel le type générique est défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-174">For generic types, gets the <see cref="T:System.Reflection.Assembly" /> in which the generic type is defined.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-175">Instance de <see cref="T:System.Reflection.Assembly" /> qui décrit l'assembly contenant le type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-175">An <see cref="T:System.Reflection.Assembly" /> instance that describes the assembly containing the current type.</span>
          </span>
          <span data-ttu-id="09f45-176">Pour les types génériques, l'instance décrit l'assembly qui contient la définition de type générique, et non pas l'assembly qui crée et utilise un type construit particulier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-176">For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-177">Si le courant <xref:System.Type> objet représente un type générique construit, cette propriété retourne l’assembly qui contient la définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-177">If the current <xref:System.Type> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</span></span> <span data-ttu-id="09f45-178">Par exemple, supposons que vous créez un assembly nommé MyGenerics.dll, qui contient la définition de type générique `MyGenericStack<T>` (`MyGenericStack(Of T)` en Visual Basic, `generic<T> ref class MyGenericStack` en C++).</span><span class="sxs-lookup"><span data-stu-id="09f45-178">For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic, `generic<T> ref class MyGenericStack` in C++).</span></span> <span data-ttu-id="09f45-179">Si vous créez une instance de `MyGenericStack<int>` (`MyGenericStack(Of Integer)` en Visual Basic) dans un autre assembly, le <xref:System.Type.Assembly%2A> propriété pour le type construit retourne un <xref:System.Reflection.Assembly> objet qui représente MyGenerics.dll.</span><span class="sxs-lookup"><span data-stu-id="09f45-179">If you create an instance of `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in another assembly, the <xref:System.Type.Assembly%2A> property for the constructed type returns an <xref:System.Reflection.Assembly> object that represents MyGenerics.dll.</span></span>  
  
 <span data-ttu-id="09f45-180">De même, si le courant <xref:System.Type> objet représente un paramètre générique non assigné `T`, cette propriété retourne l’assembly qui contient le type générique qui définit `T`.</span><span class="sxs-lookup"><span data-stu-id="09f45-180">Similarly, if the current <xref:System.Type> object represents an unassigned generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
 <span data-ttu-id="09f45-181">Si le <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propriété n’est pas disponible sur une implémentation particulière de .NET, tels que .NET Core ou de la plateforme Windows universelle, utilisez le <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> propriété à la place.</span><span class="sxs-lookup"><span data-stu-id="09f45-181">If the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> property instead.</span></span>      
  
 <span data-ttu-id="09f45-182">Cette propriété est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="09f45-182">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-183">L’exemple suivant affiche le nom de l’assembly associé à la classe et le nom qualifié complet du type.</span><span class="sxs-lookup"><span data-stu-id="09f45-183">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-184">Obtient le nom qualifié d'assembly du type, y compris le nom de l'assembly à partir duquel l'objet <see cref="T:System.Type" /> a été chargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-184">Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <see cref="T:System.Type" /> object was loaded.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-185">Le nom qualifié d'assembly du <see cref="T:System.Type" />, qui inclut le nom de l'assembly à partir duquel le <see cref="T:System.Type" /> a été chargé ou <see langword="null" /> si l'instance actuelle représente un paramètre de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-185">The assembly-qualified name of the <see cref="T:System.Type" />, which includes the name of the assembly from which the <see cref="T:System.Type" /> was loaded, or <see langword="null" /> if the current instance represents a generic type parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-186">Le nom qualifié d’assembly d’un type se compose du nom de type, y compris son espace de noms, suivie par une virgule, suivie par le nom complet de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-186">The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</span></span> <span data-ttu-id="09f45-187">Le nom complet d’un assembly est obtenu à l’aide de la <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-187">The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-188">Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-188">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="09f45-189">Par exemple, « ProcessorArchitecture = msil ».</span><span class="sxs-lookup"><span data-stu-id="09f45-189">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="09f45-190">Toutefois, il n’est pas inclus dans la chaîne retournée par la <xref:System.Type.AssemblyQualifiedName%2A> propriété, pour des raisons de compatibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-190">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="09f45-191">Consultez <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-191">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="09f45-192">Tous les compilateurs qui prennent en charge le common language runtime émettent le nom simple d’une classe imbriquée et la réflexion construit un nom tronqué interrogé, conformément aux conventions suivantes.</span><span class="sxs-lookup"><span data-stu-id="09f45-192">All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
|<span data-ttu-id="09f45-193">Délimiteur</span><span class="sxs-lookup"><span data-stu-id="09f45-193">Delimiter</span></span>|<span data-ttu-id="09f45-194">Signification</span><span class="sxs-lookup"><span data-stu-id="09f45-194">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="09f45-195">Barre oblique inverse (\\)</span><span class="sxs-lookup"><span data-stu-id="09f45-195">Backslash (\\)</span></span>|<span data-ttu-id="09f45-196">Caractère d’échappement.</span><span class="sxs-lookup"><span data-stu-id="09f45-196">Escape character.</span></span>|  
|<span data-ttu-id="09f45-197">Comma (,)</span><span class="sxs-lookup"><span data-stu-id="09f45-197">Comma (,)</span></span>|<span data-ttu-id="09f45-198">Précède le nom de l’Assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-198">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="09f45-199">Signe plus (+)</span><span class="sxs-lookup"><span data-stu-id="09f45-199">Plus sign (+)</span></span>|<span data-ttu-id="09f45-200">Précède une classe imbriquée.</span><span class="sxs-lookup"><span data-stu-id="09f45-200">Precedes a nested class.</span></span>|  
|<span data-ttu-id="09f45-201">Point (.)</span><span class="sxs-lookup"><span data-stu-id="09f45-201">Period (.)</span></span>|<span data-ttu-id="09f45-202">Indique les identificateurs d’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="09f45-202">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="09f45-203">crochets ([])</span><span class="sxs-lookup"><span data-stu-id="09f45-203">Brackets ([])</span></span>|<span data-ttu-id="09f45-204">Après un nom de type, indique un tableau de ce type.</span><span class="sxs-lookup"><span data-stu-id="09f45-204">After a type name, denotes an array of that type.</span></span><br /><br /> <span data-ttu-id="09f45-205">- ou -</span><span class="sxs-lookup"><span data-stu-id="09f45-205">-or-</span></span><br /><br /> <span data-ttu-id="09f45-206">Pour un type générique, englobe la liste d’arguments de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-206">For a generic type, encloses the generic type argument list.</span></span><br /><br /> <span data-ttu-id="09f45-207">- ou -</span><span class="sxs-lookup"><span data-stu-id="09f45-207">-or-</span></span><br /><br /> <span data-ttu-id="09f45-208">Dans une liste d’arguments de type, englobe un type qualifié d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-208">Within a type argument list, encloses an assembly-qualified type.</span></span>|  
  
 <span data-ttu-id="09f45-209">Par exemple, le nom qualifié d’assembly pour une classe peut ressembler à ceci :</span><span class="sxs-lookup"><span data-stu-id="09f45-209">For example, the assembly-qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 <span data-ttu-id="09f45-210">Si l’espace de noms contenait un signe plus, par exemple TopNamespace, puis le signe plus (+) serait précédé d’un caractère d’échappement (\\) pour l’empêcher d’être interprété comme un séparateur d’imbrication.</span><span class="sxs-lookup"><span data-stu-id="09f45-210">If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="09f45-211">La réflexion émettrait cette chaîne comme suit :</span><span class="sxs-lookup"><span data-stu-id="09f45-211">Reflection would emit this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 <span data-ttu-id="09f45-212">Un « ++ » devient «\\+\\+ » et un «\\« devient »\\\\».</span><span class="sxs-lookup"><span data-stu-id="09f45-212">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="09f45-213">Ce nom qualifié peut être persistant et utilisé ultérieurement pour charger le <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="09f45-213">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="09f45-214">Pour rechercher et charger un <xref:System.Type>, utilisez <xref:System.Type.GetType%2A> avec le type de nom uniquement ou avec le nom de type qualifié d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-214">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="09f45-215"><xref:System.Type.GetType%2A> avec le type de nom uniquement recherchera le <xref:System.Type> dans l’assembly de l’appelant, puis dans l’assembly système.</span><span class="sxs-lookup"><span data-stu-id="09f45-215"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="09f45-216"><xref:System.Type.GetType%2A> avec l’assembly de nom de type qualifié recherchera le <xref:System.Type> dans n’importe quel assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-216"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="09f45-217">Noms de types peuvent inclure des caractères de fin qui indiquent des informations supplémentaires sur le type, par exemple si le type est un type référence, un type pointeur ou un type tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-217">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="09f45-218">Pour récupérer le nom de type sans ces caractères de fin, utilisez `t.GetElementType().ToString()`, où `t` est le type.</span><span class="sxs-lookup"><span data-stu-id="09f45-218">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="09f45-219">Les espaces ne sont pertinentes dans tous les composants de nom de type, à l’exception du nom de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-219">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="09f45-220">Nom de l’assembly, les espaces avant le séparateur ',', mais des espaces après le séparateur ',' sont ignorées.</span><span class="sxs-lookup"><span data-stu-id="09f45-220">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="09f45-221">Les arguments génériques de types génériques sont eux-mêmes qualifiés par le nom de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-221">Generic arguments of generic types are themselves qualified by assembly name.</span></span> <span data-ttu-id="09f45-222">Par exemple, dans le nom de type qualifié d’assembly pour `MyGenericClass<int>` (`MyGenericClass(Of Integer)` en Visual Basic), `int` est développé pour le nom de type qualifié d’assembly pour <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="09f45-222">For example, in the assembly-qualified type name for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` is expanded to the assembly-qualified type name for <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="09f45-223">Si le courant <xref:System.Type> objet représente un paramètre générique, cette propriété retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-223">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-224">L’exemple suivant affiche le nom de l’assembly associé à la classe et le nom qualifié complet du type.</span><span class="sxs-lookup"><span data-stu-id="09f45-224">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 <span data-ttu-id="09f45-225">L’exemple suivant compare les chaînes retournées par la <xref:System.Type.ToString%2A> (méthode) et le `Name`, <xref:System.Type.FullName%2A>, et <xref:System.Type.AssemblyQualifiedName%2A> propriétés.</span><span class="sxs-lookup"><span data-stu-id="09f45-225">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-226">Obtient les attributs associés à <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-226">Gets the attributes associated with the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-227">Objet <see cref="T:System.Reflection.TypeAttributes" /> qui représente l'ensemble d'attributs du <see cref="T:System.Type" />, à moins que le <see cref="T:System.Type" /> représente un paramètre de type générique, cas dans lequel la valeur est non spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-227">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />, unless the <see cref="T:System.Type" /> represents a generic type parameter, in which case the value is unspecified.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-228">Certains membres de le <xref:System.Reflection.TypeAttributes> énumération sont des masques qui représentent un groupe de valeurs.</span><span class="sxs-lookup"><span data-stu-id="09f45-228">Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values.</span></span> <span data-ttu-id="09f45-229">Chaque groupe comprend un seul membre dont la valeur sous-jacente est égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="09f45-229">Each group includes one member whose underlying value is zero.</span></span> <span data-ttu-id="09f45-230">Par exemple, la valeur sous-jacente de la <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> membre dans le <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> groupe est égal à zéro, car est le <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> membre dans le <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> groupe.</span><span class="sxs-lookup"><span data-stu-id="09f45-230">For example, the underlying value of the <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> group is zero, as is the <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> group.</span></span> <span data-ttu-id="09f45-231">Pour cette raison, vous devez utiliser le masque avant de tester ces valeurs.</span><span class="sxs-lookup"><span data-stu-id="09f45-231">Because of this, you must use the mask before testing for those values.</span></span> <span data-ttu-id="09f45-232">Cet exemple en fournit une illustration.</span><span class="sxs-lookup"><span data-stu-id="09f45-232">The example provides an illustration.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="09f45-233">La plupart des cas, les propriétés telles que <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, et <xref:System.Type.IsSpecialName%2A> sont plus faciles à utiliser que les attributs de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-233">For most purposes, properties like <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, and <xref:System.Type.IsSpecialName%2A> are easier to use than type attributes.</span></span>  
  
 <span data-ttu-id="09f45-234">Si le courant <xref:System.Type> représente un type générique construit, cette propriété retourne les attributs de la définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-234">If the current <xref:System.Type> represents a constructed generic type, this property returns the attributes of the generic type definition.</span></span> <span data-ttu-id="09f45-235">Par exemple, les attributs retournés pour `MyGenericClass<int>` (`MyGenericClass(Of Integer)` en Visual Basic) sont les attributs de `MyGenericClass<T>` (`MyGenericClass(Of T)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-235">For example, the attributes returned for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) are the attributes of `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="09f45-236">Si actuel <xref:System.Type> représente un paramètre de type générique, autrement dit, si le <xref:System.Type.IsGenericParameter%2A> propriété renvoie `true` : le <xref:System.Reflection.TypeAttributes> valeur retournée par cette propriété n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="09f45-236">If the current <xref:System.Type> represents a generic type parameter — that is, if the <xref:System.Type.IsGenericParameter%2A> property returns `true` — the <xref:System.Reflection.TypeAttributes> value returned by this property is unspecified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-237">L’option de l’exemple suivant <xref:System.Type.Attributes%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-237">The following example usesthe <xref:System.Type.Attributes%2A> property.</span></span>  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-238">Obtient le type dont le <see cref="T:System.Type" /> actuel hérite directement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-238">Gets the type from which the current <see cref="T:System.Type" /> directly inherits.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-239">
            <see cref="T:System.Type" /> dont le <see cref="T:System.Type" /> actuel hérite directement ou <see langword="null" /> si le <see langword="Type" /> actuel représente la classe <see cref="T:System.Object" /> ou une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-239">The <see cref="T:System.Type" /> from which the current <see cref="T:System.Type" /> directly inherits, or <see langword="null" /> if the current <see langword="Type" /> represents the <see cref="T:System.Object" /> class or an interface.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-240">Le type de base est le type à partir duquel le type actuel hérite directement.</span><span class="sxs-lookup"><span data-stu-id="09f45-240">The base type is the type from which the current type directly inherits.</span></span> <span data-ttu-id="09f45-241"><xref:System.Object> est le seul type qui n’a pas un type de base, par conséquent `null` est retourné en tant que type de base de <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="09f45-241"><xref:System.Object> is the only type that does not have a base type, therefore `null` is returned as the base type of <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="09f45-242">Interfaces héritent de zéro ou plusieurs interfaces de base ; Par conséquent, cette propriété retourne `null` si le `Type` objet représente une interface.</span><span class="sxs-lookup"><span data-stu-id="09f45-242">Interfaces inherit from zero or more base interfaces; therefore, this property returns `null` if the `Type` object represents an interface.</span></span> <span data-ttu-id="09f45-243">Les interfaces de base peuvent être déterminés avec <xref:System.Type.GetInterfaces%2A> ou <xref:System.Type.FindInterfaces%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-243">The base interfaces can be determined with <xref:System.Type.GetInterfaces%2A> or <xref:System.Type.FindInterfaces%2A>.</span></span>  
  
 <span data-ttu-id="09f45-244">Si le courant <xref:System.Type> représente un type générique construit, le type de base reflète les arguments génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-244">If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments.</span></span> <span data-ttu-id="09f45-245">Observez, par exemple, les déclarations suivantes :</span><span class="sxs-lookup"><span data-stu-id="09f45-245">For example, consider the following declarations:</span></span>  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="09f45-246">Pour le type construit `C<int>` (`C(Of Integer)` en Visual Basic), la <xref:System.Type.BaseType%2A> propriété renvoie `B<int>`.</span><span class="sxs-lookup"><span data-stu-id="09f45-246">For the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the <xref:System.Type.BaseType%2A> property returns `B<int>`.</span></span>  
  
 <span data-ttu-id="09f45-247">Si le courant <xref:System.Type> représente un paramètre de type d’une définition de type générique, <xref:System.Type.BaseType%2A> retourne la contrainte de classe, autrement dit, la classe que le paramètre de type doit hériter.</span><span class="sxs-lookup"><span data-stu-id="09f45-247">If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit.</span></span> <span data-ttu-id="09f45-248">S’il n’existe aucune contrainte de classe, <xref:System.Type.BaseType%2A> retourne <xref:System.Object?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-248">If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="09f45-249">Cette propriété est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="09f45-249">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-250">L’exemple suivant montre comment utiliser le <xref:System.Type.BaseType%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-250">The following example demonstrates using the <xref:System.Type.BaseType%2A> property.</span></span>  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 <span data-ttu-id="09f45-251">L’exemple suivant utilise la récursivité pour afficher la hiérarchie d’héritage complète de chaque classe trouvé dans un assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-251">The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</span></span> <span data-ttu-id="09f45-252">L’exemple définit une classe nommée `C` qui dérive d’une classe nommée `B`, qui, à son tour, dérive une classe nommée `A`.</span><span class="sxs-lookup"><span data-stu-id="09f45-252">The example defines a class named `C` that derives from a class named `B`, which, in turn, derives from a class named `A`.</span></span>  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-253">Obtient une valeur indiquant si l'objet <see cref="T:System.Type" /> actuel a des paramètres de type qui n'ont pas été remplacés par des types spécifiques.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-253">Gets a value indicating whether the current <see cref="T:System.Type" /> object has type parameters that have not been replaced by specific types.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-254">
            <see langword="true" /> si l'objet <see cref="T:System.Type" /> est lui-même un paramètre de type générique ou a des paramètres de type pour lesquels les types spécifiques n'ont pas été fournis ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-254">
              <see langword="true" /> if the <see cref="T:System.Type" /> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-255">Pour créer une instance d’un type, il ne doit exister aucune définitions de type générique ou les types construits ouverts dans les arguments de type du type lui-même, dans les types génériques englobants, ou dans tous les éléments du type.</span><span class="sxs-lookup"><span data-stu-id="09f45-255">In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</span></span> <span data-ttu-id="09f45-256">Une autre façon d’autres termes est que quand examinées de manière récursive, le type ne doit contenir aucun paramètre de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-256">Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</span></span>  
  
 <span data-ttu-id="09f45-257">Étant donné que les types peuvent être arbitrairement complexes, il est difficile de cette décision.</span><span class="sxs-lookup"><span data-stu-id="09f45-257">Since types can be arbitrarily complex, making this determination is difficult.</span></span> <span data-ttu-id="09f45-258">Pour plus de commodité et pour réduire le risque d’erreur, le <xref:System.Type.ContainsGenericParameters%2A> propriété fournit un moyen standard de faire la distinction entre les types construits fermés, ce qui peuvent être instanciées, et ouvrez construit des types, qui ne peut pas.</span><span class="sxs-lookup"><span data-stu-id="09f45-258">For convenience and to reduce the chance of error, the <xref:System.Type.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</span></span> <span data-ttu-id="09f45-259">Si le <xref:System.Type.ContainsGenericParameters%2A> propriété renvoie `true`, le type ne peut pas être instancié.</span><span class="sxs-lookup"><span data-stu-id="09f45-259">If the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, the type cannot be instantiated.</span></span>  
  
 <span data-ttu-id="09f45-260">Le <xref:System.Type.ContainsGenericParameters%2A> propriété recherche de manière récursive pour les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-260">The <xref:System.Type.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="09f45-261">Par exemple, elle retourne `true` pour un tableau dont les éléments sont de type `A<T>` (`A(Of T)` en Visual Basic), même si le tableau n’est pas lui-même générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-261">For example, it returns `true` for an array whose elements are type `A<T>` (`A(Of T)` in Visual Basic), even though the array is not itself generic.</span></span> <span data-ttu-id="09f45-262">Ceci contraste avec le comportement de la <xref:System.Type.IsGenericType%2A> propriété qui retourne `false` pour les tableaux.</span><span class="sxs-lookup"><span data-stu-id="09f45-262">Contrast this with the behavior of the <xref:System.Type.IsGenericType%2A> property, which returns `false` for arrays.</span></span>  
  
 <span data-ttu-id="09f45-263">Pour un ensemble d’exemples de classes et d’un tableau indiquant les valeurs de la <xref:System.Type.ContainsGenericParameters%2A> propriété, consultez <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-263">For a set of example classes and a table showing the values of the <xref:System.Type.ContainsGenericParameters%2A> property, see <xref:System.Type.IsGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-264">L’exemple suivant définit une classe générique avec deux paramètres de type et définit ensuite une deuxième classe générique qui dérive de la première classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-264">The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="09f45-265">Classe de base de la classe dérivée a deux arguments de type : le premier est <xref:System.Int32> et le second est un paramètre de type du type dérivé.</span><span class="sxs-lookup"><span data-stu-id="09f45-265">The derived class's base class has two type arguments: the first is <xref:System.Int32> and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="09f45-266">L’exemple affiche des informations sur ces classes génériques, y compris les positions rapportées par le <xref:System.Type.GenericParameterPosition%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-266">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-267">Obtient un <see cref="T:System.Reflection.MethodBase" /> représentant la méthode de déclaration, si le <see cref="T:System.Type" /> actuel représente un paramètre de type d'une méthode générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-267">Gets a <see cref="T:System.Reflection.MethodBase" /> that represents the declaring method, if the current <see cref="T:System.Type" /> represents a type parameter of a generic method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-268">Si le <see cref="T:System.Type" /> actuel représente un paramètre de type d'une méthode générique, <see cref="T:System.Reflection.MethodBase" /> qui représente la méthode de déclaration ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-268">If the current <see cref="T:System.Type" /> represents a type parameter of a generic method, a <see cref="T:System.Reflection.MethodBase" /> that represents declaring method; otherwise, <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-269">La méthode de déclaration est une définition de méthode générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-269">The declaring method is a generic method definition.</span></span> <span data-ttu-id="09f45-270">Autrement dit, si <xref:System.Type.DeclaringMethod%2A> ne retourne pas `null`, puis `DeclaringMethod.IsGenericMethodDefinition` retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-270">That is, if <xref:System.Type.DeclaringMethod%2A> does not return `null`, then `DeclaringMethod.IsGenericMethodDefinition` returns `true`.</span></span>  
  
 <span data-ttu-id="09f45-271">Le <xref:System.Type.DeclaringType%2A> et <xref:System.Type.DeclaringMethod%2A> identifient les propriétés de la définition de type générique ou la définition de méthode générique dans laquelle le paramètre de type générique a été initialement défini :</span><span class="sxs-lookup"><span data-stu-id="09f45-271">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="09f45-272">Si le <xref:System.Type.DeclaringMethod%2A> propriété retourne un <xref:System.Reflection.MethodInfo>, qui <xref:System.Reflection.MethodInfo> représente une définition de méthode générique et en cours <xref:System.Type> objet représente un paramètre de type de cette définition de méthode générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-272">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="09f45-273">Si le <xref:System.Type.DeclaringMethod%2A> propriété renvoie `null`, puis le <xref:System.Type.DeclaringType%2A> propriété retourne toujours un <xref:System.Type> objet représentant une définition de type générique et en cours <xref:System.Type> objet représente un paramètre de type du type générique définition.</span><span class="sxs-lookup"><span data-stu-id="09f45-273">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="09f45-274">Mise en route le <xref:System.Type.DeclaringMethod%2A> propriété sur un type dont <xref:System.Type.IsGenericParameter%2A> propriété `false` lève une <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="09f45-274">Getting the <xref:System.Type.DeclaringMethod%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="09f45-275">Le <xref:System.Reflection.MethodBase> qui est retourné par la <xref:System.Type.DeclaringMethod%2A> propriété est un <xref:System.Reflection.MethodInfo> dans le cas d’une méthode générique, ou un <xref:System.Reflection.ConstructorInfo> dans le cas d’un constructeur générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-275">The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-276">Dans le .NET Framework version 2.0, les constructeurs génériques ne sont pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="09f45-276">In the .NET Framework version 2.0, generic constructors are not supported.</span></span>  
  
 <span data-ttu-id="09f45-277">Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-277">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-278">L’exemple de code suivant définit une classe qui possède une méthode générique, assigne un argument de type à la méthode et appelle la méthode générique construite résultante.</span><span class="sxs-lookup"><span data-stu-id="09f45-278">The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</span></span> <span data-ttu-id="09f45-279">Elle affiche également des informations sur la définition de méthode générique et la méthode construite.</span><span class="sxs-lookup"><span data-stu-id="09f45-279">It also displays information about the generic method definition and the constructed method.</span></span> <span data-ttu-id="09f45-280">Lors de l’affichage des informations sur les paramètres de type de la définition de méthode générique, dans le `DisplayGenericMethodInfo` (méthode), l’exemple de code affiche la valeur de la <xref:System.Type.DeclaringMethod%2A> propriété pour le paramètre de type générique de la méthode.</span><span class="sxs-lookup"><span data-stu-id="09f45-280">When displaying information about the type parameters of the generic method definition, in the `DisplayGenericMethodInfo` method, the example code shows the value of the <xref:System.Type.DeclaringMethod%2A> property for the method's generic type parameter.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-281">Obtient le type qui déclare le type imbriqué ou paramètre de type générique actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-281">Gets the type that declares the current nested type or generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-282">Objet <see cref="T:System.Type" /> représentant le type englobant, si le type actuel est un type imbriqué ; ou définition du type générique, si le type actuel est un paramètre de type d'un type générique ; ou type qui déclare la méthode générique, si le type actuel est un paramètre de type d'une méthode générique ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-282">A <see cref="T:System.Type" /> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-283">Si le courant <xref:System.Type> objet représente un paramètre de type d’un type générique, cette propriété retourne la définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-283">If the current <xref:System.Type> object represents a type parameter of a generic type, this property returns the generic type definition.</span></span>  
  
 <span data-ttu-id="09f45-284">Si le courant <xref:System.Type> objet représente un paramètre de type d’une méthode générique, cette propriété retourne le type qui contient la définition de méthode générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-284">If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</span></span> <span data-ttu-id="09f45-285">Si le type est générique, la définition de type générique est retournée.</span><span class="sxs-lookup"><span data-stu-id="09f45-285">If the type is generic, the generic type definition is returned.</span></span> <span data-ttu-id="09f45-286">Autrement dit, le code suivant retourne la définition de type générique de la <xref:System.Collections.Generic.List%601> classe générique qui contient le <xref:System.Collections.Generic.List%601.ConvertAll%2A> méthode générique :</span><span class="sxs-lookup"><span data-stu-id="09f45-286">That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:</span></span>  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="09f45-287">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, la <xref:System.Type.DeclaringType%2A> et <xref:System.Type.DeclaringMethod%2A> propriétés identifient la définition de type générique ou la définition de méthode générique où la paramètre de type générique a été initialement définie :</span><span class="sxs-lookup"><span data-stu-id="09f45-287">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, the <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="09f45-288">Si le <xref:System.Type.DeclaringMethod%2A> propriété retourne un <xref:System.Reflection.MethodInfo>, qui <xref:System.Reflection.MethodInfo> représente une définition de méthode générique et en cours <xref:System.Type> objet représente un paramètre de type de cette définition de méthode générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-288">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="09f45-289">Si le <xref:System.Type.DeclaringMethod%2A> propriété renvoie `null`, puis le <xref:System.Type.DeclaringType%2A> propriété retourne toujours un <xref:System.Type> objet représentant une définition de type générique et en cours <xref:System.Type> objet représente un paramètre de type du type générique définition.</span><span class="sxs-lookup"><span data-stu-id="09f45-289">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="09f45-290">Mise en route le <xref:System.Type.DeclaringType%2A> propriété sur un type dont <xref:System.Type.IsGenericParameter%2A> propriété `false` lève une <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="09f45-290">Getting the <xref:System.Type.DeclaringType%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-291">Cet exemple affiche le type de déclaration d’une méthode dans une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="09f45-291">This example displays the declaring type of a method in a derived class.</span></span>  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-292">Obtient une référence au binder par défaut, qui implémente les règles internes pour la sélection des membres appropriés appelés par <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-292">Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-293">Référence au binder par défaut utilisé par le système.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-293">A reference to the default binder used by the system.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-294">Le binder par défaut fourni avec le common language runtime est applicable dans toutes les cas plus spécifiques.</span><span class="sxs-lookup"><span data-stu-id="09f45-294">The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</span></span> <span data-ttu-id="09f45-295">Si vous avez besoin d’un classeur qui applique des règles différentes de celles du binder par défaut fournie, qui définissent un type dérivé le <xref:System.Reflection.Binder> classe et passez une instance de ce type à l’aide de la `binder` paramètre de l’un de la <xref:System.Type.InvokeMember%2A> surcharges.</span><span class="sxs-lookup"><span data-stu-id="09f45-295">If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the `binder` parameter of one of the <xref:System.Type.InvokeMember%2A> overloads.</span></span>  
  
 <span data-ttu-id="09f45-296">La réflexion modélise les règles d’accessibilité du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-296">Reflection models the accessibility rules of the common type system.</span></span> <span data-ttu-id="09f45-297">Par exemple, si l’appelant est dans le même assembly, l’appelant ne doit-elle pas des autorisations spéciales pour les membres internes.</span><span class="sxs-lookup"><span data-stu-id="09f45-297">For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</span></span> <span data-ttu-id="09f45-298">Sinon, l’appelant doit <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="09f45-298">Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="09f45-299">Cela est cohérent avec la recherche de membres protégés, privés et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="09f45-299">This is consistent with lookup of members that are protected, private, and so on.</span></span>  
  
 <span data-ttu-id="09f45-300">Le principe est que <xref:System.Reflection.Binder.ChangeType%2A> doit effectuer que des conversions étendues, qui ne perdent jamais de données.</span><span class="sxs-lookup"><span data-stu-id="09f45-300">The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data.</span></span> <span data-ttu-id="09f45-301">La conversion de valeur qui est un entier signé 32 bits à une valeur qui est un entier signé 64 bits est un exemple de conversion étendue.</span><span class="sxs-lookup"><span data-stu-id="09f45-301">An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</span></span> <span data-ttu-id="09f45-302">Elle se distingue d’une conversion restrictive, ce qui peut perdre des données.</span><span class="sxs-lookup"><span data-stu-id="09f45-302">This is distinguished from a narrowing conversion, which may lose data.</span></span> <span data-ttu-id="09f45-303">Un exemple d’une conversion restrictive convertit un entier signé 64 bits à un entier signé 32 bits.</span><span class="sxs-lookup"><span data-stu-id="09f45-303">An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</span></span>  
  
 <span data-ttu-id="09f45-304">Le tableau suivant répertorie les conversions prises en charge par le binder par défaut.</span><span class="sxs-lookup"><span data-stu-id="09f45-304">The following table lists the conversions supported by the default binder.</span></span>  
  
|<span data-ttu-id="09f45-305">Type de source</span><span class="sxs-lookup"><span data-stu-id="09f45-305">Source Type</span></span>|<span data-ttu-id="09f45-306">Type de cible</span><span class="sxs-lookup"><span data-stu-id="09f45-306">Target Type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="09f45-307">Tout type</span><span class="sxs-lookup"><span data-stu-id="09f45-307">Any type</span></span>|<span data-ttu-id="09f45-308">Son type de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-308">Its base type.</span></span>|  
|<span data-ttu-id="09f45-309">Tout type</span><span class="sxs-lookup"><span data-stu-id="09f45-309">Any type</span></span>|<span data-ttu-id="09f45-310">L’interface qu’elle implémente.</span><span class="sxs-lookup"><span data-stu-id="09f45-310">The interface it implements.</span></span>|  
|<span data-ttu-id="09f45-311">Char</span><span class="sxs-lookup"><span data-stu-id="09f45-311">Char</span></span>|<span data-ttu-id="09f45-312">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="09f45-312">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="09f45-313">Byte</span><span class="sxs-lookup"><span data-stu-id="09f45-313">Byte</span></span>|<span data-ttu-id="09f45-314">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="09f45-314">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="09f45-315">SByte</span><span class="sxs-lookup"><span data-stu-id="09f45-315">SByte</span></span>|<span data-ttu-id="09f45-316">Int16, Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="09f45-316">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="09f45-317">UInt16</span><span class="sxs-lookup"><span data-stu-id="09f45-317">UInt16</span></span>|<span data-ttu-id="09f45-318">UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="09f45-318">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="09f45-319">Int16</span><span class="sxs-lookup"><span data-stu-id="09f45-319">Int16</span></span>|<span data-ttu-id="09f45-320">Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="09f45-320">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="09f45-321">UInt32</span><span class="sxs-lookup"><span data-stu-id="09f45-321">UInt32</span></span>|<span data-ttu-id="09f45-322">UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="09f45-322">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="09f45-323">Int32</span><span class="sxs-lookup"><span data-stu-id="09f45-323">Int32</span></span>|<span data-ttu-id="09f45-324">Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="09f45-324">Int64, Single, Double</span></span>|  
|<span data-ttu-id="09f45-325">UInt64</span><span class="sxs-lookup"><span data-stu-id="09f45-325">UInt64</span></span>|<span data-ttu-id="09f45-326">Single, Double</span><span class="sxs-lookup"><span data-stu-id="09f45-326">Single, Double</span></span>|  
|<span data-ttu-id="09f45-327">Int64</span><span class="sxs-lookup"><span data-stu-id="09f45-327">Int64</span></span>|<span data-ttu-id="09f45-328">Single, Double</span><span class="sxs-lookup"><span data-stu-id="09f45-328">Single, Double</span></span>|  
|<span data-ttu-id="09f45-329">Single</span><span class="sxs-lookup"><span data-stu-id="09f45-329">Single</span></span>|<span data-ttu-id="09f45-330">Double</span><span class="sxs-lookup"><span data-stu-id="09f45-330">Double</span></span>|  
|<span data-ttu-id="09f45-331">Sans référence</span><span class="sxs-lookup"><span data-stu-id="09f45-331">Non-reference</span></span>|<span data-ttu-id="09f45-332">Par référence.</span><span class="sxs-lookup"><span data-stu-id="09f45-332">By-reference.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="09f45-333">L’exemple suivant obtient le binder par défaut à partir de la `DefaultBinder` propriété et appelle un membre de MyClass en passant la `DefaultBinder` valeur en tant que paramètre à <xref:System.Type.InvokeMember%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-333">The following example gets the default binder from the `DefaultBinder` property, and invokes a member of MyClass by passing the `DefaultBinder` value as a parameter to <xref:System.Type.InvokeMember%2A>.</span></span>  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-334">Sépare les noms dans l'espace de noms de <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-334">Separates names in the namespace of the <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="09f45-335">Ce champ est en lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-335">This field is read-only.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-336">Représente un tableau vide du type <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-336">Represents an empty array of type <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="09f45-337">Ce champ est en lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-337">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="09f45-338">Montre l’exemple de code suit le `EmptyTypes` champ utilisé dans un de la `GetConstructor` méthodes pour obtenir un constructeur qui ne prend aucun paramètre.</span><span class="sxs-lookup"><span data-stu-id="09f45-338">The following code example shows the `EmptyTypes` field used in one of the `GetConstructor` methods to get a constructor that takes no parameters.</span></span>  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-339">Détermine si le type de système sous-jacent du <see cref="T:System.Type" /> actuel est identique au type de système sous-jacent du <see cref="T:System.Object" /> ou <see cref="T:System.Type" /> spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-339">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Object" /> or <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="09f45-340">Objet dont le type de système sous-jacent doit être comparé au type de système sous-jacent du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-340">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="09f45-341">Pour que la comparaison puisse être effectuée, <c>o</c> doit pouvoir être casté ou converti en un objet de type <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-341">For the comparison to succeed, <c>o</c> must be able to be cast or converted to an object of type   <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-342">Détermine si le type de système sous-jacent de l’objet <see cref="T:System.Type" /> actuel est identique au type de système sous-jacent du <see cref="T:System.Object" /> spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-342">Determines if the underlying system type of the current <see cref="T:System.Type" /> object is the same as the underlying system type of the specified <see cref="T:System.Object" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-343">
            <see langword="true" /> si le type de système sous-jacent de <paramref name="o" /> est identique au type de système sous-jacent du <see cref="T:System.Type" /> en cours ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-343">
              <see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="09f45-344">Cette méthode retourne également <see langword="false" /> si :</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-344">This method also returns <see langword="false" /> if: .</span>
          </span>  
  
-   <span data-ttu-id="09f45-345"><paramref name="o" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="09f45-345"><paramref name="o" /> is <see langword="null" />.</span></span>  
  
-   <span data-ttu-id="09f45-346"><paramref name="o" /> ne peut pas être casté ou converti en un objet <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="09f45-346"><paramref name="o" /> cannot be cast or converted to a <see cref="T:System.Type" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-347">Cette méthode se substitue à <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-347">This method overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09f45-348">Il convertit `o` à un objet de type <xref:System.Type> et appelle le <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-348">It casts `o` to an object of type <xref:System.Type> and calls the <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-349">L’exemple suivant utilise <xref:System.Type.Equals%28System.Object%29> pour comparer différentes <xref:System.Type> avec différentes instances de l’objet <xref:System.Object> instances.</span><span class="sxs-lookup"><span data-stu-id="09f45-349">The following example uses <xref:System.Type.Equals%28System.Object%29> to compare various <xref:System.Type> object instances with various <xref:System.Object> instances.</span></span>  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 <span data-ttu-id="09f45-350">Deux choses sont particulièrement important de noter à propos de l’exemple :</span><span class="sxs-lookup"><span data-stu-id="09f45-350">Two things are particularly worth noting about the example:</span></span>  
  
-   <span data-ttu-id="09f45-351">La comparaison d’un <xref:System.Type> objet qui représente un entier avec un <xref:System.Reflection.TypeInfo> objet qui représente un entier en retour `true` car <xref:System.Reflection.TypeInfo> est dérivée de <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="09f45-351">The comparison of a <xref:System.Type> object that represents an integer with a <xref:System.Reflection.TypeInfo> object that represents an integer return `true` because <xref:System.Reflection.TypeInfo> is derived from <xref:System.Type>.</span></span>  
  
-   <span data-ttu-id="09f45-352">La comparaison d’un <xref:System.Type> objet qui représente un <xref:System.Collections.Generic.IList%601> objet (un type générique ouvert) avec un `List(Of String)` (un type générique fermé) renvoie `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-352">The comparison of a  <xref:System.Type> object that represents a <xref:System.Collections.Generic.IList%601> object (an open generic type) with a `List(Of String)` object (a closed generic type) returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="09f45-353">Objet dont le type de système sous-jacent doit être comparé au type de système sous-jacent du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-353">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-354">Détermine si le type de système sous-jacent du <see cref="T:System.Type" /> actuel est identique au type de système sous-jacent du <see cref="T:System.Type" /> spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-354">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-355">
            <see langword="true" /> si le type de système sous-jacent de <paramref name="o" /> est identique au type de système sous-jacent du <see cref="T:System.Type" /> en cours ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-355">
              <see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="09f45-356">L’exemple suivant utilise `Equals` pour comparer deux types.</span><span class="sxs-lookup"><span data-stu-id="09f45-356">The following example uses `Equals` to compare two types.</span></span>  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-357">Représente le filtre de membres utilisé avec les attributs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-357">Represents the member filter used on attributes.</span>
          </span>
          <span data-ttu-id="09f45-358">Ce champ est en lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-358">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-359">Ce champ conserve une référence au délégué utilisé par le <xref:System.Type.FindMembers%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-359">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="09f45-360">La méthode encapsulée par ce délégué prend deux paramètres : le premier est un <xref:System.Reflection.MemberInfo> objet et le second est un `Object`.</span><span class="sxs-lookup"><span data-stu-id="09f45-360">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="09f45-361">La méthode détermine si le `MemberInfo` objet correspond aux critères spécifiés par le `Object`.</span><span class="sxs-lookup"><span data-stu-id="09f45-361">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="09f45-362">Le `Object` peuvent être affectés à la valeur de l’un des champs sur les classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, ou <xref:System.Reflection.MethodImplAttributes>.</span><span class="sxs-lookup"><span data-stu-id="09f45-362">The `Object` may be assigned the value of any one of the fields on the classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes>.</span></span>  
  
 <span data-ttu-id="09f45-363">Par exemple, le `Object` peut avoir la valeur d’un champ de `FieldAttributes` comme Public.</span><span class="sxs-lookup"><span data-stu-id="09f45-363">For example, the `Object` can be assigned the value of a field from `FieldAttributes` such as Public.</span></span> <span data-ttu-id="09f45-364">Dans ce cas, lorsque le `FilterAttribute` délégué est appelé, elle retournera `true` uniquement si la méthode représentée par le `MemberInfo` objet est décoré avec l’attribut de champ public dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="09f45-364">In that case, when the `FilterAttribute` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object is decorated with the public field attribute in metadata.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-365">L’exemple suivant obtient la `FilterAttribute` délégué, il passe en tant que paramètre à la <xref:System.Type.FindMembers%2A> (méthode) et affiche les membres spécifiés et leurs attributs.</span><span class="sxs-lookup"><span data-stu-id="09f45-365">The following example gets the `FilterAttribute` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the specified members and their attributes.</span></span>  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-366">Représente le filtre de membres, avec respect de la casse, utilisé sur les noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-366">Represents the case-sensitive member filter used on names.</span>
          </span>
          <span data-ttu-id="09f45-367">Ce champ est en lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-367">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-368">Ce champ conserve une référence au délégué utilisé par le <xref:System.Type.FindMembers%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-368">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="09f45-369">La méthode encapsulée par ce délégué prend deux paramètres : le premier est un <xref:System.Reflection.MemberInfo> objet et le second est un `Object`.</span><span class="sxs-lookup"><span data-stu-id="09f45-369">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="09f45-370">La méthode détermine si le `MemberInfo` objet correspond aux critères spécifiés par le `Object`.</span><span class="sxs-lookup"><span data-stu-id="09f45-370">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="09f45-371">Le `Object` est affectée à une valeur de chaîne, ce qui peut se terminer par un « \* » caractère générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-371">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="09f45-372">Seule fin chaîne génériques est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="09f45-372">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="09f45-373">Par exemple, le `Object` peut avoir la valeur « Octets \* ».</span><span class="sxs-lookup"><span data-stu-id="09f45-373">For example, the `Object` may be assigned the value "Byte\*".</span></span> <span data-ttu-id="09f45-374">Dans ce cas, lorsque le `FilterName` délégué est appelé, elle retournera `true` uniquement si la méthode représentée par le `MemberInfo` objet a un nom qui commence par « Byte ».</span><span class="sxs-lookup"><span data-stu-id="09f45-374">In that case, when the `FilterName` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object has a name that begins with "Byte".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-375">L’exemple de code suivant obtient les méthodes associées défini par l’utilisateur `Application` type.</span><span class="sxs-lookup"><span data-stu-id="09f45-375">The following code example gets the methods associated with the user-defined `Application` type.</span></span>  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-376">Représente le filtre de membres, sans respect de la casse, utilisé sur les noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-376">Represents the case-insensitive member filter used on names.</span>
          </span>
          <span data-ttu-id="09f45-377">Ce champ est en lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-377">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-378">Ce champ conserve une référence au délégué utilisé par le <xref:System.Type.FindMembers%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-378">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="09f45-379">La méthode encapsulée par ce délégué prend deux paramètres : le premier est un <xref:System.Reflection.MemberInfo> objet et le second est un `Object`.</span><span class="sxs-lookup"><span data-stu-id="09f45-379">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="09f45-380">La méthode détermine si le `MemberInfo` objet correspond aux critères spécifiés par le `Object`.</span><span class="sxs-lookup"><span data-stu-id="09f45-380">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="09f45-381">Le `Object` est affectée à une valeur de chaîne, ce qui peut se terminer par un « \* » caractère générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-381">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="09f45-382">Seule fin chaîne génériques est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="09f45-382">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="09f45-383">Par exemple, le `Object` peut avoir la valeur « Octets \* ».</span><span class="sxs-lookup"><span data-stu-id="09f45-383">For example, the `Object` may be assigned the value "ByTe\*".</span></span> <span data-ttu-id="09f45-384">Dans ce cas, lorsque le `FilterName` délégué est appelé, il retourne true uniquement si la méthode représentée par le `MemberInfo` objet a un nom qui commence par « octets », indépendamment de la casse.</span><span class="sxs-lookup"><span data-stu-id="09f45-384">In that case, when the `FilterName` delegate is invoked, it will return true only if the method represented by the `MemberInfo` object has a name that begins with "byte", ignoring case.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-385">L’exemple suivant obtient la `MemberFilter` délégué, il passe en tant que paramètre à la <xref:System.Type.FindMembers%2A> (méthode) et affiche les méthodes et leurs attributs de la `String` classe qui commencent par la lettre « c », en ignorant la casse.</span><span class="sxs-lookup"><span data-stu-id="09f45-385">The following example gets the `MemberFilter` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the methods and their attributes of the `String` class that begin with the letter "c", disregarding the case.</span></span>  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">
          <span data-ttu-id="09f45-386">Délégué qui compare les interfaces à <c>filterCriteria</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-386">The delegate that compares the interfaces against <c>filterCriteria</c>.</span>
          </span>
        </param>
        <param name="filterCriteria">
          <span data-ttu-id="09f45-387">Critère de recherche qui détermine si une interface doit être incluse dans le tableau retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-387">The search criteria that determines whether an interface should be included in the returned array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-388">Retourne un tableau d'objets <see cref="T:System.Type" /> représentant une liste filtrée d'interfaces implémentées ou héritées par le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-388">Returns an array of <see cref="T:System.Type" /> objects representing a filtered list of interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-389">Un tableau d'objets <see cref="T:System.Type" /> qui représente une liste filtrée des interfaces implémentées ou héritées par le <see cref="T:System.Type" /> actuel ou un tableau vide de type <see cref="T:System.Type" /> si aucune interface correspondant au filtre n'est implémentée ou héritée par le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-389">An array of <see cref="T:System.Type" /> objects representing a filtered list of the interfaces implemented or inherited by the current <see cref="T:System.Type" />, or an empty array of type <see cref="T:System.Type" /> if no interfaces matching the filter are implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-390">Cette méthode peut être substituée par une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="09f45-390">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="09f45-391">Le <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> et <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> délégués fournis par le <xref:System.Reflection.Module?displayProperty=nameWithType> classe peut également être utilisée, à la place du <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> déléguer.</span><span class="sxs-lookup"><span data-stu-id="09f45-391">The <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> and <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegates supplied by the <xref:System.Reflection.Module?displayProperty=nameWithType> class may also be used, in lieu of the <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegate.</span></span>  
  
 <span data-ttu-id="09f45-392">Toutes les interfaces implémentées par cette classe sont considérées comme lors de la recherche, si déclaré par une classe de base ou cette classe elle-même.</span><span class="sxs-lookup"><span data-stu-id="09f45-392">All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</span></span>  
  
 <span data-ttu-id="09f45-393">Cette méthode recherche dans la hiérarchie de classe de base, retournant chacune des interfaces correspondantes de chacune des classes implémente ainsi que toutes les correspondances des interfaces chacun de ces implémente les interfaces (autrement dit, la fermeture transitive des interfaces correspondantes est retournée).</span><span class="sxs-lookup"><span data-stu-id="09f45-393">This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</span></span> <span data-ttu-id="09f45-394">Aucune interface double n’est retournés.</span><span class="sxs-lookup"><span data-stu-id="09f45-394">No duplicate interfaces are returned.</span></span>  
  
 <span data-ttu-id="09f45-395">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, <xref:System.Type.FindInterfaces%2A> recherche toutes les interfaces déclarées dans les contraintes sur le paramètre de type, et toutes les interfaces héritent via les interfaces déclarées dans les contraintes.</span><span class="sxs-lookup"><span data-stu-id="09f45-395">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</span></span> <span data-ttu-id="09f45-396">Si le courant <xref:System.Type> représente un argument de type d’un type générique, <xref:System.Type.FindInterfaces%2A> recherche toutes les interfaces implémentées par le type, qu’ils correspondent aux contraintes ou non.</span><span class="sxs-lookup"><span data-stu-id="09f45-396">If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-397"><xref:System.Type.FindInterfaces%2A> peut retourner des interfaces génériques, même sur des types qui ne sont pas génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-397"><xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic.</span></span> <span data-ttu-id="09f45-398">Par exemple, un type non générique peut implémenter `IEnumerable<int>` (`IEnumerable(Of Integer)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-398">For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-399">L’exemple suivant recherche l’interface spécifiée implémentée ou héritée par le type spécifié, puis affiche les noms d’interface.</span><span class="sxs-lookup"><span data-stu-id="09f45-399">The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</span></span>  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-400">
            <paramref name="filter" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-400">
              <paramref name="filter" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="09f45-401">Un initialiseur de classe est appelé et lève une exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-401">A static initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">
          <span data-ttu-id="09f45-402">Objet qui indique le type du membre à rechercher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-402">An object that indicates the type of member to search for.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-403">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-403">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-404">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-404">-or-</span>
          </span>
          <span data-ttu-id="09f45-405">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-405">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="filter">
          <span data-ttu-id="09f45-406">Délégué qui effectue les comparaisons, retournant <see langword="true" /> si le membre en cours d’examen correspond à <c>filterCriteria</c> et <see langword="false" /> dans le cas contraire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-406">The delegate that does the comparisons, returning <see langword="true" /> if the member currently being inspected matches the <c>filterCriteria</c> and <see langword="false" /> otherwise.</span>
          </span>
          <span data-ttu-id="09f45-407">Vous pouvez utiliser les délégués <see langword="FilterAttribute" />, <see langword="FilterName" /> et <see langword="FilterNameIgnoreCase" /> fournis par cette classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-407">You can use the <see langword="FilterAttribute" />, <see langword="FilterName" />, and <see langword="FilterNameIgnoreCase" /> delegates supplied by this class.</span>
          </span>
          <span data-ttu-id="09f45-408">Le premier délégué utilise les champs de <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> et <see langword="MethodImplAttributes" /> comme critère de recherche et les deux autres utilisent les objets <see langword="String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-408">The first uses the fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> as search criteria, and the other two delegates use <see langword="String" /> objects as the search criteria.</span>
          </span>
        </param>
        <param name="filterCriteria">
          <span data-ttu-id="09f45-409">Critère de recherche qui détermine si un membre est retourné dans le tableau d'objets <see langword="MemberInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-409">The search criteria that determines whether a member is returned in the array of <see langword="MemberInfo" /> objects.</span>
          </span>
          <span data-ttu-id="09f45-410">Les champs de <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> et <see langword="MethodImplAttributes" /> peuvent être utilisés conjointement au délégué <see langword="FilterAttribute" /> fourni par cette classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-410">The fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> can be used in conjunction with the <see langword="FilterAttribute" /> delegate supplied by this class.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-411">Retourne un tableau filtré d'objets <see cref="T:System.Reflection.MemberInfo" /> du type du membre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-411">Returns a filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-412">Tableau filtré d'objets <see cref="T:System.Reflection.MemberInfo" /> du type du membre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-412">A filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span>
          </span>
          <span data-ttu-id="09f45-413">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-413">-or-</span>
          </span>
          <span data-ttu-id="09f45-414">Tableau vide de type <see cref="T:System.Reflection.MemberInfo" />, si le <see cref="T:System.Type" /> actuel n'a pas de membres de type <paramref name="memberType" /> qui correspondent aux critères de filtre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-414">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have members of type <paramref name="memberType" /> that match the filter criteria.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-415">Cette méthode peut être substituée par une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="09f45-415">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="09f45-416">Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="09f45-416">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="09f45-417">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-417">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-418">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-418">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-419">Spécifiez `BindingFlags.Instance` pour inclure les membres d’instance dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-419">Specify `BindingFlags.Instance` to include instance members in the search.</span></span>  
  
-   <span data-ttu-id="09f45-420">Spécifiez `BindingFlags.Static` pour inclure les membres statiques dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-420">Specify `BindingFlags.Static` to include static members in the search.</span></span>  
  
-   <span data-ttu-id="09f45-421">Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-421">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="09f45-422">Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-422">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
 <span data-ttu-id="09f45-423">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-423">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-424">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-424">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-425">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-425">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-426">Les valeurs valides pour <xref:System.Type.MemberType%2A> sont définis dans <xref:System.Reflection.MemberInfo>.</span><span class="sxs-lookup"><span data-stu-id="09f45-426">Valid values for <xref:System.Type.MemberType%2A> are defined in <xref:System.Reflection.MemberInfo>.</span></span> <span data-ttu-id="09f45-427">Si aucun membre n’est trouvé, un tableau vide est retourné.</span><span class="sxs-lookup"><span data-stu-id="09f45-427">If no such members are found, an empty array is returned.</span></span>  
  
 <span data-ttu-id="09f45-428">Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette méthode, vous devez spécifier <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-428">To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="09f45-429">Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-429">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="09f45-430">Si le courant <xref:System.Type> représente un paramètre de type d’un type générique ou une méthode générique, <xref:System.Type.FindMembers%2A> traite tous les membres déclarés par la contrainte de classe et les contraintes d’interface du paramètre de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-430">If the current <xref:System.Type> represents a type parameter of a generic type or generic method, <xref:System.Type.FindMembers%2A> processes any members declared by the class constraint and the interface constraints of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-431">L’exemple suivant recherche tous les membres dans une classe qui correspondent aux critères de recherche spécifiés, puis affiche les membres correspondants.</span><span class="sxs-lookup"><span data-stu-id="09f45-431">The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</span></span>  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-432">
            <paramref name="filter" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-432">
              <paramref name="filter" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-433">Obtient le nom qualifié complet du type, y compris son espace de noms, mais pas l'assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-433">Gets the fully qualified name of the type, including its namespace but not its assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-434">Nom qualifié complet du type, y compris son espace de noms, mais sans l'assembly ; ou <see langword="null" /> si l'instance actuelle représente un paramètre de type générique, un type de tableau, un type pointeur, un type <see langword="byref" /> reposant sur un paramètre de type ou un type générique qui n'est pas une définition de type générique mais contient des paramètres de type non résolus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-434">The fully qualified name of the type, including its namespace but not its assembly; or <see langword="null" /> if the current instance represents a generic type parameter, an array type, pointer type, or <see langword="byref" /> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-435">Par exemple, le nom qualifié complet de le <xref:System.String> est de type `System.String`.</span><span class="sxs-lookup"><span data-stu-id="09f45-435">For example, the fully qualified name of the <xref:System.String> type is `System.String`.</span></span> <span data-ttu-id="09f45-436">Ceci contraste avec le nom qualifié d’assembly retourné par la <xref:System.Type.AssemblyQualifiedName%2A> propriété, qui est constitué du nom complet et le nom complet de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-436">Contrast this with the assembly-qualified name returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, which consists of the full name plus the full assembly name.</span></span>  
  
 <span data-ttu-id="09f45-437">Si le type actuel représente un type générique fermé, les arguments de type dans la chaîne retournée par la <xref:System.Type.FullName%2A> propriété sont qualifiés par leur nom complet de l’assembly, bien que la représentation sous forme de chaîne du type générique lui-même n’est pas qualifiée par son intégral nom de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-437">If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</span></span> <span data-ttu-id="09f45-438">L’exemple suivant illustre la différence dans la propriété FullName pour un type qui représente la définition de type générique et un qui représente un type générique fermé.</span><span class="sxs-lookup"><span data-stu-id="09f45-438">The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</span></span>  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 <span data-ttu-id="09f45-439">Cette propriété retourne `null` si :</span><span class="sxs-lookup"><span data-stu-id="09f45-439">This property returns `null` if:</span></span>  
  
-   <span data-ttu-id="09f45-440">En cours <xref:System.Type> objet représente un paramètre de type d’un type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-440">The current <xref:System.Type> object represents a type parameter of a generic type.</span></span>  
  
     <span data-ttu-id="09f45-441">L’exemple suivant récupère le paramètre de type de la <xref:System.Nullable%601> type et tente d’afficher son <xref:System.Type.FullName%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-441">The following example retrieves the type parameter of the <xref:System.Nullable%601> type and attempts to display its <xref:System.Type.FullName%2A> property.</span></span>  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   <span data-ttu-id="09f45-442">En cours <xref:System.Type> objet représente un type de tableau, un type pointeur, ou un `byref` type qui est basé sur un paramètre de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-442">The current <xref:System.Type> object represents an array type, a pointer  type, or a `byref` type that is based on a generic type parameter.</span></span>  
  
     <span data-ttu-id="09f45-443">L’exemple suivant définit un type générique, `Generictype1<T>`, avec trois méthodes : `Display(T[])`, qui est transmis à un tableau de type T ; `HandleT(T)`, qui est transmis à un objet T ; et `ChangeValue(ref T)`, un objet de T qui est passé par référence.</span><span class="sxs-lookup"><span data-stu-id="09f45-443">The following example defines a generic type, `Generictype1<T>`, with three methods: `Display(T[])`, which is passed an array of type T; `HandleT(T)`, which is passed a T object; and `ChangeValue(ref T)`, which is passed a T object by reference.</span></span> <span data-ttu-id="09f45-444">C# et Visual Basic n’autorisent pas nous pouvons T en tant que pointeur dans le `HandleT` (méthode), nous avons appeler le <xref:System.Type.MakePointerType%2A> méthode sur le <xref:System.Type> objet qui représente le type de paramètre pour créer un pointeur vers un type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-444">Because C# and Visual Basic do not allow us to define T as a pointer in the `HandleT` method, we have to call the <xref:System.Type.MakePointerType%2A> method on the <xref:System.Type> object that represents the method's parameter type to create a pointer to a generic type.</span></span> <span data-ttu-id="09f45-445">La sortie de l’exemple montre que dans les trois cas, le <xref:System.Type.FullName%2A> propriété est `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-445">The output from the example shows that in all three cases, the <xref:System.Type.FullName%2A> property is `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   <span data-ttu-id="09f45-446">Le type actuel contient des paramètres de type générique qui n’ont pas été remplacés par des types spécifiques (autrement dit, le <xref:System.Type.ContainsGenericParameters%2A> propriété renvoie `true`), mais le type n’est pas une définition de type générique (autrement dit, la <xref:System.Type.IsGenericTypeDefinition%2A> retourne de la propriété `false`</span><span class="sxs-lookup"><span data-stu-id="09f45-446">The current type contains generic type parameters that have not been replaced by specific types (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`), but the type is not a generic type definition (that is, the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `false`</span></span>  
  
     <span data-ttu-id="09f45-447">Dans l’exemple suivant, `Derived<T>` hérite `Base<T>`.</span><span class="sxs-lookup"><span data-stu-id="09f45-447">In the following example, `Derived<T>` inherits from `Base<T>`.</span></span> <span data-ttu-id="09f45-448">Le <xref:System.Type.BaseType%2A> propriété obtient le <xref:System.Type> objet qui représente le type de base de `Derived<T>`et son <xref:System.Type.FullName%2A> propriété renvoie `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-448">The <xref:System.Type.BaseType%2A> property obtains the  <xref:System.Type> object that represents the base type of `Derived<T>`, and its <xref:System.Type.FullName%2A> property returns `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     <span data-ttu-id="09f45-449">Pour obtenir un <xref:System.Type.FullName%2A> qui n’est pas `null`, vous pouvez utiliser la <xref:System.Type.GetGenericTypeDefinition%2A> méthode pour obtenir la définition de type générique, comme l’illustre l’exemple.</span><span class="sxs-lookup"><span data-stu-id="09f45-449">To get a <xref:System.Type.FullName%2A> that is not `null`, you can use the <xref:System.Type.GetGenericTypeDefinition%2A> method to get the generic type definition, as the example illustrates.</span></span>  
  
 <span data-ttu-id="09f45-450">Cette propriété est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="09f45-450">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-451">L’exemple suivant affiche le nom complet du type spécifié.</span><span class="sxs-lookup"><span data-stu-id="09f45-451">The following example displays the full name of the specified type.</span></span>  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 <span data-ttu-id="09f45-452">L’exemple suivant compare les chaînes retournées par la <xref:System.Type.ToString%2A> (méthode) et le `Name`, <xref:System.Type.FullName%2A>, et <xref:System.Type.AssemblyQualifiedName%2A> propriétés.</span><span class="sxs-lookup"><span data-stu-id="09f45-452">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-453">Obtient une combinaison d'indicateurs <see cref="T:System.Reflection.GenericParameterAttributes" /> qui décrivent la covariance et des contraintes spéciales du paramètre de type générique actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-453">Gets a combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> flags that describe the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-454">Combinaison d'opérations de bits de valeurs <see cref="T:System.Reflection.GenericParameterAttributes" /> qui décrit la covariance et les contraintes spéciales du paramètre de type générique actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-454">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-455">La valeur de cette propriété contient des indicateurs qui décrivent les contraintes spéciales et des indicateurs qui décrivent si le paramètre de type générique actuel est covariant.</span><span class="sxs-lookup"><span data-stu-id="09f45-455">The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</span></span> <span data-ttu-id="09f45-456">Utilisez le <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> valeur pour sélectionner les indicateurs de covariance et utiliser le <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> valeur pour sélectionner les indicateurs de contrainte.</span><span class="sxs-lookup"><span data-stu-id="09f45-456">Use the <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> value to select the constraint flags.</span></span>  
  
 <span data-ttu-id="09f45-457">Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-457">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-458">L’exemple de code suivant définit un type générique `Test` avec deux paramètres de type qui possèdent des contraintes différentes.</span><span class="sxs-lookup"><span data-stu-id="09f45-458">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="09f45-459">Lorsque le programme s’exécute, les contraintes sont examinées à l’aide de la <xref:System.Type.GenericParameterAttributes%2A> propriété et la <xref:System.Type.GetGenericParameterConstraints%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-459">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="09f45-460">L'objet <see cref="T:System.Type" /> actuel n'est pas un paramètre de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-460">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span>
          </span>
          <span data-ttu-id="09f45-461">Autrement dit, la propriété <see cref="P:System.Type.IsGenericParameter" /> retourne <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-461">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-462">La méthode appelée n’est pas prise en charge dans la classe de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-462">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-463">Obtient la position du paramètre de type dans la liste des paramètres de type du type générique ou de la méthode qui a déclaré le paramètre, quand l'objet <see cref="T:System.Type" /> représente un paramètre de type d'un type générique ou une méthode générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-463">Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <see cref="T:System.Type" /> object represents a type parameter of a generic type or a generic method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-464">Position d’un paramètre de type dans la liste des paramètres de type du type générique ou de la méthode qui a défini le paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-464">The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</span>
          </span>
          <span data-ttu-id="09f45-465">La numérotation des positions commence à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-465">Position numbers begin at 0.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-466">Le <xref:System.Type.GenericParameterPosition%2A> propriété retourne la position d’un paramètre de type dans la liste de paramètres de la définition de type générique ou la définition de méthode générique où le paramètre de type a été défini à l’origine.</span><span class="sxs-lookup"><span data-stu-id="09f45-466">The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</span></span> <span data-ttu-id="09f45-467">Le <xref:System.Type.DeclaringType%2A> et <xref:System.Type.DeclaringMethod%2A> propriétés identifient la définition de type ou de méthode générique :</span><span class="sxs-lookup"><span data-stu-id="09f45-467">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:</span></span>  
  
-   <span data-ttu-id="09f45-468">Si le <xref:System.Type.DeclaringMethod%2A> propriété retourne un <xref:System.Reflection.MethodInfo>, qui <xref:System.Reflection.MethodInfo> représente une définition de méthode générique et en cours <xref:System.Type> objet représente un paramètre de type de cette définition de méthode générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-468">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="09f45-469">Si le <xref:System.Type.DeclaringMethod%2A> propriété renvoie `null`, puis le <xref:System.Type.DeclaringType%2A> propriété retourne toujours un <xref:System.Type> objet représentant une définition de type générique et en cours <xref:System.Type> objet représente un paramètre de type du type générique définition.</span><span class="sxs-lookup"><span data-stu-id="09f45-469">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
 <span data-ttu-id="09f45-470">Pour fournir le contexte correct pour la valeur de la <xref:System.Type.GenericParameterPosition%2A> propriété, il est nécessaire identifier le type générique ou la méthode un paramètre de type appartient.</span><span class="sxs-lookup"><span data-stu-id="09f45-470">To provide the correct context for the value of the <xref:System.Type.GenericParameterPosition%2A> property, it is necessary to identify the generic type or method a type parameter belongs to.</span></span> <span data-ttu-id="09f45-471">Par exemple, considérez la valeur de retour de la méthode générique `GetSomething` dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="09f45-471">For example, consider the return value of the generic method `GetSomething` in the following code:</span></span>  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 <span data-ttu-id="09f45-472">Le type retourné par `GetSomething` varie selon les arguments de type fournis à la classe `A` et `GetSomething` lui-même.</span><span class="sxs-lookup"><span data-stu-id="09f45-472">The type returned by `GetSomething` depends on the type arguments supplied to class `A` and to `GetSomething` itself.</span></span> <span data-ttu-id="09f45-473">Vous pouvez obtenir un <xref:System.Reflection.MethodInfo> pour `GetSomething`, et à partir de que vous pouvez obtenir le type de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-473">You can obtain a <xref:System.Reflection.MethodInfo> for `GetSomething`, and from that you can obtain the return type.</span></span> <span data-ttu-id="09f45-474">Lorsque vous examinez les paramètres de type de retour, <xref:System.Type.GenericParameterPosition%2A> retourne 0 pour les deux.</span><span class="sxs-lookup"><span data-stu-id="09f45-474">When you examine the type parameters of the return type, <xref:System.Type.GenericParameterPosition%2A> returns 0 for both.</span></span> <span data-ttu-id="09f45-475">La position de `V` est 0 car `V` est le premier paramètre de type dans la liste de paramètres de type pour la classe `A`.</span><span class="sxs-lookup"><span data-stu-id="09f45-475">The position of `V` is 0 because `V` is the first type parameter in the type parameter list for class `A`.</span></span> <span data-ttu-id="09f45-476">La position de `X` est 0 car `X` est le premier paramètre de type dans la liste de paramètres de type `GetSomething`.</span><span class="sxs-lookup"><span data-stu-id="09f45-476">The position of `X` is 0 because `X` is the first type parameter in the type parameter list for `GetSomething`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-477">Appel de la <xref:System.Type.GenericParameterPosition%2A> propriété provoque une exception si actuel <xref:System.Type> ne représente pas un paramètre de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-477">Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter.</span></span> <span data-ttu-id="09f45-478">Lorsque vous examinez les arguments de type d’un type construit ouvert, utilisez la <xref:System.Type.IsGenericParameter%2A> propriété pour indiquer à qui sont des paramètres de type et les types.</span><span class="sxs-lookup"><span data-stu-id="09f45-478">When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types.</span></span> <span data-ttu-id="09f45-479">Le <xref:System.Type.IsGenericParameter%2A> propriété renvoie `true` pour un paramètre de type ; vous pouvez ensuite utiliser le <xref:System.Type.GenericParameterPosition%2A> méthode à obtenir sa position, utilisez la <xref:System.Type.DeclaringMethod%2A> et <xref:System.Type.DeclaringType%2A> propriétés afin de déterminer la méthode générique ou type de définition qui le définit .</span><span class="sxs-lookup"><span data-stu-id="09f45-479">The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-480">L’exemple suivant définit une classe générique avec deux paramètres de type et une deuxième classe générique qui dérive de la première classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-480">The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="09f45-481">Classe de base de la classe dérivée a deux arguments de type : le premier est <xref:System.Int32>, et le deuxième est un paramètre de type du type dérivé.</span><span class="sxs-lookup"><span data-stu-id="09f45-481">The derived class's base class has two type arguments: the first is <xref:System.Int32>, and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="09f45-482">L’exemple affiche des informations sur ces classes génériques, y compris les positions rapportées par le <xref:System.Type.GenericParameterPosition%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-482">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="09f45-483">Le type actuel ne représente pas un paramètre de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-483">The current type does not represent a type parameter.</span>
          </span>
          <span data-ttu-id="09f45-484">Autrement dit, <see cref="P:System.Type.IsGenericParameter" /> retourne <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-484">That is, <see cref="P:System.Type.IsGenericParameter" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-485">Obtient un tableau des arguments de type générique pour ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-485">Gets an array of the generic type arguments for this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-486">Tableau des arguments de type générique pour ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-486">An array of the generic type arguments for this type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-487">Cette propriété obtient uniquement les arguments de type générique ; Autrement dit, les types qui ont été spécifiées pour les paramètres de type générique du type actuel.</span><span class="sxs-lookup"><span data-stu-id="09f45-487">This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</span></span> <span data-ttu-id="09f45-488">Si le type actuel est une définition de type générique, cette propriété retourne un tableau vide.</span><span class="sxs-lookup"><span data-stu-id="09f45-488">If the current type is a generic type definition, this property returns an empty array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-489">Si un type générique est utilisé dans une méthode générique ou dans un autre type générique, certaines de ses arguments de type générique peuvent être des paramètres de type générique de la méthode ou le type englobant.</span><span class="sxs-lookup"><span data-stu-id="09f45-489">If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</span></span>  
  
 <span data-ttu-id="09f45-490">Pour obtenir les paramètres de type générique d’un type qui représente une définition de type générique, utilisez le <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-490">To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="09f45-491">Pour obtenir un <xref:System.Reflection.TypeInfo> objet en cours <xref:System.Type> de l’objet, utilisez la <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> méthode d’extension.</span><span class="sxs-lookup"><span data-stu-id="09f45-491">To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> extension method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-492">Obtient le nombre de dimensions dans un tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-492">Gets the number of dimensions in an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-493">Entier comportant le nombre de dimensions figurant dans le type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-493">An integer that contains the number of dimensions in the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="09f45-494">L’exemple suivant affiche le nombre de dimensions dans un tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-494">The following example displays the number of dimensions in an array.</span></span>  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-495">La fonctionnalité de cette méthode n’est pas prise en charge dans la classe de base et doit être implémentée dans une classe dérivée à la place.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-495">The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-496">Le type actuel n’est pas un tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-496">The current type is not an array.</span>
          </span>
        </exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-497">En cas de substitution dans une classe dérivée, implémente la propriété <see cref="P:System.Type.Attributes" /> et obtient un masque de bits indiquant les attributs associés à <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-497">When overridden in a derived class, implements the <see cref="P:System.Type.Attributes" /> property and gets a bitmask indicating the attributes associated with the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-498">Objet <see cref="T:System.Reflection.TypeAttributes" /> qui représente l'ensemble des attributs de <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-498">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-499">Obtient un constructeur spécifique du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-499">Gets a specific constructor of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">
          <span data-ttu-id="09f45-500">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres du constructeur souhaité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-500">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the desired constructor.</span>
          </span>
          <span data-ttu-id="09f45-501">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-501">-or-</span>
          </span>
          <span data-ttu-id="09f45-502">Tableau vide d'objets <see cref="T:System.Type" /> pour obtenir un constructeur n'acceptant aucun paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-502">An empty array of <see cref="T:System.Type" /> objects, to get a constructor that takes no parameters.</span>
          </span>
          <span data-ttu-id="09f45-503">Un tel tableau vide est fourni par le champ <see langword="static" /><see cref="F:System.Type.EmptyTypes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-503">Such an empty array is provided by the <see langword="static" /> field <see cref="F:System.Type.EmptyTypes" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-504">Recherche un constructeur d'instance public dont les paramètres correspondent aux types contenus dans le tableau spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-504">Searches for a public instance constructor whose parameters match the types in the specified array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-505">Objet représentant le constructeur d'instance public dont les paramètres correspondent aux types contenus dans le tableau de types de paramètres, s'il est trouvé ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-505">An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-506">Cette surcharge de méthode recherche des constructeurs d’instance publics et ne peut pas être utilisée pour obtenir un initialiseur de classe (.cctor).</span><span class="sxs-lookup"><span data-stu-id="09f45-506">This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor).</span></span> <span data-ttu-id="09f45-507">Pour obtenir un initialiseur de classe, utilisez une surcharge qui accepte <xref:System.Reflection.BindingFlags>et spécifiez <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-507">To get a class initializer, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="09f45-508">Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-508">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="09f45-509">Si le constructeur demandé est non public, cette méthode retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-509">If the requested constructor is non-public, this method returns `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-510">Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes.</span><span class="sxs-lookup"><span data-stu-id="09f45-510">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="09f45-511">Vous pouvez uniquement omettre les paramètres lors de l’appel.</span><span class="sxs-lookup"><span data-stu-id="09f45-511">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="09f45-512">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.ConstructorInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-512">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="09f45-513">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode retourne toujours `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-513">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-514">L’exemple suivant obtient le type de `MyClass`, obtient le <xref:System.Reflection.ConstructorInfo> de l’objet et affiche la signature du constructeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-514">The following example obtains the type of `MyClass`, gets the <xref:System.Reflection.ConstructorInfo> object, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-515">
            <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-515">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-516">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-516">-or-</span>
          </span>
          <span data-ttu-id="09f45-517">Un des éléments de <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-517">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-518">
            <paramref name="types" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-518">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-519">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-519">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-520">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-520">-or-</span>
          </span>
          <span data-ttu-id="09f45-521">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-521">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="09f45-522">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-522">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="09f45-523">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-523">-or-</span>
          </span>
          <span data-ttu-id="09f45-524">Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-524">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="09f45-525">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres du constructeur à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-525">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span>
          </span>
          <span data-ttu-id="09f45-526">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-526">-or-</span>
          </span>
          <span data-ttu-id="09f45-527">Tableau vide de type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir un constructeur qui ne prend aucun paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-527">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span>
          </span>
          <span data-ttu-id="09f45-528">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-528">-or-</span>
          </span>
          <span data-ttu-id="09f45-529">
            <see cref="F:System.Type.EmptyTypes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-529">
              <see cref="F:System.Type.EmptyTypes" />.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="09f45-530">Tableau d'objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l'élément correspondant dans le tableau de types de paramètres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-530">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the parameter type array.</span>
          </span>
          <span data-ttu-id="09f45-531">Le binder par défaut ne traite pas ce paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-531">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-532">Recherche un constructeur dont les paramètres correspondent aux types d’arguments et modificateurs spécifiés, à l’aide des contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-532">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-533">Objet <see cref="T:System.Reflection.ConstructorInfo" /> qui représente le constructeur correspondant aux critères spécifiés, s'il existe ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-533">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-534">Si une correspondance exacte n’existe pas, le `binder` va tenter de forcer les types de paramètre spécifiés dans le `types` tableau afin de sélectionner une correspondance.</span><span class="sxs-lookup"><span data-stu-id="09f45-534">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="09f45-535">Si le `binder` ne parvient pas à sélectionner une correspondance, puis `null` est retourné.</span><span class="sxs-lookup"><span data-stu-id="09f45-535">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="09f45-536">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les constructeurs à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-536">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-537">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-537">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-538">Spécifiez `BindingFlags.Public` pour inclure les constructeurs publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-538">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="09f45-539">Spécifiez `BindingFlags.NonPublic` pour inclure des constructeurs non publics (autrement dit, les constructeurs privés, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-539">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="09f45-540">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-540">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-541">Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette surcharge de méthode, vous devez spécifier <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-541">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="09f45-542">Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-542">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-543">Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes.</span><span class="sxs-lookup"><span data-stu-id="09f45-543">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="09f45-544">Vous pouvez uniquement omettre les paramètres lors de l’appel.</span><span class="sxs-lookup"><span data-stu-id="09f45-544">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="09f45-545">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.ConstructorInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-545">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="09f45-546">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode retourne toujours `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-546">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-547">Le programme suivant obtient le type de `MyClass1` classe, obtient le <xref:System.Reflection.ConstructorInfo> correspondant aux indicateurs de liaison spécifiée de l’objet et affiche la signature du constructeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-547">The following program obtains the type of `MyClass1` class, gets the <xref:System.Reflection.ConstructorInfo> object matching the specified binding flags, and displays the signature of the constructor.</span></span>  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-548">
            <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-548">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-549">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-549">-or-</span>
          </span>
          <span data-ttu-id="09f45-550">Un des éléments de <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-550">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-551">
            <paramref name="types" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-551">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-552">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-552">-or-</span>
          </span>
          <span data-ttu-id="09f45-553">
            <paramref name="modifiers" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-553">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-554">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-554">-or-</span>
          </span>
          <span data-ttu-id="09f45-555">
            <paramref name="types" /> et <paramref name="modifiers" /> n’ont pas la même longueur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-555">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-556">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-556">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-557">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-557">-or-</span>
          </span>
          <span data-ttu-id="09f45-558">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-558">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="09f45-559">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-559">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="09f45-560">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-560">-or-</span>
          </span>
          <span data-ttu-id="09f45-561">Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-561">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="09f45-562">Objet qui spécifie l’ensemble de règles à utiliser en ce qui concerne l’ordre et la disposition des arguments, la manière dont la valeur de retour est passée, les registres utilisés pour les arguments et la manière dont la pile est nettoyée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-562">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="09f45-563">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres du constructeur à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-563">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span>
          </span>
          <span data-ttu-id="09f45-564">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-564">-or-</span>
          </span>
          <span data-ttu-id="09f45-565">Tableau vide de type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir un constructeur qui ne prend aucun paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-565">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="09f45-566">Tableau d’objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l’élément correspondant dans le tableau <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-566">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="09f45-567">Le binder par défaut ne traite pas ce paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-567">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-568">Recherche un constructeur dont les paramètres correspondent aux types d’arguments et aux modificateurs spécifiés, en utilisant les contraintes de liaison et la convention d’appel indiquées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-568">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-569">Objet représentant le constructeur qui correspond aux critères spécifiés, s'il est trouvé ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-569">An object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-570">Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="09f45-570">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="09f45-571">`ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.</span><span class="sxs-lookup"><span data-stu-id="09f45-571">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="09f45-572">Si une correspondance exacte n’existe pas, le `binder` va tenter de forcer les types de paramètre spécifiés dans le `types` tableau afin de sélectionner une correspondance.</span><span class="sxs-lookup"><span data-stu-id="09f45-572">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="09f45-573">Si le `binder` ne parvient pas à sélectionner une correspondance, puis `null` est retourné.</span><span class="sxs-lookup"><span data-stu-id="09f45-573">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="09f45-574">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les constructeurs à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-574">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-575">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-575">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-576">Spécifiez `BindingFlags.Public` pour inclure les constructeurs publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-576">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="09f45-577">Spécifiez `BindingFlags.NonPublic` pour inclure des constructeurs non publics (autrement dit, les constructeurs privés, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-577">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="09f45-578">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-578">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-579">Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette méthode, vous devez spécifier <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-579">To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="09f45-580">Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-580">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="09f45-581">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-581">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-582">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-582">Member Type</span></span>|<span data-ttu-id="09f45-583">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-583">Static</span></span>|<span data-ttu-id="09f45-584">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-584">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-585">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-585">Constructor</span></span>|<span data-ttu-id="09f45-586">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-586">No</span></span>|<span data-ttu-id="09f45-587">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-587">No</span></span>|  
|<span data-ttu-id="09f45-588">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-588">Field</span></span>|<span data-ttu-id="09f45-589">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-589">No</span></span>|<span data-ttu-id="09f45-590">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-590">Yes.</span></span> <span data-ttu-id="09f45-591">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-591">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-592">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-592">Event</span></span>|<span data-ttu-id="09f45-593">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-593">Not applicable</span></span>|<span data-ttu-id="09f45-594">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-594">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-595">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-595">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-596">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-596">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-597">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-597">Method</span></span>|<span data-ttu-id="09f45-598">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-598">No</span></span>|<span data-ttu-id="09f45-599">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-599">Yes.</span></span> <span data-ttu-id="09f45-600">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-600">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-601">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-601">Nested Type</span></span>|<span data-ttu-id="09f45-602">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-602">No</span></span>|<span data-ttu-id="09f45-603">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-603">No</span></span>|  
|<span data-ttu-id="09f45-604">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-604">Property</span></span>|<span data-ttu-id="09f45-605">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-605">Not applicable</span></span>|<span data-ttu-id="09f45-606">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-606">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-607">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-607">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-608">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-608">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-609">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-609">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-610">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-610">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-611">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-611">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-612">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-612">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-613">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-613">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-614">Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes.</span><span class="sxs-lookup"><span data-stu-id="09f45-614">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="09f45-615">Vous pouvez uniquement omettre les paramètres lors de l’appel.</span><span class="sxs-lookup"><span data-stu-id="09f45-615">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="09f45-616">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.ConstructorInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-616">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="09f45-617">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode retourne toujours `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-617">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-618">L’exemple suivant obtient le type de `MyClass1`, obtient le <xref:System.Reflection.ConstructorInfo> objet qui correspond aux indicateurs de liaison spécifiés et affiche la signature du constructeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-618">The following example obtains the type of `MyClass1`, gets the <xref:System.Reflection.ConstructorInfo> object that matches the specified binding flags, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-619">
            <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-619">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-620">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-620">-or-</span>
          </span>
          <span data-ttu-id="09f45-621">Un des éléments de <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-621">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-622">
            <paramref name="types" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-622">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-623">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-623">-or-</span>
          </span>
          <span data-ttu-id="09f45-624">
            <paramref name="modifiers" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-624">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-625">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-625">-or-</span>
          </span>
          <span data-ttu-id="09f45-626">
            <paramref name="types" /> et <paramref name="modifiers" /> n’ont pas la même longueur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-626">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-627">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-627">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-628">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-628">-or-</span>
          </span>
          <span data-ttu-id="09f45-629">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-629">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="09f45-630">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-630">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="09f45-631">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-631">-or-</span>
          </span>
          <span data-ttu-id="09f45-632">Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-632">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="09f45-633">Objet qui spécifie l’ensemble de règles à utiliser en ce qui concerne l’ordre et la disposition des arguments, la manière dont la valeur de retour est passée, les registres utilisés pour les arguments et la manière dont la pile est nettoyée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-633">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="09f45-634">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres du constructeur à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-634">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span>
          </span>
          <span data-ttu-id="09f45-635">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-635">-or-</span>
          </span>
          <span data-ttu-id="09f45-636">Tableau vide de type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir un constructeur qui ne prend aucun paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-636">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="09f45-637">Tableau d’objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l’élément correspondant dans le tableau <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-637">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="09f45-638">Le binder par défaut ne traite pas ce paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-638">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-639">En cas de substitution dans une classe dérivée, recherche un constructeur dont les paramètres correspondent aux types d’arguments et modificateurs spécifiés, à l’aide des contraintes de liaison et de la convention d’appel spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-639">When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-640">Objet <see cref="T:System.Reflection.ConstructorInfo" /> qui représente le constructeur correspondant aux critères spécifiés, s'il existe ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-640">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-641">Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="09f45-641">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="09f45-642">`ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.</span><span class="sxs-lookup"><span data-stu-id="09f45-642">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="09f45-643">Si une correspondance exacte n’existe pas, le `binder` va tenter de forcer les types de paramètre spécifiés dans le `types` tableau afin de sélectionner une correspondance.</span><span class="sxs-lookup"><span data-stu-id="09f45-643">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="09f45-644">Si le `binder` ne parvient pas à sélectionner une correspondance, puis `null` est retourné.</span><span class="sxs-lookup"><span data-stu-id="09f45-644">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="09f45-645">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les constructeurs à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-645">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-646">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-646">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-647">Spécifiez `BindingFlags.Public` pour inclure les constructeurs publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-647">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="09f45-648">Spécifiez `BindingFlags.NonPublic` pour inclure des constructeurs non publics (autrement dit, les constructeurs privés, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-648">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="09f45-649">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-649">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-650">Cette méthode implémente <xref:System.Type.GetConstructor%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-650">This method implements <xref:System.Type.GetConstructor%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-651">
            <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-651">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-652">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-652">-or-</span>
          </span>
          <span data-ttu-id="09f45-653">Un des éléments de <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-653">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-654">
            <paramref name="types" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-654">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-655">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-655">-or-</span>
          </span>
          <span data-ttu-id="09f45-656">
            <paramref name="modifiers" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-656">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-657">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-657">-or-</span>
          </span>
          <span data-ttu-id="09f45-658">
            <paramref name="types" /> et <paramref name="modifiers" /> n’ont pas la même longueur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-658">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-659">Le type actuel est un <see cref="T:System.Reflection.Emit.TypeBuilder" /> ou un <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-659">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-660">Obtient les constructeurs du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-660">Gets the constructors of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-661">Retourne tous les constructeurs publics définis pour le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-661">Returns all the public constructors defined for the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-662">Tableau d'objets <see cref="T:System.Reflection.ConstructorInfo" /> représentant tous les constructeurs d'instance publics définis pour le <see cref="T:System.Type" /> actuel, sans inclure l'initialiseur de type (constructeur statique).</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-662">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all the public instance constructors defined for the current <see cref="T:System.Type" />, but not including the type initializer (static constructor).</span>
          </span>
          <span data-ttu-id="09f45-663">Si aucun constructeur d'instance public n'est défini pour le <see cref="T:System.Type" /> actuel ou si le <see cref="T:System.Type" /> actuel représente un paramètre de type d'une définition de type ou de méthode générique, un tableau vide de type <see cref="T:System.Reflection.ConstructorInfo" /> est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-663">If no public instance constructors are defined for the current <see cref="T:System.Type" />, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-664">Le <xref:System.Type.GetConstructors%2A> méthode ne retourne pas les constructeurs dans un ordre particulier, tel que l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-664">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="09f45-665">Votre code ne doit pas dépendent l’ordre dans lequel les constructeurs sont retournés, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-665">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-666">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-666">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-667">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-667">Member Type</span></span>|<span data-ttu-id="09f45-668">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-668">Static</span></span>|<span data-ttu-id="09f45-669">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-669">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-670">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-670">Constructor</span></span>|<span data-ttu-id="09f45-671">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-671">No</span></span>|<span data-ttu-id="09f45-672">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-672">No</span></span>|  
|<span data-ttu-id="09f45-673">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-673">Field</span></span>|<span data-ttu-id="09f45-674">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-674">No</span></span>|<span data-ttu-id="09f45-675">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-675">Yes.</span></span> <span data-ttu-id="09f45-676">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-676">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-677">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-677">Event</span></span>|<span data-ttu-id="09f45-678">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-678">Not applicable</span></span>|<span data-ttu-id="09f45-679">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-679">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-680">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-680">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-681">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-681">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-682">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-682">Method</span></span>|<span data-ttu-id="09f45-683">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-683">No</span></span>|<span data-ttu-id="09f45-684">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-684">Yes.</span></span> <span data-ttu-id="09f45-685">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-685">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-686">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-686">Nested Type</span></span>|<span data-ttu-id="09f45-687">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-687">No</span></span>|<span data-ttu-id="09f45-688">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-688">No</span></span>|  
|<span data-ttu-id="09f45-689">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-689">Property</span></span>|<span data-ttu-id="09f45-690">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-690">Not applicable</span></span>|<span data-ttu-id="09f45-691">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-691">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-692">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-692">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-693">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-693">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-694">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-694">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-695">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-695">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-696">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-696">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-697">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-697">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-698">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-698">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="09f45-699">Cette surcharge de méthode appelle la <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> la surcharge de méthode, avec <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-699">This method overload calls the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="09f45-700">Elle ne trouvera pas d’initialiseurs de classe (.cctor).</span><span class="sxs-lookup"><span data-stu-id="09f45-700">It will not find class initializers (.cctor).</span></span> <span data-ttu-id="09f45-701">Pour rechercher des initialiseurs de classe, utilisez une surcharge qui accepte <xref:System.Reflection.BindingFlags>et spécifiez <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-701">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="09f45-702">Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-702">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="09f45-703">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.ConstructorInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-703">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="09f45-704">Par exemple, si classe `C<T>` a un constructeur `C(T t1)` (`Sub New(ByVal t1 As T)` en Visual Basic), l’appel <xref:System.Type.GetConstructors%2A> sur `C<int>` retourne un <xref:System.Reflection.ConstructorInfo> représentant `C(int t1)` en c# (`Sub New(ByVal t1 As Integer)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-704">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="09f45-705">Si le courant <xref:System.Type> représente un paramètre de type générique, la <xref:System.Type.GetConstructors%2A> méthode retourne un tableau vide.</span><span class="sxs-lookup"><span data-stu-id="09f45-705">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-706">Cet exemple montre la sortie de la <xref:System.Type.GetConstructors%2A> de surcharge à partir d’une classe qui possède deux constructeurs d’instance et un constructeur statique.</span><span class="sxs-lookup"><span data-stu-id="09f45-706">This example shows the output of the <xref:System.Type.GetConstructors%2A> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="09f45-707">La sortie de ce code est :</span><span class="sxs-lookup"><span data-stu-id="09f45-707">The output of this code is:</span></span>  
  
 <span data-ttu-id="09f45-708">2</span><span class="sxs-lookup"><span data-stu-id="09f45-708">2</span></span>  
  
 <span data-ttu-id="09f45-709">False</span><span class="sxs-lookup"><span data-stu-id="09f45-709">False</span></span>  
  
 <span data-ttu-id="09f45-710">False</span><span class="sxs-lookup"><span data-stu-id="09f45-710">False</span></span>  
  
 <span data-ttu-id="09f45-711">Étant donné que la <xref:System.Type.GetConstructors> surcharge utilise uniquement <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> et <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, le constructeur statique n’est ni compté par le `for` expression ni évalué par `IsStatic`.</span><span class="sxs-lookup"><span data-stu-id="09f45-711">Because the <xref:System.Type.GetConstructors> overload uses only <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="09f45-712">Pour rechercher des constructeurs statiques, utilisez le <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> de surcharge et passez la combinaison (logique `OR`) de <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, comme illustré dans l’exemple de code suivant :</span><span class="sxs-lookup"><span data-stu-id="09f45-712">To find static constructors, use the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> overload, and pass the combination (logical `OR`) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="09f45-713">À présent, la sortie :</span><span class="sxs-lookup"><span data-stu-id="09f45-713">Now the output is:</span></span>  
  
 <span data-ttu-id="09f45-714">3</span><span class="sxs-lookup"><span data-stu-id="09f45-714">3</span></span>  
  
 <span data-ttu-id="09f45-715">False</span><span class="sxs-lookup"><span data-stu-id="09f45-715">False</span></span>  
  
 <span data-ttu-id="09f45-716">True</span><span class="sxs-lookup"><span data-stu-id="09f45-716">True</span></span>  
  
 <span data-ttu-id="09f45-717">False</span><span class="sxs-lookup"><span data-stu-id="09f45-717">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-718">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-718">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-719">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-719">-or-</span>
          </span>
          <span data-ttu-id="09f45-720">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-720">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-721">En cas de substitution dans une classe dérivée, recherche les constructeurs définis pour le <see cref="T:System.Type" /> actuel, à l'aide du <see langword="BindingFlags" /> spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-721">When overridden in a derived class, searches for the constructors defined for the current <see cref="T:System.Type" />, using the specified <see langword="BindingFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-722">Tableau d'objets <see cref="T:System.Reflection.ConstructorInfo" /> représentant tous les constructeurs définis pour le <see cref="T:System.Type" /> actuel qui correspondent aux contraintes de liaison spécifiées, y compris l'initialiseur de type s'il est défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-722">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all constructors defined for the current <see cref="T:System.Type" /> that match the specified binding constraints, including the type initializer if it is defined.</span>
          </span>
          <span data-ttu-id="09f45-723">Retourne un tableau vide de type <see cref="T:System.Reflection.ConstructorInfo" /> si aucun constructeur n'est défini pour le <see cref="T:System.Type" /> actuel, si aucun des constructeurs définis ne correspond aux contraintes de liaison, ou si le <see cref="T:System.Type" /> actuel représente un paramètre de type d'une définition de type ou de méthode générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-723">Returns an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> if no constructors are defined for the current <see cref="T:System.Type" />, if none of the defined constructors match the binding constraints, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-724">Le <xref:System.Type.GetConstructors%2A> méthode ne retourne pas les constructeurs dans un ordre particulier, tel que l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-724">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="09f45-725">Votre code ne doit pas dépendent l’ordre dans lequel les constructeurs sont retournés, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-725">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-726">`bindingAttr` peut être utilisé pour spécifier s’il faut retourner uniquement les constructeurs publics ou les constructeurs publics et non publics.</span><span class="sxs-lookup"><span data-stu-id="09f45-726">`bindingAttr` can be used to specify whether to return only public constructors or both public and non-public constructors.</span></span>  
  
 <span data-ttu-id="09f45-727">Si une correspondance exacte n’existe pas, le `binder` va tenter de forcer les types de paramètre spécifiés dans le `types` tableau afin de sélectionner une correspondance.</span><span class="sxs-lookup"><span data-stu-id="09f45-727">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="09f45-728">Si le `binder` ne parvient pas à sélectionner une correspondance, puis `null` est retourné.</span><span class="sxs-lookup"><span data-stu-id="09f45-728">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="09f45-729">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les constructeurs à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-729">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-730">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-730">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-731">Spécifiez `BindingFlags.Public` pour inclure les constructeurs publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-731">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="09f45-732">Spécifiez `BindingFlags.NonPublic` pour inclure des constructeurs non publics (autrement dit, les constructeurs privés, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-732">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span> <span data-ttu-id="09f45-733">Constructeurs de classes de base ne sont pas retournés.</span><span class="sxs-lookup"><span data-stu-id="09f45-733">Constructors of base classes are not returned.</span></span>  
  
 <span data-ttu-id="09f45-734">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-734">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-735">Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette surcharge de méthode, vous devez spécifier <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-735">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="09f45-736">Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-736">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="09f45-737">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.ConstructorInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-737">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="09f45-738">Par exemple, si classe `C<T>` a un constructeur `C(T t1)` (`Sub New(ByVal t1 As T)` en Visual Basic), l’appel <xref:System.Type.GetConstructors%2A> sur `C<int>` retourne un <xref:System.Reflection.ConstructorInfo> représentant `C(int t1)` en c# (`Sub New(ByVal t1 As Integer)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-738">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="09f45-739">Si le courant <xref:System.Type> représente un paramètre de type générique, la <xref:System.Type.GetConstructors%2A> méthode retourne un tableau vide.</span><span class="sxs-lookup"><span data-stu-id="09f45-739">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-740">Cet exemple montre la sortie de la <xref:System.Type.GetConstructors> de surcharge à partir d’une classe qui possède deux constructeurs d’instance et un constructeur statique.</span><span class="sxs-lookup"><span data-stu-id="09f45-740">This example shows the output of the <xref:System.Type.GetConstructors> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="09f45-741">La sortie de ce code est :</span><span class="sxs-lookup"><span data-stu-id="09f45-741">The output of this code is:</span></span>  
  
 <span data-ttu-id="09f45-742">2</span><span class="sxs-lookup"><span data-stu-id="09f45-742">2</span></span>  
  
 <span data-ttu-id="09f45-743">False</span><span class="sxs-lookup"><span data-stu-id="09f45-743">False</span></span>  
  
 <span data-ttu-id="09f45-744">False</span><span class="sxs-lookup"><span data-stu-id="09f45-744">False</span></span>  
  
 <span data-ttu-id="09f45-745">Étant donné que la <xref:System.Type.GetConstructors%2A> surcharge utilise uniquement <xref:System.Reflection.BindingFlags.Public> et <xref:System.Reflection.BindingFlags.Instance>, le constructeur statique n’est ni compté par le `for` expression ni évalué par `IsStatic`.</span><span class="sxs-lookup"><span data-stu-id="09f45-745">Because the <xref:System.Type.GetConstructors%2A> overload uses only <xref:System.Reflection.BindingFlags.Public> and <xref:System.Reflection.BindingFlags.Instance>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="09f45-746">Pour rechercher des constructeurs statiques, utilisez le <xref:System.Type.GetConstructors%2A> de surcharge et passez la combinaison (ou logique) de <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, comme illustré dans l’exemple de code suivant :</span><span class="sxs-lookup"><span data-stu-id="09f45-746">To find static constructors, use the <xref:System.Type.GetConstructors%2A> overload, and pass it the combination (logical OR) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="09f45-747">À présent, la sortie :</span><span class="sxs-lookup"><span data-stu-id="09f45-747">Now the output is:</span></span>  
  
 <span data-ttu-id="09f45-748">3</span><span class="sxs-lookup"><span data-stu-id="09f45-748">3</span></span>  
  
 <span data-ttu-id="09f45-749">False</span><span class="sxs-lookup"><span data-stu-id="09f45-749">False</span></span>  
  
 <span data-ttu-id="09f45-750">True</span><span class="sxs-lookup"><span data-stu-id="09f45-750">True</span></span>  
  
 <span data-ttu-id="09f45-751">False</span><span class="sxs-lookup"><span data-stu-id="09f45-751">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-752">Recherche les membres définis pour le <see cref="T:System.Type" /> actuel dont le <see cref="T:System.Reflection.DefaultMemberAttribute" /> est défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-752">Searches for the members defined for the current <see cref="T:System.Type" /> whose <see cref="T:System.Reflection.DefaultMemberAttribute" /> is set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-753">Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant tous les membres par défaut du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-753">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all default members of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="09f45-754">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-754">-or-</span>
          </span>
          <span data-ttu-id="09f45-755">Tableau vide du type <see cref="T:System.Reflection.MemberInfo" /> si le <see cref="T:System.Type" /> actuel n'a pas de membres par défaut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-755">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have default members.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-756">Le <xref:System.Type.GetDefaultMembers%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-756">The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-757">Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-757">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-758">Cette méthode peut être substituée par une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="09f45-758">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="09f45-759">Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="09f45-759">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="09f45-760">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-760">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-761">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-761">Member Type</span></span>|<span data-ttu-id="09f45-762">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-762">Static</span></span>|<span data-ttu-id="09f45-763">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-763">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-764">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-764">Constructor</span></span>|<span data-ttu-id="09f45-765">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-765">No</span></span>|<span data-ttu-id="09f45-766">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-766">No</span></span>|  
|<span data-ttu-id="09f45-767">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-767">Field</span></span>|<span data-ttu-id="09f45-768">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-768">No</span></span>|<span data-ttu-id="09f45-769">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-769">Yes.</span></span> <span data-ttu-id="09f45-770">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-770">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-771">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-771">Event</span></span>|<span data-ttu-id="09f45-772">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-772">Not applicable</span></span>|<span data-ttu-id="09f45-773">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-773">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-774">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-774">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-775">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-775">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-776">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-776">Method</span></span>|<span data-ttu-id="09f45-777">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-777">No</span></span>|<span data-ttu-id="09f45-778">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-778">Yes.</span></span> <span data-ttu-id="09f45-779">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-779">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-780">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-780">Nested Type</span></span>|<span data-ttu-id="09f45-781">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-781">No</span></span>|<span data-ttu-id="09f45-782">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-782">No</span></span>|  
|<span data-ttu-id="09f45-783">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-783">Property</span></span>|<span data-ttu-id="09f45-784">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-784">Not applicable</span></span>|<span data-ttu-id="09f45-785">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-785">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-786">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-786">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-787">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-787">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-788">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-788">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-789">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-789">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-790">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-790">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-791">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-791">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-792">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-792">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="09f45-793">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.MemberInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-793">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="09f45-794">Par exemple, si classe `C<T>` a une propriété `P` qui retourne `T`, l’appel <xref:System.Type.GetDefaultMembers%2A> sur `C<int>` retourne `int P` en c# (`Property P As Integer` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-794">For example, if class `C<T>` has a property `P` that returns `T`, calling <xref:System.Type.GetDefaultMembers%2A> on `C<int>` returns `int P` in C# (`Property P As Integer` in Visual Basic).</span></span>  
  
 <span data-ttu-id="09f45-795">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-795">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-796">L’exemple suivant obtient les informations de membre par défaut de `MyClass` et affiche les membres par défaut.</span><span class="sxs-lookup"><span data-stu-id="09f45-796">The following example obtains the default member information of `MyClass` and displays the default members.</span></span>  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-797">En cas de substitution dans une classe dérivée, retourne le <see cref="T:System.Type" /> de l'objet englobé ou de l'objet auquel le tableau, pointeur ou type référence actuel fait référence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-797">When overridden in a derived class, returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or reference type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-798">
            <see cref="T:System.Type" /> de l'objet englobé ou auquel le tableau, pointeur ou type référence actuel fait référence, ou <see langword="null" /> si le <see cref="T:System.Type" /> actuel n'est pas un tableau ou un pointeur, ou n'est pas passé par référence ou représente un type générique ou un paramètre de type dans la définition d'un type ou d'une méthode générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-798">The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer, or reference type, or <see langword="null" /> if the current <see cref="T:System.Type" /> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-799">Cette méthode retourne `null` pour la <xref:System.Array> classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-799">This method returns `null` for the <xref:System.Array> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-800">L’exemple suivant montre comment utiliser le `GetElementType` (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-800">The following example demonstrates using the `GetElementType` method.</span></span>  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="09f45-801">Valeur dont le nom doit être récupéré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-801">The value whose name is to be retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-802">Retourne le nom de la constante qui a la valeur spécifiée, pour le type énumération actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-802">Returns the name of the constant that has the specified value, for the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-803">Nom du membre du type énumération actuel qui a la valeur spécifiée, ou <see langword="null" /> si une telle constante est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-803">The name of the member of the current enumeration type that has the specified value, or <see langword="null" /> if no such constant is found.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-804">Le type actuel n’est pas une énumération.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-804">The current type is not an enumeration.</span>
          </span>
          <span data-ttu-id="09f45-805">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-805">-or-</span>
          </span>
          <span data-ttu-id="09f45-806">
            <paramref name="value" /> n'est pas du type actuel et n'a pas le même type sous-jacent que le type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-806">
              <paramref name="value" /> is neither of the current type nor does it have the same underlying type as the current type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-807">
            <paramref name="value" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-807">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-808">Retourne les noms des membres du type énumération actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-808">Returns the names of the members of the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-809">Tableau qui contient les noms des membres de l'énumération.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-809">An array that contains the names of the members of the enumeration.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-810">Les éléments du tableau de valeur de retour sont triés par les valeurs binaires (autrement dit, les valeurs non signées) des constantes énumérées.</span><span class="sxs-lookup"><span data-stu-id="09f45-810">The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</span></span> <span data-ttu-id="09f45-811">Si le tableau contient des constantes énumérées avec la même valeur, l’ordre de leurs noms correspondants n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="09f45-811">If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-812">Le type actuel n’est pas une énumération.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-812">The current type is not an enumeration.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-813">Retourne le type sous-jacent du type énumération actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-813">Returns the underlying type of the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-814">Type sous-jacent de l'énumération actuelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-814">The underlying type of the current enumeration.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-815">Par défaut, le type sous-jacent d’une énumération en c# et Visual Basic est <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="09f45-815">By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>.</span></span> <span data-ttu-id="09f45-816">Autres types d’entiers peuvent être spécifiés.</span><span class="sxs-lookup"><span data-stu-id="09f45-816">Other integer types can be specified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-817">Le type actuel n’est pas une énumération.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-817">The current type is not an enumeration.</span>
          </span>
          <span data-ttu-id="09f45-818">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-818">-or-</span>
          </span>
          <span data-ttu-id="09f45-819">Le type d’énumération n’est pas valide, car il contient plusieurs champs d’instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-819">The enumeration type is not valid, because it contains more than one instance field.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-820">Retourne un tableau des valeurs des constantes dans le type énumération actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-820">Returns an array of the values of the constants in the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-821">Tableau qui contient les valeurs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-821">An array that contains the values.</span>
          </span>
          <span data-ttu-id="09f45-822">Les éléments du tableau sont triés en fonction des valeurs binaires (à savoir les valeurs non signées) des constantes de l'énumération.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-822">The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-823">Le type actuel n’est pas une énumération.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-823">The current type is not an enumeration.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-824">Obtient un événement spécifique déclaré ou hérité par le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-824">Gets a specific event declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-825">Chaîne contenant le nom d'un événement déclaré ou hérité par le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-825">The string containing the name of an event that is declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-826">Retourne l'objet <see cref="T:System.Reflection.EventInfo" /> représentant l'événement public spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-826">Returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified public event.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-827">Objet représentant l'événement public spécifié qui est déclaré ou hérité par le <see cref="T:System.Type" /> actuel, s'il est trouvé ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-827">The object representing the specified public event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-828">Un événement est considérée comme publique de la réflexion s’il a au moins une méthode ou l’accesseur est public.</span><span class="sxs-lookup"><span data-stu-id="09f45-828">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="09f45-829">Sinon, l’événement est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.</span><span class="sxs-lookup"><span data-stu-id="09f45-829">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="09f45-830">La recherche de `name` respecte la casse.</span><span class="sxs-lookup"><span data-stu-id="09f45-830">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="09f45-831">La recherche inclut les événements d’instance public de static et public.</span><span class="sxs-lookup"><span data-stu-id="09f45-831">The search includes public static and public instance events.</span></span>  
  
 <span data-ttu-id="09f45-832">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-832">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-833">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-833">Member Type</span></span>|<span data-ttu-id="09f45-834">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-834">Static</span></span>|<span data-ttu-id="09f45-835">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-835">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-836">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-836">Constructor</span></span>|<span data-ttu-id="09f45-837">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-837">No</span></span>|<span data-ttu-id="09f45-838">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-838">No</span></span>|  
|<span data-ttu-id="09f45-839">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-839">Field</span></span>|<span data-ttu-id="09f45-840">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-840">No</span></span>|<span data-ttu-id="09f45-841">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-841">Yes.</span></span> <span data-ttu-id="09f45-842">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-842">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-843">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-843">Event</span></span>|<span data-ttu-id="09f45-844">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-844">Not applicable</span></span>|<span data-ttu-id="09f45-845">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-845">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-846">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-846">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-847">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-847">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-848">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-848">Method</span></span>|<span data-ttu-id="09f45-849">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-849">No</span></span>|<span data-ttu-id="09f45-850">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-850">Yes.</span></span> <span data-ttu-id="09f45-851">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-851">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-852">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-852">Nested Type</span></span>|<span data-ttu-id="09f45-853">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-853">No</span></span>|<span data-ttu-id="09f45-854">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-854">No</span></span>|  
|<span data-ttu-id="09f45-855">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-855">Property</span></span>|<span data-ttu-id="09f45-856">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-856">Not applicable</span></span>|<span data-ttu-id="09f45-857">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-857">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-858">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-858">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-859">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-859">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-860">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-860">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-861">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-861">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-862">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-862">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-863">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-863">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-864">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-864">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="09f45-865">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.EventInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-865">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-866">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les événements de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-866">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-867">L’exemple suivant crée un <xref:System.Reflection.EventInfo> de l’objet et obtient l’événement pour une classe de bouton pour l’événement spécifié.</span><span class="sxs-lookup"><span data-stu-id="09f45-867">The following example creates an <xref:System.Reflection.EventInfo> object and gets the event for a button class for the specified event.</span></span>  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-868">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-868">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-869">Chaîne contenant le nom d'un événement déclaré ou hérité par le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-869">The string containing the name of an event which is declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-870">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-870">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-871">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-871">-or-</span>
          </span>
          <span data-ttu-id="09f45-872">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-872">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-873">En cas de substitution dans une classe dérivée, retourne l'objet <see cref="T:System.Reflection.EventInfo" /> représentant l'événement spécifié, à l'aide des contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-873">When overridden in a derived class, returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified event, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-874">Objet représentant l'événement spécifié qui est déclaré ou hérité par le <see cref="T:System.Type" /> actuel, s'il est trouvé ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-874">The object representing the specified event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-875">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les événements à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-875">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-876">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-876">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-877">Spécifiez `BindingFlags.Public` pour inclure les événements publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-877">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="09f45-878">Spécifiez `BindingFlags.NonPublic` pour inclure les événements non publics (c'est-à-dire les événements privés, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-878">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span>  
  
-   <span data-ttu-id="09f45-879">Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-879">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="09f45-880">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-880">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-881">`BindingFlags.IgnoreCase` pour ignorer la casse de `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-881">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="09f45-882">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les événements déclarés sur le <xref:System.Type>, pas les événements qui ont été simplement hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-882">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-883">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-883">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-884">Un événement est considérée comme publique de la réflexion s’il a au moins une méthode ou l’accesseur est public.</span><span class="sxs-lookup"><span data-stu-id="09f45-884">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="09f45-885">Sinon, l’événement est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.</span><span class="sxs-lookup"><span data-stu-id="09f45-885">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="09f45-886">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.EventInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-886">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-887">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les événements de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-887">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-888">Le code suivant exemple utilise le <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> méthode pour rechercher un type pour un événement public ou non public nommé « Cliquez » qui n’est pas `static` (`Shared` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-888">The following code example uses the <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> method to search a type for a public or non-public event named "Click" that is not `static` (`Shared` in Visual Basic).</span></span>  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-889">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-889">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-890">Obtient les événements qui sont déclarés ou hérités par le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-890">Gets the events that are declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-891">Retourne tous les événements publics qui sont déclarés ou hérités par le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-891">Returns all the public events that are declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-892">Tableau d'objets <see cref="T:System.Reflection.EventInfo" /> représentant tous les événements publics qui sont déclarés ou hérités par le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-892">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events which are declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="09f45-893">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-893">-or-</span>
          </span>
          <span data-ttu-id="09f45-894">Tableau vide du type <see cref="T:System.Reflection.EventInfo" /> si le <see cref="T:System.Type" /> actuel n'a pas d'événements publics.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-894">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have public events.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-895">Un événement est considérée comme publique de la réflexion s’il a au moins une méthode ou l’accesseur est public.</span><span class="sxs-lookup"><span data-stu-id="09f45-895">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="09f45-896">Sinon, l’événement est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.</span><span class="sxs-lookup"><span data-stu-id="09f45-896">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="09f45-897">Le <xref:System.Type.GetEvents%2A> méthode ne retourne pas les événements dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-897">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-898">Votre code ne doit pas dépendent l’ordre dans lequel les événements sont retournés, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-898">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-899">Cette méthode peut être substituée par une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="09f45-899">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="09f45-900">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-900">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-901">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-901">Member Type</span></span>|<span data-ttu-id="09f45-902">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-902">Static</span></span>|<span data-ttu-id="09f45-903">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-903">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-904">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-904">Constructor</span></span>|<span data-ttu-id="09f45-905">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-905">No</span></span>|<span data-ttu-id="09f45-906">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-906">No</span></span>|  
|<span data-ttu-id="09f45-907">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-907">Field</span></span>|<span data-ttu-id="09f45-908">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-908">No</span></span>|<span data-ttu-id="09f45-909">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-909">Yes.</span></span> <span data-ttu-id="09f45-910">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-910">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-911">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-911">Event</span></span>|<span data-ttu-id="09f45-912">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-912">Not applicable</span></span>|<span data-ttu-id="09f45-913">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-913">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-914">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-914">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-915">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-915">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-916">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-916">Method</span></span>|<span data-ttu-id="09f45-917">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-917">No</span></span>|<span data-ttu-id="09f45-918">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-918">Yes.</span></span> <span data-ttu-id="09f45-919">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-919">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-920">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-920">Nested Type</span></span>|<span data-ttu-id="09f45-921">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-921">No</span></span>|<span data-ttu-id="09f45-922">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-922">No</span></span>|  
|<span data-ttu-id="09f45-923">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-923">Property</span></span>|<span data-ttu-id="09f45-924">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-924">Not applicable</span></span>|<span data-ttu-id="09f45-925">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-925">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-926">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-926">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-927">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-927">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-928">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-928">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-929">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-929">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-930">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-930">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-931">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-931">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-932">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-932">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="09f45-933">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.EventInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-933">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-934">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les événements de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-934">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-935">L’exemple suivant obtient un tableau de <xref:System.Reflection.EventInfo> des objets, tous les événements pour un `Button` de classe et affiche les noms des événements.</span><span class="sxs-lookup"><span data-stu-id="09f45-935">The following example obtains an array of <xref:System.Reflection.EventInfo> objects, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="09f45-936">Pour compiler l’exemple Visual Basic, utilisez la ligne de commande suivante :</span><span class="sxs-lookup"><span data-stu-id="09f45-936">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-937">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-937">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-938">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-938">-or-</span>
          </span>
          <span data-ttu-id="09f45-939">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-939">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-940">En cas de substitution dans une classe dérivée, recherche les événements qui sont déclarés ou hérités par le <see cref="T:System.Type" /> actuel, à l'aide des contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-940">When overridden in a derived class, searches for events that are declared or inherited by the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-941">Tableau d'objets <see cref="T:System.Reflection.EventInfo" /> représentant tous les événements qui sont déclarés ou hérités par le <see cref="T:System.Type" /> actuel et correspondent aux contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-941">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all events that are declared or inherited by the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="09f45-942">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-942">-or-</span>
          </span>
          <span data-ttu-id="09f45-943">Tableau vide du type <see cref="T:System.Reflection.EventInfo" /> si le <see cref="T:System.Type" /> actuel n'a pas d'événements ou si aucun des événements ne correspond aux contraintes de liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-943">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have events, or if none of the events match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-944">Le <xref:System.Type.GetEvents%2A> méthode ne retourne pas les événements dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-944">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-945">Votre code ne doit pas dépendent l’ordre dans lequel les événements sont retournés, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-945">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-946">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les événements à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-946">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-947">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-947">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-948">Spécifiez `BindingFlags.Public` pour inclure les événements publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-948">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="09f45-949">Spécifiez `BindingFlags.NonPublic` pour inclure les événements non publics (c'est-à-dire les événements privés, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-949">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span> <span data-ttu-id="09f45-950">Seuls protégés et des événements internes sur les classes de base sont retournés ; événements privés sur les classes de base ne sont pas retournés.</span><span class="sxs-lookup"><span data-stu-id="09f45-950">Only protected and internal events on base classes are returned; private events on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="09f45-951">Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-951">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="09f45-952">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-952">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-953">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les événements déclarés sur le <xref:System.Type>, pas les événements qui ont été simplement hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-953">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-954">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-954">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-955">Un événement est considérée comme publique de la réflexion s’il a au moins une méthode ou l’accesseur est public.</span><span class="sxs-lookup"><span data-stu-id="09f45-955">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="09f45-956">Sinon, l’événement est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.</span><span class="sxs-lookup"><span data-stu-id="09f45-956">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="09f45-957">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.EventInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-957">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-958">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les événements de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-958">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-959">L’exemple suivant obtient un tableau de <xref:System.Reflection.EventInfo> objets qui correspondent aux indicateurs de liaison spécifiés, obtient tous les événements pour un `Button` de classe et affiche les noms des événements.</span><span class="sxs-lookup"><span data-stu-id="09f45-959">The following example obtains an array of <xref:System.Reflection.EventInfo> objects that match the specified binding flags, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="09f45-960">Pour compiler l’exemple Visual Basic, utilisez la ligne de commande suivante :</span><span class="sxs-lookup"><span data-stu-id="09f45-960">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-961">Obtient un champ spécifique du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-961">Gets a specific field of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-962">Chaîne contenant le nom du champ de données à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-962">The string containing the name of the data field to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-963">Recherche le champ public portant le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-963">Searches for the public field with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-964">Objet représentant le champ public avec le nom spécifié, s'il est trouvé ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-964">An object representing the public field with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-965">La recherche de `name` respecte la casse.</span><span class="sxs-lookup"><span data-stu-id="09f45-965">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="09f45-966">La recherche inclut des champs d’instance publics de static et public.</span><span class="sxs-lookup"><span data-stu-id="09f45-966">The search includes public static and public instance fields.</span></span>  
  
 <span data-ttu-id="09f45-967">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.FieldInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-967">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-968">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les champs de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-968">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-969">L’exemple suivant obtient la `Type` de l’objet pour la classe spécifiée, qui obtient le <xref:System.Reflection.FieldInfo> objet pour le champ et affiche la valeur du champ.</span><span class="sxs-lookup"><span data-stu-id="09f45-969">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-970">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-970">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-971">Cet objet <see cref="T:System.Type" /> est un <see cref="T:System.Reflection.Emit.TypeBuilder" /> dont la méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> n'a pas encore été appelée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-971">This <see cref="T:System.Type" /> object is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> whose <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has not yet been called.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-972">Chaîne contenant le nom du champ de données à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-972">The string containing the name of the data field to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-973">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-973">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-974">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-974">-or-</span>
          </span>
          <span data-ttu-id="09f45-975">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-975">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-976">Recherche le champ spécifié, à l’aide des contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-976">Searches for the specified field, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-977">Objet représentant le champ qui correspond aux critères spécifiés, s'il est trouvé ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-977">An object representing the field that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-978">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-978">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-979">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-979">Member Type</span></span>|<span data-ttu-id="09f45-980">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-980">Static</span></span>|<span data-ttu-id="09f45-981">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-981">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-982">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-982">Constructor</span></span>|<span data-ttu-id="09f45-983">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-983">No</span></span>|<span data-ttu-id="09f45-984">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-984">No</span></span>|  
|<span data-ttu-id="09f45-985">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-985">Field</span></span>|<span data-ttu-id="09f45-986">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-986">No</span></span>|<span data-ttu-id="09f45-987">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-987">Yes.</span></span> <span data-ttu-id="09f45-988">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-988">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-989">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-989">Event</span></span>|<span data-ttu-id="09f45-990">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-990">Not applicable</span></span>|<span data-ttu-id="09f45-991">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-991">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-992">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-992">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-993">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-993">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-994">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-994">Method</span></span>|<span data-ttu-id="09f45-995">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-995">No</span></span>|<span data-ttu-id="09f45-996">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-996">Yes.</span></span> <span data-ttu-id="09f45-997">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-997">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-998">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-998">Nested Type</span></span>|<span data-ttu-id="09f45-999">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-999">No</span></span>|<span data-ttu-id="09f45-1000">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1000">No</span></span>|  
|<span data-ttu-id="09f45-1001">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-1001">Property</span></span>|<span data-ttu-id="09f45-1002">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1002">Not applicable</span></span>|<span data-ttu-id="09f45-1003">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1003">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1004">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1004">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1005">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1005">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-1006">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1006">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-1007">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-1007">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-1008">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1008">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1009">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-1009">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-1010">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-1010">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="09f45-1011">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les champs à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1011">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-1012">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1012">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-1013">Spécifiez `BindingFlags.Public` pour inclure les champs publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1013">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1014">Spécifiez `BindingFlags.NonPublic` pour inclure les champs non publics (autrement dit, les champs privés, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1014">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1015">Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-1015">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="09f45-1016">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1016">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-1017">`BindingFlags.IgnoreCase` pour ignorer la casse de `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1017">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="09f45-1018">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les champs déclarés sur le <xref:System.Type>, pas les champs qui ont été simplement hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-1018">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-1019">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1019">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-1020">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.FieldInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1020">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1021">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les champs de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1021">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1022">L’exemple suivant obtient la `Type` de l’objet pour la classe spécifiée, qui obtient le <xref:System.Reflection.FieldInfo> objet pour le champ qui correspond aux indicateurs de liaison spécifiés et affiche la valeur du champ.</span><span class="sxs-lookup"><span data-stu-id="09f45-1022">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field that matches the specified binding flags, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1023">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1023">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1024">Obtient les champs du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1024">Gets the fields of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1025">Retourne tous les champs publics du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1025">Returns all the public fields of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1026">Tableau d'objets <see cref="T:System.Reflection.FieldInfo" /> représentant tous les champs publics définis pour le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1026">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all the public fields defined for the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="09f45-1027">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1027">-or-</span>
          </span>
          <span data-ttu-id="09f45-1028">Tableau vide du type <see cref="T:System.Reflection.FieldInfo" /> si aucun champ public n'est défini pour le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1028">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no public fields are defined for the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1029">Le <xref:System.Type.GetFields%2A> méthode ne retourne pas les champs dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-1029">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-1030">Votre code ne doit pas dépendent l’ordre dans lequel les champs sont retournés, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-1030">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-1031">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1031">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-1032">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-1032">Member Type</span></span>|<span data-ttu-id="09f45-1033">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-1033">Static</span></span>|<span data-ttu-id="09f45-1034">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-1034">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-1035">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-1035">Constructor</span></span>|<span data-ttu-id="09f45-1036">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1036">No</span></span>|<span data-ttu-id="09f45-1037">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1037">No</span></span>|  
|<span data-ttu-id="09f45-1038">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-1038">Field</span></span>|<span data-ttu-id="09f45-1039">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1039">No</span></span>|<span data-ttu-id="09f45-1040">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-1040">Yes.</span></span> <span data-ttu-id="09f45-1041">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1041">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-1042">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-1042">Event</span></span>|<span data-ttu-id="09f45-1043">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1043">Not applicable</span></span>|<span data-ttu-id="09f45-1044">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1044">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1045">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1045">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1046">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1046">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-1047">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-1047">Method</span></span>|<span data-ttu-id="09f45-1048">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1048">No</span></span>|<span data-ttu-id="09f45-1049">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-1049">Yes.</span></span> <span data-ttu-id="09f45-1050">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1050">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-1051">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-1051">Nested Type</span></span>|<span data-ttu-id="09f45-1052">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1052">No</span></span>|<span data-ttu-id="09f45-1053">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1053">No</span></span>|  
|<span data-ttu-id="09f45-1054">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-1054">Property</span></span>|<span data-ttu-id="09f45-1055">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1055">Not applicable</span></span>|<span data-ttu-id="09f45-1056">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1056">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1057">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1057">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1058">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1058">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-1059">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1059">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-1060">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-1060">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-1061">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1061">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1062">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-1062">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-1063">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-1063">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="09f45-1064">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.FieldInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1064">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1065">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les champs publics de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1065">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1066">L’exemple suivant illustre une utilisation de la `GetFields()` (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-1066">The following example shows a use of the `GetFields()` method.</span></span>  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-1067">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1067">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-1068">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1068">-or-</span>
          </span>
          <span data-ttu-id="09f45-1069">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1069">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1070">En cas de substitution dans une classe dérivée, recherche les champs définis pour le <see cref="T:System.Type" /> actuel, à l'aide des contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1070">When overridden in a derived class, searches for the fields defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1071">Tableau d'objets <see cref="T:System.Reflection.FieldInfo" /> représentant tous les champs définis pour le <see cref="T:System.Type" /> actuel qui correspondent aux contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1071">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all fields defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="09f45-1072">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1072">-or-</span>
          </span>
          <span data-ttu-id="09f45-1073">Tableau vide du type <see cref="T:System.Reflection.FieldInfo" /> si aucun champ n'est défini pour le <see cref="T:System.Type" /> actuel ou si aucun des champs définis ne correspond aux contraintes de liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1073">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no fields are defined for the current <see cref="T:System.Type" />, or if none of the defined fields match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1074">Le <xref:System.Type.GetFields%2A> méthode ne retourne pas les champs dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-1074">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-1075">Votre code ne doit pas dépendent l’ordre dans lequel les champs sont retournés, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-1075">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-1076">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les champs à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1076">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-1077">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1077">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-1078">Spécifiez `BindingFlags.Public` pour inclure les champs publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1078">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1079">Spécifiez `BindingFlags.NonPublic` pour inclure les champs non publics (autrement dit, les champs privés, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1079">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span> <span data-ttu-id="09f45-1080">Seuls protégés et les champs internes sur les classes de base sont retournés ; les champs privés sur les classes de base ne sont pas retournés.</span><span class="sxs-lookup"><span data-stu-id="09f45-1080">Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="09f45-1081">Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-1081">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="09f45-1082">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1082">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-1083">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les champs déclarés sur le <xref:System.Type>, pas les champs qui ont été simplement hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-1083">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-1084">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1084">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-1085">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.FieldInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1085">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1086">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les champs publics de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1086">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1087">L’exemple suivant illustre une utilisation de la `GetFields(BindingFlags)` (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-1087">The following example shows a use of the `GetFields(BindingFlags)` method.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1088">Retourne un tableau d'objets <see cref="T:System.Type" /> qui représentent les arguments de type d'un type générique fermé ou les paramètres de type d'une définition de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1088">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1089">Tableau d'objets <see cref="T:System.Type" /> qui représentent les arguments de type d'un type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1089">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type.</span>
          </span>
          <span data-ttu-id="09f45-1090">Retourne un tableau vide si le type actuel n'est pas un type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1090">Returns an empty array if the current type is not a generic type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1091">Les éléments du tableau sont retournés dans l’ordre dans lequel elles apparaissent dans la liste d’arguments de type pour le type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-1091">The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</span></span>  
  
-   <span data-ttu-id="09f45-1092">Si le type actuel est un type construit fermé (autrement dit, le <xref:System.Type.ContainsGenericParameters%2A> propriété renvoie `false`), le tableau retourné par la <xref:System.Type.GetGenericArguments%2A> méthode contient les types qui ont été attribuées aux paramètres de type générique de la définition de type générique .</span><span class="sxs-lookup"><span data-stu-id="09f45-1092">If the current type is a closed constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Type.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic type definition.</span></span>  
  
-   <span data-ttu-id="09f45-1093">Si le type actuel est une définition de type générique, le tableau contient les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1093">If the current type is a generic type definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="09f45-1094">Si le type actuel est un type construit ouvert (autrement dit, le <xref:System.Type.ContainsGenericParameters%2A> propriété renvoie `true`) dans lequel des types spécifiques n’ont pas été assignés à tous les paramètres de type et les paramètres de type de placer des types ou méthodes génériques, le tableau contient les types et les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1094">If the current type is an open constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</span></span> <span data-ttu-id="09f45-1095">Utilisez le <xref:System.Type.IsGenericParameter%2A> propriété pour les distinguer.</span><span class="sxs-lookup"><span data-stu-id="09f45-1095">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="09f45-1096">Pour une démonstration de ce scénario, consultez l’exemple de code pour le <xref:System.Type.ContainsGenericParameters%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1096">For a demonstration of this scenario, see the code example for the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="09f45-1097">Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1097">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1098">Le code suivant exemple utilise le <xref:System.Type.GetGenericArguments%2A> méthode pour afficher les arguments de type d’un type construit et les paramètres de type de sa définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-1098">The following code example uses the <xref:System.Type.GetGenericArguments%2A> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</span></span>  
  
 <span data-ttu-id="09f45-1099">Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.Type.IsGenericTypeDefinition%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1099">This code example is part of a larger example provided for the <xref:System.Type.IsGenericTypeDefinition%2A> property.</span></span> <span data-ttu-id="09f45-1100">Consultez l’exemple plus complet pour l’exemple de sortie.</span><span class="sxs-lookup"><span data-stu-id="09f45-1100">See the larger example for sample output.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-1101">La méthode appelée n’est pas prise en charge dans la classe de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1101">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="09f45-1102">Les classes dérivées doivent fournir une implémentation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1102">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1103">Retourne un tableau d'objets <see cref="T:System.Type" /> qui représentent les contraintes qui s'exercent sur le paramètre de type générique actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1103">Returns an array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1104">Tableau d'objets <see cref="T:System.Type" /> qui représentent les contraintes qui s'exercent sur le paramètre de type générique actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1104">An array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1105">Chaque contrainte sur un paramètre de type générique est exprimée comme une <xref:System.Type> objet.</span><span class="sxs-lookup"><span data-stu-id="09f45-1105">Each constraint on a generic type parameter is expressed as a <xref:System.Type> object.</span></span> <span data-ttu-id="09f45-1106">Utilisez le <xref:System.Type.IsClass%2A> propriété pour déterminer si une contrainte est la contrainte de classe de base ; si la propriété retourne `false`, la contrainte est une contrainte d’interface.</span><span class="sxs-lookup"><span data-stu-id="09f45-1106">Use the <xref:System.Type.IsClass%2A> property to determine whether a constraint is the base class constraint; if the property returns `false`, the constraint is an interface constraint.</span></span> <span data-ttu-id="09f45-1107">Si un paramètre de type a aucune contrainte de classe et les contraintes d’interface, un tableau vide est retourné.</span><span class="sxs-lookup"><span data-stu-id="09f45-1107">If a type parameter has no class constraint and no interface constraints, an empty array is returned.</span></span>  
  
 <span data-ttu-id="09f45-1108">Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1108">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1109">L’exemple de code suivant définit un type générique `Test` avec deux paramètres de type qui possèdent des contraintes différentes.</span><span class="sxs-lookup"><span data-stu-id="09f45-1109">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="09f45-1110">Lorsque le programme s’exécute, les contraintes sont examinées à l’aide de la <xref:System.Type.GenericParameterAttributes%2A> propriété et la <xref:System.Type.GetGenericParameterConstraints%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-1110">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="09f45-1111">L'objet <see cref="T:System.Type" /> actuel n'est pas un paramètre de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1111">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span>
          </span>
          <span data-ttu-id="09f45-1112">Autrement dit, la propriété <see cref="P:System.Type.IsGenericParameter" /> retourne <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1112">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1113">Retourne un objet <see cref="T:System.Type" /> qui représente une définition de type générique à partir de laquelle le type générique actuel peut être construit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1113">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current generic type can be constructed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1114">Objet <see cref="T:System.Type" /> représentant un type générique à partir duquel le type actuel peut être construit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1114">A <see cref="T:System.Type" /> object representing a generic type from which the current type can be constructed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1115">Une définition de type générique est un modèle à partir de laquelle d’autres types peuvent être construits.</span><span class="sxs-lookup"><span data-stu-id="09f45-1115">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="09f45-1116">Par exemple, à partir de la définition de type générique `G<T>` (exprimé en syntaxe c# ; `G(Of T)` en Visual Basic ou `generic <typename T> ref class G` en C++) vous pouvez construire et instancier le type `G<int>` (`G(Of Integer)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-1116">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic).</span></span> <span data-ttu-id="09f45-1117">Étant donné un <xref:System.Type> objet représentant ce type construit, le <xref:System.Type.GetGenericTypeDefinition%2A> méthode retourne la définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-1117">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the generic type definition.</span></span>  
  
 <span data-ttu-id="09f45-1118">Si deux types construits sont créés à partir de la même définition de type générique, à l’aide des mêmes arguments de type, le <xref:System.Type.GetGenericTypeDefinition%2A> méthode retourne la même <xref:System.Type> objet pour les deux types.</span><span class="sxs-lookup"><span data-stu-id="09f45-1118">If two constructed types are created from the same generic type definition, using the same type arguments, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the same <xref:System.Type> object for both types.</span></span>  
  
 <span data-ttu-id="09f45-1119">Si vous appelez le <xref:System.Type.GetGenericTypeDefinition%2A> méthode sur un <xref:System.Type> objet qui représente déjà une définition de type générique, elle renvoie l’actuel <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1119">If you call the <xref:System.Type.GetGenericTypeDefinition%2A> method on a <xref:System.Type> object that already represents a generic type definition, it returns the current <xref:System.Type>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="09f45-1120">Un tableau de types génériques n’est pas lui-même générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-1120">An array of generic types is not itself generic.</span></span> <span data-ttu-id="09f45-1121">Dans le code c# `A<int>[] v;` ou le code Visual Basic `Dim v() As A(Of Integer)`, le type de variable `v` n’est pas générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-1121">In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic.</span></span> <span data-ttu-id="09f45-1122">Utilisez <xref:System.Type.IsGenericType%2A> pour déterminer si un type est générique avant d’appeler <xref:System.Type.GetGenericTypeDefinition%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1122">Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>.</span></span>  
  
 <span data-ttu-id="09f45-1123">Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1123">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1124">L’exemple de code suivant crée une instance d’un type construit à l’aide de la création d’instance ordinaire, puis utilise le <xref:System.Type.GetType%2A> et <xref:System.Type.GetGenericTypeDefinition%2A> méthodes pour récupérer le type construit et la définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-1124">The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <xref:System.Type.GetType%2A> and <xref:System.Type.GetGenericTypeDefinition%2A> methods to retrieve the constructed type and the generic type definition.</span></span> <span data-ttu-id="09f45-1125">Cet exemple utilise le type générique <xref:System.Collections.Generic.Dictionary%602> type ; le type construit représente un <xref:System.Collections.Generic.Dictionary%602> de `Test` objets avec des clés de chaîne.</span><span class="sxs-lookup"><span data-stu-id="09f45-1125">This example uses the generic <xref:System.Collections.Generic.Dictionary%602> type; the constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="09f45-1126">Le type actuel n’est pas un type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1126">The current type is not a generic type.</span>
          </span>
          <span data-ttu-id="09f45-1127">Autrement dit, <see cref="P:System.Type.IsGenericType" /> retourne <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1127">That is, <see cref="P:System.Type.IsGenericType" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-1128">La méthode appelée n’est pas prise en charge dans la classe de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1128">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="09f45-1129">Les classes dérivées doivent fournir une implémentation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1129">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1130">Retourne le code de hachage de cette instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1130">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1131">Code de hachage de cette instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1131">The hash code for this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1132">Cette méthode se substitue à <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1132">This method overrides <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1133">L’exemple suivant affiche le code de hachage de la `System.Windows.Forms.Button` classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1133">The following example displays the hash code of the `System.Windows.Forms.Button` class.</span></span>  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1134">Obtient une interface spécifique implémentée ou héritée par le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1134">Gets a specific interface implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-1135">Chaîne contenant le nom de l'interface à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1135">The string containing the name of the interface to get.</span>
          </span>
          <span data-ttu-id="09f45-1136">Pour les interfaces génériques, il s'agit du nom tronqué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1136">For generic interfaces, this is the mangled name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1137">Recherche l'interface avec le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1137">Searches for the interface with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1138">Objet qui représente l'interface ayant le nom spécifié, implémentée ou héritée par le <see cref="T:System.Type" /> actuel, s'il est trouvé ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1138">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1139">La recherche de `name` respecte la casse.</span><span class="sxs-lookup"><span data-stu-id="09f45-1139">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="09f45-1140">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Type> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1140">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1141">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les contraintes d’interface et toutes les interfaces héritées des contraintes de classe ou interface.</span><span class="sxs-lookup"><span data-stu-id="09f45-1141">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1142">Pour les interfaces génériques, le `name` paramètre est le nom tronqué, se terminant par un accent grave (\`) et le nombre de paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1142">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="09f45-1143">Cela est vrai pour les définitions d’interface générique et les interfaces génériques construits.</span><span class="sxs-lookup"><span data-stu-id="09f45-1143">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="09f45-1144">Par exemple, pour rechercher `IExample<T>` (`IExample(Of T)` en Visual Basic) ou `IExample<string>` (`IExample(Of String)` en Visual Basic), recherchez ``"IExample`1"``.</span><span class="sxs-lookup"><span data-stu-id="09f45-1144">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``"IExample`1"``.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1145">Le de code suivant montre comment utiliser le <xref:System.Type.GetInterface%28System.String%29> méthode pour rechercher le <xref:System.Collections.Hashtable> de classes pour la <xref:System.Runtime.Serialization.IDeserializationCallback> interface et répertorie les méthodes de l’interface.</span><span class="sxs-lookup"><span data-stu-id="09f45-1145">The following code example uses the <xref:System.Type.GetInterface%28System.String%29> method to search the <xref:System.Collections.Hashtable> class for the <xref:System.Runtime.Serialization.IDeserializationCallback> interface, and lists the methods of the interface.</span></span>  
  
 <span data-ttu-id="09f45-1146">L’exemple de code montre également le <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> surcharge de méthode et la <xref:System.Type.GetInterfaceMap%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-1146">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1147">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1147">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-1148">Le <see cref="T:System.Type" /> actuel représente un type qui implémente la même interface générique avec des arguments de type différents.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1148">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-1149">Chaîne contenant le nom de l'interface à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1149">The string containing the name of the interface to get.</span>
          </span>
          <span data-ttu-id="09f45-1150">Pour les interfaces génériques, il s'agit du nom tronqué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1150">For generic interfaces, this is the mangled name.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="09f45-1151">
            <see langword="true" /> pour ignorer la casse de cette partie de <c>name</c> qui spécifie le nom d’interface simple (la casse de la partie qui spécifie l’espace de noms doit être respectée).</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1151">
              <see langword="true" /> to ignore the case of that part of <c>name</c> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</span>
          </span>
          <span data-ttu-id="09f45-1152">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1152">-or-</span>
          </span>
          <span data-ttu-id="09f45-1153">
            <see langword="false" /> pour effectuer une recherche qui respecte la casse de toutes les parties de <c>name</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1153">
              <see langword="false" /> to perform a case-sensitive search for all parts of <c>name</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1154">En cas de substitution dans une classe dérivée, recherche l'interface spécifiée, en indiquant s'il faut faire une recherche qui ne respecte pas la casse pour le nom de l'interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1154">When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1155">Objet qui représente l'interface ayant le nom spécifié, implémentée ou héritée par le <see cref="T:System.Type" /> actuel, s'il est trouvé ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1155">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1156">Le `ignoreCase` paramètre s’applique uniquement au nom d’interface simple, pas à l’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="09f45-1156">The `ignoreCase` parameter applies only to the simple interface name, not to the namespace.</span></span> <span data-ttu-id="09f45-1157">La partie de `name` qui spécifie l’espace de noms doive respecter la casse, ou l’interface est introuvable.</span><span class="sxs-lookup"><span data-stu-id="09f45-1157">The portion of `name` that specifies the namespace must have the correct case, or the interface will not be found.</span></span> <span data-ttu-id="09f45-1158">Par exemple, la chaîne « System.icomparable » recherche les <xref:System.IComparable> interface, mais la chaîne « system.icomparable » n’est pas.</span><span class="sxs-lookup"><span data-stu-id="09f45-1158">For example, the string "System.icomparable" finds the <xref:System.IComparable> interface, but the string "system.icomparable" does not.</span></span>  
  
 <span data-ttu-id="09f45-1159">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Type> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1159">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1160">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les contraintes d’interface et toutes les interfaces héritées des contraintes de classe ou interface.</span><span class="sxs-lookup"><span data-stu-id="09f45-1160">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1161">Pour les interfaces génériques, le `name` paramètre est le nom tronqué, se terminant par un accent grave (\`) et le nombre de paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1161">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="09f45-1162">Cela est vrai pour les définitions d’interface générique et les interfaces génériques construits.</span><span class="sxs-lookup"><span data-stu-id="09f45-1162">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="09f45-1163">Par exemple, pour rechercher `IExample<T>` (`IExample(Of T)` en Visual Basic) ou `IExample<string>` (`IExample(Of String)` en Visual Basic), recherchez `"IExample`1 » '.</span><span class="sxs-lookup"><span data-stu-id="09f45-1163">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `"IExample`1"\`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1164">Le de code suivant montre comment utiliser le <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> méthode pour effectuer une recherche sans respecter la casse de la <xref:System.Collections.Hashtable> de classes pour la <xref:System.Collections.IEnumerable> interface.</span><span class="sxs-lookup"><span data-stu-id="09f45-1164">The following code example uses the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method to perform a case-insensitive search of the <xref:System.Collections.Hashtable> class for the <xref:System.Collections.IEnumerable> interface.</span></span>  
  
 <span data-ttu-id="09f45-1165">L’exemple de code montre également le <xref:System.Type.GetInterface%28System.String%29> surcharge de méthode et la <xref:System.Type.GetInterfaceMap%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-1165">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1166">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1166">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-1167">Le <see cref="T:System.Type" /> actuel représente un type qui implémente la même interface générique avec des arguments de type différents.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1167">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <span data-ttu-id="09f45-1168">Type d'interface pour lequel extraire un mappage.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1168">The interface type to retrieve a mapping for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1169">Retourne un mappage d'interface pour le type interface spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1169">Returns an interface mapping for the specified interface type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1170">Objet qui représente le mappage d'interface pour <paramref name="interfaceType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1170">An object that represents the interface mapping for <paramref name="interfaceType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1171">Le mappage d’interface indique le mode de mappage d’une interface dans les membres réels sur une classe qui implémente cette interface.</span><span class="sxs-lookup"><span data-stu-id="09f45-1171">The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</span></span>  
  
 <span data-ttu-id="09f45-1172">Si actuel <xref:System.Type> représente un type générique construit, type de paramètres sont remplacés par les arguments de type appropriés dans les éléments de la <xref:System.Reflection.InterfaceMapping> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="09f45-1172">If the current <xref:System.Type> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <xref:System.Reflection.InterfaceMapping> returned by this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1173">L’exemple suivant appelle la <xref:System.Type.GetInterfaceMap%2A> méthode pour déterminer comment la <xref:System.IFormatProvider> interface mappe à <xref:System.Globalization.CultureInfo> méthodes et comment la <xref:System.IAppDomainSetup> interface mappe à <xref:System.AppDomainSetup> propriétés.</span><span class="sxs-lookup"><span data-stu-id="09f45-1173">The following example calls the <xref:System.Type.GetInterfaceMap%2A> method to determine how the <xref:System.IFormatProvider> interface maps to <xref:System.Globalization.CultureInfo> methods, and how the <xref:System.IAppDomainSetup> interface maps to <xref:System.AppDomainSetup> properties.</span></span> <span data-ttu-id="09f45-1174">Notez que, étant donné que la <xref:System.IAppDomainSetup> interface définit un ensemble de propriétés, retournés <xref:System.Reflection.InterfaceMapping> objet inclut distinct <xref:System.Reflection.MethodInfo> objets pour d’une propriété accesseurs get et set.</span><span class="sxs-lookup"><span data-stu-id="09f45-1174">Note that, because the <xref:System.IAppDomainSetup> interface defines a set of properties, the returned <xref:System.Reflection.InterfaceMapping> object includes separate <xref:System.Reflection.MethodInfo> objects for a property's get and set accessors.</span></span>  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-1175">
            <paramref name="interfaceType" /> n'est pas implémenté par le type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1175">
              <paramref name="interfaceType" /> is not implemented by the current type.</span>
          </span>
          <span data-ttu-id="09f45-1176">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1176">-or-</span>
          </span>
          <span data-ttu-id="09f45-1177">Le paramètre <paramref name="interfaceType" /> ne fait pas référence à une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1177">The <paramref name="interfaceType" /> parameter does not refer to an interface.</span>
          </span>
          <span data-ttu-id="09f45-1178">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1178">-or-</span>
          </span>
          <span data-ttu-id="09f45-1179">
            <paramref name="interfaceType" /> est une interface générique et le type actuel est un type de tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1179">
              <paramref name="interfaceType" /> is a generic interface, and the current type is an array type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1180">
            <paramref name="interfaceType" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1180">
              <paramref name="interfaceType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="09f45-1181">Le <see cref="T:System.Type" /> actuel représente un paramètre de type générique ; c'est-à-dire que <see cref="P:System.Type.IsGenericParameter" /> a la valeur <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1181">The current <see cref="T:System.Type" /> represents a generic type parameter; that is, <see cref="P:System.Type.IsGenericParameter" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-1182">La méthode appelée n’est pas prise en charge dans la classe de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1182">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="09f45-1183">Les classes dérivées doivent fournir une implémentation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1183">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1184">En cas de substitution dans une classe dérivée, obtient toutes les interfaces implémentées ou héritées par le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1184">When overridden in a derived class, gets all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1185">Tableau d'objets <see cref="T:System.Type" /> représentant toutes les interfaces implémentées ou héritées par le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1185">An array of <see cref="T:System.Type" /> objects representing all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="09f45-1186">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1186">-or-</span>
          </span>
          <span data-ttu-id="09f45-1187">Tableau vide du type <see cref="T:System.Type" /> si aucune interface n'est implémentée ou héritée par le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1187">An empty array of type <see cref="T:System.Type" />, if no interfaces are implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1188">Le <xref:System.Type.GetInterfaces%2A> méthode ne retourne pas les interfaces dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-1188">The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-1189">Votre code ne doit pas dépendent l’ordre dans lequel les interfaces sont retournées, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-1189">Your code must not depend on the order in which interfaces are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-1190">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Type> objets avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1190">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1191">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les contraintes d’interface et toutes les interfaces héritées des contraintes de classe ou interface.</span><span class="sxs-lookup"><span data-stu-id="09f45-1191">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1192">L’exemple suivant obtient le type de la classe spécifiée et affiche toutes les interfaces que le type implémente ou en hérite.</span><span class="sxs-lookup"><span data-stu-id="09f45-1192">The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</span></span> <span data-ttu-id="09f45-1193">Pour compiler l’exemple Visual Basic, utilisez les commandes de compilateur suivantes :</span><span class="sxs-lookup"><span data-stu-id="09f45-1193">To compile the Visual Basic example, use the following compiler commands:</span></span>  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="09f45-1194">Un initialiseur de classe est appelé et lève une exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1194">A static initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1195">Obtient les membres spécifiés du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1195">Gets the specified members of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-1196">Chaîne contenant le nom des membres publics à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1196">The string containing the name of the public members to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1197">Recherche les membres publics portant le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1197">Searches for the public members with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1198">Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant les membres publics portant le nom spécifié, si ces objets sont trouvés ; sinon, un tableau vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1198">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1199">La recherche de `name` respecte la casse.</span><span class="sxs-lookup"><span data-stu-id="09f45-1199">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="09f45-1200">La recherche inclut les membres d’instance publics de static et public.</span><span class="sxs-lookup"><span data-stu-id="09f45-1200">The search includes public static and public instance members.</span></span>  
  
 <span data-ttu-id="09f45-1201">Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="09f45-1201">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="09f45-1202">Le <xref:System.Type.GetMember%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-1202">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-1203">Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-1203">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-1204">Cette surcharge de méthode ne trouvera pas d’initialiseurs de classe (.cctor).</span><span class="sxs-lookup"><span data-stu-id="09f45-1204">This method overload will not find class initializers (.cctor).</span></span> <span data-ttu-id="09f45-1205">Pour rechercher des initialiseurs de classe, utilisez une surcharge qui accepte <xref:System.Reflection.BindingFlags>et spécifiez <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-1205">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="09f45-1206">Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1206">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="09f45-1207">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1207">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-1208">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-1208">Member Type</span></span>|<span data-ttu-id="09f45-1209">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-1209">Static</span></span>|<span data-ttu-id="09f45-1210">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-1210">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-1211">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-1211">Constructor</span></span>|<span data-ttu-id="09f45-1212">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1212">No</span></span>|<span data-ttu-id="09f45-1213">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1213">No</span></span>|  
|<span data-ttu-id="09f45-1214">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-1214">Field</span></span>|<span data-ttu-id="09f45-1215">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1215">No</span></span>|<span data-ttu-id="09f45-1216">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-1216">Yes.</span></span> <span data-ttu-id="09f45-1217">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1217">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-1218">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-1218">Event</span></span>|<span data-ttu-id="09f45-1219">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1219">Not applicable</span></span>|<span data-ttu-id="09f45-1220">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1220">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1221">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1221">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1222">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1222">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-1223">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-1223">Method</span></span>|<span data-ttu-id="09f45-1224">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1224">No</span></span>|<span data-ttu-id="09f45-1225">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-1225">Yes.</span></span> <span data-ttu-id="09f45-1226">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1226">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-1227">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-1227">Nested Type</span></span>|<span data-ttu-id="09f45-1228">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1228">No</span></span>|<span data-ttu-id="09f45-1229">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1229">No</span></span>|  
|<span data-ttu-id="09f45-1230">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-1230">Property</span></span>|<span data-ttu-id="09f45-1231">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1231">Not applicable</span></span>|<span data-ttu-id="09f45-1232">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1232">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1233">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1233">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1234">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1234">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-1235">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1235">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-1236">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-1236">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-1237">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1237">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1238">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-1238">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-1239">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-1239">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="09f45-1240">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MemberInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1240">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1241">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1241">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1242">Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1242">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="09f45-1243">Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1243">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1244">L’exemple suivant affiche tous les membres de la `String` classe qui commencent par la lettre C.</span><span class="sxs-lookup"><span data-stu-id="09f45-1244">The following example displays all the members of the `String` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1245">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1245">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-1246">Chaîne contenant le nom des membres à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1246">The string containing the name of the members to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-1247">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1247">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-1248">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1248">-or-</span>
          </span>
          <span data-ttu-id="09f45-1249">Zéro, pour retourner un tableau vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1249">Zero, to return an empty array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1250">Recherche les membres spécifiés, à l’aide des contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1250">Searches for the specified members, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1251">Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant les membres publics portant le nom spécifié, si ces objets sont trouvés ; sinon, un tableau vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1251">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1252">Cette méthode peut être substituée par une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="09f45-1252">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="09f45-1253">Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="09f45-1253">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="09f45-1254">Le <xref:System.Type.GetMember%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-1254">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-1255">Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-1255">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-1256">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1256">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-1257">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1257">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-1258">Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1258">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1259">Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1259">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1260">Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-1260">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="09f45-1261">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1261">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-1262">`BindingFlags.IgnoreCase` pour ignorer la casse de `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1262">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="09f45-1263">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-1263">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-1264">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1264">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-1265">Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette surcharge de méthode, vous devez spécifier « .cctor » pour `name`, et <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic) pour `bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1265">To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for `name`, and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="09f45-1266">Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1266">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="09f45-1267">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MemberInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1267">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1268">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1268">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1269">Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1269">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="09f45-1270">Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1270">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1271">L’exemple suivant affiche tous les membres statiques publics de la `myString` classe qui commencent par la lettre C.</span><span class="sxs-lookup"><span data-stu-id="09f45-1271">The following example displays all the public static members of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1272">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1272">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-1273">Chaîne contenant le nom des membres à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1273">The string containing the name of the members to get.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="09f45-1274">La valeur à rechercher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1274">The value to search for.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-1275">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1275">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-1276">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1276">-or-</span>
          </span>
          <span data-ttu-id="09f45-1277">Zéro, pour retourner un tableau vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1277">Zero, to return an empty array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1278">Recherche les membres spécifiés du type de membre spécifié, à l’aide des contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1278">Searches for the specified members of the specified member type, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1279">Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant les membres publics portant le nom spécifié, si ces objets sont trouvés ; sinon, un tableau vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1279">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1280">Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="09f45-1280">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="09f45-1281">Le <xref:System.Type.GetMember%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-1281">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-1282">Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-1282">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-1283">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1283">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-1284">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1284">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-1285">Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1285">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1286">Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1286">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1287">Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-1287">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="09f45-1288">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1288">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-1289">`BindingFlags.IgnoreCase` pour ignorer la casse de `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1289">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="09f45-1290">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-1290">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-1291">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1291">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-1292">Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette surcharge de méthode, vous devez spécifier « .cctor » pour `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> pour `type`, et <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> dans Visual Basic) pour `bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1292">To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> for `type`, and  <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="09f45-1293">Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1293">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="09f45-1294">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MemberInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1294">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1295">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1295">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1296">Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1296">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="09f45-1297">Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1297">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1298">L’exemple suivant affiche toutes les méthodes de la `myString` classe qui commencent par la lettre C.</span><span class="sxs-lookup"><span data-stu-id="09f45-1298">The following example displays all the methods of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1299">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1299">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-1300">Une classe dérivée doit fournir une implémentation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1300">A derived class must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1301">Obtient les membres (propriétés, méthodes, champs, événements, etc.) du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1301">Gets the members (properties, methods, fields, events, and so on) of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1302">Retourne tous les membres publics du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1302">Returns all the public members of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1303">Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant tous les membres publics du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1303">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all the public members of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="09f45-1304">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1304">-or-</span>
          </span>
          <span data-ttu-id="09f45-1305">Tableau vide du type <see cref="T:System.Reflection.MemberInfo" /> si le <see cref="T:System.Type" /> actuel n'a pas de membres publics.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1305">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have public members.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1306">Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="09f45-1306">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="09f45-1307">Le <xref:System.Type.GetMembers%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-1307">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-1308">Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-1308">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-1309">Cette surcharge de méthode appelle la <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> la surcharge de méthode, avec <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-1309">This method overload calls the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="09f45-1310">Elle ne trouvera pas d’initialiseurs de classe (.cctor).</span><span class="sxs-lookup"><span data-stu-id="09f45-1310">It will not find class initializers (.cctor).</span></span> <span data-ttu-id="09f45-1311">Pour rechercher des initialiseurs de classe, utilisez une surcharge qui accepte <xref:System.Reflection.BindingFlags>et spécifiez <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-1311">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="09f45-1312">Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1312">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="09f45-1313">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1313">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-1314">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-1314">Member Type</span></span>|<span data-ttu-id="09f45-1315">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-1315">Static</span></span>|<span data-ttu-id="09f45-1316">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-1316">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-1317">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-1317">Constructor</span></span>|<span data-ttu-id="09f45-1318">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1318">No</span></span>|<span data-ttu-id="09f45-1319">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1319">No</span></span>|  
|<span data-ttu-id="09f45-1320">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-1320">Field</span></span>|<span data-ttu-id="09f45-1321">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1321">No</span></span>|<span data-ttu-id="09f45-1322">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-1322">Yes.</span></span> <span data-ttu-id="09f45-1323">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1323">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-1324">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-1324">Event</span></span>|<span data-ttu-id="09f45-1325">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1325">Not applicable</span></span>|<span data-ttu-id="09f45-1326">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1326">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1327">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1327">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1328">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1328">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-1329">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-1329">Method</span></span>|<span data-ttu-id="09f45-1330">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1330">No</span></span>|<span data-ttu-id="09f45-1331">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-1331">Yes.</span></span> <span data-ttu-id="09f45-1332">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1332">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-1333">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-1333">Nested Type</span></span>|<span data-ttu-id="09f45-1334">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1334">No</span></span>|<span data-ttu-id="09f45-1335">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1335">No</span></span>|  
|<span data-ttu-id="09f45-1336">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-1336">Property</span></span>|<span data-ttu-id="09f45-1337">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1337">Not applicable</span></span>|<span data-ttu-id="09f45-1338">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1338">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1339">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1339">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1340">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1340">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-1341">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1341">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-1342">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-1342">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-1343">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1343">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1344">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-1344">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-1345">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-1345">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="09f45-1346">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.MemberInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1346">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1347">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1347">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1348">L’exemple de code suivant montre comment utiliser le <xref:System.Type.GetMembers> surcharge de méthode pour collecter des informations sur tous les membres publics d’une classe spécifiée.</span><span class="sxs-lookup"><span data-stu-id="09f45-1348">The following code example demonstrates how to use the <xref:System.Type.GetMembers> method overload to collect information about all public members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-1349">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1349">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-1350">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1350">-or-</span>
          </span>
          <span data-ttu-id="09f45-1351">Zéro (<see cref="F:System.Reflection.BindingFlags.Default" />), pour retourner un tableau vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1351">Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), to return an empty array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1352">En cas de substitution dans une classe dérivée, recherche les membres définis pour le <see cref="T:System.Type" /> actuel, à l'aide des contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1352">When overridden in a derived class, searches for the members defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1353">Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant tous les membres définis pour le <see cref="T:System.Type" /> actuel qui correspondent aux contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1353">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all members defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="09f45-1354">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1354">-or-</span>
          </span>
          <span data-ttu-id="09f45-1355">Tableau vide du type <see cref="T:System.Reflection.MemberInfo" /> si aucun membre n'est défini pour le <see cref="T:System.Type" /> actuel ou si aucun des membres définis ne correspond aux contraintes de liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1355">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if no members are defined for the current <see cref="T:System.Type" />, or if none of the defined members match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1356">Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="09f45-1356">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="09f45-1357">Le <xref:System.Type.GetMembers%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-1357">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-1358">Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-1358">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-1359">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1359">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-1360">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1360">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-1361">Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1361">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1362">Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1362">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span> <span data-ttu-id="09f45-1363">Seuls protégés et des membres internes sur les classes de base sont retournés ; les membres privés sur les classes de base ne sont pas retournés.</span><span class="sxs-lookup"><span data-stu-id="09f45-1363">Only protected and internal members on base classes are returned; private members on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="09f45-1364">Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-1364">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="09f45-1365">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1365">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-1366">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-1366">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-1367">Appel de cette méthode avec uniquement le `Public` indicateur ou uniquement les `NonPublic` indicateur retournera les membres spécifiés et ne nécessite pas de tous les autres indicateurs.</span><span class="sxs-lookup"><span data-stu-id="09f45-1367">Calling this method with only the `Public` flag or only the `NonPublic` flag will return the specified members and does not require any other flags.</span></span>  
  
 <span data-ttu-id="09f45-1368">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1368">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-1369">Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette surcharge de méthode, vous devez spécifier <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-1369">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="09f45-1370">Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1370">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="09f45-1371">Si le t : System.type actuel représente un type générique construit, cette méthode retourne le <xref:System.Reflection.MemberInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1371">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1372">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1372">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1373">L’exemple de code suivant montre comment utiliser le <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> surcharge de méthode pour collecter des informations sur tous les membres d’instance publics d’une classe spécifiée.</span><span class="sxs-lookup"><span data-stu-id="09f45-1373">The following code example demonstrates how to use the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload to collect information about all public instance members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1374">Obtient une méthode spécifique du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1374">Gets a specific method of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-1375">Chaîne contenant le nom de la méthode publique à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1375">The string containing the name of the public method to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1376">Recherche la méthode publique avec le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1376">Searches for the public method with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1377">Objet qui représente la méthode publique avec le nom spécifié, si elle est trouvée ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1377">An object that represents the public method with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1378">La recherche de `name` respecte la casse.</span><span class="sxs-lookup"><span data-stu-id="09f45-1378">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="09f45-1379">La recherche inclut des méthodes d’instance publique de static et public.</span><span class="sxs-lookup"><span data-stu-id="09f45-1379">The search includes public static and public instance methods.</span></span>  
  
 <span data-ttu-id="09f45-1380">Si une méthode est surchargée et a plus d’une méthode publique, la <xref:System.Type.GetMethod%28System.String%29> méthode lève une exception une <xref:System.Reflection.AmbiguousMatchException> exception.</span><span class="sxs-lookup"><span data-stu-id="09f45-1380">If a method is overloaded and has more than one public method, the <xref:System.Type.GetMethod%28System.String%29> method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="09f45-1381">Dans l’exemple suivant, une exception est levée, car il existe plusieurs surcharges publique de la <xref:System.Int32.ToString%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-1381">In the following example, an exception is thrown because there is more than one public overload of the <xref:System.Int32.ToString%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="09f45-1382">Quant à eux, car le `Person.ToString` substitutions de méthode <xref:System.Object.ToString%2A?displayProperty=nameWithType> et par conséquent n’est pas surchargé, la <xref:System.Type.GetMethod%28System.String%29> (méthode) est en mesure de récupérer le <xref:System.Reflection.MethodInfo> objet.</span><span class="sxs-lookup"><span data-stu-id="09f45-1382">On the other hand, because the `Person.ToString` method overrides  <xref:System.Object.ToString%2A?displayProperty=nameWithType> and therefore is not overloaded, the <xref:System.Type.GetMethod%28System.String%29> method is able to retrieve the <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 <span data-ttu-id="09f45-1383">Vous pouvez effectuer l’une des opérations suivantes pour récupérer une méthode spécifique :</span><span class="sxs-lookup"><span data-stu-id="09f45-1383">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="09f45-1384">Appelez le <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> (méthode) et spécifiez un `bindingAttr` argument qui identifie de façon unique la méthode.</span><span class="sxs-lookup"><span data-stu-id="09f45-1384">Call the <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> method and specify a `bindingAttr` argument that uniquely identifies the method.</span></span> <span data-ttu-id="09f45-1385">Par exemple, si l’exception est levée, car un type a un statique et une surcharge de l’instance, vous pouvez spécifier un `bindingAttr` argument de <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1385">For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  `bindingAttr` argument  of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="09f45-1386">Appelez une surcharge de la <xref:System.Type.GetMethod%2A> méthode inclut un `types` paramètre qui définit les types de paramètres de la méthode.</span><span class="sxs-lookup"><span data-stu-id="09f45-1386">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="09f45-1387">Appelez le <xref:System.Type.GetMethods> méthode pour récupérer un tableau qui contient toutes les méthodes publiques qui appartiennent à un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1387">Call the <xref:System.Type.GetMethods> method to retrieve an array containing all of the public methods belonging to a type.</span></span> <span data-ttu-id="09f45-1388">Vous pouvez ensuite itérer pour identifier les méthodes dupliquées nommés `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1388">You can then iterate it to identify the duplicate methods named `name`.</span></span>  
  
 <span data-ttu-id="09f45-1389">Si le t : System.type actuel représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1389">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1390">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1390">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1391">Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1391">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="09f45-1392">Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1392">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1393">L’exemple suivant obtient une méthode nommée `MethodA`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1393">The following example gets a method named `MethodA`.</span></span>  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-1394">Plusieurs méthodes ont été trouvées avec le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1394">More than one method is found with the specified name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1395">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1395">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-1396">Chaîne contenant le nom de la méthode à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1396">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-1397">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1397">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-1398">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1398">-or-</span>
          </span>
          <span data-ttu-id="09f45-1399">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1399">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1400">Recherche la méthode spécifiée, à l'aide des contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1400">Searches for the specified method, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1401">Objet qui représente la méthode correspondant aux critères spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1401">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1402">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les méthodes à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1402">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-1403">Vous devez spécifier soit <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1403">You must specify either <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-1404">Spécifiez <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> pour inclure les méthodes publiques dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1404">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1405">Spécifiez <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> pour inclure des méthodes non publiques (autrement dit, les méthodes privées, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1405">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1406">Spécifiez <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-1406">Specify <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="09f45-1407">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1407">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-1408"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> pour ignorer la casse de `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1408"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="09f45-1409"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> Pour rechercher uniquement les méthodes déclarées sur le <xref:System.Type>, pas les méthodes qui ont été simplement hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-1409"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-1410">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1410">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-1411">Si une méthode est surchargée et plusieurs surcharges aux contraintes spécifiées par le `bindingAttr` argument, la méthode lève un <xref:System.Reflection.AmbiguousMatchException> exception.</span><span class="sxs-lookup"><span data-stu-id="09f45-1411">If a method is overloaded and more than one overload meets the constraints specified by the `bindingAttr` argument, the method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="09f45-1412">Dans l’exemple suivant, une exception est levée, car :</span><span class="sxs-lookup"><span data-stu-id="09f45-1412">In the following example, an exception is thrown because:</span></span>  
  
-   <span data-ttu-id="09f45-1413">Le `TestClass` type possède deux surcharges d’instance publique de la `DisplayValue` (méthode), `DisplayValue(String)` et `DisplayValue(String, Object[])`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1413">The `TestClass` type has two public instance overloads of the `DisplayValue` method, `DisplayValue(String)` and `DisplayValue(String, Object[])`.</span></span>  
  
-   <span data-ttu-id="09f45-1414">Le `TestClass` type possède deux surcharges d’instance publique de la `Equals` méthode, un d’eux est hérité de <xref:System.Object>: `Equals(TestClass)` et `Equals(Object)`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1414">The `TestClass` type has two public instance overloads of the `Equals` method,  one of which is inherited from <xref:System.Object>: `Equals(TestClass)` and `Equals(Object)`.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 <span data-ttu-id="09f45-1415">Vous pouvez effectuer l’une des opérations suivantes pour récupérer une méthode spécifique :</span><span class="sxs-lookup"><span data-stu-id="09f45-1415">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="09f45-1416">Modifiez les contraintes de liaison.</span><span class="sxs-lookup"><span data-stu-id="09f45-1416">Change the binding constraints.</span></span> <span data-ttu-id="09f45-1417">Dans l’exemple précédent, tente de récupérer une instance publique `Equals` récupère de la méthode qui est déclarée par le type et pas héritée correctement `Equals(TestClass)`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1417">In the previous example, attempting to retrieve a public instance `Equals` method that is declared by the type and not inherited successfully retrieves `Equals(TestClass)`.</span></span>  
  
-   <span data-ttu-id="09f45-1418">Appelez une surcharge de la <xref:System.Type.GetMethod%2A> méthode inclut un `types` paramètre qui définit les types de paramètres de la méthode.</span><span class="sxs-lookup"><span data-stu-id="09f45-1418">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="09f45-1419">Appelez le <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> méthode pour récupérer un tableau qui contient toutes les méthodes appartenant à un type dont les attributs de liaison spécifiées.</span><span class="sxs-lookup"><span data-stu-id="09f45-1419">Call the <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</span></span> <span data-ttu-id="09f45-1420">Vous pouvez ensuite itérer pour identifier les méthodes dupliquées nommés `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1420">You can then iterate it to identify the duplicate methods named `name`.</span></span> <span data-ttu-id="09f45-1421">Cette approche est illustrée dans le Gestionnaire de l’exemple précédent pour le <xref:System.Reflection.AmbiguousMatchException> exception.</span><span class="sxs-lookup"><span data-stu-id="09f45-1421">This approach is illustrated in the previous example's handler for the <xref:System.Reflection.AmbiguousMatchException> exception.</span></span>  
  
 <span data-ttu-id="09f45-1422">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1422">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1423">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1423">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1424">Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1424">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="09f45-1425">Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1425">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1426">L’exemple suivant obtient la méthode correspondant aux indicateurs de liaison spécifiés.</span><span class="sxs-lookup"><span data-stu-id="09f45-1426">The following example gets the method that matches the specified binding flags.</span></span>  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-1427">Au moins deux méthodes portent le nom spécifié et correspondent aux contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1427">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1428">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1428">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-1429">Chaîne contenant le nom de la méthode publique à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1429">The string containing the name of the public method to get.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="09f45-1430">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la méthode à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1430">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="09f45-1431">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1431">-or-</span>
          </span>
          <span data-ttu-id="09f45-1432">Tableau vide d'objets <see cref="T:System.Type" /> (tels que le champ <see cref="F:System.Type.EmptyTypes" /> les fournit) pour obtenir une méthode qui ne prend aucun paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1432">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1433">Recherche la méthode publique spécifiée dont les paramètres correspondent aux types d'arguments spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1433">Searches for the specified public method whose parameters match the specified argument types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1434">Objet représentant la méthode publique dont les paramètres correspondent aux types d'arguments spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1434">An object representing the public method whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1435">La recherche de `name` respecte la casse.</span><span class="sxs-lookup"><span data-stu-id="09f45-1435">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="09f45-1436">La recherche inclut des méthodes d’instance publique de static et public.</span><span class="sxs-lookup"><span data-stu-id="09f45-1436">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1437">Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes.</span><span class="sxs-lookup"><span data-stu-id="09f45-1437">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="09f45-1438">Vous pouvez uniquement omettre les paramètres lors de l’appel.</span><span class="sxs-lookup"><span data-stu-id="09f45-1438">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="09f45-1439">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1439">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1440">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1440">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1441">Le `name` paramètre ne peut pas inclure des arguments de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1441">The `name` parameter cannot include type arguments.</span></span> <span data-ttu-id="09f45-1442">Par exemple, le code c# `GetMethod("MyGenericMethod<int>")` recherche une méthode avec le nom «`MyGenericMethod<int>`», plutôt que pour une méthode nommée `MyGenericMethod` qui possède un argument générique de type `int`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1442">For example, the C# code `GetMethod("MyGenericMethod<int>")` searches for a method with the text name "`MyGenericMethod<int>`", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="09f45-1443">Au lieu de cela, utilisez `GetMethod("MyGenericMethod")` avec le paramètre approprié dans le `types` tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-1443">Instead, use `GetMethod("MyGenericMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1444">L’exemple suivant recherche des surcharges spécifiques de `MethodA`, en spécifiant une variété de types d’arguments.</span><span class="sxs-lookup"><span data-stu-id="09f45-1444">The following example finds specific overloads of `MethodA`, specifying a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1445">Le [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemple nécessite la `/unsafe` option du compilateur.</span><span class="sxs-lookup"><span data-stu-id="09f45-1445">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 <span data-ttu-id="09f45-1446">L’exemple suivant récupère <xref:System.Reflection.MethodInfo> des objets qui représentent les `Add` méthodes d’un type non générique (le <xref:System.Collections.ArrayList> classe), un type générique ouvert (le <xref:System.Collections.Generic.List%601> classe) et un type générique fermé (la `List(Of String)` type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1446">The following example retrieves <xref:System.Reflection.MethodInfo> objects that represent the `Add` methods  of a non-generic type (the <xref:System.Collections.ArrayList> class), an open generic type (the <xref:System.Collections.Generic.List%601> class), and a closed generic type (the `List(Of String)` type.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 <span data-ttu-id="09f45-1447">L’exemple définit un `GetAddMethod` méthode qui Récupère les <xref:System.Reflection.MethodInfo> objet.</span><span class="sxs-lookup"><span data-stu-id="09f45-1447">The example defines a `GetAddMethod` method that retrieves the appropriate <xref:System.Reflection.MethodInfo> object.</span></span> <span data-ttu-id="09f45-1448">Pour fournir la `types` argument pour un type générique ouvert, il appelle le <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-1448">To provide the `types` argument for an open generic type, it calls the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="09f45-1449">Pour fournir la `types` argument pour un type générique fermé, il récupère la valeur de la <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1449">To provide the `types` argument for a closed generic type, it retrieves the value of the <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-1450">Plusieurs méthodes ont été trouvées avec le nom et les paramètres spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1450">More than one method is found with the specified name and specified parameters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1451">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1451">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-1452">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1452">-or-</span>
          </span>
          <span data-ttu-id="09f45-1453">
            <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1453">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-1454">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1454">-or-</span>
          </span>
          <span data-ttu-id="09f45-1455">Un des éléments de <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1455">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-1456">
            <paramref name="types" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1456">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-1457">Chaîne contenant le nom de la méthode publique à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1457">The string containing the name of the public method to get.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="09f45-1458">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la méthode à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1458">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="09f45-1459">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1459">-or-</span>
          </span>
          <span data-ttu-id="09f45-1460">Tableau vide d'objets <see cref="T:System.Type" /> (tels que le champ <see cref="F:System.Type.EmptyTypes" /> les fournit) pour obtenir une méthode qui ne prend aucun paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1460">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="09f45-1461">Tableau d’objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l’élément correspondant dans le tableau <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1461">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="09f45-1462">À utiliser uniquement au moment d'un appel via COM Interop ; de plus, seuls sont gérés les paramètres passés par référence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1462">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span>
          </span>
          <span data-ttu-id="09f45-1463">Le binder par défaut ne traite pas ce paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1463">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1464">Recherche la méthode publique spécifiée dont les paramètres correspondent aux types d’arguments et modificateurs spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1464">Searches for the specified public method whose parameters match the specified argument types and modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1465">Objet qui représente la méthode publique correspondant aux critères spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1465">An object representing the public method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1466">Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1466">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="09f45-1467">`ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.</span><span class="sxs-lookup"><span data-stu-id="09f45-1467">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="09f45-1468">La recherche de `name` respecte la casse.</span><span class="sxs-lookup"><span data-stu-id="09f45-1468">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="09f45-1469">La recherche inclut des méthodes d’instance publique de static et public.</span><span class="sxs-lookup"><span data-stu-id="09f45-1469">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1470">Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes.</span><span class="sxs-lookup"><span data-stu-id="09f45-1470">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="09f45-1471">Vous pouvez uniquement omettre les paramètres lors de l’appel.</span><span class="sxs-lookup"><span data-stu-id="09f45-1471">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="09f45-1472">Si le t : System.type actuel représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1472">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1473">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1473">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1474">Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1474">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="09f45-1475">Par exemple, le code c# `GetMethod("MyMethod<int>")` recherche un membre portant le nom «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1475">For example, the C# code `GetMethod("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="09f45-1476">Au lieu de cela, utilisez `GetMethod("MyMethod")` avec le paramètre approprié dans le `types` tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-1476">Instead, use `GetMethod("MyMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-1477">Plusieurs méthodes ont été trouvées avec le nom et les paramètres spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1477">More than one method is found with the specified name and specified parameters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1478">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1478">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-1479">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1479">-or-</span>
          </span>
          <span data-ttu-id="09f45-1480">
            <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1480">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-1481">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1481">-or-</span>
          </span>
          <span data-ttu-id="09f45-1482">Un des éléments de <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1482">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-1483">
            <paramref name="types" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1483">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-1484">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1484">-or-</span>
          </span>
          <span data-ttu-id="09f45-1485">
            <paramref name="modifiers" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1485">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-1486">Chaîne contenant le nom de la méthode à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1486">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-1487">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1487">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-1488">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1488">-or-</span>
          </span>
          <span data-ttu-id="09f45-1489">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1489">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="09f45-1490">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1490">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="09f45-1491">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1491">-or-</span>
          </span>
          <span data-ttu-id="09f45-1492">Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1492">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="09f45-1493">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la méthode à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1493">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="09f45-1494">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1494">-or-</span>
          </span>
          <span data-ttu-id="09f45-1495">Tableau vide d'objets <see cref="T:System.Type" /> (tels que le champ <see cref="F:System.Type.EmptyTypes" /> les fournit) pour obtenir une méthode qui ne prend aucun paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1495">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="09f45-1496">Tableau d’objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l’élément correspondant dans le tableau <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1496">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="09f45-1497">À utiliser uniquement au moment d'un appel via COM Interop ; de plus, seuls sont gérés les paramètres passés par référence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1497">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span>
          </span>
          <span data-ttu-id="09f45-1498">Le binder par défaut ne traite pas ce paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1498">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1499">Recherche la méthode spécifiée dont les paramètres correspondent aux types d’arguments et modificateurs spécifiés, à l’aide des contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1499">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1500">Objet qui représente la méthode correspondant aux critères spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1500">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1501">Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1501">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="09f45-1502">`ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.</span><span class="sxs-lookup"><span data-stu-id="09f45-1502">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="09f45-1503">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les méthodes à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1503">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-1504">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1504">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-1505">Spécifiez `BindingFlags.Public` pour inclure les méthodes publiques dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1505">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1506">Spécifiez `BindingFlags.NonPublic` pour inclure des méthodes non publiques (autrement dit, les méthodes privées, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1506">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1507">Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-1507">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="09f45-1508">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1508">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-1509">`BindingFlags.IgnoreCase` pour ignorer la casse de `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1509">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="09f45-1510">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les méthodes déclarées sur le <xref:System.Type>, pas les méthodes qui ont été simplement hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-1510">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-1511">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1511">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1512">Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes.</span><span class="sxs-lookup"><span data-stu-id="09f45-1512">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="09f45-1513">Vous pouvez uniquement omettre les paramètres lors de l’appel.</span><span class="sxs-lookup"><span data-stu-id="09f45-1513">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="09f45-1514">Si le t : System.type actuel représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1514">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1515">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1515">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1516">Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1516">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="09f45-1517">Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1517">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1518">L’exemple suivant recherche des surcharges spécifiques de `MethodA`, en spécifiant les contraintes de liaison et une variété de types d’arguments.</span><span class="sxs-lookup"><span data-stu-id="09f45-1518">The following example finds specific overloads of `MethodA`, specifying binding constraints and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1519">Le [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemple nécessite la `/unsafe` option du compilateur.</span><span class="sxs-lookup"><span data-stu-id="09f45-1519">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-1520">Au moins deux méthodes portent le nom spécifié et correspondent aux contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1520">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1521">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1521">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-1522">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1522">-or-</span>
          </span>
          <span data-ttu-id="09f45-1523">
            <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1523">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-1524">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1524">-or-</span>
          </span>
          <span data-ttu-id="09f45-1525">Un des éléments de <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1525">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-1526">
            <paramref name="types" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1526">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-1527">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1527">-or-</span>
          </span>
          <span data-ttu-id="09f45-1528">
            <paramref name="modifiers" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1528">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-1529">Chaîne contenant le nom de la méthode à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1529">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-1530">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1530">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-1531">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1531">-or-</span>
          </span>
          <span data-ttu-id="09f45-1532">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1532">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="09f45-1533">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1533">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="09f45-1534">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1534">-or-</span>
          </span>
          <span data-ttu-id="09f45-1535">Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1535">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="09f45-1536">Objet qui spécifie l’ensemble de règles à utiliser en ce qui concerne l’ordre et la disposition des arguments, la manière dont la valeur de retour est passée, les registres utilisés pour les arguments et la manière dont la pile est nettoyée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1536">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="09f45-1537">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la méthode à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1537">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="09f45-1538">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1538">-or-</span>
          </span>
          <span data-ttu-id="09f45-1539">Tableau vide d'objets <see cref="T:System.Type" /> (tels que le champ <see cref="F:System.Type.EmptyTypes" /> les fournit) pour obtenir une méthode qui ne prend aucun paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1539">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="09f45-1540">Tableau d’objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l’élément correspondant dans le tableau <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1540">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="09f45-1541">À utiliser uniquement au moment d'un appel via COM Interop ; de plus, seuls sont gérés les paramètres passés par référence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1541">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span>
          </span>
          <span data-ttu-id="09f45-1542">Le binder par défaut ne traite pas ce paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1542">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1543">Recherche la méthode spécifiée dont les paramètres correspondent aux types d’arguments et aux modificateurs spécifiés, en utilisant les contraintes de liaison et la convention d’appel indiquées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1543">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1544">Objet qui représente la méthode correspondant aux critères spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1544">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1545">Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1545">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="09f45-1546">`ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.</span><span class="sxs-lookup"><span data-stu-id="09f45-1546">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="09f45-1547">Le tableau suivant présente les membres d’une classe de base sont retournés par la `GetXXX` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1547">The following table shows what members of a base class are returned by the `GetXXX` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-1548">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-1548">Member Type</span></span>|<span data-ttu-id="09f45-1549">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-1549">Static</span></span>|<span data-ttu-id="09f45-1550">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-1550">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-1551">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-1551">Constructor</span></span>|<span data-ttu-id="09f45-1552">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1552">No</span></span>|<span data-ttu-id="09f45-1553">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1553">No</span></span>|  
|<span data-ttu-id="09f45-1554">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-1554">Field</span></span>|<span data-ttu-id="09f45-1555">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1555">No</span></span>|<span data-ttu-id="09f45-1556">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-1556">Yes.</span></span> <span data-ttu-id="09f45-1557">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1557">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-1558">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-1558">Event</span></span>|<span data-ttu-id="09f45-1559">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1559">Not applicable</span></span>|<span data-ttu-id="09f45-1560">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1560">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1561">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1561">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1562">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1562">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-1563">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-1563">Method</span></span>|<span data-ttu-id="09f45-1564">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1564">No</span></span>|<span data-ttu-id="09f45-1565">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-1565">Yes.</span></span> <span data-ttu-id="09f45-1566">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1566">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-1567">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-1567">Nested Type</span></span>|<span data-ttu-id="09f45-1568">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1568">No</span></span>|<span data-ttu-id="09f45-1569">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1569">No</span></span>|  
|<span data-ttu-id="09f45-1570">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-1570">Property</span></span>|<span data-ttu-id="09f45-1571">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1571">Not applicable</span></span>|<span data-ttu-id="09f45-1572">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1572">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1573">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1573">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1574">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1574">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-1575">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1575">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-1576">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-1576">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-1577">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1577">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1578">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-1578">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-1579">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-1579">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="09f45-1580">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les méthodes à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1580">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-1581">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1581">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-1582">Spécifiez `BindingFlags.Public` pour inclure les méthodes publiques dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1582">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1583">Spécifiez `BindingFlags.NonPublic` pour inclure des méthodes non publiques (autrement dit, les méthodes privées, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1583">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1584">Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-1584">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="09f45-1585">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1585">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-1586">`BindingFlags.IgnoreCase` pour ignorer la casse de `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1586">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="09f45-1587">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les méthodes déclarées sur le <xref:System.Type>, pas les méthodes qui ont été simplement hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-1587">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-1588">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1588">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1589">Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes.</span><span class="sxs-lookup"><span data-stu-id="09f45-1589">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="09f45-1590">Vous pouvez uniquement omettre les paramètres lors de l’appel.</span><span class="sxs-lookup"><span data-stu-id="09f45-1590">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="09f45-1591">Si le t : System.type actuel représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1591">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1592">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1592">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1593">Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1593">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="09f45-1594">Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1594">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1595">L’exemple suivant recherche des surcharges spécifiques de `MethodA`, en spécifiant les contraintes de liaison, les conventions d’appel et divers types d’arguments.</span><span class="sxs-lookup"><span data-stu-id="09f45-1595">The following example finds specific overloads of `MethodA`, specifying binding constraints, calling conventions, and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1596">Le [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemple nécessite la `/unsafe` option du compilateur.</span><span class="sxs-lookup"><span data-stu-id="09f45-1596">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-1597">Au moins deux méthodes portent le nom spécifié et correspondent aux contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1597">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1598">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1598">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-1599">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1599">-or-</span>
          </span>
          <span data-ttu-id="09f45-1600">
            <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1600">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-1601">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1601">-or-</span>
          </span>
          <span data-ttu-id="09f45-1602">Un des éléments de <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1602">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-1603">
            <paramref name="types" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1603">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-1604">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1604">-or-</span>
          </span>
          <span data-ttu-id="09f45-1605">
            <paramref name="modifiers" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1605">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-1606">Chaîne contenant le nom de la méthode à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1606">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-1607">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1607">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-1608">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1608">-or-</span>
          </span>
          <span data-ttu-id="09f45-1609">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1609">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="09f45-1610">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1610">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="09f45-1611">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1611">-or-</span>
          </span>
          <span data-ttu-id="09f45-1612">Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1612">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="09f45-1613">Objet qui spécifie l'ensemble de règles à utiliser en ce qui concerne l'ordre et la disposition des arguments, la manière dont la valeur de retour est passée, les registres utilisés pour les arguments et le processus de nettoyage de la pile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1613">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="09f45-1614">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la méthode à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1614">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="09f45-1615">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1615">-or-</span>
          </span>
          <span data-ttu-id="09f45-1616">Tableau vide de type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir une méthode qui ne prend aucun paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1616">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</span>
          </span>
          <span data-ttu-id="09f45-1617">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1617">-or-</span>
          </span>
          <span data-ttu-id="09f45-1618">
            <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1618">
              <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-1619">Si <c>types</c> est <see langword="null" />, les arguments ne correspondent pas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1619">If <c>types</c> is <see langword="null" />, arguments are not matched.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="09f45-1620">Tableau d’objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l’élément correspondant dans le tableau <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1620">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="09f45-1621">Le binder par défaut ne traite pas ce paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1621">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1622">En cas de substitution dans une classe dérivée, recherche la méthode spécifiée dont les paramètres correspondent aux types d’arguments et modificateurs spécifiés, à l’aide des contraintes de liaison et de la convention d’appel spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1622">When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1623">Objet qui représente la méthode correspondant aux critères spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1623">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1624">Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1624">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="09f45-1625">`ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.</span><span class="sxs-lookup"><span data-stu-id="09f45-1625">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="09f45-1626">Si `types` est `null`, les arguments ne correspondent pas.</span><span class="sxs-lookup"><span data-stu-id="09f45-1626">If `types` is `null`, arguments are not matched.</span></span>  
  
 <span data-ttu-id="09f45-1627">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les méthodes à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1627">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-1628">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1628">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-1629">Spécifiez `BindingFlags.Public` pour inclure les méthodes publiques dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1629">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1630">Spécifiez `BindingFlags.NonPublic` pour inclure des méthodes non publiques (autrement dit, les méthodes privées, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1630">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1631">Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-1631">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="09f45-1632">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1632">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-1633">`BindingFlags.IgnoreCase` pour ignorer la casse de `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1633">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="09f45-1634">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les méthodes déclarées sur le <xref:System.Type>, pas les méthodes qui ont été simplement hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-1634">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-1635">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1635">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-1636">Au moins deux méthodes portent le nom spécifié et correspondent aux contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1636">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1637">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1637">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-1638">
            <paramref name="types" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1638">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-1639">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1639">-or-</span>
          </span>
          <span data-ttu-id="09f45-1640">
            <paramref name="modifiers" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1640">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-1641">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1641">-or-</span>
          </span>
          <span data-ttu-id="09f45-1642">
            <paramref name="types" /> et <paramref name="modifiers" /> n’ont pas la même longueur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1642">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-1643">Le type actuel est un <see cref="T:System.Reflection.Emit.TypeBuilder" /> ou un <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1643">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1644">Obtient les méthodes du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1644">Gets the methods of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1645">Retourne toutes les méthodes publiques du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1645">Returns all the public methods of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1646">Tableau d'objets <see cref="T:System.Reflection.MethodInfo" /> représentant toutes les méthodes publiques définies pour le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1646">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the public methods defined for the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="09f45-1647">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1647">-or-</span>
          </span>
          <span data-ttu-id="09f45-1648">Tableau vide du type <see cref="T:System.Reflection.MethodInfo" /> si aucune méthode publique n'est définie pour le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1648">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no public methods are defined for the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1649">Le <xref:System.Type.GetMethods%2A> méthode ne retourne pas les méthodes dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-1649">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-1650">Votre code ne doit pas dépendent l’ordre dans lequel les méthodes sont retournées, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-1650">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-1651">Constructeurs ne sont pas inclus dans le tableau de méthodes retourné par cet appel.</span><span class="sxs-lookup"><span data-stu-id="09f45-1651">Constructors are not included in the array of methods returned by this call.</span></span> <span data-ttu-id="09f45-1652">Effectuer un appel séparé à `GetConstructors()` pour obtenir les méthodes de constructeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-1652">Make a separate call to `GetConstructors()` to get the constructor methods.</span></span>  
  
 <span data-ttu-id="09f45-1653">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1653">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-1654">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-1654">Member Type</span></span>|<span data-ttu-id="09f45-1655">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-1655">Static</span></span>|<span data-ttu-id="09f45-1656">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-1656">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-1657">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-1657">Constructor</span></span>|<span data-ttu-id="09f45-1658">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1658">No</span></span>|<span data-ttu-id="09f45-1659">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1659">No</span></span>|  
|<span data-ttu-id="09f45-1660">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-1660">Field</span></span>|<span data-ttu-id="09f45-1661">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1661">No</span></span>|<span data-ttu-id="09f45-1662">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-1662">Yes.</span></span> <span data-ttu-id="09f45-1663">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1663">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-1664">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-1664">Event</span></span>|<span data-ttu-id="09f45-1665">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1665">Not applicable</span></span>|<span data-ttu-id="09f45-1666">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1666">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1667">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1667">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1668">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1668">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-1669">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-1669">Method</span></span>|<span data-ttu-id="09f45-1670">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1670">No</span></span>|<span data-ttu-id="09f45-1671">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-1671">Yes.</span></span> <span data-ttu-id="09f45-1672">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1672">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-1673">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-1673">Nested Type</span></span>|<span data-ttu-id="09f45-1674">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1674">No</span></span>|<span data-ttu-id="09f45-1675">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1675">No</span></span>|  
|<span data-ttu-id="09f45-1676">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-1676">Property</span></span>|<span data-ttu-id="09f45-1677">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1677">Not applicable</span></span>|<span data-ttu-id="09f45-1678">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1678">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1679">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1679">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1680">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1680">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-1681">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1681">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-1682">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-1682">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-1683">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1683">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1684">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-1684">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-1685">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-1685">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1686">Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes.</span><span class="sxs-lookup"><span data-stu-id="09f45-1686">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="09f45-1687">Vous pouvez uniquement omettre les paramètres lors de l’appel.</span><span class="sxs-lookup"><span data-stu-id="09f45-1687">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="09f45-1688">Si le t : System.type actuel représente un type générique construit, cette méthode retourne le <xref:System.Reflection.MethodInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1688">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1689">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1689">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-1690">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1690">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-1691">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1691">-or-</span>
          </span>
          <span data-ttu-id="09f45-1692">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1692">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1693">En cas de substitution dans une classe dérivée, recherche les méthodes définies pour le <see cref="T:System.Type" /> actuel, à l'aide des contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1693">When overridden in a derived class, searches for the methods defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1694">Tableau d'objets <see cref="T:System.Reflection.MethodInfo" /> représentant toutes les méthodes définies pour le <see cref="T:System.Type" /> actuel qui correspondent aux contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1694">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all methods defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="09f45-1695">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1695">-or-</span>
          </span>
          <span data-ttu-id="09f45-1696">Tableau vide du type <see cref="T:System.Reflection.MethodInfo" /> si aucune méthode n'est définie pour le <see cref="T:System.Type" /> actuel ou si aucune des méthodes définies ne correspond aux contraintes de liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1696">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no methods are defined for the current <see cref="T:System.Type" />, or if none of the defined methods match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1697">Le <xref:System.Type.GetMethods%2A> méthode ne retourne pas les méthodes dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-1697">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-1698">Votre code ne doit pas dépendent l’ordre dans lequel les méthodes sont retournées, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-1698">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-1699">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les méthodes à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1699">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-1700">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1700">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-1701">Spécifiez `BindingFlags.Public` pour inclure les méthodes publiques dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1701">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1702">Spécifiez `BindingFlags.NonPublic` pour inclure des méthodes non publiques (autrement dit, les méthodes privées, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1702">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span> <span data-ttu-id="09f45-1703">Seuls protégés et des méthodes internes sur les classes de base sont retournés ; méthodes privées sur les classes de base ne sont pas retournés.</span><span class="sxs-lookup"><span data-stu-id="09f45-1703">Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="09f45-1704">Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-1704">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="09f45-1705">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1705">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-1706">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les méthodes déclarées sur le <xref:System.Type>, pas les méthodes qui ont été simplement hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-1706">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-1707">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1707">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1708">Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes.</span><span class="sxs-lookup"><span data-stu-id="09f45-1708">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="09f45-1709">Vous pouvez uniquement omettre les paramètres lors de l’appel.</span><span class="sxs-lookup"><span data-stu-id="09f45-1709">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="09f45-1710">Si le t : System.type actuel représente un type générique construit, cette méthode retourne le <xref:System.Reflection.MethodInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1710">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1711">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1711">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1712">L’exemple suivant crée une classe avec deux méthodes publiques et une méthode protégée, crée un `Type` objet correspondant à `MyTypeClass`Obtient toutes les méthodes publiques et non publiques et affiche leurs noms.</span><span class="sxs-lookup"><span data-stu-id="09f45-1712">The following example creates a class with two public methods and one protected method, creates a `Type` object corresponding to `MyTypeClass`, gets all public and non-public methods, and displays their names.</span></span>  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1713">Obtient un type spécifique imbriqué dans le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1713">Gets a specific type nested within the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-1714">Chaîne contenant le nom du type imbriqué à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1714">The string containing the name of the nested type to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1715">Recherche le type imbriqué public avec le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1715">Searches for the public nested type with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1716">Objet représentant le type imbriqué public avec le nom spécifié, s'il est trouvé ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1716">An object representing the public nested type with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1717">La recherche de `name` respecte la casse.</span><span class="sxs-lookup"><span data-stu-id="09f45-1717">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="09f45-1718">Utilisez le nom simple de la classe imbriquée pour `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1718">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="09f45-1719">Ne la qualifiez pas avec le nom de la classe externe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1719">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="09f45-1720">Pour une classe imbriquée générique, utilisez le nom tronqué — c'est-à-dire, ajoutez un accent grave et le nombre d’arguments génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-1720">For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic arguments.</span></span> <span data-ttu-id="09f45-1721">Par exemple, utilisez la chaîne « interne\`1 » pour obtenir le type générique de classe imbriquée `Inner<T>` (`Inner(Of T)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-1721">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="09f45-1722">N’incluez pas de syntaxe spécifique au langage pour les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1722">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="09f45-1723">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1723">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-1724">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-1724">Member Type</span></span>|<span data-ttu-id="09f45-1725">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-1725">Static</span></span>|<span data-ttu-id="09f45-1726">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-1726">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-1727">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-1727">Constructor</span></span>|<span data-ttu-id="09f45-1728">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1728">No</span></span>|<span data-ttu-id="09f45-1729">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1729">No</span></span>|  
|<span data-ttu-id="09f45-1730">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-1730">Field</span></span>|<span data-ttu-id="09f45-1731">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1731">No</span></span>|<span data-ttu-id="09f45-1732">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-1732">Yes.</span></span> <span data-ttu-id="09f45-1733">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1733">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-1734">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-1734">Event</span></span>|<span data-ttu-id="09f45-1735">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1735">Not applicable</span></span>|<span data-ttu-id="09f45-1736">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1736">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1737">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1737">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1738">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1738">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-1739">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-1739">Method</span></span>|<span data-ttu-id="09f45-1740">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1740">No</span></span>|<span data-ttu-id="09f45-1741">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-1741">Yes.</span></span> <span data-ttu-id="09f45-1742">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1742">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-1743">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-1743">Nested Type</span></span>|<span data-ttu-id="09f45-1744">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1744">No</span></span>|<span data-ttu-id="09f45-1745">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1745">No</span></span>|  
|<span data-ttu-id="09f45-1746">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-1746">Property</span></span>|<span data-ttu-id="09f45-1747">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1747">Not applicable</span></span>|<span data-ttu-id="09f45-1748">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1748">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1749">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1749">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1750">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1750">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-1751">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1751">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-1752">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-1752">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-1753">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1753">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1754">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-1754">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-1755">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-1755">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="09f45-1756">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les types imbriqués de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1756">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="09f45-1757">Si un type imbriqué est générique, cette méthode retourne sa définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-1757">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="09f45-1758">Cela est vrai même si le type générique englobant est un type construit fermé.</span><span class="sxs-lookup"><span data-stu-id="09f45-1758">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1759">Si le courant <xref:System.Type> représente un type générique défini en c#, Visual Basic ou C++, ses types imbriqués sont tous génériques même s’ils n’ont aucuns leurs propres paramètres génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-1759">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="09f45-1760">Ce n’est pas nécessairement vrai pour les types imbriqués définis dans des assemblys dynamiques ou compilés avec le [Ilasm.exe (assembleur IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="09f45-1760">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="09f45-1761">Pour plus d’informations sur les types génériques imbriqués et sur la construction de types génériques imbriqués à partir de leurs définitions de type générique, consultez <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1761">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1762">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1762">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-1763">Chaîne contenant le nom du type imbriqué à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1763">The string containing the name of the nested type to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-1764">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1764">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-1765">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1765">-or-</span>
          </span>
          <span data-ttu-id="09f45-1766">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1766">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1767">En cas de substitution dans une classe dérivée, recherche le type imbriqué spécifié, à l'aide des contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1767">When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1768">Objet qui représente le type imbriqué correspondant aux critères spécifiés, s'il est trouvé ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1768">An object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1769">Utilisez le nom simple de la classe imbriquée pour `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1769">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="09f45-1770">Ne la qualifiez pas avec le nom de la classe externe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1770">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="09f45-1771">Pour une classe imbriquée générique, utilisez le nom tronqué — c'est-à-dire, ajoutez un accent grave et le nombre de paramètres génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-1771">For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic parameters.</span></span> <span data-ttu-id="09f45-1772">Par exemple, utilisez la chaîne « interne\`1 » pour obtenir le type générique de classe imbriquée `Inner<T>` (`Inner(Of T)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-1772">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="09f45-1773">N’incluez pas de syntaxe spécifique au langage pour les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1773">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="09f45-1774">Les éléments suivants <xref:System.Reflection.BindingFlags> filtre indicateurs peuvent être utilisés pour définir ce qui est imbriqué types à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1774">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-1775">Vous devez spécifier soit <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> pour obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1775">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-1776">Spécifiez <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> pour inclure les types imbriqués publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1776">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1777">Spécifiez <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> pour inclure les types imbriqués non publics (autrement dit, privés, internes et protégés types imbriqués) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1777">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="09f45-1778">Cette méthode retourne uniquement les types imbriqués du type actuel.</span><span class="sxs-lookup"><span data-stu-id="09f45-1778">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="09f45-1779">Il ne recherche pas les classes de base du type actuel.</span><span class="sxs-lookup"><span data-stu-id="09f45-1779">It does not search the base classes of the current type.</span></span> <span data-ttu-id="09f45-1780">Pour rechercher des types qui sont imbriqués dans les classes de base, vous devez parcourir la hiérarchie d’héritage, en appelant <xref:System.Type.GetNestedType%2A> à chaque niveau.</span><span class="sxs-lookup"><span data-stu-id="09f45-1780">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level.</span></span>  
  
 <span data-ttu-id="09f45-1781"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> et <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="09f45-1781"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="09f45-1782">Appel de cette méthode avec uniquement le <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> indicateur ou uniquement les <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> retournera types l’imbriqués spécifiés et ne nécessitent pas de tous les autres indicateurs.</span><span class="sxs-lookup"><span data-stu-id="09f45-1782">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="09f45-1783">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1783">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-1784">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les types imbriqués de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1784">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="09f45-1785">Si un type imbriqué est générique, cette méthode retourne sa définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-1785">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="09f45-1786">Cela est vrai même si le type générique englobant est un type construit fermé.</span><span class="sxs-lookup"><span data-stu-id="09f45-1786">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1787">Si le courant <xref:System.Type> représente un type générique défini en c#, Visual Basic ou C++, ses types imbriqués sont tous génériques même s’ils n’ont aucuns leurs propres paramètres génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-1787">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="09f45-1788">Ce n’est pas nécessairement vrai pour les types imbriqués définis dans des assemblys dynamiques ou compilés avec le [Ilasm.exe (assembleur IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="09f45-1788">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="09f45-1789">Pour plus d’informations sur les types génériques imbriqués et sur la construction de types génériques imbriqués à partir de leurs définitions de type générique, consultez <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1789">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1790">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1790">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1791">Obtient les types imbriqués dans le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1791">Gets the types nested within the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1792">Retourne les types publics imbriqués dans le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1792">Returns the public types nested in the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1793">Tableau d'objets <see cref="T:System.Type" /> représentant les types publics imbriqués dans le <see cref="T:System.Type" /> actuel (la recherche n'est pas récursive), ou tableau vide de type <see cref="T:System.Type" /> si aucun type public n'est imbriqué dans le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1793">An array of <see cref="T:System.Type" /> objects representing the public types nested in the current <see cref="T:System.Type" /> (the search is not recursive), or an empty array of type <see cref="T:System.Type" /> if no public types are nested in the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1794">Le <xref:System.Type.GetNestedTypes%2A> méthode ne retourne pas les types dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-1794">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-1795">Votre code ne doit pas dépendent l’ordre dans lequel les types sont retournés, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-1795">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-1796">Seuls les types publics immédiatement imbriqués dans le type actuel sont retournés ; la recherche n’est pas récursive.</span><span class="sxs-lookup"><span data-stu-id="09f45-1796">Only the public types immediately nested in the current type are returned; the search is not recursive.</span></span>  
  
 <span data-ttu-id="09f45-1797">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1797">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-1798">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-1798">Member Type</span></span>|<span data-ttu-id="09f45-1799">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-1799">Static</span></span>|<span data-ttu-id="09f45-1800">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-1800">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-1801">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-1801">Constructor</span></span>|<span data-ttu-id="09f45-1802">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1802">No</span></span>|<span data-ttu-id="09f45-1803">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1803">No</span></span>|  
|<span data-ttu-id="09f45-1804">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-1804">Field</span></span>|<span data-ttu-id="09f45-1805">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1805">No</span></span>|<span data-ttu-id="09f45-1806">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-1806">Yes.</span></span> <span data-ttu-id="09f45-1807">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1807">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-1808">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-1808">Event</span></span>|<span data-ttu-id="09f45-1809">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1809">Not applicable</span></span>|<span data-ttu-id="09f45-1810">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1810">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1811">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1811">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1812">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1812">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-1813">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-1813">Method</span></span>|<span data-ttu-id="09f45-1814">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1814">No</span></span>|<span data-ttu-id="09f45-1815">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-1815">Yes.</span></span> <span data-ttu-id="09f45-1816">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1816">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-1817">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-1817">Nested Type</span></span>|<span data-ttu-id="09f45-1818">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1818">No</span></span>|<span data-ttu-id="09f45-1819">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1819">No</span></span>|  
|<span data-ttu-id="09f45-1820">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-1820">Property</span></span>|<span data-ttu-id="09f45-1821">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1821">Not applicable</span></span>|<span data-ttu-id="09f45-1822">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1822">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1823">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1823">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1824">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1824">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-1825">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1825">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-1826">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-1826">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-1827">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1827">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1828">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-1828">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-1829">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-1829">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="09f45-1830">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les types imbriqués de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1830">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="09f45-1831">Si un type imbriqué est générique, cette méthode retourne sa définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-1831">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="09f45-1832">Cela est vrai même si le type générique englobant est un type construit fermé.</span><span class="sxs-lookup"><span data-stu-id="09f45-1832">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1833">Si le courant <xref:System.Type> représente un type générique défini en c#, Visual Basic ou C++, ses types imbriqués sont tous génériques même s’ils n’ont aucuns leurs propres paramètres génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-1833">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="09f45-1834">Ce n’est pas nécessairement vrai pour les types imbriqués définis dans des assemblys dynamiques ou compilés avec le [Ilasm.exe (assembleur IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="09f45-1834">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="09f45-1835">Pour plus d’informations sur les types génériques imbriqués et sur la construction de types génériques imbriqués à partir de leurs définitions de type générique, consultez <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1835">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1836">L’exemple suivant définit une classe imbriquée et un `struct` dans `MyClass`, puis il obtient les objets des types imbriqués à l’aide du type de `MyClass`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1836">The following example defines a nested class and a `struct` in `MyClass`, and then obtains objects of the nested types using the type of `MyClass`.</span></span>  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-1837">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1837">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-1838">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1838">-or-</span>
          </span>
          <span data-ttu-id="09f45-1839">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1839">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1840">En cas de substitution dans une classe dérivée, recherche les types imbriqués dans le <see cref="T:System.Type" /> actuel, à l'aide des contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1840">When overridden in a derived class, searches for the types nested in the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1841">Tableau d'objets <see cref="T:System.Type" /> représentant tous les types imbriqués dans le <see cref="T:System.Type" /> actuel qui correspondent aux contraintes de liaison spécifiées (la recherche n'est pas récursive), ou tableau vide de type <see cref="T:System.Type" /> si aucun type imbriqué correspondant aux contraintes de liaison n'est trouvé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1841">An array of <see cref="T:System.Type" /> objects representing all the types nested in the current <see cref="T:System.Type" /> that match the specified binding constraints (the search is not recursive), or an empty array of type <see cref="T:System.Type" />, if no nested types are found that match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1842">La recherche pour les types imbriqués n’est pas récursive.</span><span class="sxs-lookup"><span data-stu-id="09f45-1842">The search for nested types is not recursive.</span></span>  
  
 <span data-ttu-id="09f45-1843">Le <xref:System.Type.GetNestedTypes%2A> méthode ne retourne pas les types dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-1843">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-1844">Votre code ne doit pas dépendent l’ordre dans lequel les types sont retournés, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-1844">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-1845">Les éléments suivants <xref:System.Reflection.BindingFlags> filtre indicateurs peuvent être utilisés pour définir ce qui est imbriqué types à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1845">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-1846">Vous devez spécifier soit <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> pour obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1846">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-1847">Spécifiez <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> pour inclure les types imbriqués publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1847">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1848">Spécifiez <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> pour inclure les types imbriqués non publics (autrement dit, privés, internes et protégés types imbriqués) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1848">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="09f45-1849">Cette méthode retourne uniquement les types imbriqués du type actuel.</span><span class="sxs-lookup"><span data-stu-id="09f45-1849">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="09f45-1850">Il ne recherche pas les classes de base du type actuel.</span><span class="sxs-lookup"><span data-stu-id="09f45-1850">It does not search the base classes of the current type.</span></span> <span data-ttu-id="09f45-1851">Pour rechercher des types qui sont imbriqués dans les classes de base, vous devez parcourir la hiérarchie d’héritage, en appelant <xref:System.Type.GetNestedTypes%2A> à chaque niveau.</span><span class="sxs-lookup"><span data-stu-id="09f45-1851">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level.</span></span>  
  
 <span data-ttu-id="09f45-1852"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> et <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="09f45-1852"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="09f45-1853">Appel de cette méthode avec uniquement le <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> indicateur ou uniquement les <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> retournera types l’imbriqués spécifiés et ne nécessitent pas de tous les autres indicateurs.</span><span class="sxs-lookup"><span data-stu-id="09f45-1853">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="09f45-1854">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1854">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-1855">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les types imbriqués de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1855">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="09f45-1856">Si un type imbriqué est générique, cette méthode retourne sa définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-1856">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="09f45-1857">Cela est vrai même si le type générique englobant est un type construit fermé.</span><span class="sxs-lookup"><span data-stu-id="09f45-1857">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-1858">Si le courant <xref:System.Type> représente un type générique défini en c#, Visual Basic ou C++, ses types imbriqués sont tous génériques même s’ils n’ont aucuns leurs propres paramètres génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-1858">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="09f45-1859">Ce n’est pas nécessairement vrai pour les types imbriqués définis dans des assemblys dynamiques ou compilés avec le [Ilasm.exe (assembleur IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="09f45-1859">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="09f45-1860">Pour plus d’informations sur les types génériques imbriqués et sur la construction de types génériques imbriqués à partir de leurs définitions de type générique, consultez <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1860">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1861">L’exemple suivant crée deux classes publiques imbriquées et deux classes protégées imbriquées et affiche des informations pour les classes qui correspondent aux contraintes de liaison spécifiées.</span><span class="sxs-lookup"><span data-stu-id="09f45-1861">The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1862">Obtient les propriétés du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1862">Gets the properties of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1863">Retourne toutes les propriétés publiques du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1863">Returns all the public properties of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1864">Tableau d'objets <see cref="T:System.Reflection.PropertyInfo" /> représentant toutes les propriétés publiques du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1864">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all public properties of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="09f45-1865">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1865">-or-</span>
          </span>
          <span data-ttu-id="09f45-1866">Tableau vide du type <see cref="T:System.Reflection.PropertyInfo" /> si le <see cref="T:System.Type" /> actuel n'a pas de propriétés publiques.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1866">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have public properties.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1867">Appel de cette surcharge revient à appeler la <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> surcharge avec un `bindingAttr` argument égal à `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` en c# et `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="09f45-1867">Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a `bindingAttr` argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic.</span></span> <span data-ttu-id="09f45-1868">Il retourne tous les public propriétés d’instance et statiques, à la fois ceux définis par le type représenté par les <xref:System.Type> objet, ainsi que celles héritent à partir de ses types de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-1868">It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types.</span></span>  
  
 <span data-ttu-id="09f45-1869">Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public.</span><span class="sxs-lookup"><span data-stu-id="09f45-1869">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="09f45-1870">Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.</span><span class="sxs-lookup"><span data-stu-id="09f45-1870">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="09f45-1871">Le <xref:System.Type.GetProperties%2A> méthode ne retourne pas les propriétés dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-1871">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-1872">Votre code ne doit pas dépendent l’ordre dans lequel les propriétés sont retournées, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-1872">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-1873">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1873">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-1874">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-1874">Member Type</span></span>|<span data-ttu-id="09f45-1875">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-1875">Static</span></span>|<span data-ttu-id="09f45-1876">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-1876">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-1877">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-1877">Constructor</span></span>|<span data-ttu-id="09f45-1878">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1878">No</span></span>|<span data-ttu-id="09f45-1879">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1879">No</span></span>|  
|<span data-ttu-id="09f45-1880">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-1880">Field</span></span>|<span data-ttu-id="09f45-1881">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1881">No</span></span>|<span data-ttu-id="09f45-1882">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-1882">Yes.</span></span> <span data-ttu-id="09f45-1883">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1883">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-1884">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-1884">Event</span></span>|<span data-ttu-id="09f45-1885">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1885">Not applicable</span></span>|<span data-ttu-id="09f45-1886">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1886">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1887">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1887">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1888">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1888">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-1889">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-1889">Method</span></span>|<span data-ttu-id="09f45-1890">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1890">No</span></span>|<span data-ttu-id="09f45-1891">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-1891">Yes.</span></span> <span data-ttu-id="09f45-1892">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1892">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-1893">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-1893">Nested Type</span></span>|<span data-ttu-id="09f45-1894">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1894">No</span></span>|<span data-ttu-id="09f45-1895">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-1895">No</span></span>|  
|<span data-ttu-id="09f45-1896">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-1896">Property</span></span>|<span data-ttu-id="09f45-1897">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-1897">Not applicable</span></span>|<span data-ttu-id="09f45-1898">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1898">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-1899">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1899">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1900">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-1900">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-1901">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1901">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-1902">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-1902">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-1903">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-1903">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-1904">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-1904">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-1905">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-1905">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="09f45-1906">Si le t : System.type actuel représente un type générique construit, cette méthode retourne le <xref:System.Reflection.PropertyInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1906">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1907">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1907">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1908">L'exemple suivant illustre l'utilisation de la méthode `GetProperties`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1908">The following example demonstrates the use of the `GetProperties` method.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-1909">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1909">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-1910">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1910">-or-</span>
          </span>
          <span data-ttu-id="09f45-1911">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1911">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1912">En cas de substitution dans une classe dérivée, recherche les propriétés du <see cref="T:System.Type" /> actuel, à l'aide des contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1912">When overridden in a derived class, searches for the properties of the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1913">Tableau d'objets <see cref="T:System.Reflection.PropertyInfo" /> représentant toutes les propriétés du <see cref="T:System.Type" /> actuel qui correspondent aux contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1913">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all properties of the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="09f45-1914">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1914">-or-</span>
          </span>
          <span data-ttu-id="09f45-1915">Tableau vide du type <see cref="T:System.Reflection.PropertyInfo" /> si le <see cref="T:System.Type" /> actuel n'a pas de propriétés ou si aucune des propriétés ne correspond aux contraintes de liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1915">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have properties, or if none of the properties match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1916">Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public.</span><span class="sxs-lookup"><span data-stu-id="09f45-1916">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="09f45-1917">Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.</span><span class="sxs-lookup"><span data-stu-id="09f45-1917">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="09f45-1918">Le <xref:System.Type.GetProperties%2A> méthode ne retourne pas les propriétés dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration.</span><span class="sxs-lookup"><span data-stu-id="09f45-1918">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="09f45-1919">Votre code ne doit pas dépendent l’ordre dans lequel les propriétés sont retournées, car cet ordre varie.</span><span class="sxs-lookup"><span data-stu-id="09f45-1919">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="09f45-1920">Les éléments suivants <xref:System.Reflection.BindingFlags> filtre indicateurs peuvent être utilisés pour définir ce qui est imbriqué types à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1920">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-1921">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1921">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-1922">Spécifiez `BindingFlags.Public` pour inclure les propriétés publiques dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1922">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1923">Spécifiez `BindingFlags.NonPublic` pour inclure les propriétés non publiques (autrement dit, les propriétés privées, internes et protégées) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1923">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span> <span data-ttu-id="09f45-1924">Seuls protégés et des propriétés internes sur les classes de base sont retournées ; les propriétés privées sur les classes de base ne sont pas retournées.</span><span class="sxs-lookup"><span data-stu-id="09f45-1924">Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="09f45-1925">Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-1925">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="09f45-1926">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1926">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-1927">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les propriétés déclarées sur le <xref:System.Type>, pas les propriétés qui ont été simplement héritées.</span><span class="sxs-lookup"><span data-stu-id="09f45-1927">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-1928">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1928">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-1929">Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public.</span><span class="sxs-lookup"><span data-stu-id="09f45-1929">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="09f45-1930">Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.</span><span class="sxs-lookup"><span data-stu-id="09f45-1930">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="09f45-1931">Si le t : System.type actuel représente un type générique construit, cette méthode retourne le <xref:System.Reflection.PropertyInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1931">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1932">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1932">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1933">L’exemple suivant définit une classe nommée `PropertyClass` qui inclut six propriétés : deux sont publics, une est privée, un est protégé, l’autre est interne (`Friend` en Visual Basic), et une est protected internal (`Protected Friend` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-1933">The following example defines a class named `PropertyClass` that includes six properties: two are public, one is private, one is protected, one is internal (`Friend` in Visual Basic), and one is protected internal (`Protected Friend` in Visual Basic).</span></span> <span data-ttu-id="09f45-1934">Il affiche ensuite des informations sur les propriétés de base (le nom de la propriété et le type, s’il est en lecture/écriture et la visibilité de son `get` et `set` accesseurs) pour les propriétés qui correspondent aux contraintes de liaison spécifiées.</span><span class="sxs-lookup"><span data-stu-id="09f45-1934">It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its `get` and `set` accessors) for the properties that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-1935">Obtient une propriété spécifique du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1935">Gets a specific property of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-1936">Chaîne contenant le nom de la propriété publique à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1936">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1937">Recherche la propriété publique avec le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1937">Searches for the public property with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1938">Objet représentant la propriété publique avec le nom spécifié, si elle est trouvée ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1938">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1939">La recherche de `name` respecte la casse.</span><span class="sxs-lookup"><span data-stu-id="09f45-1939">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="09f45-1940">La recherche inclut les propriétés d’instance public de static et public.</span><span class="sxs-lookup"><span data-stu-id="09f45-1940">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="09f45-1941">Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public.</span><span class="sxs-lookup"><span data-stu-id="09f45-1941">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="09f45-1942">Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.</span><span class="sxs-lookup"><span data-stu-id="09f45-1942">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="09f45-1943">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1943">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1944">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1944">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="09f45-1945">Situations dans lesquelles <xref:System.Reflection.AmbiguousMatchException> se produit incluent les éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="09f45-1945">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="09f45-1946">Un type contient deux propriétés indexées qui ont le même nom mais des nombres de paramètres.</span><span class="sxs-lookup"><span data-stu-id="09f45-1946">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="09f45-1947">Pour résoudre l’ambiguïté, utilisez une surcharge de la <xref:System.Type.GetProperty%2A> méthode qui spécifie les types de paramètres.</span><span class="sxs-lookup"><span data-stu-id="09f45-1947">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="09f45-1948">Un type dérivé déclare une propriété qui masque une propriété héritée avec le même nom, à l’aide de la `new` modificateur (`Shadows` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-1948">A derived type declares a property that hides an inherited property with the same name, by using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="09f45-1949">Pour résoudre l’ambiguïté, utilisez la <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> surcharge de méthode et ajoutez le <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> indicateur pour limiter la recherche aux membres qui ne sont pas hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-1949">To resolve the ambiguity, use the <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> method overload and add the <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flag to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="09f45-1950">Les indexeurs et les propriétés par défaut</span><span class="sxs-lookup"><span data-stu-id="09f45-1950">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="09f45-1951">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1951">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="09f45-1952">Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index 3.</span><span class="sxs-lookup"><span data-stu-id="09f45-1952">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="09f45-1953">Vous pouvez surcharger la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1953">You can overload the property.</span></span>  
  
 <span data-ttu-id="09f45-1954">En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom.</span><span class="sxs-lookup"><span data-stu-id="09f45-1954">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="09f45-1955">Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ».</span><span class="sxs-lookup"><span data-stu-id="09f45-1955">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="09f45-1956">Toutefois, un développeur de bibliothèque de classes peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="09f45-1956">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="09f45-1957">Par exemple, le <xref:System.String> classe a un indexeur nommé <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1957">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="09f45-1958">Les propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms autres que de l’élément, également.</span><span class="sxs-lookup"><span data-stu-id="09f45-1958">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="09f45-1959">Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut.</span><span class="sxs-lookup"><span data-stu-id="09f45-1959">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="09f45-1960">Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.</span><span class="sxs-lookup"><span data-stu-id="09f45-1960">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-1961">L’exemple suivant récupère la `Type` objet d’une classe définie par l’utilisateur, récupère une propriété de cette classe et affiche le nom de propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1961">The following example retrieves the `Type` object of a user-defined class, retrieves a property of that class, and displays the property name.</span></span>  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 <span data-ttu-id="09f45-1962">En interne, cette propriété est référencée dans les métadonnées par le nom « Item ».</span><span class="sxs-lookup"><span data-stu-id="09f45-1962">Internally, this property is referred to in the metadata by the name "Item."</span></span> <span data-ttu-id="09f45-1963">Toute tentative d’obtenir `PropertyInfo` à l’aide de la réflexion doit spécifier ce nom interne afin de retourner correctement le `PropertyInfo` propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1963">Any attempt to get `PropertyInfo` using reflection must specify this internal name in order to correctly return the `PropertyInfo` property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-1964">Plus d’une propriété a été trouvée avec le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1964">More than one property is found with the specified name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-1965">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1965">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-1966">Chaîne contenant le nom de la propriété à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1966">The string containing the name of the property to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-1967">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1967">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-1968">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1968">-or-</span>
          </span>
          <span data-ttu-id="09f45-1969">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1969">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-1970">Recherche la propriété spécifiée, à l’aide des contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1970">Searches for the specified property, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-1971">Objet représentant la propriété qui correspond aux critères spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-1971">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-1972">Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public.</span><span class="sxs-lookup"><span data-stu-id="09f45-1972">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="09f45-1973">Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.</span><span class="sxs-lookup"><span data-stu-id="09f45-1973">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="09f45-1974">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les propriétés à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1974">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-1975">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-1975">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-1976">Spécifiez `BindingFlags.Public` pour inclure les propriétés publiques dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1976">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1977">Spécifiez `BindingFlags.NonPublic` pour inclure les propriétés non publiques (autrement dit, les propriétés privées, internes et protégées) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-1977">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="09f45-1978">Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-1978">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="09f45-1979">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-1979">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-1980">`BindingFlags.IgnoreCase` pour ignorer la casse de `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-1980">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="09f45-1981">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les propriétés déclarées sur le <xref:System.Type>, pas les propriétés qui ont été simplement héritées.</span><span class="sxs-lookup"><span data-stu-id="09f45-1981">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-1982">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1982">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-1983">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-1983">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-1984">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-1984">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="09f45-1985">Situations dans lesquelles <xref:System.Reflection.AmbiguousMatchException> se produit incluent les éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="09f45-1985">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="09f45-1986">Un type contient deux propriétés indexées qui ont le même nom mais des nombres de paramètres.</span><span class="sxs-lookup"><span data-stu-id="09f45-1986">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="09f45-1987">Pour résoudre l’ambiguïté, utilisez une surcharge de la <xref:System.Type.GetProperty%2A> méthode qui spécifie les types de paramètres.</span><span class="sxs-lookup"><span data-stu-id="09f45-1987">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="09f45-1988">Un type dérivé déclare une propriété qui masque une propriété héritée avec le même nom, à l’aide de la `new` modificateur (`Shadows` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-1988">A derived type declares a property that hides an inherited property with the same name, using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="09f45-1989">Pour résoudre l’ambiguïté, incluez <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> pour limiter la recherche aux membres qui ne sont pas hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-1989">To resolve the ambiguity, include <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="09f45-1990">Les indexeurs et les propriétés par défaut</span><span class="sxs-lookup"><span data-stu-id="09f45-1990">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="09f45-1991">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type.</span><span class="sxs-lookup"><span data-stu-id="09f45-1991">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="09f45-1992">Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index 3.</span><span class="sxs-lookup"><span data-stu-id="09f45-1992">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="09f45-1993">Vous pouvez surcharger la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-1993">You can overload the property.</span></span>  
  
 <span data-ttu-id="09f45-1994">En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom.</span><span class="sxs-lookup"><span data-stu-id="09f45-1994">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="09f45-1995">Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ».</span><span class="sxs-lookup"><span data-stu-id="09f45-1995">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="09f45-1996">Toutefois, un développeur de bibliothèque de classes peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="09f45-1996">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="09f45-1997">Par exemple, le <xref:System.String> classe a un indexeur nommé <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-1997">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="09f45-1998">Les propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms autres que de l’élément, également.</span><span class="sxs-lookup"><span data-stu-id="09f45-1998">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="09f45-1999">Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut.</span><span class="sxs-lookup"><span data-stu-id="09f45-1999">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="09f45-2000">Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.</span><span class="sxs-lookup"><span data-stu-id="09f45-2000">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-2001">L’exemple suivant récupère le type d’une classe définie par l’utilisateur, récupère une propriété de cette classe et affiche le nom de propriété conformément aux contraintes de liaison spécifiées.</span><span class="sxs-lookup"><span data-stu-id="09f45-2001">The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-2002">Au moins deux propriétés portent le nom spécifié et correspondent aux contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2002">More than one property is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-2003">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2003">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-2004">Chaîne contenant le nom de la propriété publique à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2004">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="09f45-2005">Type de retour de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2005">The return type of the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-2006">Recherche la propriété publique à l’aide du nom et du type de retour spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2006">Searches for the public property with the specified name and return type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-2007">Objet représentant la propriété publique avec le nom spécifié, si elle est trouvée ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2007">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-2008">Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public.</span><span class="sxs-lookup"><span data-stu-id="09f45-2008">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="09f45-2009">Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.</span><span class="sxs-lookup"><span data-stu-id="09f45-2009">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="09f45-2010">La recherche de `name` respecte la casse.</span><span class="sxs-lookup"><span data-stu-id="09f45-2010">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="09f45-2011">La recherche inclut les propriétés d’instance public de static et public.</span><span class="sxs-lookup"><span data-stu-id="09f45-2011">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="09f45-2012">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-2012">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-2013">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-2013">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="09f45-2014">Les indexeurs et les propriétés par défaut</span><span class="sxs-lookup"><span data-stu-id="09f45-2014">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="09f45-2015">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2015">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="09f45-2016">Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index 3.</span><span class="sxs-lookup"><span data-stu-id="09f45-2016">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="09f45-2017">Vous pouvez surcharger la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-2017">You can overload the property.</span></span>  
  
 <span data-ttu-id="09f45-2018">En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom.</span><span class="sxs-lookup"><span data-stu-id="09f45-2018">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="09f45-2019">Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ».</span><span class="sxs-lookup"><span data-stu-id="09f45-2019">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="09f45-2020">Toutefois, un développeur de bibliothèque de classes peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="09f45-2020">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="09f45-2021">Par exemple, le <xref:System.String> classe a un indexeur nommé <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2021">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="09f45-2022">Les propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms autres que de l’élément, également.</span><span class="sxs-lookup"><span data-stu-id="09f45-2022">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="09f45-2023">Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut.</span><span class="sxs-lookup"><span data-stu-id="09f45-2023">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="09f45-2024">Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.</span><span class="sxs-lookup"><span data-stu-id="09f45-2024">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-2025">L’exemple suivant définit une classe avec une propriété et récupère le nom et le type de la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-2025">The following example defines a class with one property and retrieves the name and type of the property.</span></span>  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-2026">Plus d’une propriété a été trouvée avec le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2026">More than one property is found with the specified name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-2027">
            <paramref name="name" /> est <see langword="null" /> ou <paramref name="returnType" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2027">
              <paramref name="name" /> is <see langword="null" />, or <paramref name="returnType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-2028">Chaîne contenant le nom de la propriété publique à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2028">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="09f45-2029">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la propriété indexée à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2029">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="09f45-2030">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2030">-or-</span>
          </span>
          <span data-ttu-id="09f45-2031">Tableau vide du type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir une propriété qui n'est pas indexée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2031">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-2032">Recherche la propriété publique spécifiée dont les paramètres correspondent aux types d’arguments spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2032">Searches for the specified public property whose parameters match the specified argument types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-2033">Objet représentant la propriété publique dont les paramètres correspondent aux types d'arguments spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2033">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-2034">Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public.</span><span class="sxs-lookup"><span data-stu-id="09f45-2034">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="09f45-2035">Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.</span><span class="sxs-lookup"><span data-stu-id="09f45-2035">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="09f45-2036">La recherche de `name` respecte la casse.</span><span class="sxs-lookup"><span data-stu-id="09f45-2036">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="09f45-2037">La recherche inclut les propriétés d’instance public de static et public.</span><span class="sxs-lookup"><span data-stu-id="09f45-2037">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="09f45-2038">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-2038">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-2039">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-2039">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="09f45-2040">Les indexeurs et les propriétés par défaut</span><span class="sxs-lookup"><span data-stu-id="09f45-2040">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="09f45-2041">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2041">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="09f45-2042">Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index 3.</span><span class="sxs-lookup"><span data-stu-id="09f45-2042">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="09f45-2043">Vous pouvez surcharger la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-2043">You can overload the property.</span></span>  
  
 <span data-ttu-id="09f45-2044">En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom.</span><span class="sxs-lookup"><span data-stu-id="09f45-2044">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="09f45-2045">Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ».</span><span class="sxs-lookup"><span data-stu-id="09f45-2045">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="09f45-2046">Toutefois, un développeur de bibliothèque de classes peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="09f45-2046">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="09f45-2047">Par exemple, le <xref:System.String> classe a un indexeur nommé <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2047">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="09f45-2048">Les propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms autres que de l’élément, également.</span><span class="sxs-lookup"><span data-stu-id="09f45-2048">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="09f45-2049">Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut.</span><span class="sxs-lookup"><span data-stu-id="09f45-2049">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="09f45-2050">Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.</span><span class="sxs-lookup"><span data-stu-id="09f45-2050">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-2051">L’exemple suivant récupère la `Type` objet d’une classe définie par l’utilisateur, récupère la propriété de cette classe et affiche le nom de la propriété et le type de la propriété comme spécifié par les arguments passés à `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2051">The following example retrieves the `Type` object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to `GetProperty`.</span></span>  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-2052">Au moins deux propriétés portent le nom spécifié et correspondent aux types d’arguments spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2052">More than one property is found with the specified name and matching the specified argument types.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-2053">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2053">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-2054">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2054">-or-</span>
          </span>
          <span data-ttu-id="09f45-2055">
            <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2055">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-2056">
            <paramref name="types" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2056">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="09f45-2057">Un élément de <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2057">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-2058">Chaîne contenant le nom de la propriété publique à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2058">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="09f45-2059">Type de retour de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2059">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="09f45-2060">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la propriété indexée à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2060">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="09f45-2061">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2061">-or-</span>
          </span>
          <span data-ttu-id="09f45-2062">Tableau vide du type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir une propriété qui n'est pas indexée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2062">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-2063">Recherche la propriété publique spécifiée dont les paramètres correspondent aux types d’arguments spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2063">Searches for the specified public property whose parameters match the specified argument types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-2064">Objet représentant la propriété publique dont les paramètres correspondent aux types d'arguments spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2064">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-2065">Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public.</span><span class="sxs-lookup"><span data-stu-id="09f45-2065">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="09f45-2066">Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.</span><span class="sxs-lookup"><span data-stu-id="09f45-2066">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="09f45-2067">La recherche de `name` respecte la casse.</span><span class="sxs-lookup"><span data-stu-id="09f45-2067">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="09f45-2068">La recherche inclut les propriétés d’instance public de static et public.</span><span class="sxs-lookup"><span data-stu-id="09f45-2068">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="09f45-2069">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-2069">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-2070">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-2070">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="09f45-2071">Les indexeurs et les propriétés par défaut</span><span class="sxs-lookup"><span data-stu-id="09f45-2071">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="09f45-2072">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2072">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="09f45-2073">Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index 3.</span><span class="sxs-lookup"><span data-stu-id="09f45-2073">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="09f45-2074">Vous pouvez surcharger la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-2074">You can overload the property.</span></span>  
  
 <span data-ttu-id="09f45-2075">En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom.</span><span class="sxs-lookup"><span data-stu-id="09f45-2075">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="09f45-2076">Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ».</span><span class="sxs-lookup"><span data-stu-id="09f45-2076">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="09f45-2077">Toutefois, un développeur de bibliothèque de classes peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="09f45-2077">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="09f45-2078">Par exemple, le <xref:System.String> classe a un indexeur nommé <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2078">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="09f45-2079">Les propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms autres que de l’élément, également.</span><span class="sxs-lookup"><span data-stu-id="09f45-2079">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="09f45-2080">Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut.</span><span class="sxs-lookup"><span data-stu-id="09f45-2080">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="09f45-2081">Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.</span><span class="sxs-lookup"><span data-stu-id="09f45-2081">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-2082">Au moins deux propriétés portent le nom spécifié et correspondent aux types d’arguments spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2082">More than one property is found with the specified name and matching the specified argument types.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-2083">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2083">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-2084">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2084">-or-</span>
          </span>
          <span data-ttu-id="09f45-2085">
            <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2085">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-2086">
            <paramref name="types" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2086">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="09f45-2087">Un élément de <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2087">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-2088">Chaîne contenant le nom de la propriété publique à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2088">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="09f45-2089">Type de retour de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2089">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="09f45-2090">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la propriété indexée à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2090">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="09f45-2091">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2091">-or-</span>
          </span>
          <span data-ttu-id="09f45-2092">Tableau vide du type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir une propriété qui n'est pas indexée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2092">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="09f45-2093">Tableau d’objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l’élément correspondant dans le tableau <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2093">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="09f45-2094">Le binder par défaut ne traite pas ce paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2094">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-2095">Recherche la propriété publique spécifiée dont les paramètres correspondent aux types d’arguments et modificateurs spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2095">Searches for the specified public property whose parameters match the specified argument types and modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-2096">Objet qui représente la propriété publique correspondant aux critères spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2096">An object representing the public property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-2097">Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public.</span><span class="sxs-lookup"><span data-stu-id="09f45-2097">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="09f45-2098">Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.</span><span class="sxs-lookup"><span data-stu-id="09f45-2098">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="09f45-2099">Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2099">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="09f45-2100">`ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.</span><span class="sxs-lookup"><span data-stu-id="09f45-2100">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="09f45-2101">La recherche de `name` respecte la casse.</span><span class="sxs-lookup"><span data-stu-id="09f45-2101">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="09f45-2102">La recherche inclut les propriétés d’instance public de static et public.</span><span class="sxs-lookup"><span data-stu-id="09f45-2102">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="09f45-2103">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-2103">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-2104">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-2104">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="09f45-2105">Les indexeurs et les propriétés par défaut</span><span class="sxs-lookup"><span data-stu-id="09f45-2105">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="09f45-2106">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2106">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="09f45-2107">Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index 3.</span><span class="sxs-lookup"><span data-stu-id="09f45-2107">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="09f45-2108">Vous pouvez surcharger la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-2108">You can overload the property.</span></span>  
  
 <span data-ttu-id="09f45-2109">En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom.</span><span class="sxs-lookup"><span data-stu-id="09f45-2109">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="09f45-2110">Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ».</span><span class="sxs-lookup"><span data-stu-id="09f45-2110">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="09f45-2111">Toutefois, un développeur de bibliothèque de classes peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="09f45-2111">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="09f45-2112">Par exemple, le <xref:System.String> classe a un indexeur nommé <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2112">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="09f45-2113">Les propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms autres que de l’élément, également.</span><span class="sxs-lookup"><span data-stu-id="09f45-2113">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="09f45-2114">Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut.</span><span class="sxs-lookup"><span data-stu-id="09f45-2114">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="09f45-2115">Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.</span><span class="sxs-lookup"><span data-stu-id="09f45-2115">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-2116">L’exemple suivant obtient un `Type` objet correspondant à `MyPropertyClass`, et la propriété indexée de cette classe est récupérée à l’aide des arguments passés à la `GetProperty` (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-2116">The following example obtains a `Type` object corresponding to `MyPropertyClass`, and the indexed property of this class is retrieved using the arguments passed to the `GetProperty` method.</span></span>  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-2117">Au moins deux propriétés portent le nom spécifié et correspondent aux types et modificateurs d’arguments spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2117">More than one property is found with the specified name and matching the specified argument types and modifiers.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-2118">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2118">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-2119">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2119">-or-</span>
          </span>
          <span data-ttu-id="09f45-2120">
            <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2120">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-2121">
            <paramref name="types" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2121">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-2122">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2122">-or-</span>
          </span>
          <span data-ttu-id="09f45-2123">
            <paramref name="modifiers" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2123">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-2124">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2124">-or-</span>
          </span>
          <span data-ttu-id="09f45-2125">
            <paramref name="types" /> et <paramref name="modifiers" /> n’ont pas la même longueur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2125">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="09f45-2126">Un élément de <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2126">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-2127">Chaîne contenant le nom de la propriété à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2127">The string containing the name of the property to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-2128">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2128">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-2129">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2129">-or-</span>
          </span>
          <span data-ttu-id="09f45-2130">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2130">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="09f45-2131">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2131">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="09f45-2132">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2132">-or-</span>
          </span>
          <span data-ttu-id="09f45-2133">Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2133">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="09f45-2134">Type de retour de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2134">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="09f45-2135">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la propriété indexée à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2135">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="09f45-2136">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2136">-or-</span>
          </span>
          <span data-ttu-id="09f45-2137">Tableau vide du type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir une propriété qui n'est pas indexée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2137">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="09f45-2138">Tableau d’objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l’élément correspondant dans le tableau <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2138">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="09f45-2139">Le binder par défaut ne traite pas ce paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2139">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-2140">Recherche la propriété spécifiée dont les paramètres correspondent aux types d’arguments et aux modificateurs spécifiés, en utilisant les contraintes de liaison indiquées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2140">Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-2141">Objet représentant la propriété qui correspond aux critères spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2141">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-2142">Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public.</span><span class="sxs-lookup"><span data-stu-id="09f45-2142">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="09f45-2143">Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.</span><span class="sxs-lookup"><span data-stu-id="09f45-2143">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="09f45-2144">Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2144">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="09f45-2145">`ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.</span><span class="sxs-lookup"><span data-stu-id="09f45-2145">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="09f45-2146">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2146">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-2147">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-2147">Member Type</span></span>|<span data-ttu-id="09f45-2148">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-2148">Static</span></span>|<span data-ttu-id="09f45-2149">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-2149">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-2150">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-2150">Constructor</span></span>|<span data-ttu-id="09f45-2151">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2151">No</span></span>|<span data-ttu-id="09f45-2152">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2152">No</span></span>|  
|<span data-ttu-id="09f45-2153">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-2153">Field</span></span>|<span data-ttu-id="09f45-2154">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2154">No</span></span>|<span data-ttu-id="09f45-2155">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-2155">Yes.</span></span> <span data-ttu-id="09f45-2156">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2156">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-2157">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-2157">Event</span></span>|<span data-ttu-id="09f45-2158">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-2158">Not applicable</span></span>|<span data-ttu-id="09f45-2159">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-2159">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-2160">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2160">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-2161">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-2161">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-2162">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-2162">Method</span></span>|<span data-ttu-id="09f45-2163">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2163">No</span></span>|<span data-ttu-id="09f45-2164">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-2164">Yes.</span></span> <span data-ttu-id="09f45-2165">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2165">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-2166">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-2166">Nested Type</span></span>|<span data-ttu-id="09f45-2167">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2167">No</span></span>|<span data-ttu-id="09f45-2168">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2168">No</span></span>|  
|<span data-ttu-id="09f45-2169">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-2169">Property</span></span>|<span data-ttu-id="09f45-2170">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-2170">Not applicable</span></span>|<span data-ttu-id="09f45-2171">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-2171">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-2172">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2172">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-2173">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-2173">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-2174">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-2174">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-2175">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-2175">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-2176">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2176">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-2177">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-2177">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-2178">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-2178">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="09f45-2179">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les propriétés à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-2179">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-2180">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-2180">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-2181">Spécifiez `BindingFlags.Public` pour inclure les propriétés publiques dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-2181">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="09f45-2182">Spécifiez `BindingFlags.NonPublic` pour inclure les propriétés non publiques (autrement dit, les propriétés privées, internes et protégées) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-2182">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="09f45-2183">Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-2183">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="09f45-2184">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-2184">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-2185">`BindingFlags.IgnoreCase` pour ignorer la casse de `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2185">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="09f45-2186">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les propriétés déclarées sur le <xref:System.Type>, pas les propriétés qui ont été simplement héritées.</span><span class="sxs-lookup"><span data-stu-id="09f45-2186">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-2187">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2187">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-2188">Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-2188">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="09f45-2189">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-2189">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="09f45-2190">Les indexeurs et les propriétés par défaut</span><span class="sxs-lookup"><span data-stu-id="09f45-2190">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="09f45-2191">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2191">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="09f45-2192">Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index 3.</span><span class="sxs-lookup"><span data-stu-id="09f45-2192">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="09f45-2193">Vous pouvez surcharger la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-2193">You can overload the property.</span></span>  
  
 <span data-ttu-id="09f45-2194">En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom.</span><span class="sxs-lookup"><span data-stu-id="09f45-2194">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="09f45-2195">Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ».</span><span class="sxs-lookup"><span data-stu-id="09f45-2195">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="09f45-2196">Toutefois, un développeur de bibliothèque de classes peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="09f45-2196">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="09f45-2197">Par exemple, le <xref:System.String> classe a un indexeur nommé <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2197">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="09f45-2198">Les propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms autres que de l’élément, également.</span><span class="sxs-lookup"><span data-stu-id="09f45-2198">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="09f45-2199">Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut.</span><span class="sxs-lookup"><span data-stu-id="09f45-2199">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="09f45-2200">Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.</span><span class="sxs-lookup"><span data-stu-id="09f45-2200">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-2201">Au moins deux propriétés portent le nom spécifié et correspondent aux contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2201">More than one property is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-2202">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2202">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-2203">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2203">-or-</span>
          </span>
          <span data-ttu-id="09f45-2204">
            <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2204">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-2205">
            <paramref name="types" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2205">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-2206">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2206">-or-</span>
          </span>
          <span data-ttu-id="09f45-2207">
            <paramref name="modifiers" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2207">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-2208">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2208">-or-</span>
          </span>
          <span data-ttu-id="09f45-2209">
            <paramref name="types" /> et <paramref name="modifiers" /> n’ont pas la même longueur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2209">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="09f45-2210">Un élément de <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2210">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-2211">Chaîne contenant le nom de la propriété à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2211">The string containing the name of the property to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="09f45-2212">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2212">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-2213">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2213">-or-</span>
          </span>
          <span data-ttu-id="09f45-2214">Zéro, pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2214">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="09f45-2215">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d’un membre surchargé, la contrainte de types d’arguments et l’appel d’un membre par la réflexion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2215">An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="09f45-2216">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2216">-or-</span>
          </span>
          <span data-ttu-id="09f45-2217">Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2217">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="09f45-2218">Type de retour de la propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2218">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="09f45-2219">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la propriété indexée à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2219">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="09f45-2220">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2220">-or-</span>
          </span>
          <span data-ttu-id="09f45-2221">Tableau vide du type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir une propriété qui n'est pas indexée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2221">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="09f45-2222">Tableau d’objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l’élément correspondant dans le tableau <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2222">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="09f45-2223">Le binder par défaut ne traite pas ce paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2223">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-2224">En cas de substitution dans une classe dérivée, recherche la propriété spécifiée dont les paramètres correspondent aux types d’arguments et modificateurs spécifiés, en utilisant les contraintes de liaison indiquées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2224">When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-2225">Objet représentant la propriété qui correspond aux critères spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2225">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-2226">Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2226">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="09f45-2227">`ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.</span><span class="sxs-lookup"><span data-stu-id="09f45-2227">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="09f45-2228">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les propriétés à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-2228">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-2229">Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-2229">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="09f45-2230">Spécifiez `BindingFlags.Public` pour inclure les propriétés publiques dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-2230">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="09f45-2231">Spécifiez `BindingFlags.NonPublic` pour inclure les propriétés non publiques (autrement dit, les propriétés privées, internes et protégées) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-2231">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="09f45-2232">Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-2232">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="09f45-2233">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-2233">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-2234">`BindingFlags.IgnoreCase` pour ignorer la casse de `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2234">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="09f45-2235">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les propriétés déclarées sur le <xref:System.Type>, pas les propriétés qui ont été simplement héritées.</span><span class="sxs-lookup"><span data-stu-id="09f45-2235">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-2236">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2236">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-2237">Au moins deux propriétés portent le nom spécifié et correspondent aux contraintes de liaison spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2237">More than one property is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-2238">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2238">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-2239">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2239">-or-</span>
          </span>
          <span data-ttu-id="09f45-2240">
            <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2240">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-2241">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2241">-or-</span>
          </span>
          <span data-ttu-id="09f45-2242">Un des éléments de <paramref name="types" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2242">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-2243">
            <paramref name="types" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2243">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-2244">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2244">-or-</span>
          </span>
          <span data-ttu-id="09f45-2245">
            <paramref name="modifiers" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2245">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="09f45-2246">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2246">-or-</span>
          </span>
          <span data-ttu-id="09f45-2247">
            <paramref name="types" /> et <paramref name="modifiers" /> n’ont pas la même longueur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2247">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-2248">Le type actuel est un <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> ou <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2248">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-2249">Obtient un objet <see cref="T:System.Type" /> qui représente le type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2249">Gets a <see cref="T:System.Type" /> object that represents the specified type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-2250">Obtient le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2250">Gets the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-2251">
            <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2251">The current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="09f45-2252">Un initialiseur de classe est appelé et lève une exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2252">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="09f45-2253">Nom qualifié d'assembly du type à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2253">The assembly-qualified name of the type to get.</span>
          </span>
          <span data-ttu-id="09f45-2254">Consultez <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2254">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          </span>
          <span data-ttu-id="09f45-2255">Si le type se trouve dans Mscorlib.dll ou l'assembly en cours d'exécution, il suffit de fournir le nom du type qualifié par son espace de noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2255">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-2256">Obtient le <see cref="T:System.Type" /> avec le nom spécifié, effectuant une recherche qui respecte la casse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2256">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-2257">Type présentant le nom spécifié, s'il est trouvé ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2257">The type with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-2258">Vous pouvez utiliser la <xref:System.Type.GetType%2A> méthode pour obtenir un <xref:System.Type> de l’objet d’un type dans un autre assembly, si vous connaissez son nom qualifié d’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="09f45-2258">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its namespace-qualified name.</span></span> <span data-ttu-id="09f45-2259"><xref:System.Type.GetType%2A> provoque le chargement de l’assembly spécifié dans `typeName`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2259"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="09f45-2260">Vous pouvez également charger un assembly à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode), puis utiliser le <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> méthodes de la <xref:System.Reflection.Assembly> classe pour laquelle obtenir <xref:System.Type> objets.</span><span class="sxs-lookup"><span data-stu-id="09f45-2260">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="09f45-2261">Si un type est dans un assembly connu de votre programme au moment de la compilation, il est plus efficace d’utiliser en c#, <xref:System.Type.GetType%2A> en Visual Basic, ou en C++.</span><span class="sxs-lookup"><span data-stu-id="09f45-2261">If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <xref:System.Type.GetType%2A> in Visual Basic, or  in C++.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-2262">Si `typeName` ne peut pas être trouvée, l’appel à la <xref:System.Type.GetType%28System.String%29> méthode renvoie `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2262">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`.</span></span> <span data-ttu-id="09f45-2263">Il ne lève pas d’exception.</span><span class="sxs-lookup"><span data-stu-id="09f45-2263">It does not throw an exception.</span></span> <span data-ttu-id="09f45-2264">Pour contrôler si une exception est levée, appelez une surcharge de la <xref:System.Type.GetType%2A> méthode qui a un `throwOnError` paramètre.</span><span class="sxs-lookup"><span data-stu-id="09f45-2264">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="09f45-2265"><xref:System.Type.GetType%2A> fonctionne uniquement sur les assemblys chargés à partir du disque.</span><span class="sxs-lookup"><span data-stu-id="09f45-2265"><xref:System.Type.GetType%2A> only works on assemblies loaded from disk.</span></span> <span data-ttu-id="09f45-2266">Si vous appelez <xref:System.Type.GetType%2A> pour rechercher un type défini dans un assembly dynamique défini à l’aide de la <xref:System.Reflection.Emit> services, vous pouvez obtenir un comportement incohérent.</span><span class="sxs-lookup"><span data-stu-id="09f45-2266">If you call <xref:System.Type.GetType%2A> to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="09f45-2267">Le comportement varie selon que l’assembly dynamique est persistant, autrement dit, créé à l’aide de la `RunAndSave` ou `Save` accéder aux modes de le <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> énumération.</span><span class="sxs-lookup"><span data-stu-id="09f45-2267">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="09f45-2268">Si l’assembly dynamique est persistant et qu’il a été écrit sur le disque avant `GetType` est appelé, le chargeur recherche l’assembly enregistré sur le disque, charge l’assembly et récupère le type de cet assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2268">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="09f45-2269">Si l’assembly n’a pas été enregistré sur le disque lorsque `GetType` est appelée, la méthode retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2269">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="09f45-2270">`GetType` ne comprend pas les assemblys dynamiques transitoires ; Par conséquent, l’appel `GetType` pour récupérer un type dans un temporaire assembly dynamique retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2270">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="09f45-2271">Pour utiliser `GetType` sur un module dynamique, vous abonner à la <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> événements et les appels `GetType` avant l’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="09f45-2271">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="09f45-2272">Sinon, vous obtiendrez deux copies de l’assembly dans la mémoire.</span><span class="sxs-lookup"><span data-stu-id="09f45-2272">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="09f45-2273">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2273">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-2274">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-2274">Member Type</span></span>|<span data-ttu-id="09f45-2275">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-2275">Static</span></span>|<span data-ttu-id="09f45-2276">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-2276">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-2277">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-2277">Constructor</span></span>|<span data-ttu-id="09f45-2278">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2278">No</span></span>|<span data-ttu-id="09f45-2279">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2279">No</span></span>|  
|<span data-ttu-id="09f45-2280">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-2280">Field</span></span>|<span data-ttu-id="09f45-2281">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2281">No</span></span>|<span data-ttu-id="09f45-2282">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-2282">Yes.</span></span> <span data-ttu-id="09f45-2283">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2283">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-2284">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-2284">Event</span></span>|<span data-ttu-id="09f45-2285">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-2285">Not applicable</span></span>|<span data-ttu-id="09f45-2286">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-2286">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-2287">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2287">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-2288">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-2288">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-2289">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-2289">Method</span></span>|<span data-ttu-id="09f45-2290">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2290">No</span></span>|<span data-ttu-id="09f45-2291">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-2291">Yes.</span></span> <span data-ttu-id="09f45-2292">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2292">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-2293">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-2293">Nested Type</span></span>|<span data-ttu-id="09f45-2294">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2294">No</span></span>|<span data-ttu-id="09f45-2295">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2295">No</span></span>|  
|<span data-ttu-id="09f45-2296">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-2296">Property</span></span>|<span data-ttu-id="09f45-2297">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-2297">Not applicable</span></span>|<span data-ttu-id="09f45-2298">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-2298">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-2299">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2299">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-2300">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-2300">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-2301">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-2301">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-2302">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-2302">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-2303">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2303">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-2304">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-2304">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-2305">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-2305">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="09f45-2306">Les tableaux ou types COM ne sont pas recherchés, sauf si elles ont déjà été chargés dans la table des classes disponibles.</span><span class="sxs-lookup"><span data-stu-id="09f45-2306">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="09f45-2307">`typeName` le nom de type qualifié par son espace de noms ou un nom qualifié d’assembly qui inclut une spécification de nom d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2307">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="09f45-2308">Consultez <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2308">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="09f45-2309">Si `typeName` inclut l’espace de noms mais pas le nom de l’assembly, cette méthode recherche uniquement les assembly de l’objet appelant et dans Mscorlib.dll, dans cet ordre.</span><span class="sxs-lookup"><span data-stu-id="09f45-2309">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="09f45-2310">Si typeName est qualifié avec le nom d’assembly partiel ou complet, cette méthode recherche dans l’assembly spécifié.</span><span class="sxs-lookup"><span data-stu-id="09f45-2310">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="09f45-2311">Si l’assembly a un nom fort, un nom d’assembly complet est requis.</span><span class="sxs-lookup"><span data-stu-id="09f45-2311">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="09f45-2312">Le <xref:System.Type.AssemblyQualifiedName%2A> propriété retourne un nom de type qualifié complet, y compris les types imbriqués, le nom de l’assembly et les arguments de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-2312">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</span></span> <span data-ttu-id="09f45-2313">Tous les compilateurs qui prennent en charge le common language runtime émettront le nom simple d’une classe imbriquée et la réflexion construit un nom tronqué interrogé, conformément aux conventions suivantes.</span><span class="sxs-lookup"><span data-stu-id="09f45-2313">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-2314">Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2314">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="09f45-2315">Par exemple, « ProcessorArchitecture = msil ».</span><span class="sxs-lookup"><span data-stu-id="09f45-2315">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="09f45-2316">Toutefois, il n’est pas inclus dans la chaîne retournée par la <xref:System.Type.AssemblyQualifiedName%2A> propriété, pour des raisons de compatibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-2316">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="09f45-2317">Vous pouvez également charger des types en créant un <xref:System.Reflection.AssemblyName> objet et en le passant à la surcharge appropriée de la <xref:System.Reflection.Assembly.Load%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-2317">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="09f45-2318">Vous pouvez ensuite utiliser le <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> méthode pour charger les types à partir de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2318">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="09f45-2319">Voir aussi <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2319">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="09f45-2320">Délimiteur</span><span class="sxs-lookup"><span data-stu-id="09f45-2320">Delimiter</span></span>|<span data-ttu-id="09f45-2321">Signification</span><span class="sxs-lookup"><span data-stu-id="09f45-2321">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="09f45-2322">Barre oblique inverse (\\)</span><span class="sxs-lookup"><span data-stu-id="09f45-2322">Backslash (\\)</span></span>|<span data-ttu-id="09f45-2323">Caractère d’échappement.</span><span class="sxs-lookup"><span data-stu-id="09f45-2323">Escape character.</span></span>|  
|<span data-ttu-id="09f45-2324">Accent grave (')</span><span class="sxs-lookup"><span data-stu-id="09f45-2324">Backtick (\`)</span></span>|<span data-ttu-id="09f45-2325">Précède un ou plusieurs chiffres représentant le nombre de paramètres de type, à la fin du nom d’un type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-2325">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="09f45-2326">crochets ([])</span><span class="sxs-lookup"><span data-stu-id="09f45-2326">Brackets ([])</span></span>|<span data-ttu-id="09f45-2327">Placez une liste d’arguments de type générique, pour un type générique construit ; dans une liste d’arguments de type, placez un type qualifié d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2327">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="09f45-2328">Comma (,)</span><span class="sxs-lookup"><span data-stu-id="09f45-2328">Comma (,)</span></span>|<span data-ttu-id="09f45-2329">Précède le nom de l’Assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2329">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="09f45-2330">Point (.)</span><span class="sxs-lookup"><span data-stu-id="09f45-2330">Period (.)</span></span>|<span data-ttu-id="09f45-2331">Indique les identificateurs d’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="09f45-2331">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="09f45-2332">Signe plus (+)</span><span class="sxs-lookup"><span data-stu-id="09f45-2332">Plus sign (+)</span></span>|<span data-ttu-id="09f45-2333">Précède une classe imbriquée.</span><span class="sxs-lookup"><span data-stu-id="09f45-2333">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="09f45-2334">Par exemple, le nom qualifié complet d’une classe peut ressembler à ceci :</span><span class="sxs-lookup"><span data-stu-id="09f45-2334">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="09f45-2335">Si l’espace de noms ont été TopNamespace, alors que la chaîne devrait faire précéder le signe plus (+) avec un caractère d’échappement (\\) pour l’empêcher d’être interprété comme un séparateur d’imbrication.</span><span class="sxs-lookup"><span data-stu-id="09f45-2335">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="09f45-2336">La réflexion génère cette chaîne comme suit :</span><span class="sxs-lookup"><span data-stu-id="09f45-2336">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="09f45-2337">Un « ++ » devient «\\+\\+ » et un «\\« devient »\\\\».</span><span class="sxs-lookup"><span data-stu-id="09f45-2337">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="09f45-2338">Ce nom qualifié peut être persistant et utilisé ultérieurement pour charger le <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2338">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="09f45-2339">Pour rechercher et charger un <xref:System.Type>, utilisez <xref:System.Type.GetType%2A> avec le type de nom uniquement ou avec le nom de type qualifié d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2339">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="09f45-2340"><xref:System.Type.GetType%2A> avec le type de nom uniquement recherchera le <xref:System.Type> dans l’assembly de l’appelant, puis dans l’assembly système.</span><span class="sxs-lookup"><span data-stu-id="09f45-2340"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="09f45-2341"><xref:System.Type.GetType%2A> avec l’assembly de nom de type qualifié recherchera le <xref:System.Type> dans n’importe quel assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2341"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="09f45-2342">Noms de types peuvent inclure des caractères de fin qui indiquent des informations supplémentaires sur le type, par exemple si le type est un type référence, un type pointeur ou un type tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-2342">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="09f45-2343">Pour récupérer le nom de type sans ces caractères de fin, utilisez `t.GetElementType().ToString()`, où `t` est le type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2343">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="09f45-2344">Les espaces ne sont pertinentes dans tous les composants de nom de type, à l’exception du nom de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2344">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="09f45-2345">Nom de l’assembly, les espaces avant le séparateur ',', mais des espaces après le séparateur ',' sont ignorées.</span><span class="sxs-lookup"><span data-stu-id="09f45-2345">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="09f45-2346">Le nom d’un type générique se termine par un accent grave (\`) suivi de chiffres représentant le nombre d’arguments de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-2346">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="09f45-2347">L’objectif de cette altération des noms est de permettre aux compilateurs prendre en charge des types génériques portant le même nom mais avec différents nombres de paramètres de type, qui se produisent dans la même portée.</span><span class="sxs-lookup"><span data-stu-id="09f45-2347">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="09f45-2348">Par exemple, la réflexion retourne les noms tronqués `Tuple`1` and `Tuple`2` à partir des méthodes génériques `Tuple(Of T)` et `Tuple(Of T0, T1)` en Visual Basic, ou `Tuple<T>` et Tuple`\<T0, T1>` en Visual c#.</span><span class="sxs-lookup"><span data-stu-id="09f45-2348">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="09f45-2349">Pour les types génériques, la liste d’arguments de type est placé entre crochets et les arguments de type sont séparés par des virgules.</span><span class="sxs-lookup"><span data-stu-id="09f45-2349">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="09f45-2350">Par exemple, un type générique <xref:System.Collections.Generic.Dictionary%602> possède deux paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2350">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="09f45-2351">A <xref:System.Collections.Generic.Dictionary%602> de `MyType` avec des clés de type <xref:System.String> peut être représenté comme suit :</span><span class="sxs-lookup"><span data-stu-id="09f45-2351">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="09f45-2352">Pour spécifier un type qualifié d’assembly dans une liste d’arguments de type, mettez le type qualifié d’assembly entre crochets.</span><span class="sxs-lookup"><span data-stu-id="09f45-2352">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="09f45-2353">Sinon, les virgules qui séparent les parties du nom qualifié d’assembly sont interprétées comme délimitant les arguments de type supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="09f45-2353">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="09f45-2354">Par exemple, un <xref:System.Collections.Generic.Dictionary%602> de `MyType` fromMyAssembly.dll, avec des clés de type <xref:System.String>, peut être spécifiée comme suit :</span><span class="sxs-lookup"><span data-stu-id="09f45-2354">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` fromMyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="09f45-2355">Un type qualifié d’assembly peut être placé entre crochets uniquement lorsqu’il apparaît dans une liste de paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2355">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="09f45-2356">Les règles pour la recherche d’assemblys de types qualifiés et non qualifiés dans les listes de paramètres de type sont le même que les règles pour les types non génériques qualifiés et non qualifiés.</span><span class="sxs-lookup"><span data-stu-id="09f45-2356">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="09f45-2357">Les types Nullable sont un cas spécial de types génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-2357">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="09f45-2358">Par exemple, autorisant des valeurs null <xref:System.Int32> est représenté par la chaîne « System.Nullable'1[System.Int32] ».</span><span class="sxs-lookup"><span data-stu-id="09f45-2358">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-2359">En c#, C++ et Visual Basic, vous pouvez également obtenir des types nullables à l’aide d’opérateurs de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2359">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="09f45-2360">Par exemple, le nullable <xref:System.Boolean> type renvoyé par `typeof(Nullable<bool>)` en c#, par `Nullable<Boolean>::typeid` en C++ et par `GetType(Nullable(Of Boolean))` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="09f45-2360">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="09f45-2361">Le tableau suivant montre la syntaxe à utiliser avec `GetType` pour différents types.</span><span class="sxs-lookup"><span data-stu-id="09f45-2361">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="09f45-2362">Pour obtenir</span><span class="sxs-lookup"><span data-stu-id="09f45-2362">To Get</span></span>|<span data-ttu-id="09f45-2363">Utilisez</span><span class="sxs-lookup"><span data-stu-id="09f45-2363">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="09f45-2364">Un nullable <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="09f45-2364">A nullable <xref:System.Int32></span></span>|<span data-ttu-id="09f45-2365">`Type.GetType("System.Nullable`1[System.Int32]")\`</span><span class="sxs-lookup"><span data-stu-id="09f45-2365">`Type.GetType("System.Nullable`1[System.Int32]")\`</span></span>|  
|<span data-ttu-id="09f45-2366">Un pointeur non managé vers `MyType`</span><span class="sxs-lookup"><span data-stu-id="09f45-2366">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="09f45-2367">Un pointeur non managé vers un pointeur vers `MyType`</span><span class="sxs-lookup"><span data-stu-id="09f45-2367">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="09f45-2368">Un pointeur managé ou la référence à `MyType`</span><span class="sxs-lookup"><span data-stu-id="09f45-2368">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="09f45-2369">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2369">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="09f45-2370">Notez que contrairement aux pointeurs, les références sont limitées à un niveau.</span><span class="sxs-lookup"><span data-stu-id="09f45-2370">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="09f45-2371">Une classe parente et une classe imbriquée</span><span class="sxs-lookup"><span data-stu-id="09f45-2371">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="09f45-2372">Un tableau unidimensionnel avec une limite inférieure de 0</span><span class="sxs-lookup"><span data-stu-id="09f45-2372">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyType[]")`|  
|<span data-ttu-id="09f45-2373">Un tableau unidimensionnel avec une limite inférieure est inconnue</span><span class="sxs-lookup"><span data-stu-id="09f45-2373">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyType[*]")`|  
|<span data-ttu-id="09f45-2374">Un tableau à n dimensions</span><span class="sxs-lookup"><span data-stu-id="09f45-2374">An n-dimensional array</span></span>|<span data-ttu-id="09f45-2375">Une virgule (,) entre les crochets total de n-1 fois.</span><span class="sxs-lookup"><span data-stu-id="09f45-2375">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="09f45-2376">Par exemple, `System.Object[,,]` représente un graphique en trois dimensions `Object` tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-2376">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="09f45-2377">Un tableau de tableaux unidimensionnels</span><span class="sxs-lookup"><span data-stu-id="09f45-2377">An array of one-dimensional arrays</span></span>|`Type.GetType("MyType[][]")`|  
|<span data-ttu-id="09f45-2378">Un tableau rectangulaire à deux dimensions avec des limites inférieures inconnus</span><span class="sxs-lookup"><span data-stu-id="09f45-2378">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyType[,]")`|  
|<span data-ttu-id="09f45-2379">Un type générique avec un argument de type</span><span class="sxs-lookup"><span data-stu-id="09f45-2379">A generic type with one type argument</span></span>|<span data-ttu-id="09f45-2380">`Type.GetType("MyGenericType`1[MyType]")\`</span><span class="sxs-lookup"><span data-stu-id="09f45-2380">`Type.GetType("MyGenericType`1[MyType]")\`</span></span>|  
|<span data-ttu-id="09f45-2381">Un type générique avec deux arguments de type</span><span class="sxs-lookup"><span data-stu-id="09f45-2381">A generic type with two type arguments</span></span>|<span data-ttu-id="09f45-2382">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span><span class="sxs-lookup"><span data-stu-id="09f45-2382">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span></span>|  
|<span data-ttu-id="09f45-2383">Un type générique avec deux arguments de type qualifié d’assembly</span><span class="sxs-lookup"><span data-stu-id="09f45-2383">A generic type with two assembly-qualified type arguments</span></span>|<span data-ttu-id="09f45-2384">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span><span class="sxs-lookup"><span data-stu-id="09f45-2384">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span></span>|  
|<span data-ttu-id="09f45-2385">Un type générique qualifié d’assembly avec un argument de type qualifié d’assembly</span><span class="sxs-lookup"><span data-stu-id="09f45-2385">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="09f45-2386">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span><span class="sxs-lookup"><span data-stu-id="09f45-2386">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span></span>|  
|<span data-ttu-id="09f45-2387">Un type générique dont l’argument de type est un type générique avec deux arguments de type</span><span class="sxs-lookup"><span data-stu-id="09f45-2387">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="09f45-2388">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span><span class="sxs-lookup"><span data-stu-id="09f45-2388">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="09f45-2389">L’exemple suivant récupère le type de `System.Int32` et utilise cet objet de type pour afficher le <xref:System.Type.FullName%2A> propriété du `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2389">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-2390">
            <paramref name="typeName" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2390">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="09f45-2391">Un initialiseur de classe est appelé et lève une exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2391">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-2392">
            <paramref name="typeName" /> représente un type générique qui a un type pointeur, un type <see langword="ByRef" /> ou <see cref="T:System.Void" /> comme l’un de ses arguments de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2392">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="09f45-2393">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2393">-or-</span>
          </span>
          <span data-ttu-id="09f45-2394">
            <paramref name="typeName" /> représente un type générique qui a un nombre incorrect d’arguments de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2394">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="09f45-2395">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2395">-or-</span>
          </span>
          <span data-ttu-id="09f45-2396">
            <paramref name="typeName" /> représente un type générique, et un de ses arguments de type ne satisfait pas aux contraintes pour le paramètre de type correspondant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2396">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="09f45-2397">
            <paramref name="typeName" /> représente un tableau de <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2397">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="09f45-2398">Dans [.NET pour les applications du Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou la [Bibliothèque de classes portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), interceptez l’exception de la classe de base, <see cref="T:System.IO.IOException" />, à la place.</span>
              <span class="sxs-lookup">
                <span data-stu-id="09f45-2398">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="09f45-2399">L’assembly ou une de ses dépendances a été trouvé, mais n’a pas pu être chargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2399">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="09f45-2400">L’assembly ou une de ses dépendances n’est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2400">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="09f45-2401">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2401">-or-</span>
          </span>
          <span data-ttu-id="09f45-2402">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée, et l’assembly a été compilé avec une version ultérieure.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2402">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="09f45-2403">Nom qualifié d'assembly du type à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2403">The assembly-qualified name of the type to get.</span>
          </span>
          <span data-ttu-id="09f45-2404">Consultez <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2404">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          </span>
          <span data-ttu-id="09f45-2405">Si le type se trouve dans Mscorlib.dll ou l'assembly en cours d'exécution, il suffit de fournir le nom du type qualifié par son espace de noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2405">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="09f45-2406">
            <see langword="true" /> pour lever une exception si le type est introuvable ; <see langword="false" /> pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2406">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-2407">
            <see langword="false" /> supprime également d'autres conditions d'exception, mais pas toutes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2407">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="09f45-2408">Consultez la section Exceptions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2408">See the Exceptions section.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-2409">Obtient le <see cref="T:System.Type" /> portant le nom spécifié, en effectuant une recherche respectant la casse et en spécifiant s'il faut lever une exception si le type est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2409">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-2410">Type portant le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2410">The type with the specified name.</span>
          </span>
          <span data-ttu-id="09f45-2411">Si le type est introuvable, le paramètre <paramref name="throwOnError" /> spécifie si <see langword="null" /> est retourné ou bien une exception est levée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2411">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="09f45-2412">Dans certains cas, une exception est levée indépendamment de la valeur de <paramref name="throwOnError" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2412">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="09f45-2413">Consultez la section Exceptions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2413">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-2414">Vous pouvez utiliser la <xref:System.Type.GetType%2A> méthode pour obtenir un <xref:System.Type> de l’objet d’un type dans un autre assembly, si vous connaissez son nom qualifié d’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="09f45-2414">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if the you know its namespace-qualified name.</span></span> <span data-ttu-id="09f45-2415"><xref:System.Type.GetType%2A> provoque le chargement de l’assembly spécifié dans `typeName`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2415"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="09f45-2416">Vous pouvez également charger un assembly à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode), puis utiliser le <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> méthodes de la <xref:System.Reflection.Assembly> classe pour laquelle obtenir <xref:System.Type> objets.</span><span class="sxs-lookup"><span data-stu-id="09f45-2416">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="09f45-2417">Si un type est dans un assembly connu de votre programme au moment de la compilation, il est plus efficace d’utiliser `typeof` en c#, <xref:System.Type.GetType%2A> en Visual Basic, ou `typeid` en C++.</span><span class="sxs-lookup"><span data-stu-id="09f45-2417">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.</span></span>  
  
 <span data-ttu-id="09f45-2418">`GetType` fonctionne uniquement sur les assemblys chargés à partir du disque.</span><span class="sxs-lookup"><span data-stu-id="09f45-2418">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="09f45-2419">Si vous appelez `GetType` pour rechercher un type défini dans un assembly dynamique défini à l’aide de la <xref:System.Reflection.Emit> services, vous pouvez obtenir un comportement incohérent.</span><span class="sxs-lookup"><span data-stu-id="09f45-2419">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="09f45-2420">Le comportement varie selon que l’assembly dynamique est persistant, autrement dit, créé à l’aide de la `RunAndSave` ou `Save` accéder aux modes de le <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> énumération.</span><span class="sxs-lookup"><span data-stu-id="09f45-2420">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="09f45-2421">Si l’assembly dynamique est persistant et qu’il a été écrit sur le disque avant `GetType` est appelé, le chargeur recherche l’assembly enregistré sur le disque, charge l’assembly et récupère le type de cet assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2421">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="09f45-2422">Si l’assembly n’a pas été enregistré sur le disque lorsque `GetType` est appelée, la méthode retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2422">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="09f45-2423">`GetType` ne comprend pas les assemblys dynamiques transitoires ; Par conséquent, l’appel `GetType` pour récupérer un type dans un temporaire assembly dynamique retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2423">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="09f45-2424">Pour utiliser `GetType` sur un module dynamique, vous abonner à la <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> événements et les appels `GetType` avant l’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="09f45-2424">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="09f45-2425">Sinon, vous obtiendrez deux copies de l’assembly dans la mémoire.</span><span class="sxs-lookup"><span data-stu-id="09f45-2425">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="09f45-2426">Le `throwOnError` paramètre spécifie que se passe-t-il lorsque le type est introuvable et supprime également certaines autres conditions d’exception, comme décrit dans la section Exceptions.</span><span class="sxs-lookup"><span data-stu-id="09f45-2426">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="09f45-2427">Certaines exceptions sont levées, quelle que soit la valeur de `throwOnError`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2427">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="09f45-2428">Par exemple, si le type est trouvé mais ne peut pas être chargé, un <xref:System.TypeLoadException> est levée même si `throwOnError` est `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2428">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="09f45-2429">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2429">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-2430">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-2430">Member Type</span></span>|<span data-ttu-id="09f45-2431">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-2431">Static</span></span>|<span data-ttu-id="09f45-2432">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-2432">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-2433">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-2433">Constructor</span></span>|<span data-ttu-id="09f45-2434">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2434">No</span></span>|<span data-ttu-id="09f45-2435">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2435">No</span></span>|  
|<span data-ttu-id="09f45-2436">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-2436">Field</span></span>|<span data-ttu-id="09f45-2437">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2437">No</span></span>|<span data-ttu-id="09f45-2438">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-2438">Yes.</span></span> <span data-ttu-id="09f45-2439">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2439">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-2440">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-2440">Event</span></span>|<span data-ttu-id="09f45-2441">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-2441">Not applicable</span></span>|<span data-ttu-id="09f45-2442">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-2442">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-2443">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2443">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-2444">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-2444">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-2445">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-2445">Method</span></span>|<span data-ttu-id="09f45-2446">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2446">No</span></span>|<span data-ttu-id="09f45-2447">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-2447">Yes.</span></span> <span data-ttu-id="09f45-2448">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2448">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-2449">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-2449">Nested Type</span></span>|<span data-ttu-id="09f45-2450">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2450">No</span></span>|<span data-ttu-id="09f45-2451">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2451">No</span></span>|  
|<span data-ttu-id="09f45-2452">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-2452">Property</span></span>|<span data-ttu-id="09f45-2453">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-2453">Not applicable</span></span>|<span data-ttu-id="09f45-2454">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-2454">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-2455">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2455">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-2456">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-2456">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-2457">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-2457">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-2458">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-2458">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-2459">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2459">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-2460">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-2460">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-2461">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-2461">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="09f45-2462">Les tableaux ou types COM ne sont pas recherchés, sauf si elles ont déjà été chargés dans la table des classes disponibles.</span><span class="sxs-lookup"><span data-stu-id="09f45-2462">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="09f45-2463">`typeName` le nom de type qualifié par son espace de noms ou un nom qualifié d’assembly qui inclut une spécification de nom d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2463">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="09f45-2464">Consultez <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2464">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="09f45-2465">Si `typeName` inclut l’espace de noms mais pas le nom de l’assembly, cette méthode recherche uniquement les assembly de l’objet appelant et dans Mscorlib.dll, dans cet ordre.</span><span class="sxs-lookup"><span data-stu-id="09f45-2465">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="09f45-2466">Si typeName est qualifié avec le nom d’assembly partiel ou complet, cette méthode recherche dans l’assembly spécifié.</span><span class="sxs-lookup"><span data-stu-id="09f45-2466">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="09f45-2467">Si l’assembly a un nom fort, un nom d’assembly complet est requis.</span><span class="sxs-lookup"><span data-stu-id="09f45-2467">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="09f45-2468">Le <xref:System.Type.AssemblyQualifiedName%2A> propriété retourne un nom de type qualifié complet, y compris les types imbriqués, le nom de l’assembly et les arguments génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-2468">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</span></span> <span data-ttu-id="09f45-2469">Tous les compilateurs qui prennent en charge le common language runtime émettront le nom simple d’une classe imbriquée et la réflexion construit un nom tronqué interrogé, conformément aux conventions suivantes.</span><span class="sxs-lookup"><span data-stu-id="09f45-2469">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-2470">Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2470">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="09f45-2471">Par exemple, « ProcessorArchitecture = msil ».</span><span class="sxs-lookup"><span data-stu-id="09f45-2471">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="09f45-2472">Toutefois, il n’est pas inclus dans la chaîne retournée par la <xref:System.Type.AssemblyQualifiedName%2A> propriété, pour des raisons de compatibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-2472">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="09f45-2473">Vous pouvez également charger des types en créant un <xref:System.Reflection.AssemblyName> objet et en le passant à la surcharge appropriée de la <xref:System.Reflection.Assembly.Load%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-2473">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="09f45-2474">Vous pouvez ensuite utiliser le <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> méthode pour charger les types à partir de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2474">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="09f45-2475">Voir aussi <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2475">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="09f45-2476">Délimiteur</span><span class="sxs-lookup"><span data-stu-id="09f45-2476">Delimiter</span></span>|<span data-ttu-id="09f45-2477">Signification</span><span class="sxs-lookup"><span data-stu-id="09f45-2477">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="09f45-2478">Barre oblique inverse (\\)</span><span class="sxs-lookup"><span data-stu-id="09f45-2478">Backslash (\\)</span></span>|<span data-ttu-id="09f45-2479">Caractère d’échappement.</span><span class="sxs-lookup"><span data-stu-id="09f45-2479">Escape character.</span></span>|  
|<span data-ttu-id="09f45-2480">Accent grave (')</span><span class="sxs-lookup"><span data-stu-id="09f45-2480">Backtick (\`)</span></span>|<span data-ttu-id="09f45-2481">Précède un ou plusieurs chiffres représentant le nombre de paramètres de type, à la fin du nom d’un type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-2481">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="09f45-2482">crochets ([])</span><span class="sxs-lookup"><span data-stu-id="09f45-2482">Brackets ([])</span></span>|<span data-ttu-id="09f45-2483">Placez une liste d’arguments de type générique, pour un type générique construit ; dans une liste d’arguments de type, placez un type qualifié d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2483">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="09f45-2484">Comma (,)</span><span class="sxs-lookup"><span data-stu-id="09f45-2484">Comma (,)</span></span>|<span data-ttu-id="09f45-2485">Précède le nom de l’Assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2485">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="09f45-2486">Point (.)</span><span class="sxs-lookup"><span data-stu-id="09f45-2486">Period (.)</span></span>|<span data-ttu-id="09f45-2487">Indique les identificateurs d’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="09f45-2487">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="09f45-2488">Signe plus (+)</span><span class="sxs-lookup"><span data-stu-id="09f45-2488">Plus sign (+)</span></span>|<span data-ttu-id="09f45-2489">Précède une classe imbriquée.</span><span class="sxs-lookup"><span data-stu-id="09f45-2489">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="09f45-2490">Par exemple, le nom qualifié complet d’une classe peut ressembler à ceci :</span><span class="sxs-lookup"><span data-stu-id="09f45-2490">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="09f45-2491">Si l’espace de noms ont été TopNamespace, alors que la chaîne devrait faire précéder le signe plus (+) avec un caractère d’échappement (\\) pour l’empêcher d’être interprété comme un séparateur d’imbrication.</span><span class="sxs-lookup"><span data-stu-id="09f45-2491">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="09f45-2492">La réflexion génère cette chaîne comme suit :</span><span class="sxs-lookup"><span data-stu-id="09f45-2492">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="09f45-2493">Un « ++ » devient «\\+\\+ » et un «\\« devient »\\\\».</span><span class="sxs-lookup"><span data-stu-id="09f45-2493">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="09f45-2494">Ce nom qualifié peut être persistant et utilisé ultérieurement pour charger le <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2494">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="09f45-2495">Pour rechercher et charger un <xref:System.Type>, utilisez <xref:System.Type.GetType%2A> avec le type de nom uniquement ou avec le nom de type qualifié d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2495">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="09f45-2496"><xref:System.Type.GetType%2A> avec le type de nom uniquement recherchera le <xref:System.Type> dans l’assembly de l’appelant, puis dans l’assembly système.</span><span class="sxs-lookup"><span data-stu-id="09f45-2496"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="09f45-2497"><xref:System.Type.GetType%2A> avec l’assembly de nom de type qualifié recherchera le <xref:System.Type> dans n’importe quel assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2497"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="09f45-2498">Noms de types peuvent inclure des caractères de fin qui indiquent des informations supplémentaires sur le type, par exemple si le type est un type référence, un type pointeur ou un type tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-2498">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="09f45-2499">Pour récupérer le nom de type sans ces caractères de fin, utilisez `t.GetElementType().ToString()`, où `t` est le type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2499">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="09f45-2500">Les espaces ne sont pertinentes dans tous les composants de nom de type, à l’exception du nom de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2500">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="09f45-2501">Nom de l’assembly, les espaces avant le séparateur ',', mais des espaces après le séparateur ',' sont ignorées.</span><span class="sxs-lookup"><span data-stu-id="09f45-2501">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="09f45-2502">Le nom d’un type générique se termine par un accent grave (\`) suivi de chiffres représentant le nombre d’arguments de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-2502">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="09f45-2503">L’objectif de cette altération des noms est de permettre aux compilateurs prendre en charge des types génériques portant le même nom mais avec différents nombres de paramètres de type, qui se produisent dans la même portée.</span><span class="sxs-lookup"><span data-stu-id="09f45-2503">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="09f45-2504">Par exemple, la réflexion retourne les noms tronqués `Tuple`1` and `Tuple`2` à partir des méthodes génériques `Tuple(Of T)` et `Tuple(Of T0, T1)` en Visual Basic, ou `Tuple<T>` et Tuple`\<T0, T1>` en Visual c#.</span><span class="sxs-lookup"><span data-stu-id="09f45-2504">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="09f45-2505">Pour les types génériques, la liste d’arguments de type est placé entre crochets et les arguments de type sont séparés par des virgules.</span><span class="sxs-lookup"><span data-stu-id="09f45-2505">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="09f45-2506">Par exemple, un type générique <xref:System.Collections.Generic.Dictionary%602> possède deux paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2506">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="09f45-2507">A <xref:System.Collections.Generic.Dictionary%602> de `MyType` avec des clés de type <xref:System.String> peut être représenté comme suit :</span><span class="sxs-lookup"><span data-stu-id="09f45-2507">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="09f45-2508">Pour spécifier un type qualifié d’assembly dans une liste d’arguments de type, mettez le type qualifié d’assembly entre crochets.</span><span class="sxs-lookup"><span data-stu-id="09f45-2508">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="09f45-2509">Sinon, les virgules qui séparent les parties du nom qualifié d’assembly sont interprétées comme délimitant les arguments de type supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="09f45-2509">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="09f45-2510">Par exemple, un <xref:System.Collections.Generic.Dictionary%602> de `MyType` issu de MyAssembly.dll, avec des clés de type <xref:System.String>, peut être spécifiée comme suit :</span><span class="sxs-lookup"><span data-stu-id="09f45-2510">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="09f45-2511">Un type qualifié d’assembly peut être placé entre crochets uniquement lorsqu’il apparaît dans une liste de paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2511">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="09f45-2512">Les règles pour la recherche d’assemblys de types qualifiés et non qualifiés dans les listes de paramètres de type sont le même que les règles pour les types non génériques qualifiés et non qualifiés.</span><span class="sxs-lookup"><span data-stu-id="09f45-2512">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="09f45-2513">Les types Nullable sont un cas spécial de types génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-2513">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="09f45-2514">Par exemple, autorisant des valeurs null <xref:System.Int32> est représenté par la chaîne « System.Nullable'1[System.Int32] ».</span><span class="sxs-lookup"><span data-stu-id="09f45-2514">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-2515">En c#, C++ et Visual Basic, vous pouvez également obtenir des types nullables à l’aide d’opérateurs de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2515">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="09f45-2516">Par exemple, le nullable <xref:System.Boolean> type renvoyé par `typeof(Nullable<bool>)` en c#, par `Nullable<Boolean>::typeid` en C++ et par `GetType(Nullable(Of Boolean))` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="09f45-2516">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="09f45-2517">Le tableau suivant montre la syntaxe à utiliser avec `GetType` pour différents types.</span><span class="sxs-lookup"><span data-stu-id="09f45-2517">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="09f45-2518">Pour obtenir</span><span class="sxs-lookup"><span data-stu-id="09f45-2518">To Get</span></span>|<span data-ttu-id="09f45-2519">Utilisez</span><span class="sxs-lookup"><span data-stu-id="09f45-2519">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="09f45-2520">Un nullable <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="09f45-2520">A nullable <xref:System.Int32></span></span>|<span data-ttu-id="09f45-2521">`Type.GetType("System.Nullable`1[System.Int32]")\`</span><span class="sxs-lookup"><span data-stu-id="09f45-2521">`Type.GetType("System.Nullable`1[System.Int32]")\`</span></span>|  
|<span data-ttu-id="09f45-2522">Un pointeur non managé vers `MyType`</span><span class="sxs-lookup"><span data-stu-id="09f45-2522">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="09f45-2523">Un pointeur non managé vers un pointeur vers `MyType`</span><span class="sxs-lookup"><span data-stu-id="09f45-2523">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="09f45-2524">Un pointeur managé ou la référence à `MyType`</span><span class="sxs-lookup"><span data-stu-id="09f45-2524">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="09f45-2525">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2525">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="09f45-2526">Notez que contrairement aux pointeurs, les références sont limitées à un niveau.</span><span class="sxs-lookup"><span data-stu-id="09f45-2526">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="09f45-2527">Une classe parente et une classe imbriquée</span><span class="sxs-lookup"><span data-stu-id="09f45-2527">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="09f45-2528">Un tableau unidimensionnel avec une limite inférieure de 0</span><span class="sxs-lookup"><span data-stu-id="09f45-2528">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="09f45-2529">Un tableau unidimensionnel avec une limite inférieure est inconnue</span><span class="sxs-lookup"><span data-stu-id="09f45-2529">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="09f45-2530">Un tableau à n dimensions</span><span class="sxs-lookup"><span data-stu-id="09f45-2530">An n-dimensional array</span></span>|<span data-ttu-id="09f45-2531">Une virgule (,) entre les crochets total de n-1 fois.</span><span class="sxs-lookup"><span data-stu-id="09f45-2531">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="09f45-2532">Par exemple, `System.Object[,,]` représente un graphique en trois dimensions `Object` tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-2532">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="09f45-2533">Tableau d’un tableau à deux dimensions</span><span class="sxs-lookup"><span data-stu-id="09f45-2533">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="09f45-2534">Un tableau rectangulaire à deux dimensions avec des limites inférieures inconnus</span><span class="sxs-lookup"><span data-stu-id="09f45-2534">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="09f45-2535">Un type générique avec un argument de type</span><span class="sxs-lookup"><span data-stu-id="09f45-2535">A generic type with one type argument</span></span>|<span data-ttu-id="09f45-2536">`Type.GetType("MyGenericType`1[MyType]")\`</span><span class="sxs-lookup"><span data-stu-id="09f45-2536">`Type.GetType("MyGenericType`1[MyType]")\`</span></span>|  
|<span data-ttu-id="09f45-2537">Un type générique avec deux arguments de type</span><span class="sxs-lookup"><span data-stu-id="09f45-2537">A generic type with two type arguments</span></span>|<span data-ttu-id="09f45-2538">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span><span class="sxs-lookup"><span data-stu-id="09f45-2538">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span></span>|  
|<span data-ttu-id="09f45-2539">Un type générique avec deux arguments de type qualifié d’assembly</span><span class="sxs-lookup"><span data-stu-id="09f45-2539">A generic type with two assembly-qualified type arguments</span></span>|<span data-ttu-id="09f45-2540">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span><span class="sxs-lookup"><span data-stu-id="09f45-2540">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span></span>|  
|<span data-ttu-id="09f45-2541">Un type générique qualifié d’assembly avec un argument de type qualifié d’assembly</span><span class="sxs-lookup"><span data-stu-id="09f45-2541">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="09f45-2542">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span><span class="sxs-lookup"><span data-stu-id="09f45-2542">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span></span>|  
|<span data-ttu-id="09f45-2543">Un type générique dont l’argument de type est un type générique avec deux arguments de type</span><span class="sxs-lookup"><span data-stu-id="09f45-2543">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="09f45-2544">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span><span class="sxs-lookup"><span data-stu-id="09f45-2544">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="09f45-2545">L’exemple suivant récupère le type de `System.Int32` et utilise cet objet de type pour afficher le <xref:System.Type.FullName%2A> propriété du `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2545">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span> <span data-ttu-id="09f45-2546">Si un objet de type fait référence à un assembly qui n’existe pas, cet exemple lève une exception.</span><span class="sxs-lookup"><span data-stu-id="09f45-2546">If a type object refers to an assembly that does not exist, this example throws an exception.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-2547">
            <paramref name="typeName" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2547">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="09f45-2548">Un initialiseur de classe est appelé et lève une exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2548">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="09f45-2549">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et le type est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2549">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="09f45-2550">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2550">-or-</span>
          </span>
          <span data-ttu-id="09f45-2551">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient des caractères non valides, tels qu’une tabulation incorporée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2551">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="09f45-2552">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2552">-or-</span>
          </span>
          <span data-ttu-id="09f45-2553">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> est une chaîne vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2553">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="09f45-2554">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2554">-or-</span>
          </span>
          <span data-ttu-id="09f45-2555">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> représente un type de tableau avec une taille non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2555">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="09f45-2556">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2556">-or-</span>
          </span>
          <span data-ttu-id="09f45-2557">
            <paramref name="typeName" /> représente un tableau de <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2557">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-2558">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient une syntaxe non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2558">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span>
          </span>
          <span data-ttu-id="09f45-2559">Par exemple, « MyType [, \*,] ».</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2559">For example, "MyType[,\*,]".</span>
          </span>
          <span data-ttu-id="09f45-2560">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2560">-or-</span>
          </span>
          <span data-ttu-id="09f45-2561">
            <paramref name="typeName" /> représente un type générique qui a un type pointeur, un type <see langword="ByRef" /> ou <see cref="T:System.Void" /> comme l’un de ses arguments de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2561">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="09f45-2562">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2562">-or-</span>
          </span>
          <span data-ttu-id="09f45-2563">
            <paramref name="typeName" /> représente un type générique qui a un nombre incorrect d’arguments de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2563">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="09f45-2564">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2564">-or-</span>
          </span>
          <span data-ttu-id="09f45-2565">
            <paramref name="typeName" /> représente un type générique, et un de ses arguments de type ne satisfait pas aux contraintes pour le paramètre de type correspondant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2565">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="09f45-2566">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et l’assembly ou l’une de ses dépendances est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2566">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="09f45-2567">Dans [.NET pour les applications du Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou la [Bibliothèque de classes portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), interceptez l’exception de la classe de base, <see cref="T:System.IO.IOException" />, à la place.</span>
              <span class="sxs-lookup">
                <span data-stu-id="09f45-2567">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="09f45-2568">L’assembly ou une de ses dépendances a été trouvé, mais n’a pas pu être chargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2568">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="09f45-2569">L’assembly ou une de ses dépendances n’est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2569">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="09f45-2570">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2570">-or-</span>
          </span>
          <span data-ttu-id="09f45-2571">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée, et l’assembly a été compilé avec une version ultérieure.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2571">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="09f45-2572">Nom qualifié d'assembly du type à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2572">The assembly-qualified name of the type to get.</span>
          </span>
          <span data-ttu-id="09f45-2573">Consultez <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2573">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          </span>
          <span data-ttu-id="09f45-2574">Si le type se trouve dans Mscorlib.dll ou l'assembly en cours d'exécution, il suffit de fournir le nom du type qualifié par son espace de noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2574">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="09f45-2575">
            <see langword="true" /> pour lever une exception si le type est introuvable ; <see langword="false" /> pour retourner <see langword="null" />. La spécification de <see langword="false" /> supprime également d'autres conditions d'exception, mais pas toutes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2575">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="09f45-2576">Consultez la section Exceptions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2576">See the Exceptions section.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="09f45-2577">
            <see langword="true" /> pour effectuer une recherche qui ne respecte pas la casse de <c>typeName</c> ; <see langword="false" /> pour effectuer une recherche qui respecte la casse de <c>typeName</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2577">
              <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>, <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-2578">Obtient le <see cref="T:System.Type" /> portant le nom spécifié, indiquant s'il faut lever une exception si le type est introuvable et s'il faut effectuer une recherche respectant la casse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2578">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-2579">Type portant le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2579">The type with the specified name.</span>
          </span>
          <span data-ttu-id="09f45-2580">Si le type est introuvable, le paramètre <paramref name="throwOnError" /> spécifie si <see langword="null" /> est retourné ou bien une exception est levée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2580">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="09f45-2581">Dans certains cas, une exception est levée indépendamment de la valeur de <paramref name="throwOnError" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2581">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="09f45-2582">Consultez la section Exceptions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2582">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-2583">Vous pouvez utiliser la <xref:System.Type.GetType%2A> méthode pour obtenir un <xref:System.Type> de l’objet d’un type dans un autre assembly, si vous connaissez son nom qualifié d’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="09f45-2583">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if the you know its namespace-qualified name.</span></span> <span data-ttu-id="09f45-2584"><xref:System.Type.GetType%2A> provoque le chargement de l’assembly spécifié dans `typeName`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2584"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="09f45-2585">Vous pouvez également charger un assembly à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode), puis utiliser le <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> méthodes de la <xref:System.Reflection.Assembly> classe pour laquelle obtenir <xref:System.Type> objets.</span><span class="sxs-lookup"><span data-stu-id="09f45-2585">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="09f45-2586">Si un type est dans un assembly connu de votre programme au moment de la compilation, il est plus efficace d’utiliser `typeof` en c#, <xref:System.Type.GetType%2A> en Visual Basic, ou `typeid` en C++.</span><span class="sxs-lookup"><span data-stu-id="09f45-2586">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.</span></span>  
  
 <span data-ttu-id="09f45-2587">`GetType` fonctionne uniquement sur les assemblys chargés à partir du disque.</span><span class="sxs-lookup"><span data-stu-id="09f45-2587">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="09f45-2588">Si vous appelez `GetType` pour rechercher un type défini dans un assembly dynamique défini à l’aide de la <xref:System.Reflection.Emit> services, vous pouvez obtenir un comportement incohérent.</span><span class="sxs-lookup"><span data-stu-id="09f45-2588">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="09f45-2589">Le comportement varie selon que l’assembly dynamique est persistant, autrement dit, créé à l’aide de la `RunAndSave` ou `Save` accéder aux modes de le <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> énumération.</span><span class="sxs-lookup"><span data-stu-id="09f45-2589">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="09f45-2590">Si l’assembly dynamique est persistant et qu’il a été écrit sur le disque avant `GetType` est appelé, le chargeur recherche l’assembly enregistré sur le disque, charge l’assembly et récupère le type de cet assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2590">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="09f45-2591">Si l’assembly n’a pas été enregistré sur le disque lorsque `GetType` est appelée, la méthode retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2591">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="09f45-2592">`GetType` ne comprend pas les assemblys dynamiques transitoires ; Par conséquent, l’appel `GetType` pour récupérer un type dans un temporaire assembly dynamique retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2592">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="09f45-2593">Pour utiliser `GetType` sur un module dynamique, vous abonner à la <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> événements et les appels `GetType` avant l’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="09f45-2593">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="09f45-2594">Sinon, vous obtiendrez deux copies de l’assembly dans la mémoire.</span><span class="sxs-lookup"><span data-stu-id="09f45-2594">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="09f45-2595">Le `throwOnError` paramètre spécifie que se passe-t-il lorsque le type est introuvable et supprime également certaines autres conditions d’exception, comme décrit dans la section Exceptions.</span><span class="sxs-lookup"><span data-stu-id="09f45-2595">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="09f45-2596">Certaines exceptions sont levées, quelle que soit la valeur de `throwOnError`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2596">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="09f45-2597">Par exemple, si le type est trouvé mais ne peut pas être chargé, un <xref:System.TypeLoadException> est levée même si `throwOnError` est `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2597">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="09f45-2598">Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2598">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="09f45-2599">Type de membre</span><span class="sxs-lookup"><span data-stu-id="09f45-2599">Member Type</span></span>|<span data-ttu-id="09f45-2600">Statique</span><span class="sxs-lookup"><span data-stu-id="09f45-2600">Static</span></span>|<span data-ttu-id="09f45-2601">Non statique</span><span class="sxs-lookup"><span data-stu-id="09f45-2601">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="09f45-2602">Constructeur</span><span class="sxs-lookup"><span data-stu-id="09f45-2602">Constructor</span></span>|<span data-ttu-id="09f45-2603">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2603">No</span></span>|<span data-ttu-id="09f45-2604">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2604">No</span></span>|  
|<span data-ttu-id="09f45-2605">Champ</span><span class="sxs-lookup"><span data-stu-id="09f45-2605">Field</span></span>|<span data-ttu-id="09f45-2606">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2606">No</span></span>|<span data-ttu-id="09f45-2607">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-2607">Yes.</span></span> <span data-ttu-id="09f45-2608">Un champ est toujours masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2608">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-2609">événement</span><span class="sxs-lookup"><span data-stu-id="09f45-2609">Event</span></span>|<span data-ttu-id="09f45-2610">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-2610">Not applicable</span></span>|<span data-ttu-id="09f45-2611">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-2611">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-2612">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2612">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-2613">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-2613">See note 2 below.</span></span>|  
|<span data-ttu-id="09f45-2614">Méthode</span><span class="sxs-lookup"><span data-stu-id="09f45-2614">Method</span></span>|<span data-ttu-id="09f45-2615">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2615">No</span></span>|<span data-ttu-id="09f45-2616">Oui.</span><span class="sxs-lookup"><span data-stu-id="09f45-2616">Yes.</span></span> <span data-ttu-id="09f45-2617">Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2617">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="09f45-2618">Type imbriqué</span><span class="sxs-lookup"><span data-stu-id="09f45-2618">Nested Type</span></span>|<span data-ttu-id="09f45-2619">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2619">No</span></span>|<span data-ttu-id="09f45-2620">Non</span><span class="sxs-lookup"><span data-stu-id="09f45-2620">No</span></span>|  
|<span data-ttu-id="09f45-2621">Property</span><span class="sxs-lookup"><span data-stu-id="09f45-2621">Property</span></span>|<span data-ttu-id="09f45-2622">Non applicable</span><span class="sxs-lookup"><span data-stu-id="09f45-2622">Not applicable</span></span>|<span data-ttu-id="09f45-2623">La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-2623">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="09f45-2624">Réflexion traite les propriétés comme masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2624">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-2625">Voir la Remarque 2 ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="09f45-2625">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="09f45-2626">Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour.</span><span class="sxs-lookup"><span data-stu-id="09f45-2626">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="09f45-2627">Il s’agit d’une comparaison binaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-2627">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="09f45-2628">Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature.</span><span class="sxs-lookup"><span data-stu-id="09f45-2628">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="09f45-2629">Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-2629">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="09f45-2630">Attributs personnalisés ne font pas partie du système de type commun.</span><span class="sxs-lookup"><span data-stu-id="09f45-2630">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="09f45-2631">Les tableaux ou types COM ne sont pas recherchés, sauf si elles ont déjà été chargés dans la table des classes disponibles.</span><span class="sxs-lookup"><span data-stu-id="09f45-2631">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="09f45-2632">`typeName` le nom de type qualifié par son espace de noms ou un nom qualifié d’assembly qui inclut une spécification de nom d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2632">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="09f45-2633">Consultez <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2633">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="09f45-2634">Si `typeName` inclut l’espace de noms mais pas le nom de l’assembly, cette méthode recherche uniquement les assembly de l’objet appelant et dans Mscorlib.dll, dans cet ordre.</span><span class="sxs-lookup"><span data-stu-id="09f45-2634">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="09f45-2635">Si typeName est qualifié avec le nom d’assembly partiel ou complet, cette méthode recherche dans l’assembly spécifié.</span><span class="sxs-lookup"><span data-stu-id="09f45-2635">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="09f45-2636">Si l’assembly a un nom fort, un nom d’assembly complet est requis.</span><span class="sxs-lookup"><span data-stu-id="09f45-2636">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="09f45-2637">Le <xref:System.Type.AssemblyQualifiedName%2A> propriété retourne un nom de type qualifié complet, y compris les types imbriqués, le nom de l’assembly et les arguments de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2637">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</span></span> <span data-ttu-id="09f45-2638">Tous les compilateurs qui prennent en charge le common language runtime émettront le nom simple d’une classe imbriquée et la réflexion construit un nom tronqué interrogé, conformément aux conventions suivantes.</span><span class="sxs-lookup"><span data-stu-id="09f45-2638">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-2639">Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2639">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="09f45-2640">Par exemple, « ProcessorArchitecture = msil ».</span><span class="sxs-lookup"><span data-stu-id="09f45-2640">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="09f45-2641">Toutefois, il n’est pas inclus dans la chaîne retournée par la <xref:System.Type.AssemblyQualifiedName%2A> propriété, pour des raisons de compatibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-2641">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="09f45-2642">Vous pouvez également charger des types en créant un <xref:System.Reflection.AssemblyName> objet et en le passant à la surcharge appropriée de la <xref:System.Reflection.Assembly.Load%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-2642">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="09f45-2643">Vous pouvez ensuite utiliser le <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> méthode pour charger les types à partir de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2643">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="09f45-2644">Voir aussi <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2644">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="09f45-2645">Délimiteur</span><span class="sxs-lookup"><span data-stu-id="09f45-2645">Delimiter</span></span>|<span data-ttu-id="09f45-2646">Signification</span><span class="sxs-lookup"><span data-stu-id="09f45-2646">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="09f45-2647">Barre oblique inverse (\\)</span><span class="sxs-lookup"><span data-stu-id="09f45-2647">Backslash (\\)</span></span>|<span data-ttu-id="09f45-2648">Caractère d’échappement.</span><span class="sxs-lookup"><span data-stu-id="09f45-2648">Escape character.</span></span>|  
|<span data-ttu-id="09f45-2649">Accent grave (')</span><span class="sxs-lookup"><span data-stu-id="09f45-2649">Backtick (\`)</span></span>|<span data-ttu-id="09f45-2650">Précède un ou plusieurs chiffres représentant le nombre de paramètres de type, à la fin du nom d’un type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-2650">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="09f45-2651">crochets ([])</span><span class="sxs-lookup"><span data-stu-id="09f45-2651">Brackets ([])</span></span>|<span data-ttu-id="09f45-2652">Placez une liste d’arguments de type générique, pour un type générique construit ; dans une liste d’arguments de type, placez un type qualifié d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2652">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="09f45-2653">Comma (,)</span><span class="sxs-lookup"><span data-stu-id="09f45-2653">Comma (,)</span></span>|<span data-ttu-id="09f45-2654">Précède le nom de l’Assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2654">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="09f45-2655">Point (.)</span><span class="sxs-lookup"><span data-stu-id="09f45-2655">Period (.)</span></span>|<span data-ttu-id="09f45-2656">Indique les identificateurs d’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="09f45-2656">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="09f45-2657">Signe plus (+)</span><span class="sxs-lookup"><span data-stu-id="09f45-2657">Plus sign (+)</span></span>|<span data-ttu-id="09f45-2658">Précède une classe imbriquée.</span><span class="sxs-lookup"><span data-stu-id="09f45-2658">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="09f45-2659">Par exemple, le nom qualifié complet d’une classe peut ressembler à ceci :</span><span class="sxs-lookup"><span data-stu-id="09f45-2659">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="09f45-2660">Si l’espace de noms ont été TopNamespace, alors que la chaîne devrait faire précéder le signe plus (+) avec un caractère d’échappement (\\) pour l’empêcher d’être interprété comme un séparateur d’imbrication.</span><span class="sxs-lookup"><span data-stu-id="09f45-2660">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="09f45-2661">La réflexion génère cette chaîne comme suit :</span><span class="sxs-lookup"><span data-stu-id="09f45-2661">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="09f45-2662">Un « ++ » devient «\\+\\+ » et un «\\« devient »\\\\».</span><span class="sxs-lookup"><span data-stu-id="09f45-2662">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="09f45-2663">Ce nom qualifié peut être persistant et utilisé ultérieurement pour charger le <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2663">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="09f45-2664">Pour rechercher et charger un <xref:System.Type>, utilisez <xref:System.Type.GetType%2A> avec le type de nom uniquement ou avec le nom de type qualifié d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2664">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="09f45-2665"><xref:System.Type.GetType%2A> avec le type de nom uniquement recherchera le <xref:System.Type> dans l’assembly de l’appelant, puis dans l’assembly système.</span><span class="sxs-lookup"><span data-stu-id="09f45-2665"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="09f45-2666"><xref:System.Type.GetType%2A> avec l’assembly de nom de type qualifié recherchera le <xref:System.Type> dans n’importe quel assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2666"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="09f45-2667">Noms de types peuvent inclure des caractères de fin qui indiquent des informations supplémentaires sur le type, par exemple si le type est un type référence, un type pointeur ou un type tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-2667">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="09f45-2668">Pour récupérer le nom de type sans ces caractères de fin, utilisez `t.GetElementType().ToString()`, où `t` est le type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2668">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="09f45-2669">Les espaces ne sont pertinentes dans tous les composants de nom de type, à l’exception du nom de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2669">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="09f45-2670">Nom de l’assembly, les espaces avant le séparateur ',', mais des espaces après le séparateur ',' sont ignorées.</span><span class="sxs-lookup"><span data-stu-id="09f45-2670">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="09f45-2671">Le nom d’un type générique se termine par un accent grave (\`) suivi de chiffres représentant le nombre d’arguments de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-2671">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="09f45-2672">L’objectif de cette altération des noms est de permettre aux compilateurs prendre en charge des types génériques portant le même nom mais avec différents nombres de paramètres de type, qui se produisent dans la même portée.</span><span class="sxs-lookup"><span data-stu-id="09f45-2672">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="09f45-2673">Par exemple, la réflexion retourne les noms tronqués `Tuple`1` and `Tuple`2` à partir des méthodes génériques `Tuple(Of T)` et `Tuple(Of T0, T1)` en Visual Basic, ou `Tuple<T>` et Tuple`\<T0, T1>` en Visual c#.</span><span class="sxs-lookup"><span data-stu-id="09f45-2673">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="09f45-2674">Pour les types génériques, la liste d’arguments de type est placé entre crochets et les arguments de type sont séparés par des virgules.</span><span class="sxs-lookup"><span data-stu-id="09f45-2674">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="09f45-2675">Par exemple, un type générique <xref:System.Collections.Generic.Dictionary%602> possède deux paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2675">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="09f45-2676">A <xref:System.Collections.Generic.Dictionary%602> de `MyType` avec des clés de type <xref:System.String> peut être représenté comme suit :</span><span class="sxs-lookup"><span data-stu-id="09f45-2676">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="09f45-2677">Pour spécifier un type qualifié d’assembly dans une liste d’arguments de type, mettez le type qualifié d’assembly entre crochets.</span><span class="sxs-lookup"><span data-stu-id="09f45-2677">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="09f45-2678">Sinon, les virgules qui séparent les parties du nom qualifié d’assembly sont interprétées comme délimitant les arguments de type supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="09f45-2678">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="09f45-2679">Par exemple, un <xref:System.Collections.Generic.Dictionary%602> de `MyType` issu de MyAssembly.dll, avec des clés de type <xref:System.String>, peut être spécifiée comme suit :</span><span class="sxs-lookup"><span data-stu-id="09f45-2679">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="09f45-2680">Un type qualifié d’assembly peut être placé entre crochets uniquement lorsqu’il apparaît dans une liste de paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2680">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="09f45-2681">Les règles pour la recherche d’assemblys de types qualifiés et non qualifiés dans les listes de paramètres de type sont le même que les règles pour les types non génériques qualifiés et non qualifiés.</span><span class="sxs-lookup"><span data-stu-id="09f45-2681">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="09f45-2682">Les types Nullable sont un cas spécial de types génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-2682">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="09f45-2683">Par exemple, autorisant des valeurs null <xref:System.Int32> est représenté par la chaîne « System.Nullable'1[System.Int32] ».</span><span class="sxs-lookup"><span data-stu-id="09f45-2683">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-2684">En c#, C++ et Visual Basic, vous pouvez également obtenir des types nullables à l’aide d’opérateurs de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2684">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="09f45-2685">Par exemple, le nullable <xref:System.Boolean> type renvoyé par `typeof(Nullable<bool>)` en c#, par `Nullable<Boolean>::typeid` en C++ et par `GetType(Nullable(Of Boolean))` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="09f45-2685">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="09f45-2686">Le tableau suivant montre la syntaxe à utiliser avec `GetType` pour différents types.</span><span class="sxs-lookup"><span data-stu-id="09f45-2686">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="09f45-2687">Pour obtenir</span><span class="sxs-lookup"><span data-stu-id="09f45-2687">To Get</span></span>|<span data-ttu-id="09f45-2688">Utilisez</span><span class="sxs-lookup"><span data-stu-id="09f45-2688">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="09f45-2689">Un nullable <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="09f45-2689">A nullable <xref:System.Int32></span></span>|<span data-ttu-id="09f45-2690">`Type.GetType("System.Nullable`1[System.Int32]")\`</span><span class="sxs-lookup"><span data-stu-id="09f45-2690">`Type.GetType("System.Nullable`1[System.Int32]")\`</span></span>|  
|<span data-ttu-id="09f45-2691">Un pointeur non managé vers `MyType`</span><span class="sxs-lookup"><span data-stu-id="09f45-2691">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="09f45-2692">Un pointeur non managé vers un pointeur vers `MyType`</span><span class="sxs-lookup"><span data-stu-id="09f45-2692">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="09f45-2693">Un pointeur managé ou la référence à `MyType`</span><span class="sxs-lookup"><span data-stu-id="09f45-2693">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="09f45-2694">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2694">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="09f45-2695">Notez que contrairement aux pointeurs, les références sont limitées à un niveau.</span><span class="sxs-lookup"><span data-stu-id="09f45-2695">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="09f45-2696">Une classe parente et une classe imbriquée</span><span class="sxs-lookup"><span data-stu-id="09f45-2696">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="09f45-2697">Un tableau unidimensionnel avec une limite inférieure de 0</span><span class="sxs-lookup"><span data-stu-id="09f45-2697">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="09f45-2698">Un tableau unidimensionnel avec une limite inférieure est inconnue</span><span class="sxs-lookup"><span data-stu-id="09f45-2698">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="09f45-2699">Un tableau à n dimensions</span><span class="sxs-lookup"><span data-stu-id="09f45-2699">An n-dimensional array</span></span>|<span data-ttu-id="09f45-2700">Une virgule (,) entre les crochets total de n-1 fois.</span><span class="sxs-lookup"><span data-stu-id="09f45-2700">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="09f45-2701">Par exemple, `System.Object[,,]` représente un graphique en trois dimensions `Object` tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-2701">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="09f45-2702">Tableau d’un tableau à deux dimensions</span><span class="sxs-lookup"><span data-stu-id="09f45-2702">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="09f45-2703">Un tableau rectangulaire à deux dimensions avec des limites inférieures inconnus</span><span class="sxs-lookup"><span data-stu-id="09f45-2703">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="09f45-2704">Un type générique avec un argument de type</span><span class="sxs-lookup"><span data-stu-id="09f45-2704">A generic type with one type argument</span></span>|<span data-ttu-id="09f45-2705">`Type.GetType("MyGenericType`1[MyType]")\`</span><span class="sxs-lookup"><span data-stu-id="09f45-2705">`Type.GetType("MyGenericType`1[MyType]")\`</span></span>|  
|<span data-ttu-id="09f45-2706">Un type générique avec deux arguments de type</span><span class="sxs-lookup"><span data-stu-id="09f45-2706">A generic type with two type arguments</span></span>|<span data-ttu-id="09f45-2707">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span><span class="sxs-lookup"><span data-stu-id="09f45-2707">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span></span>|  
|<span data-ttu-id="09f45-2708">Un type générique avec deux arguments de type qualifié d’assembly</span><span class="sxs-lookup"><span data-stu-id="09f45-2708">A generic type with two assembly-qualified type arguments</span></span>|<span data-ttu-id="09f45-2709">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span><span class="sxs-lookup"><span data-stu-id="09f45-2709">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span></span>|  
|<span data-ttu-id="09f45-2710">Un type générique qualifié d’assembly avec un argument de type qualifié d’assembly</span><span class="sxs-lookup"><span data-stu-id="09f45-2710">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="09f45-2711">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span><span class="sxs-lookup"><span data-stu-id="09f45-2711">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span></span>|  
|<span data-ttu-id="09f45-2712">Un type générique dont l’argument de type est un type générique avec deux arguments de type</span><span class="sxs-lookup"><span data-stu-id="09f45-2712">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="09f45-2713">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span><span class="sxs-lookup"><span data-stu-id="09f45-2713">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-2714">
            <paramref name="typeName" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2714">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="09f45-2715">Un initialiseur de classe est appelé et lève une exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2715">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="09f45-2716">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et le type est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2716">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="09f45-2717">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2717">-or-</span>
          </span>
          <span data-ttu-id="09f45-2718">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient des caractères non valides, tels qu’une tabulation incorporée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2718">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="09f45-2719">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2719">-or-</span>
          </span>
          <span data-ttu-id="09f45-2720">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> est une chaîne vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2720">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="09f45-2721">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2721">-or-</span>
          </span>
          <span data-ttu-id="09f45-2722">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> représente un type de tableau avec une taille non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2722">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="09f45-2723">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2723">-or-</span>
          </span>
          <span data-ttu-id="09f45-2724">
            <paramref name="typeName" /> représente un tableau de <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2724">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-2725">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient une syntaxe non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2725">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span>
          </span>
          <span data-ttu-id="09f45-2726">Par exemple, « MyType [, \*,] ».</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2726">For example, "MyType[,\*,]".</span>
          </span>
          <span data-ttu-id="09f45-2727">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2727">-or-</span>
          </span>
          <span data-ttu-id="09f45-2728">
            <paramref name="typeName" /> représente un type générique qui a un type pointeur, un type <see langword="ByRef" /> ou <see cref="T:System.Void" /> comme l’un de ses arguments de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2728">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="09f45-2729">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2729">-or-</span>
          </span>
          <span data-ttu-id="09f45-2730">
            <paramref name="typeName" /> représente un type générique qui a un nombre incorrect d’arguments de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2730">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="09f45-2731">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2731">-or-</span>
          </span>
          <span data-ttu-id="09f45-2732">
            <paramref name="typeName" /> représente un type générique, et un de ses arguments de type ne satisfait pas aux contraintes pour le paramètre de type correspondant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2732">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="09f45-2733">
            <paramref name="throwOnError" /> a la valeur <see langword="true" />, et l’assembly ou l’une de ses dépendances est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2733">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="09f45-2734">L’assembly ou une de ses dépendances a été trouvé, mais n’a pas pu être chargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2734">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="09f45-2735">L’assembly ou une de ses dépendances n’est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2735">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="09f45-2736">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2736">-or-</span>
          </span>
          <span data-ttu-id="09f45-2737">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée, et l’assembly a été compilé avec une version ultérieure.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2737">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="09f45-2738">Nom du type à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2738">The name of the type to get.</span>
          </span>
          <span data-ttu-id="09f45-2739">Si le paramètre <c>typeResolver</c> est fourni, le nom de type peut être n’importe quelle chaîne pouvant être résolue par <c>typeResolver</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2739">If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving.</span>
          </span>
          <span data-ttu-id="09f45-2740">Si le paramètre <c>assemblyResolver</c> est fourni ou si la résolution de type standard est utilisée, <c>typeName</c> doit être un nom d’assembly complet (voir <see cref="P:System.Type.AssemblyQualifiedName" />), à moins que le type ne se trouve dans l’assembly en cours d’exécution ou dans Mscorlib.dll, cas dans lequel il suffit de fournir le nom de type qualifié par son espace de noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2740">If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="assemblyResolver">
          <span data-ttu-id="09f45-2741">Méthode qui trouve et retourne l’assembly spécifié dans <c>typeName</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2741">A method that locates and returns the assembly that is specified in <c>typeName</c>.</span>
          </span>
          <span data-ttu-id="09f45-2742">Le nom de l’assembly est passé à <c>assemblyResolver</c> en tant qu’objet <see cref="T:System.Reflection.AssemblyName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2742">The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
          <span data-ttu-id="09f45-2743">Si <c>typeName</c> ne contient pas le nom d’un assembly, <c>assemblyResolver</c> n’est pas appelé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2743">If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called.</span>
          </span>
          <span data-ttu-id="09f45-2744">Si <c>assemblyResolver</c> n’est pas fourni, une résolution d’assembly standard est effectuée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2744">If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.</span>
          </span>
          <span data-ttu-id="09f45-2745">Attention   Ne passez pas de méthodes provenant d’appelants inconnus ou non fiables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2745">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
          <span data-ttu-id="09f45-2746">Vous risqueriez d'élever les privilèges du code malveillant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2746">Doing so could result in elevation of privilege for malicious code.</span>
          </span>
          <span data-ttu-id="09f45-2747">Utilisez uniquement les méthodes que vous fournissez ou avec lesquelles vous êtes familiarisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2747">Use only methods that you provide or that you are familiar with.</span>
          </span>
        </param>
        <param name="typeResolver">
          <span data-ttu-id="09f45-2748">Méthode qui trouve et retourne le type spécifié par <c>typeName</c> à partir de l’assembly retourné par <c>assemblyResolver</c> ou par la résolution d’assembly standard.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2748">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution.</span>
          </span>
          <span data-ttu-id="09f45-2749">Si aucun assembly n’est fourni, la méthode <c>typeResolver</c> peut en fournir un.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2749">If no assembly is provided, the <c>typeResolver</c> method can provide one.</span>
          </span>
          <span data-ttu-id="09f45-2750">La méthode prend également un paramètre qui spécifie s'il faut exécuter une recherche non sensible à la casse ; <see langword="false" /> est passé à ce paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2750">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span>
          </span>
          <span data-ttu-id="09f45-2751">Attention   Ne passez pas de méthodes provenant d’appelants inconnus ou non fiables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2751">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-2752">Obtient le type avec le nom spécifié et éventuellement des méthodes personnalisées permettant de résoudre l'assembly et le type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2752">Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-2753">Type portant le nom spécifié, ou <see langword="null" /> si le type est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2753">The type with the specified name, or <see langword="null" /> if the type is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-2754">Scénarios d’utilisation pour cette méthode et les détails de la `assemblyResolver` et `typeResolver` paramètres peuvent être trouvés dans le <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="09f45-2754">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-2755">Si `typeName` ne peut pas être trouvée, l’appel à la <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> méthode renvoie `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2755">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`.</span></span> <span data-ttu-id="09f45-2756">Il ne lève pas d’exception.</span><span class="sxs-lookup"><span data-stu-id="09f45-2756">It does not throw an exception.</span></span> <span data-ttu-id="09f45-2757">Pour contrôler si une exception est levée, appelez une surcharge de la <xref:System.Type.GetType%2A> méthode qui a un `throwOnError` paramètre.</span><span class="sxs-lookup"><span data-stu-id="09f45-2757">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="09f45-2758">Appel de cette surcharge de méthode est le même que d’appeler le <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode et en spécifiant `false` pour le `throwOnError` et `ignoreCase` paramètres.</span><span class="sxs-lookup"><span data-stu-id="09f45-2758">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `throwOnError` and `ignoreCase` parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-2759">
            <paramref name="typeName" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2759">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="09f45-2760">Un initialiseur de classe est appelé et lève une exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2760">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-2761">Une erreur se produit lorsque <paramref name="typeName" /> est analysé dans un nom de type et un nom d'assembly (par exemple, lorsque le nom de type simple inclut un caractère spécial sans séquence d'échappement).</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2761">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span>
          </span>
          <span data-ttu-id="09f45-2762">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2762">-or-</span>
          </span>
          <span data-ttu-id="09f45-2763">
            <paramref name="typeName" /> représente un type générique qui a un type pointeur, un type <see langword="ByRef" /> ou <see cref="T:System.Void" /> comme l’un de ses arguments de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2763">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="09f45-2764">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2764">-or-</span>
          </span>
          <span data-ttu-id="09f45-2765">
            <paramref name="typeName" /> représente un type générique qui a un nombre incorrect d’arguments de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2765">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="09f45-2766">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2766">-or-</span>
          </span>
          <span data-ttu-id="09f45-2767">
            <paramref name="typeName" /> représente un type générique, et un de ses arguments de type ne satisfait pas aux contraintes pour le paramètre de type correspondant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2767">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="09f45-2768">
            <paramref name="typeName" /> représente un tableau de <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2768">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="09f45-2769">L’assembly ou une de ses dépendances a été trouvé, mais n’a pas pu être chargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2769">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
          <span data-ttu-id="09f45-2770">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2770">-or-</span>
          </span>
          <span data-ttu-id="09f45-2771">
            <paramref name="typeName" /> contient un nom d'assembly non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2771">
              <paramref name="typeName" /> contains an invalid assembly name.</span>
          </span>
          <span data-ttu-id="09f45-2772">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2772">-or-</span>
          </span>
          <span data-ttu-id="09f45-2773">
            <paramref name="typeName" /> est un nom d'assembly valide sans nom de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2773">
              <paramref name="typeName" /> is a valid assembly name without a type name.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="09f45-2774">L’assembly ou une de ses dépendances n’est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2774">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="09f45-2775">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2775">-or-</span>
          </span>
          <span data-ttu-id="09f45-2776">L’assembly a été compilé avec une version du Common Language Runtime postérieure à la version actuellement chargée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2776">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="09f45-2777">Nom du type à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2777">The name of the type to get.</span>
          </span>
          <span data-ttu-id="09f45-2778">Si le paramètre <c>typeResolver</c> est fourni, le nom de type peut être n’importe quelle chaîne pouvant être résolue par <c>typeResolver</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2778">If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving.</span>
          </span>
          <span data-ttu-id="09f45-2779">Si le paramètre <c>assemblyResolver</c> est fourni ou si la résolution de type standard est utilisée, <c>typeName</c> doit être un nom d’assembly complet (voir <see cref="P:System.Type.AssemblyQualifiedName" />), à moins que le type ne se trouve dans l’assembly en cours d’exécution ou dans Mscorlib.dll, cas dans lequel il suffit de fournir le nom de type qualifié par son espace de noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2779">If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="assemblyResolver">
          <span data-ttu-id="09f45-2780">Méthode qui trouve et retourne l’assembly spécifié dans <c>typeName</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2780">A method that locates and returns the assembly that is specified in <c>typeName</c>.</span>
          </span>
          <span data-ttu-id="09f45-2781">Le nom de l’assembly est passé à <c>assemblyResolver</c> en tant qu’objet <see cref="T:System.Reflection.AssemblyName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2781">The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
          <span data-ttu-id="09f45-2782">Si <c>typeName</c> ne contient pas le nom d’un assembly, <c>assemblyResolver</c> n’est pas appelé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2782">If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called.</span>
          </span>
          <span data-ttu-id="09f45-2783">Si <c>assemblyResolver</c> n’est pas fourni, une résolution d’assembly standard est effectuée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2783">If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.</span>
          </span>
          <span data-ttu-id="09f45-2784">Attention   Ne passez pas de méthodes provenant d’appelants inconnus ou non fiables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2784">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
          <span data-ttu-id="09f45-2785">Vous risqueriez d'élever les privilèges du code malveillant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2785">Doing so could result in elevation of privilege for malicious code.</span>
          </span>
          <span data-ttu-id="09f45-2786">Utilisez uniquement les méthodes que vous fournissez ou avec lesquelles vous êtes familiarisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2786">Use only methods that you provide or that you are familiar with.</span>
          </span>
        </param>
        <param name="typeResolver">
          <span data-ttu-id="09f45-2787">Méthode qui trouve et retourne le type spécifié par <c>typeName</c> à partir de l’assembly retourné par <c>assemblyResolver</c> ou par la résolution d’assembly standard.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2787">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution.</span>
          </span>
          <span data-ttu-id="09f45-2788">Si aucun assembly n'est fourni, la méthode peut en fournir un.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2788">If no assembly is provided, the method can provide one.</span>
          </span>
          <span data-ttu-id="09f45-2789">La méthode prend également un paramètre qui spécifie s'il faut exécuter une recherche non sensible à la casse ; <see langword="false" /> est passé à ce paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2789">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span>
          </span>
          <span data-ttu-id="09f45-2790">Attention   Ne passez pas de méthodes provenant d’appelants inconnus ou non fiables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2790">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="09f45-2791">
            <see langword="true" /> pour lever une exception si le type est introuvable ; <see langword="false" /> pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2791">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-2792">
            <see langword="false" /> supprime également d'autres conditions d'exception, mais pas toutes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2792">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="09f45-2793">Consultez la section Exceptions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2793">See the Exceptions section.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-2794">Obtient le type portant le nom spécifié, en indiquant s'il faut lever une exception si le type est introuvable et, éventuellement, en fournissant des méthodes personnalisées qui permettent de résoudre l'assembly et le type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2794">Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-2795">Type portant le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2795">The type with the specified name.</span>
          </span>
          <span data-ttu-id="09f45-2796">Si le type est introuvable, le paramètre <paramref name="throwOnError" /> spécifie si <see langword="null" /> est retourné ou bien une exception est levée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2796">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="09f45-2797">Dans certains cas, une exception est levée indépendamment de la valeur de <paramref name="throwOnError" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2797">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="09f45-2798">Consultez la section Exceptions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2798">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-2799">Scénarios d’utilisation pour cette méthode et les détails de la `assemblyResolver` et `typeResolver` paramètres peuvent être trouvés dans le <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="09f45-2799">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="09f45-2800">Appel de cette surcharge de méthode est le même que d’appeler le <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode et en spécifiant `false` pour la `ignoreCase` paramètre.</span><span class="sxs-lookup"><span data-stu-id="09f45-2800">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `ignoreCase` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-2801">
            <paramref name="typeName" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2801">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="09f45-2802">Un initialiseur de classe est appelé et lève une exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2802">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="09f45-2803">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et le type est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2803">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="09f45-2804">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2804">-or-</span>
          </span>
          <span data-ttu-id="09f45-2805">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient des caractères non valides, tels qu’une tabulation incorporée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2805">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="09f45-2806">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2806">-or-</span>
          </span>
          <span data-ttu-id="09f45-2807">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> est une chaîne vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2807">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="09f45-2808">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2808">-or-</span>
          </span>
          <span data-ttu-id="09f45-2809">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> représente un type de tableau avec une taille non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2809">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="09f45-2810">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2810">-or-</span>
          </span>
          <span data-ttu-id="09f45-2811">
            <paramref name="typeName" /> représente un tableau de <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2811">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-2812">Une erreur se produit lorsque <paramref name="typeName" /> est analysé dans un nom de type et un nom d'assembly (par exemple, lorsque le nom de type simple inclut un caractère spécial sans séquence d'échappement).</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2812">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span>
          </span>
          <span data-ttu-id="09f45-2813">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2813">-or-</span>
          </span>
          <span data-ttu-id="09f45-2814">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient une syntaxe non valide (par exemple, "MyType[,\*,]").</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2814">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span>
          </span>
          <span data-ttu-id="09f45-2815">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2815">-or-</span>
          </span>
          <span data-ttu-id="09f45-2816">
            <paramref name="typeName" /> représente un type générique qui a un type pointeur, un type <see langword="ByRef" /> ou <see cref="T:System.Void" /> comme l’un de ses arguments de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2816">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="09f45-2817">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2817">-or-</span>
          </span>
          <span data-ttu-id="09f45-2818">
            <paramref name="typeName" /> représente un type générique qui a un nombre incorrect d’arguments de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2818">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="09f45-2819">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2819">-or-</span>
          </span>
          <span data-ttu-id="09f45-2820">
            <paramref name="typeName" /> représente un type générique, et un de ses arguments de type ne satisfait pas aux contraintes pour le paramètre de type correspondant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2820">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="09f45-2821">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et l’assembly ou l’une de ses dépendances est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2821">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
          <span data-ttu-id="09f45-2822">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2822">-or-</span>
          </span>
          <span data-ttu-id="09f45-2823">
            <paramref name="typeName" /> contient un nom d'assembly non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2823">
              <paramref name="typeName" /> contains an invalid assembly name.</span>
          </span>
          <span data-ttu-id="09f45-2824">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2824">-or-</span>
          </span>
          <span data-ttu-id="09f45-2825">
            <paramref name="typeName" /> est un nom d'assembly valide sans nom de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2825">
              <paramref name="typeName" /> is a valid assembly name without a type name.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="09f45-2826">L’assembly ou une de ses dépendances a été trouvé, mais n’a pas pu être chargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2826">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="09f45-2827">L’assembly ou une de ses dépendances n’est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2827">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="09f45-2828">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2828">-or-</span>
          </span>
          <span data-ttu-id="09f45-2829">L’assembly a été compilé avec une version du Common Language Runtime postérieure à la version actuellement chargée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2829">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="09f45-2830">Nom du type à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2830">The name of the type to get.</span>
          </span>
          <span data-ttu-id="09f45-2831">Si le paramètre <c>typeResolver</c> est fourni, le nom de type peut être n’importe quelle chaîne pouvant être résolue par <c>typeResolver</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2831">If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving.</span>
          </span>
          <span data-ttu-id="09f45-2832">Si le paramètre <c>assemblyResolver</c> est fourni ou si la résolution de type standard est utilisée, <c>typeName</c> doit être un nom d’assembly complet (voir <see cref="P:System.Type.AssemblyQualifiedName" />), à moins que le type ne se trouve dans l’assembly en cours d’exécution ou dans Mscorlib.dll, cas dans lequel il suffit de fournir le nom de type qualifié par son espace de noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2832">If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="assemblyResolver">
          <span data-ttu-id="09f45-2833">Méthode qui trouve et retourne l’assembly spécifié dans <c>typeName</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2833">A method that locates and returns the assembly that is specified in <c>typeName</c>.</span>
          </span>
          <span data-ttu-id="09f45-2834">Le nom de l’assembly est passé à <c>assemblyResolver</c> en tant qu’objet <see cref="T:System.Reflection.AssemblyName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2834">The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
          <span data-ttu-id="09f45-2835">Si <c>typeName</c> ne contient pas le nom d’un assembly, <c>assemblyResolver</c> n’est pas appelé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2835">If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called.</span>
          </span>
          <span data-ttu-id="09f45-2836">Si <c>assemblyResolver</c> n’est pas fourni, une résolution d’assembly standard est effectuée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2836">If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.</span>
          </span>
          <span data-ttu-id="09f45-2837">Attention   Ne passez pas de méthodes provenant d’appelants inconnus ou non fiables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2837">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
          <span data-ttu-id="09f45-2838">Vous risqueriez d'élever les privilèges du code malveillant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2838">Doing so could result in elevation of privilege for malicious code.</span>
          </span>
          <span data-ttu-id="09f45-2839">Utilisez uniquement les méthodes que vous fournissez ou avec lesquelles vous êtes familiarisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2839">Use only methods that you provide or that you are familiar with.</span>
          </span>
        </param>
        <param name="typeResolver">
          <span data-ttu-id="09f45-2840">Méthode qui trouve et retourne le type spécifié par <c>typeName</c> à partir de l’assembly retourné par <c>assemblyResolver</c> ou par la résolution d’assembly standard.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2840">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution.</span>
          </span>
          <span data-ttu-id="09f45-2841">Si aucun assembly n'est fourni, la méthode peut en fournir un.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2841">If no assembly is provided, the method can provide one.</span>
          </span>
          <span data-ttu-id="09f45-2842">La méthode prend également un paramètre qui spécifie s’il faut exécuter une recherche non sensible à la casse ; la valeur de <c>ignoreCase</c> est passée à ce paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2842">The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <c>ignoreCase</c> is passed to that parameter.</span>
          </span>
          <span data-ttu-id="09f45-2843">Attention   Ne passez pas de méthodes provenant d’appelants inconnus ou non fiables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2843">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="09f45-2844">
            <see langword="true" /> pour lever une exception si le type est introuvable ; <see langword="false" /> pour retourner <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2844">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-2845">
            <see langword="false" /> supprime également d'autres conditions d'exception, mais pas toutes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2845">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="09f45-2846">Consultez la section Exceptions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2846">See the Exceptions section.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="09f45-2847">
            <see langword="true" /> pour effectuer une recherche qui ne respecte pas la casse de <c>typeName</c> ; <see langword="false" /> pour effectuer une recherche qui respecte la casse de <c>typeName</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2847">
              <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>, <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-2848">Obtient le type portant le nom spécifié, en indiquant s'il faut effectuer une recherche qui respecte la casse et si une exception doit être levée si le type est introuvable, et éventuellement, en fournissant des méthodes personnalisées qui permettent de résoudre l'assembly et le type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2848">Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-2849">Type portant le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2849">The type with the specified name.</span>
          </span>
          <span data-ttu-id="09f45-2850">Si le type est introuvable, le paramètre <paramref name="throwOnError" /> spécifie si <see langword="null" /> est retourné ou bien une exception est levée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2850">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="09f45-2851">Dans certains cas, une exception est levée indépendamment de la valeur de <paramref name="throwOnError" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2851">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="09f45-2852">Consultez la section Exceptions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2852">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-2853">Utilisez cette surcharge de méthode et ses surcharges associées (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> et <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) pour remplacer l’implémentation par défaut de la <xref:System.Type.GetType%2A> méthode avec des implémentations plus flexibles.</span><span class="sxs-lookup"><span data-stu-id="09f45-2853">Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations.</span></span> <span data-ttu-id="09f45-2854">En fournissant vos propres méthodes pour résoudre les noms de type et les noms des assemblys qui contiennent les, vous pouvez procédez comme suit :</span><span class="sxs-lookup"><span data-stu-id="09f45-2854">By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</span></span>  
  
-   <span data-ttu-id="09f45-2855">Contrôler la version d’un assembly d’un type est chargé à partir de.</span><span class="sxs-lookup"><span data-stu-id="09f45-2855">Control which version of an assembly a type is loaded from.</span></span>  
  
-   <span data-ttu-id="09f45-2856">Fournissez un autre emplacement pour rechercher un nom de type qui n’inclut pas un nom d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2856">Provide another place to look for a type name that does not include an assembly name.</span></span>  
  
-   <span data-ttu-id="09f45-2857">Charger des assemblys à l’aide des noms d’assemblys partiels.</span><span class="sxs-lookup"><span data-stu-id="09f45-2857">Load assemblies using partial assembly names.</span></span>  
  
-   <span data-ttu-id="09f45-2858">Retournez les sous-classes de <xref:System.Type?displayProperty=nameWithType> qui ne sont pas créés par le common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="09f45-2858">Return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the common language runtime (CLR).</span></span>  
  
 <span data-ttu-id="09f45-2859">Par exemple, sérialisation avec tolérance de version de cette méthode vous permet de rechercher un assembly « ajustement optimal » à l’aide d’un nom partiel.</span><span class="sxs-lookup"><span data-stu-id="09f45-2859">For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</span></span> <span data-ttu-id="09f45-2860">D’autres surcharges de la <xref:System.Type.GetType%2A> méthode requiert un nom de type qualifié d’assembly, qui inclut le numéro de version.</span><span class="sxs-lookup"><span data-stu-id="09f45-2860">Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number.</span></span>  
  
 <span data-ttu-id="09f45-2861">Les implémentations alternatives du système de type devra peut-être retourner des sous-classes de <xref:System.Type?displayProperty=nameWithType> qui ne sont pas créés par le CLR ; tous les types qui sont retournées par les autres surcharges de la <xref:System.Type.GetType%2A> méthode sont des types de runtime.</span><span class="sxs-lookup"><span data-stu-id="09f45-2861">Alternate implementations of the type system may need to return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the CLR; all types that are returned by other overloads of the <xref:System.Type.GetType%2A> method are runtime types.</span></span>  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a><span data-ttu-id="09f45-2862">Notes d’utilisation</span><span class="sxs-lookup"><span data-stu-id="09f45-2862">Usage Notes</span></span>  
 <span data-ttu-id="09f45-2863">Cette surcharge de méthode et ses surcharges associées analysent `typeName` dans le nom d’un type et le nom d’un assembly, puis pour résoudre les noms.</span><span class="sxs-lookup"><span data-stu-id="09f45-2863">This method overload and its associated overloads parse `typeName` into the name of a type and the name of an assembly, and then resolve the names.</span></span> <span data-ttu-id="09f45-2864">Résolution du nom de l’assembly se produit avant la résolution du nom de type, car un nom de type doit être résolu dans le contexte d’un assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2864">Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-2865">Si vous n’êtes pas familiarisé avec le concept de noms de type qualifié d’assembly, consultez la <xref:System.Type.AssemblyQualifiedName%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-2865">If you are unfamiliar with the concept of assembly-qualified type names, see the <xref:System.Type.AssemblyQualifiedName%2A> property.</span></span>  
  
 <span data-ttu-id="09f45-2866">Si `typeName` n’est pas un nom qualifié d’assembly et résolution de l’assembly est ignorée.</span><span class="sxs-lookup"><span data-stu-id="09f45-2866">If `typeName` is not an assembly-qualified name, assembly resolution is skipped.</span></span> <span data-ttu-id="09f45-2867">Les noms de type non qualifiés peuvent être résolus dans le contexte de Mscorlib.dll ou l’assembly en cours d’exécution, ou vous pouvez éventuellement fournir un assembly dans le `typeResolver` paramètre.</span><span class="sxs-lookup"><span data-stu-id="09f45-2867">Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the `typeResolver` parameter.</span></span> <span data-ttu-id="09f45-2868">Les effets d’inclure ou d’omettre le nom de l’assembly pour différents types de résolution de noms sont affichés sous la forme d’une table dans le [résolution des noms mixtes](#mixed_name_resolution) section.</span><span class="sxs-lookup"><span data-stu-id="09f45-2868">The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section.</span></span>  
  
 <span data-ttu-id="09f45-2869">Remarques d’utilisation générales :</span><span class="sxs-lookup"><span data-stu-id="09f45-2869">General usage notes:</span></span>  
  
-   <span data-ttu-id="09f45-2870">Ne passez pas de méthodes à `assemblyResolver` ou `typeResolver` si elles proviennent d’appelants inconnus ou non approuvés.</span><span class="sxs-lookup"><span data-stu-id="09f45-2870">Do not pass methods to `assemblyResolver` or `typeResolver` if they come from unknown or untrusted callers.</span></span> <span data-ttu-id="09f45-2871">Utilisez uniquement les méthodes que vous fournissez ou avec lesquelles vous êtes familiarisé.</span><span class="sxs-lookup"><span data-stu-id="09f45-2871">Use only methods that you provide or that you are familiar with.</span></span>  
  
    > [!CAUTION]
    >  <span data-ttu-id="09f45-2872">À l’aide de méthodes provenant d’appelants inconnus ou non fiables peut entraîner une élévation de privilèges pour le code malveillant.</span><span class="sxs-lookup"><span data-stu-id="09f45-2872">Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</span></span>  
  
-   <span data-ttu-id="09f45-2873">Si vous omettez le `assemblyResolver` et/ou `typeResolver` paramètres, la valeur de le `throwOnError` paramètre est passé aux méthodes qui effectuent la résolution par défaut.</span><span class="sxs-lookup"><span data-stu-id="09f45-2873">If you omit the `assemblyResolver` and/or `typeResolver` parameters, the value of the `throwOnError` parameter is passed to the methods that perform the default resolution.</span></span>  
  
-   <span data-ttu-id="09f45-2874">Si `throwOnError` est `true`, cette méthode lève un <xref:System.TypeLoadException> lorsque `typeResolver` retourne `null`et un <xref:System.IO.FileNotFoundException> lorsque `assemblyResolver` retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2874">If `throwOnError` is `true`, this method throws a <xref:System.TypeLoadException> when `typeResolver` returns `null`, and a <xref:System.IO.FileNotFoundException> when `assemblyResolver` returns `null`.</span></span>  
  
-   <span data-ttu-id="09f45-2875">Cette méthode n’intercepte pas les exceptions levées par `assemblyResolver` et `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2875">This method does not catch exceptions thrown by `assemblyResolver` and `typeResolver`.</span></span> <span data-ttu-id="09f45-2876">Vous êtes responsable de toutes les exceptions levées par les méthodes de résolution.</span><span class="sxs-lookup"><span data-stu-id="09f45-2876">You are responsible for any exceptions that are thrown by the resolver methods.</span></span>  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a><span data-ttu-id="09f45-2877">Résolution d’assemblys</span><span class="sxs-lookup"><span data-stu-id="09f45-2877">Resolving Assemblies</span></span>  
 <span data-ttu-id="09f45-2878">Le `assemblyResolver` méthode reçoit un <xref:System.Reflection.AssemblyName> objet, qui est généré en analysant le nom d’assembly de chaîne qui est inclus dans `typeName`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2878">The `assemblyResolver` method receives an <xref:System.Reflection.AssemblyName> object, which is produced by parsing the string assembly name that is included in `typeName`.</span></span> <span data-ttu-id="09f45-2879">Si `typeName` ne contient pas de nom d’assembly, `assemblyResolver` n’est pas appelée et `null` est passé à `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2879">If `typeName` does not contain an assembly name, `assemblyResolver` is not called and `null` is passed to `typeResolver`.</span></span>  
  
 <span data-ttu-id="09f45-2880">Si `assemblyResolver` n’est pas fourni, standard assembly détection permet de localiser l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2880">If `assemblyResolver` is not supplied, standard assembly probing is used to locate the assembly.</span></span> <span data-ttu-id="09f45-2881">Si `assemblyResolver` est fourni, le <xref:System.Type.GetType%2A> méthode n’effectue pas la détection standard ; dans ce cas vous devez vous assurer que votre `assemblyResolver` peut gérer tous les assemblys que vous passez à celui-ci.</span><span class="sxs-lookup"><span data-stu-id="09f45-2881">If `assemblyResolver` is provided, the <xref:System.Type.GetType%2A> method does not do standard probing; in that case you must ensure that your `assemblyResolver` can handle all the assemblies you pass to it.</span></span>  
  
 <span data-ttu-id="09f45-2882">Le `assemblyResolver` méthode doit retourner `null` si l’assembly ne peut pas être résolu.</span><span class="sxs-lookup"><span data-stu-id="09f45-2882">The `assemblyResolver` method should return `null` if the assembly cannot be resolved.</span></span> <span data-ttu-id="09f45-2883">Si `assemblyResolver` retourne `null`, `typeResolver` n’est pas appelée et qu’aucun traitement supplémentaire se produit ; en outre, si `throwOnError` est `true`, un <xref:System.IO.FileNotFoundException> est levée.</span><span class="sxs-lookup"><span data-stu-id="09f45-2883">If `assemblyResolver` returns `null`, `typeResolver` is not called and no further processing occurs; additionally, if `throwOnError` is `true`, a <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="09f45-2884">Si le <xref:System.Reflection.AssemblyName> qui est passé à `assemblyResolver` est un partiel nom, un ou plusieurs de ses parties sont `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2884">If the <xref:System.Reflection.AssemblyName> that is passed to `assemblyResolver` is a partial name, one or more of its parts are `null`.</span></span> <span data-ttu-id="09f45-2885">Par exemple, si elle dispose d’une version sans le <xref:System.Reflection.AssemblyName.Version%2A> propriété est `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2885">For example, if it has no version, the <xref:System.Reflection.AssemblyName.Version%2A> property is `null`.</span></span> <span data-ttu-id="09f45-2886">Si le <xref:System.Reflection.AssemblyName.Version%2A> propriété, le <xref:System.Reflection.AssemblyName.CultureInfo%2A> propriété et le <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> tout retour de la méthode `null`, alors seulement le nom simple de l’assembly a été fourni.</span><span class="sxs-lookup"><span data-stu-id="09f45-2886">If the <xref:System.Reflection.AssemblyName.Version%2A> property, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property, and the <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method all return `null`, then only the simple name of the assembly was supplied.</span></span> <span data-ttu-id="09f45-2887">Le `assemblyResolver` méthode peut utiliser ou ignorer toutes les parties du nom de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2887">The `assemblyResolver` method can use or ignore all parts of the assembly name.</span></span>  
  
 <span data-ttu-id="09f45-2888">Les effets des options de résolution d’assembly différents sont affichés sous la forme d’une table dans le [résolution des noms mixtes](#mixed_name_resolution) section, pour les noms de types simples et qualifiés d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2888">The effects of different assembly resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a><span data-ttu-id="09f45-2889">Résolution de Types</span><span class="sxs-lookup"><span data-stu-id="09f45-2889">Resolving Types</span></span>  
 <span data-ttu-id="09f45-2890">Si `typeName` ne spécifie pas de nom d’assembly, `typeResolver` est toujours appelée.</span><span class="sxs-lookup"><span data-stu-id="09f45-2890">If `typeName` does not specify an assembly name, `typeResolver` is always called.</span></span> <span data-ttu-id="09f45-2891">Si `typeName` Spécifie le nom d’assembly, `typeResolver` est appelée uniquement lorsque le nom de l’assembly est résolu avec succès.</span><span class="sxs-lookup"><span data-stu-id="09f45-2891">If `typeName` specifies an assembly name, `typeResolver` is called only when the assembly name is successfully resolved.</span></span> <span data-ttu-id="09f45-2892">Si `assemblyResolver` ou retourne de détection d’assembly standard `null`, `typeResolver` n’est pas appelée.</span><span class="sxs-lookup"><span data-stu-id="09f45-2892">If `assemblyResolver` or standard assembly probing returns `null`, `typeResolver` is not called.</span></span>  
  
 <span data-ttu-id="09f45-2893">Le `typeResolver` méthode reçoit les trois arguments :</span><span class="sxs-lookup"><span data-stu-id="09f45-2893">The `typeResolver` method receives three arguments:</span></span>  
  
-   <span data-ttu-id="09f45-2894">L’assembly à rechercher ou `null` si `typeName` ne contient pas un nom d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2894">The assembly to search or `null` if `typeName` does not contain an assembly name.</span></span>  
  
-   <span data-ttu-id="09f45-2895">Nom du type simple.</span><span class="sxs-lookup"><span data-stu-id="09f45-2895">The simple name of the type.</span></span> <span data-ttu-id="09f45-2896">Dans le cas d’un type imbriqué, il s’agit du type conteneur extérieur.</span><span class="sxs-lookup"><span data-stu-id="09f45-2896">In the case of a nested type, this is the outermost containing type.</span></span> <span data-ttu-id="09f45-2897">Dans le cas d’un type générique, il s’agit du nom simple du type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-2897">In the case of a generic type, this is the simple name of the generic type.</span></span>  
  
-   <span data-ttu-id="09f45-2898">Valeur booléenne qui est `true` si la casse des noms de type doit être ignoré.</span><span class="sxs-lookup"><span data-stu-id="09f45-2898">A Boolean value that is `true` if the case of type names is to be ignored.</span></span>  
  
 <span data-ttu-id="09f45-2899">L’implémentation de détermine la manière dont ces arguments sont utilisées.</span><span class="sxs-lookup"><span data-stu-id="09f45-2899">The implementation determines the way these arguments are used.</span></span> <span data-ttu-id="09f45-2900">Le `typeResolver` méthode doit retourner `null` si elle ne peut pas résoudre le type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2900">The `typeResolver` method should return `null` if it cannot resolve the type.</span></span> <span data-ttu-id="09f45-2901">Si `typeResolver` retourne `null` et `throwOnError` est `true`, cette surcharge de <xref:System.Type.GetType%2A> lève une <xref:System.TypeLoadException>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2901">If `typeResolver` returns `null` and `throwOnError` is `true`, this overload of <xref:System.Type.GetType%2A> throws a <xref:System.TypeLoadException>.</span></span>  
  
 <span data-ttu-id="09f45-2902">Les effets des options de résolution de type différent sont affichés sous la forme d’une table dans le [résolution des noms mixtes](#mixed_name_resolution) section, pour les noms de types simples et qualifiés d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2902">The effects of different type resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
#### <a name="resolving-nested-types"></a><span data-ttu-id="09f45-2903">Résolution de Types imbriqués</span><span class="sxs-lookup"><span data-stu-id="09f45-2903">Resolving Nested Types</span></span>  
 <span data-ttu-id="09f45-2904">Si `typeName` est un type imbriqué, seul le nom de l’extérieur qui contient le type est passé à `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2904">If `typeName` is a nested type, only the name of the outermost containing type is passed to `typeResolver`.</span></span> <span data-ttu-id="09f45-2905">Lorsque `typeResolver` retourne ce type, le <xref:System.Type.GetNestedType%2A> méthode est appelée de manière récursive jusqu'à ce que le plus profond type imbriqué a été résolu.</span><span class="sxs-lookup"><span data-stu-id="09f45-2905">When `typeResolver` returns this type, the <xref:System.Type.GetNestedType%2A> method is called recursively until the innermost nested type has been resolved.</span></span>  
  
#### <a name="resolving-generic-types"></a><span data-ttu-id="09f45-2906">Résolution de Types génériques</span><span class="sxs-lookup"><span data-stu-id="09f45-2906">Resolving Generic Types</span></span>  
 <span data-ttu-id="09f45-2907">Le <xref:System.Type.GetType%2A> est appelée de manière récursive pour résoudre les types génériques : pour résoudre le type générique lui-même, puis pour résoudre ses arguments de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2907">The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</span></span> <span data-ttu-id="09f45-2908">Si un argument de type est générique, <xref:System.Type.GetType%2A> est appelée de manière récursive pour résoudre ses arguments de type et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="09f45-2908">If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on.</span></span>  
  
 <span data-ttu-id="09f45-2909">La combinaison de `assemblyResolver` et `typeResolver` que vous fournissez doit être capable de résoudre tous les niveaux de cette récursivité.</span><span class="sxs-lookup"><span data-stu-id="09f45-2909">The combination of `assemblyResolver` and `typeResolver` that you provide must be capable of resolving all levels of this recursion.</span></span> <span data-ttu-id="09f45-2910">Par exemple, supposez que vous fournissez un `assemblyResolver` qui contrôle le chargement de `MyAssembly`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2910">For example, suppose you supply an `assemblyResolver` that controls the loading of `MyAssembly`.</span></span> <span data-ttu-id="09f45-2911">Supposons que vous souhaitez résoudre le type générique `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-2911">Suppose you want to resolve the generic type `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic).</span></span> <span data-ttu-id="09f45-2912">Vous pouvez passer le nom de type générique suivant :</span><span class="sxs-lookup"><span data-stu-id="09f45-2912">You might pass the following generic type name:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="09f45-2913">Notez que `MyType` est l’argument de type qualifié d’assembly uniquement.</span><span class="sxs-lookup"><span data-stu-id="09f45-2913">Notice that `MyType` is the only assembly-qualified type argument.</span></span> <span data-ttu-id="09f45-2914">Les noms de la <xref:System.Collections.Generic.Dictionary%602> et <xref:System.String> classes ne sont pas qualifiés d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2914">The names of the <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String> classes are not assembly-qualified.</span></span> <span data-ttu-id="09f45-2915">Votre `typeResolver` doit être en mesure de gérer un assembly ou `null`, car il recevra `null` pour <xref:System.Collections.Generic.Dictionary%602> et <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="09f45-2915">Your `typeResolver` must be able handle either an assembly or `null`, because it will receive `null` for <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String>.</span></span> <span data-ttu-id="09f45-2916">Il peut gérer ce cas en appelant une surcharge de la <xref:System.Type.GetType%2A> méthode qui prend une chaîne, car les deux noms de type non qualifiés sont dans Mscorlib.dll :</span><span class="sxs-lookup"><span data-stu-id="09f45-2916">It can handle that case by calling an overload of the <xref:System.Type.GetType%2A> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 <span data-ttu-id="09f45-2917">Le `assemblyResolver` méthode n’est pas appelée pour le type de dictionnaire et le type de chaîne, car ces noms de types ne sont pas qualifiés d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2917">The `assemblyResolver` method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</span></span>  
  
 <span data-ttu-id="09f45-2918">Supposons maintenant qu’au lieu de `System.String`, le premier type d’argument générique est `YourType`, à partir de `YourAssembly`:</span><span class="sxs-lookup"><span data-stu-id="09f45-2918">Now suppose that instead of `System.String`, the first generic argument type is `YourType`, from `YourAssembly`:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="09f45-2919">Étant donné que cet assembly n’est ni Mscorlib.dll, ni l’assembly en cours d’exécution, vous ne peut pas résoudre `YourType` sans un nom qualifié d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2919">Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve `YourType` without an assembly-qualified name.</span></span> <span data-ttu-id="09f45-2920">Étant donné que votre `assemblyResolve` sera appelé de manière récursive, il doit être en mesure de gérer ce cas.</span><span class="sxs-lookup"><span data-stu-id="09f45-2920">Because your `assemblyResolve` will be called recursively, it must be able to handle this case.</span></span> <span data-ttu-id="09f45-2921">Au lieu de retourner `null` pour les assemblys autres que `MyAssembly`, elle s’exécute maintenant le chargement d’un assembly à l’aide de l’élément <xref:System.Reflection.AssemblyName> objet.</span><span class="sxs-lookup"><span data-stu-id="09f45-2921">Instead of returning `null` for assemblies other than `MyAssembly`, it now performs an assembly load using the supplied <xref:System.Reflection.AssemblyName> object.</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 <span data-ttu-id="09f45-2922">Retour au [Notes d’utilisation](#usage_notes).</span><span class="sxs-lookup"><span data-stu-id="09f45-2922">Back to [Usage Notes](#usage_notes).</span></span>  
  
#### <a name="resolving-type-names-with-special-characters"></a><span data-ttu-id="09f45-2923">Résolution de noms de Type avec des caractères spéciaux</span><span class="sxs-lookup"><span data-stu-id="09f45-2923">Resolving Type Names with Special Characters</span></span>  
 <span data-ttu-id="09f45-2924">Certains caractères ont une signification particulière dans les noms qualifiés d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2924">Certain characters have special meanings in assembly-qualified names.</span></span> <span data-ttu-id="09f45-2925">Si un nom de type simple contient ces caractères, les caractères provoquent des erreurs d’analyse lorsque le nom simple fait partie d’un nom qualifié d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2925">If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</span></span> <span data-ttu-id="09f45-2926">Pour éviter les erreurs d’analyse, vous devez isoler les caractères spéciaux par une barre oblique inverse avant de pouvoir passer le nom qualifié d’assembly pour le <xref:System.Type.GetType%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-2926">To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="09f45-2927">Par exemple, si un type est nommé `Strange]Type`, le caractère d’échappement doit être ajouté avant les crochets comme suit : `Strange\]Type`.</span><span class="sxs-lookup"><span data-stu-id="09f45-2927">For example, if a type is named `Strange]Type`, the escape character must be added ahead of the square bracket as follows: `Strange\]Type`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-2928">Les noms de ces caractères spéciaux ne peut pas être créés en Visual Basic ou c#, mais peuvent être créés à l’aide du langage intermédiaire Microsoft (MSIL) ou par l’émission d’assemblys dynamiques.</span><span class="sxs-lookup"><span data-stu-id="09f45-2928">Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</span></span>  
  
 <span data-ttu-id="09f45-2929">Le tableau suivant présente les caractères spéciaux pour les noms de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2929">The following table shows the special characters for type names.</span></span>  
  
|<span data-ttu-id="09f45-2930">Caractère</span><span class="sxs-lookup"><span data-stu-id="09f45-2930">Character</span></span>|<span data-ttu-id="09f45-2931">Signification</span><span class="sxs-lookup"><span data-stu-id="09f45-2931">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="09f45-2932">`,` (virgule)</span><span class="sxs-lookup"><span data-stu-id="09f45-2932">`,` (comma)</span></span>|<span data-ttu-id="09f45-2933">Délimiteur pour les noms qualifiés d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2933">Delimiter for assembly-qualified names.</span></span>|  
|<span data-ttu-id="09f45-2934">`[]` (les crochets)</span><span class="sxs-lookup"><span data-stu-id="09f45-2934">`[]` (square brackets)</span></span>|<span data-ttu-id="09f45-2935">En tant que suffixe paire, indique un type de tableau ; comme une paire de séparateurs, englobe les listes d’arguments génériques et les noms qualifiés d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2935">As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</span></span>|  
|<span data-ttu-id="09f45-2936">`&` (et commercial)</span><span class="sxs-lookup"><span data-stu-id="09f45-2936">`&` (ampersand)</span></span>|<span data-ttu-id="09f45-2937">En guise de suffixe, indique qu’un type est un type référence.</span><span class="sxs-lookup"><span data-stu-id="09f45-2937">As a suffix, indicates that a type is a reference type.</span></span>|  
|<span data-ttu-id="09f45-2938">`*` (astérisque)</span><span class="sxs-lookup"><span data-stu-id="09f45-2938">`*` (asterisk)</span></span>|<span data-ttu-id="09f45-2939">En guise de suffixe, indique qu’un type est un type pointeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-2939">As a suffix, indicates that a type is a pointer type.</span></span>|  
|<span data-ttu-id="09f45-2940">`+` (plus)</span><span class="sxs-lookup"><span data-stu-id="09f45-2940">`+` (plus)</span></span>|<span data-ttu-id="09f45-2941">Délimiteur pour les types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="09f45-2941">Delimiter for nested types.</span></span>|  
|<span data-ttu-id="09f45-2942">`\` (barre oblique inverse)</span><span class="sxs-lookup"><span data-stu-id="09f45-2942">`\` (backslash)</span></span>|<span data-ttu-id="09f45-2943">Caractère d’échappement.</span><span class="sxs-lookup"><span data-stu-id="09f45-2943">Escape character.</span></span>|  
  
 <span data-ttu-id="09f45-2944">Propriétés, telles que <xref:System.Type.AssemblyQualifiedName%2A> retour correctement d’échappement de chaînes.</span><span class="sxs-lookup"><span data-stu-id="09f45-2944">Properties such as <xref:System.Type.AssemblyQualifiedName%2A> return correctly escaped strings.</span></span> <span data-ttu-id="09f45-2945">Vous devez passer des chaînes correctement échappées à le <xref:System.Type.GetType%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-2945">You must pass correctly escaped strings to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="09f45-2946">À son tour, le <xref:System.Type.GetType%2A> méthode passe les noms correctement échappées à `typeResolver` et aux méthodes de résolution de type par défaut.</span><span class="sxs-lookup"><span data-stu-id="09f45-2946">In turn, the <xref:System.Type.GetType%2A> method passes correctly escaped names to `typeResolver` and to the default type resolution methods.</span></span> <span data-ttu-id="09f45-2947">Si vous devez comparer un nom à un nom sans séquence d’échappement dans `typeResolver`, vous devez supprimer les caractères d’échappement.</span><span class="sxs-lookup"><span data-stu-id="09f45-2947">If you need to compare a name to an unescaped name in `typeResolver`, you must remove the escape characters.</span></span>  
  
 <span data-ttu-id="09f45-2948">Retour au [Notes d’utilisation](#usage_notes).</span><span class="sxs-lookup"><span data-stu-id="09f45-2948">Back to [Usage Notes](#usage_notes).</span></span>  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a><span data-ttu-id="09f45-2949">Résolution de noms mixtes</span><span class="sxs-lookup"><span data-stu-id="09f45-2949">Mixed Name Resolution</span></span>  
 <span data-ttu-id="09f45-2950">Le tableau suivant récapitule les interactions entre `assemblyResolver`, `typeResolver`et la résolution de noms par défaut, pour toutes les combinaisons de nom de type et le nom de l’assembly dans `typeName`:</span><span class="sxs-lookup"><span data-stu-id="09f45-2950">The following table summarizes the interactions between `assemblyResolver`, `typeResolver`, and default name resolution, for all combinations of type name and assembly name in `typeName`:</span></span>  
  
|<span data-ttu-id="09f45-2951">Contenu du nom de type</span><span class="sxs-lookup"><span data-stu-id="09f45-2951">Contents of type name</span></span>|<span data-ttu-id="09f45-2952">Méthode de programme de résolution d’assembly</span><span class="sxs-lookup"><span data-stu-id="09f45-2952">Assembly resolver method</span></span>|<span data-ttu-id="09f45-2953">Méthode de programme de résolution de type</span><span class="sxs-lookup"><span data-stu-id="09f45-2953">Type resolver method</span></span>|<span data-ttu-id="09f45-2954">Résultat</span><span class="sxs-lookup"><span data-stu-id="09f45-2954">Result</span></span>|  
|---------------------------|------------------------------|--------------------------|------------|  
|<span data-ttu-id="09f45-2955">type, l’assembly</span><span class="sxs-lookup"><span data-stu-id="09f45-2955">type, assembly</span></span>|<span data-ttu-id="09f45-2956">null</span><span class="sxs-lookup"><span data-stu-id="09f45-2956">null</span></span>|<span data-ttu-id="09f45-2957">null</span><span class="sxs-lookup"><span data-stu-id="09f45-2957">null</span></span>|<span data-ttu-id="09f45-2958">Équivalent à l’appel du <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="09f45-2958">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span>|  
|<span data-ttu-id="09f45-2959">type, l’assembly</span><span class="sxs-lookup"><span data-stu-id="09f45-2959">type, assembly</span></span>|<span data-ttu-id="09f45-2960">fourni</span><span class="sxs-lookup"><span data-stu-id="09f45-2960">provided</span></span>|<span data-ttu-id="09f45-2961">null</span><span class="sxs-lookup"><span data-stu-id="09f45-2961">null</span></span>|<span data-ttu-id="09f45-2962">`assemblyResolver` Retourne l’assembly ou `null` si elle ne peut pas résoudre l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2962">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="09f45-2963">Si l’assembly est résolu, le <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> surcharge de méthode est utilisée pour charger le type à partir de l’assembly ; sinon, il n’existe aucune tentative de résoudre le type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2963">If the assembly is resolved, the <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</span></span>|  
|<span data-ttu-id="09f45-2964">type, l’assembly</span><span class="sxs-lookup"><span data-stu-id="09f45-2964">type, assembly</span></span>|<span data-ttu-id="09f45-2965">null</span><span class="sxs-lookup"><span data-stu-id="09f45-2965">null</span></span>|<span data-ttu-id="09f45-2966">fourni</span><span class="sxs-lookup"><span data-stu-id="09f45-2966">provided</span></span>|<span data-ttu-id="09f45-2967">Équivalent à la conversion du nom de l’assembly à un <xref:System.Reflection.AssemblyName> objet et en appelant le <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> surcharge de méthode pour obtenir l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2967">Equivalent to converting the assembly name to an <xref:System.Reflection.AssemblyName> object and calling the <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> method overload to get the assembly.</span></span> <span data-ttu-id="09f45-2968">Si l’assembly est résolu, il est passé à `typeResolver`; sinon, `typeResolver` n’est pas appelée et il n’existe aucune autre tentative de résoudre le type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2968">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="09f45-2969">type, l’assembly</span><span class="sxs-lookup"><span data-stu-id="09f45-2969">type, assembly</span></span>|<span data-ttu-id="09f45-2970">fourni</span><span class="sxs-lookup"><span data-stu-id="09f45-2970">provided</span></span>|<span data-ttu-id="09f45-2971">fourni</span><span class="sxs-lookup"><span data-stu-id="09f45-2971">provided</span></span>|<span data-ttu-id="09f45-2972">`assemblyResolver` Retourne l’assembly ou `null` si elle ne peut pas résoudre l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2972">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="09f45-2973">Si l’assembly est résolu, il est passé à `typeResolver`; sinon, `typeResolver` n’est pas appelée et il n’existe aucune autre tentative de résoudre le type.</span><span class="sxs-lookup"><span data-stu-id="09f45-2973">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="09f45-2974">type</span><span class="sxs-lookup"><span data-stu-id="09f45-2974">type</span></span>|<span data-ttu-id="09f45-2975">NULL, fourni</span><span class="sxs-lookup"><span data-stu-id="09f45-2975">null, provided</span></span>|<span data-ttu-id="09f45-2976">null</span><span class="sxs-lookup"><span data-stu-id="09f45-2976">null</span></span>|<span data-ttu-id="09f45-2977">Équivalent à l’appel du <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="09f45-2977">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="09f45-2978">Étant donné que le nom de l’assembly n’est pas fourni, Mscorlib.dll et l’assembly en cours d’exécution sont recherchés.</span><span class="sxs-lookup"><span data-stu-id="09f45-2978">Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</span></span> <span data-ttu-id="09f45-2979">Si `assemblyResolver` est fourni, il est ignoré.</span><span class="sxs-lookup"><span data-stu-id="09f45-2979">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="09f45-2980">type</span><span class="sxs-lookup"><span data-stu-id="09f45-2980">type</span></span>|<span data-ttu-id="09f45-2981">NULL, fourni</span><span class="sxs-lookup"><span data-stu-id="09f45-2981">null, provided</span></span>|<span data-ttu-id="09f45-2982">fourni</span><span class="sxs-lookup"><span data-stu-id="09f45-2982">provided</span></span>|<span data-ttu-id="09f45-2983">`typeResolver` est appelée, et `null` est passé pour l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2983">`typeResolver` is called, and `null` is passed for the assembly.</span></span> <span data-ttu-id="09f45-2984">`typeResolver` peut de fournir un type à partir de n’importe quel assembly, y compris les assemblys qu’il charge à cet effet.</span><span class="sxs-lookup"><span data-stu-id="09f45-2984">`typeResolver` can provide a type from any assembly, including assemblies it loads for the purpose.</span></span> <span data-ttu-id="09f45-2985">Si `assemblyResolver` est fourni, il est ignoré.</span><span class="sxs-lookup"><span data-stu-id="09f45-2985">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="09f45-2986">assembly</span><span class="sxs-lookup"><span data-stu-id="09f45-2986">assembly</span></span>|<span data-ttu-id="09f45-2987">NULL, fourni</span><span class="sxs-lookup"><span data-stu-id="09f45-2987">null, provided</span></span>|<span data-ttu-id="09f45-2988">NULL, fourni</span><span class="sxs-lookup"><span data-stu-id="09f45-2988">null, provided</span></span>|<span data-ttu-id="09f45-2989">A <xref:System.IO.FileLoadException> est levée, car le nom de l’assembly est analysé comme s’il s’agissait d’un nom de type qualifié d’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-2989">A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</span></span> <span data-ttu-id="09f45-2990">Cela entraîne un nom d’assembly non valide.</span><span class="sxs-lookup"><span data-stu-id="09f45-2990">This results in an invalid assembly name.</span></span>|  
  
 <span data-ttu-id="09f45-2991">À : [Notes d’utilisation](#usage_notes), [résolution d’assemblys](#resolving_assemblies), [résoudre les Types](#resolving_types).</span><span class="sxs-lookup"><span data-stu-id="09f45-2991">Back to: [Usage Notes](#usage_notes), [Resolving Assemblies](#resolving_assemblies), [Resolving Types](#resolving_types).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-2992">
            <paramref name="typeName" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2992">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="09f45-2993">Un initialiseur de classe est appelé et lève une exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2993">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="09f45-2994">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et le type est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2994">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="09f45-2995">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2995">-or-</span>
          </span>
          <span data-ttu-id="09f45-2996">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient des caractères non valides, tels qu’une tabulation incorporée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2996">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="09f45-2997">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2997">-or-</span>
          </span>
          <span data-ttu-id="09f45-2998">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> est une chaîne vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2998">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="09f45-2999">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-2999">-or-</span>
          </span>
          <span data-ttu-id="09f45-3000">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> représente un type de tableau avec une taille non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3000">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="09f45-3001">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3001">-or-</span>
          </span>
          <span data-ttu-id="09f45-3002">
            <paramref name="typeName" /> représente un tableau de <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3002">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-3003">Une erreur se produit lorsque <paramref name="typeName" /> est analysé dans un nom de type et un nom d'assembly (par exemple, lorsque le nom de type simple inclut un caractère spécial sans séquence d'échappement).</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3003">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span>
          </span>
          <span data-ttu-id="09f45-3004">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3004">-or-</span>
          </span>
          <span data-ttu-id="09f45-3005">
            <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient une syntaxe non valide (par exemple, "MyType[,\*,]").</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3005">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span>
          </span>
          <span data-ttu-id="09f45-3006">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3006">-or-</span>
          </span>
          <span data-ttu-id="09f45-3007">
            <paramref name="typeName" /> représente un type générique qui a un type pointeur, un type <see langword="ByRef" /> ou <see cref="T:System.Void" /> comme l’un de ses arguments de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3007">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="09f45-3008">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3008">-or-</span>
          </span>
          <span data-ttu-id="09f45-3009">
            <paramref name="typeName" /> représente un type générique qui a un nombre incorrect d’arguments de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3009">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="09f45-3010">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3010">-or-</span>
          </span>
          <span data-ttu-id="09f45-3011">
            <paramref name="typeName" /> représente un type générique, et un de ses arguments de type ne satisfait pas aux contraintes pour le paramètre de type correspondant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3011">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="09f45-3012">
            <paramref name="throwOnError" /> a la valeur <see langword="true" />, et l’assembly ou l’une de ses dépendances est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3012">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="09f45-3013">L’assembly ou l’une de ses dépendances a été trouvé, mais n’a pas pu être chargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3013">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
          <span data-ttu-id="09f45-3014">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3014">-or-</span>
          </span>
          <span data-ttu-id="09f45-3015">
            <paramref name="typeName" /> contient un nom d'assembly non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3015">
              <paramref name="typeName" /> contains an invalid assembly name.</span>
          </span>
          <span data-ttu-id="09f45-3016">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3016">-or-</span>
          </span>
          <span data-ttu-id="09f45-3017">
            <paramref name="typeName" /> est un nom d'assembly valide sans nom de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3017">
              <paramref name="typeName" /> is a valid assembly name without a type name.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="09f45-3018">L’assembly ou une de ses dépendances n’est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3018">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="09f45-3019">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3019">-or-</span>
          </span>
          <span data-ttu-id="09f45-3020">L’assembly a été compilé avec une version du Common Language Runtime postérieure à la version actuellement chargée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3020">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">
          <span data-ttu-id="09f45-3021">Tableau d'objets dont les types sont à déterminer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3021">An array of objects whose types to determine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3022">Obtient les types des objets dans le tableau spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3022">Gets the types of the objects in the specified array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3023">Tableau d'objets <see cref="T:System.Type" /> représentant les types des éléments correspondants dans <paramref name="args" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3023">An array of <see cref="T:System.Type" /> objects representing the types of the corresponding elements in <paramref name="args" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="09f45-3024">L’exemple de code suivant montre comment utiliser la <xref:System.Type.GetTypeArray%2A> méthode pour répertorier les types des éléments du tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-3024">The following code example demonstrates how to use the <xref:System.Type.GetTypeArray%2A> method to list the types of the elements of an array.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-3025">
            <paramref name="args" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3025">
              <paramref name="args" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-3026">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3026">-or-</span>
          </span>
          <span data-ttu-id="09f45-3027">Au moins un des éléments de <paramref name="args" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3027">One or more of the elements in <paramref name="args" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="09f45-3028">Les initialiseurs de classe sont appelés et au moins l’un d’eux lève une exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3028">The class initializers are invoked and at least one throws an exception.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="09f45-3029">Type dont le code de type sous-jacent doit être obtenu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3029">The type whose underlying type code to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3030">Obtient le code du type sous-jacent du <see cref="T:System.Type" /> spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3030">Gets the underlying type code of the specified <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3031">Code du type sous-jacent ou <see cref="F:System.TypeCode.Empty" /> si <paramref name="type" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3031">The code of the underlying type, or <see cref="F:System.TypeCode.Empty" /> if <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3032">Lorsque vous héritez de <xref:System.Type>, vous pouvez modifier le comportement de cette méthode en substituant le <xref:System.Type.GetTypeCodeImpl%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3032">When you inherit from <xref:System.Type>, you can change the behavior of this method by overriding the <xref:System.Type.GetTypeCodeImpl%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3033">L’exemple de code suivant montre comment la <xref:System.TypeCode> énumération peut être utilisée.</span><span class="sxs-lookup"><span data-stu-id="09f45-3033">The following code example demonstrates how the <xref:System.TypeCode> enumeration can be used.</span></span> <span data-ttu-id="09f45-3034">Dans un bloc de décision le `WriteObjectInfo` (méthode), la <xref:System.TypeCode> d’un <xref:System.Object> paramètre est examiné, et un message approprié est écrit dans la console.</span><span class="sxs-lookup"><span data-stu-id="09f45-3034">In a decision block inside the `WriteObjectInfo` method, the <xref:System.TypeCode> of an <xref:System.Object> parameter is examined, and an appropriate message is written to the console.</span></span>  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3035">Retourne le code du type sous-jacent de cette instance <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3035">Returns the underlying type code of this <see cref="T:System.Type" /> instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3036">Code du type sous-jacent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3036">The type code of the underlying type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3037">Cette méthode fournit l’implémentation pour la `static` (en c#) ou `Shared` (en Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3037">This method provides the implementation for the `static` (in C#) or `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> method.</span></span> <span data-ttu-id="09f45-3038">Lorsque vous héritez de <xref:System.Type>, vous pouvez substituer cette méthode pour fournir votre propre implémentation de <xref:System.Type.GetTypeCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3038">When you inherit from <xref:System.Type>, you can override this method to provide your own implementation of <xref:System.Type.GetTypeCode%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3039">Obtient le type associé à l'identificateur de classe (CLSID) spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3039">Gets the type associated with the specified class identifier (CLSID).</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="09f45-3040">CLSID du type à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3040">The CLSID of the type to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3041">Obtient le type associé à l'identificateur de classe (CLSID) spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3041">Gets the type associated with the specified class identifier (CLSID).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3042">
            <see langword="System.__ComObject" /> que le CLSID soit valide ou non.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3042">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3043">Le <xref:System.Type.GetTypeFromCLSID%2A> méthode prend en charge l’accès à liaison tardive aux objets COM non managés à partir d’applications .NET Framework lorsque vous connaissez l’identificateur de classe de l’objet COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="09f45-3043">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="09f45-3044">L’identificateur de classe pour les classes COM est défini dans la clé HKEY_CLASSES_ROOT\CLSID du Registre.</span><span class="sxs-lookup"><span data-stu-id="09f45-3044">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="09f45-3045">Vous pouvez récupérer la valeur de la <xref:System.Type.IsCOMObject%2A> propriété pour déterminer si le type retourné par cette méthode est un objet COM.</span><span class="sxs-lookup"><span data-stu-id="09f45-3045">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="09f45-3046">Vous pouvez appeler la <xref:System.Type.GetTypeFromProgID%2A> méthode pour l’accès à liaison tardive à COM objets dont identificateur programmatique (ProgID) que vous connaissez.</span><span class="sxs-lookup"><span data-stu-id="09f45-3046">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="09f45-3047">Instanciation d’un objet COM non managé à partir de son CLSID est un processus en deux étapes :</span><span class="sxs-lookup"><span data-stu-id="09f45-3047">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="09f45-3048">Obtenir un <xref:System.Type> objet qui représente le`__ComObject` qui correspond au CLSID en appelant le <xref:System.Type.GetTypeFromCLSID%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3048">Get a <xref:System.Type> object that represents the`__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="09f45-3049">Appelez le <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> pour instancier l’objet COM (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3049">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="09f45-3050">Consultez l’exemple pour obtenir une illustration.</span><span class="sxs-lookup"><span data-stu-id="09f45-3050">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="09f45-3051">Le <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> surcharge ignore toute exception qui peut se produire lorsque vous instanciez un <xref:System.Type> objet basé sur le `clsid` argument.</span><span class="sxs-lookup"><span data-stu-id="09f45-3051">The <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignores any exception that may occur when instantiating a <xref:System.Type> object based on the `clsid` argument.</span></span> <span data-ttu-id="09f45-3052">Notez qu’aucune exception n’est levée si `clsid` est introuvable dans le Registre.</span><span class="sxs-lookup"><span data-stu-id="09f45-3052">Note that no exception is thrown if `clsid` is not found in the registry.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3053">L’exemple suivant utilise le CLSID de le Microsoft Word [objet Application](http://msdn.microsoft.com/library/office/ff838565.aspx) pour récupérer un type COM qui représente l’application Microsoft Word.</span><span class="sxs-lookup"><span data-stu-id="09f45-3053">The following example uses the CLSID of the Microsoft Word [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="09f45-3054">Il instancie ensuite le type en appelant le <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (méthode) et le ferme en appelant le [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3054">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="09f45-3055">Cette méthode est destinée à utiliser lorsque vous travaillez avec des objets COM, pas avec les objets .NET Framework.</span>
            <span class="sxs-lookup">
              <span data-stu-id="09f45-3055">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="09f45-3056">Tous les objets, y compris ceux qui sont visibles par COM gérés par (autrement dit, leurs <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribut est <see langword="true" />) ont un GUID qui est retourné par la <see cref="P:System.Type.GUID" /> propriété.</span>
            <span class="sxs-lookup">
              <span data-stu-id="09f45-3056">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="09f45-3057">Bien que la méthode retourne un <see cref="T:System.Type" /> objets d’objet qui correspond au GUID du .NET Framework, vous ne pouvez pas utiliser <see cref="T:System.Type" /> objet pour créer une instance de type en appelant le <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode, comme le montre l’exemple suivant.</span>
            <span class="sxs-lookup">
              <span data-stu-id="09f45-3057">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 <span data-ttu-id="09f45-3058">Au lieu de cela, le <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> doit uniquement être utilisé pour récupérer le GUID d’un objet COM non managé et résultant <see cref="T:System.Type" /> objet est passé à la <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode doit représenter un objet COM non managé.</span><span class="sxs-lookup"><span data-stu-id="09f45-3058">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="09f45-3059">CLSID du type à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3059">The CLSID of the type to get.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="09f45-3060">
            <see langword="true" /> pour lever toute exception qui se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3060">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="09f45-3061">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3061">-or-</span>
          </span>
          <span data-ttu-id="09f45-3062">
            <see langword="false" /> pour ignorer toute exception qui se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3062">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3063">Obtient le type associé à l'identificateur de classe (CLSID) spécifié, indiquant s'il faut lever une exception en cas d'erreur pendant le chargement du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3063">Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3064">
            <see langword="System.__ComObject" /> que le CLSID soit valide ou non.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3064">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3065">Le <xref:System.Type.GetTypeFromCLSID%2A> méthode prend en charge l’accès à liaison tardive aux objets COM non managés à partir d’applications .NET Framework lorsque vous connaissez l’identificateur de classe de l’objet COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="09f45-3065">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="09f45-3066">L’identificateur de classe pour les classes COM est défini dans la clé HKEY_CLASSES_ROOT\CLSID du Registre.</span><span class="sxs-lookup"><span data-stu-id="09f45-3066">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="09f45-3067">Vous pouvez récupérer la valeur de la <xref:System.Type.IsCOMObject%2A> propriété pour déterminer si le type retourné par cette méthode est un objet COM.</span><span class="sxs-lookup"><span data-stu-id="09f45-3067">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="09f45-3068">Vous pouvez appeler la <xref:System.Type.GetTypeFromProgID%2A> méthode pour l’accès à liaison tardive à COM objets dont identificateur programmatique (ProgID) que vous connaissez.</span><span class="sxs-lookup"><span data-stu-id="09f45-3068">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="09f45-3069">Instanciation d’un objet COM non managé à partir de son CLSID est un processus en deux étapes :</span><span class="sxs-lookup"><span data-stu-id="09f45-3069">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="09f45-3070">Obtenir un <xref:System.Type> objet qui représente le `__ComObject` qui correspond au CLSID en appelant le <xref:System.Type.GetTypeFromCLSID%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3070">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="09f45-3071">Appelez le <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> pour instancier l’objet COM (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3071">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="09f45-3072">Consultez l’exemple pour obtenir une illustration.</span><span class="sxs-lookup"><span data-stu-id="09f45-3072">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="09f45-3073">Exceptions telles que <xref:System.OutOfMemoryException> sera levée lors de la spécification `true` pour `throwOnError`, mais non inscrits CLSID n’échouera pas.</span><span class="sxs-lookup"><span data-stu-id="09f45-3073">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3074">L’exemple suivant utilise le CLSID de le Microsoft Word [objet Application](http://msdn.microsoft.com/library/office/ff838565.aspx) pour récupérer un type COM qui représente l’application Microsoft Word.</span><span class="sxs-lookup"><span data-stu-id="09f45-3074">The following example uses the CLSID of the Microsoft Word [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="09f45-3075">Il instancie ensuite le type en appelant le <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (méthode) et le ferme en appelant le [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3075">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) method.</span></span> <span data-ttu-id="09f45-3076">Une exception est levée si une erreur se produit pendant le chargement du type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3076">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="09f45-3077">Cette méthode est destinée à utiliser lorsque vous travaillez avec des objets COM, pas avec les objets .NET Framework.</span>
            <span class="sxs-lookup">
              <span data-stu-id="09f45-3077">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="09f45-3078">Tous les objets, y compris ceux qui sont visibles par COM gérés par (autrement dit, leurs <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribut est <see langword="true" />) ont un GUID qui est retourné par la <see cref="P:System.Type.GUID" /> propriété.</span>
            <span class="sxs-lookup">
              <span data-stu-id="09f45-3078">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="09f45-3079">Bien que la méthode retourne un <see cref="T:System.Type" /> objets d’objet qui correspond au GUID du .NET Framework, vous ne pouvez pas utiliser <see cref="T:System.Type" /> objet pour créer une instance de type en appelant le <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode, comme le montre l’exemple suivant.</span>
            <span class="sxs-lookup">
              <span data-stu-id="09f45-3079">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 <span data-ttu-id="09f45-3080">Au lieu de cela, le <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> doit uniquement être utilisé pour récupérer le GUID d’un objet COM non managé et résultant <see cref="T:System.Type" /> objet est passé à la <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode doit représenter un objet COM non managé.</span><span class="sxs-lookup"><span data-stu-id="09f45-3080">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="09f45-3081">CLSID du type à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3081">The CLSID of the type to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="09f45-3082">Serveur à partir duquel le type doit être chargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3082">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="09f45-3083">Si le nom de serveur est <see langword="null" />, cette méthode revient automatiquement à la machine locale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3083">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3084">Obtient le type associé à l'identificateur de classe (CLSID) spécifié à partir du serveur défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3084">Gets the type associated with the specified class identifier (CLSID) from the specified server.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3085">
            <see langword="System.__ComObject" /> que le CLSID soit valide ou non.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3085">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3086">Le <xref:System.Type.GetTypeFromCLSID%2A> méthode prend en charge l’accès à liaison tardive aux objets COM non managés à partir d’applications .NET Framework lorsque vous connaissez l’identificateur de classe de l’objet COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="09f45-3086">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="09f45-3087">L’identificateur de classe pour les classes COM est défini dans la clé HKEY_CLASSES_ROOT\CLSID du Registre.</span><span class="sxs-lookup"><span data-stu-id="09f45-3087">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="09f45-3088">Vous pouvez récupérer la valeur de la <xref:System.Type.IsCOMObject%2A> propriété pour déterminer si le type retourné par cette méthode est un objet COM.</span><span class="sxs-lookup"><span data-stu-id="09f45-3088">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="09f45-3089">Vous pouvez appeler la <xref:System.Type.GetTypeFromProgID%2A> méthode pour l’accès à liaison tardive à COM objets dont identificateur programmatique (ProgID) que vous connaissez.</span><span class="sxs-lookup"><span data-stu-id="09f45-3089">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="09f45-3090">Instanciation d’un objet COM non managé à partir de son CLSID est un processus en deux étapes :</span><span class="sxs-lookup"><span data-stu-id="09f45-3090">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="09f45-3091">Obtenir un <xref:System.Type> objet qui représente le `__ComObject` qui correspond au CLSID en appelant le <xref:System.Type.GetTypeFromCLSID%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3091">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="09f45-3092">Appelez le <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> pour instancier l’objet COM (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3092">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3093">L’exemple suivant utilise le CLSID de le Microsoft Word [objet Application](http://msdn.microsoft.com/library/office/ff838565.aspx) pour récupérer un type COM qui représente l’application Microsoft Word à partir d’un serveur nommé computer17.central.contoso.com. Il instancie ensuite le type en appelant le <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (méthode) et le ferme en appelant le [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3093">The following example uses the CLSID of the Microsoft Word [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="09f45-3094">Cette méthode est destinée à utiliser lorsque vous travaillez avec des objets COM, pas avec les objets .NET Framework.</span>
            <span class="sxs-lookup">
              <span data-stu-id="09f45-3094">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="09f45-3095">Tous les objets, y compris ceux qui sont visibles par COM gérés par (autrement dit, leurs <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribut est <see langword="true" />) ont un GUID qui est retourné par la <see cref="P:System.Type.GUID" /> propriété.</span>
            <span class="sxs-lookup">
              <span data-stu-id="09f45-3095">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="09f45-3096">Bien que la méthode retourne un <see cref="T:System.Type" /> objets d’objet qui correspond au GUID du .NET Framework, vous ne pouvez pas utiliser <see cref="T:System.Type" /> objet pour créer une instance de type en appelant le <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode, comme le montre l’exemple suivant.</span>
            <span class="sxs-lookup">
              <span data-stu-id="09f45-3096">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 <span data-ttu-id="09f45-3097">Au lieu de cela, le <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> doit uniquement être utilisé pour récupérer le GUID d’un objet COM non managé et résultant <see cref="T:System.Type" /> objet est passé à la <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode doit représenter un objet COM non managé.</span><span class="sxs-lookup"><span data-stu-id="09f45-3097">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="09f45-3098">CLSID du type à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3098">The CLSID of the type to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="09f45-3099">Serveur à partir duquel le type doit être chargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3099">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="09f45-3100">Si le nom de serveur est <see langword="null" />, cette méthode revient automatiquement à la machine locale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3100">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="09f45-3101">
            <see langword="true" /> pour lever toute exception qui se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3101">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="09f45-3102">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3102">-or-</span>
          </span>
          <span data-ttu-id="09f45-3103">
            <see langword="false" /> pour ignorer toute exception qui se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3103">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3104">Obtient le type associé à l'identificateur de classe (CLSID) spécifié à partir du serveur défini, indiquant s'il faut lever une exception en cas d'erreur pendant le chargement du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3104">Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3105">
            <see langword="System.__ComObject" /> que le CLSID soit valide ou non.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3105">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3106">Le <xref:System.Type.GetTypeFromCLSID%2A> méthode prend en charge l’accès à liaison tardive aux objets COM non managés à partir d’applications .NET Framework lorsque vous connaissez l’identificateur de classe de l’objet COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="09f45-3106">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="09f45-3107">L’identificateur de classe pour les classes COM est défini dans la clé HKEY_CLASSES_ROOT\CLSID du Registre.</span><span class="sxs-lookup"><span data-stu-id="09f45-3107">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="09f45-3108">Vous pouvez récupérer la valeur de la <xref:System.Type.IsCOMObject%2A> propriété pour déterminer si le type retourné par cette méthode est un objet COM.</span><span class="sxs-lookup"><span data-stu-id="09f45-3108">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="09f45-3109">Vous pouvez appeler la <xref:System.Type.GetTypeFromProgID%2A> méthode pour l’accès à liaison tardive à COM objets dont identificateur programmatique (ProgID) que vous connaissez.</span><span class="sxs-lookup"><span data-stu-id="09f45-3109">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="09f45-3110">Instanciation d’un objet COM non managé à partir de son CLSID est un processus en deux étapes :</span><span class="sxs-lookup"><span data-stu-id="09f45-3110">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="09f45-3111">Obtenir un <xref:System.Type> objet qui représente le `__ComObject` qui correspond au CLSID en appelant le <xref:System.Type.GetTypeFromCLSID%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3111">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="09f45-3112">Appelez le <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> pour instancier l’objet COM (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3112">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="09f45-3113">Exceptions telles que <xref:System.OutOfMemoryException> sera levée lors de la spécification `true` pour `throwOnError`, mais non inscrits CLSID n’échouera pas.</span><span class="sxs-lookup"><span data-stu-id="09f45-3113">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3114">L’exemple suivant utilise le CLSID de le Microsoft Word [objet Application](http://msdn.microsoft.com/library/office/ff838565.aspx) pour récupérer un type COM qui représente l’application Microsoft Word à partir d’un serveur nommé computer17.central.contoso.com. Il instancie ensuite le type en appelant le <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (méthode) et le ferme en appelant le [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3114">The following example uses the CLSID of the Microsoft Word [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) method.</span></span> <span data-ttu-id="09f45-3115">Une exception est levée si une erreur se produit pendant le chargement du type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3115">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="09f45-3116">Cette méthode est destinée à utiliser lorsque vous travaillez avec des objets COM, pas avec les objets .NET Framework.</span>
            <span class="sxs-lookup">
              <span data-stu-id="09f45-3116">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="09f45-3117">Tous les objets, y compris ceux qui sont visibles par COM gérés par (autrement dit, leurs <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribut est <see langword="true" />) ont un GUID qui est retourné par la <see cref="P:System.Type.GUID" /> propriété.</span>
            <span class="sxs-lookup">
              <span data-stu-id="09f45-3117">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="09f45-3118">Bien que le <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> méthode retourne un <see cref="T:System.Type" /> objet qui correspond au GUID d’un objet managé particulier, vous ne pouvez pas utiliser <see cref="T:System.Type" /> objet pour créer une instance de type en appelant le <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode, comme l’exemple suivant montre.</span>
            <span class="sxs-lookup">
              <span data-stu-id="09f45-3118">Although the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for a particular managed object, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 <span data-ttu-id="09f45-3119">Au lieu de cela, le <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> doit uniquement être utilisé pour récupérer le GUID d’un objet COM non managé et résultant <see cref="T:System.Type" /> objet est passé à la <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode doit représenter un objet COM non managé.</span><span class="sxs-lookup"><span data-stu-id="09f45-3119">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="09f45-3120">Objet qui fait référence au type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3120">The object that refers to the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3121">Obtient le type référencé par le handle de type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3121">Gets the type referenced by the specified type handle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3122">Le type référencé par le <see cref="T:System.RuntimeTypeHandle" /> spécifié, ou <see langword="null" /> si la propriété <see cref="P:System.RuntimeTypeHandle.Value" /> de <paramref name="handle" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3122">The type referenced by the specified <see cref="T:System.RuntimeTypeHandle" />, or <see langword="null" /> if the <see cref="P:System.RuntimeTypeHandle.Value" /> property of <paramref name="handle" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3123">Les poignées sont valides uniquement dans le domaine d’application dans lequel ils ont été obtenus.</span><span class="sxs-lookup"><span data-stu-id="09f45-3123">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3124">L’exemple suivant utilise le <xref:System.Type.GetTypeFromHandle%2A> méthode pour obtenir un <xref:System.Type> à partir de l’objet un <xref:System.RuntimeTypeHandle> fournie par le <xref:System.Type.GetTypeHandle%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3124">The following example uses the <xref:System.Type.GetTypeFromHandle%2A> method to get a <xref:System.Type> object from a <xref:System.RuntimeTypeHandle> provided by the <xref:System.Type.GetTypeHandle%2A> method.</span></span>  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="09f45-3125">Un initialiseur de classe est appelé et lève une exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3125">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3126">Obtient le type associé à l'identificateur de programme (ProgID) spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3126">Gets the type associated with the specified program identifier (ProgID).</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="09f45-3127">Identificateur de programme (ProgID) du type à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3127">The ProgID of the type to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3128">Obtient le type associé à l'identificateur de programme (ProgID) spécifié, retournant null en cas d'erreur pendant le chargement de <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3128">Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3129">Type associé à l'identificateur de programme (ProgID) spécifié si <paramref name="progID" /> est une entrée valide dans le Registre et qu'un type lui est associé ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3129">The type associated with the specified ProgID, if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3130">Cette méthode est fournie pour la prise en charge COM.</span><span class="sxs-lookup"><span data-stu-id="09f45-3130">This method is provided for COM support.</span></span> <span data-ttu-id="09f45-3131">ProgID ne sont pas utilisés dans le Microsoft .NET Framework, car ils ont été remplacés par le concept d’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="09f45-3131">ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-3132">
            <paramref name="progID" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3132">
              <paramref name="progID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="09f45-3133">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3133">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="09f45-3134">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3134">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="09f45-3135">Identificateur de programme (ProgID) du type à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3135">The ProgID of the type to get.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="09f45-3136">
            <see langword="true" /> pour lever toute exception qui se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3136">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="09f45-3137">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3137">-or-</span>
          </span>
          <span data-ttu-id="09f45-3138">
            <see langword="false" /> pour ignorer toute exception qui se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3138">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3139">Obtient le type associé à l'identificateur de programme (ProgID) spécifié, indiquant s'il faut lever une exception en cas d'erreur pendant le chargement du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3139">Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3140">Type associé à l'identificateur de programme (ProgID) spécifié si <paramref name="progID" /> est une entrée valide dans le Registre et qu'un type lui est associé ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3140">The type associated with the specified program identifier (ProgID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3141">Cette méthode est fournie pour la prise en charge COM.</span><span class="sxs-lookup"><span data-stu-id="09f45-3141">This method is provided for COM support.</span></span> <span data-ttu-id="09f45-3142">ID de programme ne sont pas utilisés dans Microsoft .NET Framework, car ils ont été remplacés par le concept d’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="09f45-3142">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3143">L’exemple suivant récupère un type en passant un ProgID, indiquant s’il faut lever une exception si le ProgID n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="09f45-3143">The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</span></span> <span data-ttu-id="09f45-3144">L’exemple affiche ensuite le ClassID associé au ProgID, ainsi que tout message d’exception approprié.</span><span class="sxs-lookup"><span data-stu-id="09f45-3144">The example then displays the ClassID related to the ProgID, along with any applicable exception message.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-3145">
            <paramref name="progID" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3145">
              <paramref name="progID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <span data-ttu-id="09f45-3146">Le progID spécifié n’est pas inscrit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3146">The specified ProgID is not registered.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="09f45-3147">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3147">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="09f45-3148">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3148">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="09f45-3149">Identificateur de programme (ProgID) du type à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3149">The progID of the type to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="09f45-3150">Serveur à partir duquel le type doit être chargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3150">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="09f45-3151">Si le nom de serveur est <see langword="null" />, cette méthode revient automatiquement à la machine locale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3151">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3152">Obtient le type associé à l'identificateur de programme (ProgID) spécifié à partir du serveur défini, retournant null en cas d'erreur pendant le chargement du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3152">Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3153">Type associé à l'identificateur de programme (ProgID) spécifié si <paramref name="progID" /> est une entrée valide dans le Registre et qu'un type lui est associé ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3153">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3154">Cette méthode est fournie pour la prise en charge COM.</span><span class="sxs-lookup"><span data-stu-id="09f45-3154">This method is provided for COM support.</span></span> <span data-ttu-id="09f45-3155">ID de programme ne sont pas utilisés dans Microsoft .NET Framework, car ils ont été remplacés par le concept d’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="09f45-3155">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3156">L’exemple suivant récupère un type en passant un ProgID et nom de serveur.</span><span class="sxs-lookup"><span data-stu-id="09f45-3156">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="09f45-3157">L’exemple puis affiche le ClassID associé au ProgID, ou lève une exception si le ProgID ou le nom du serveur n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="09f45-3157">The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-3158">
            <paramref name="prodID" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3158">
              <paramref name="prodID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="09f45-3159">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3159">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="09f45-3160">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3160">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="09f45-3161">Identificateur de programme (ProgID) du <see cref="T:System.Type" /> à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3161">The progID of the <see cref="T:System.Type" /> to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="09f45-3162">Serveur à partir duquel le type doit être chargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3162">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="09f45-3163">Si le nom de serveur est <see langword="null" />, cette méthode revient automatiquement à la machine locale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3163">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="09f45-3164">
            <see langword="true" /> pour lever toute exception qui se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3164">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="09f45-3165">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3165">-or-</span>
          </span>
          <span data-ttu-id="09f45-3166">
            <see langword="false" /> pour ignorer toute exception qui se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3166">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3167">Obtient le type associé à l'identificateur de programme (ProgID) spécifié à partir du serveur défini, indiquant s'il faut lever une exception en cas d'erreur pendant le chargement du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3167">Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3168">Type associé à l'identificateur de programme (ProgID) spécifié si <paramref name="progID" /> est une entrée valide dans le Registre et qu'un type lui est associé ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3168">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3169">Cette méthode est fournie pour la prise en charge COM.</span><span class="sxs-lookup"><span data-stu-id="09f45-3169">This method is provided for COM support.</span></span> <span data-ttu-id="09f45-3170">ID de programme ne sont pas utilisés dans Microsoft .NET Framework, car ils ont été remplacés par le concept d’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="09f45-3170">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3171">L’exemple suivant récupère un type en passant un ProgID et nom de serveur.</span><span class="sxs-lookup"><span data-stu-id="09f45-3171">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="09f45-3172">L’exemple affiche ensuite le ClassID associé au ProgID, en spécifiant s’il faut lever une exception si le ProgID ou le nom du serveur n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="09f45-3172">The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-3173">
            <paramref name="progID" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3173">
              <paramref name="progID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <span data-ttu-id="09f45-3174">Le progID spécifié n’est pas inscrit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3174">The specified progID is not registered.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="09f45-3175">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3175">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="09f45-3176">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3176">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="09f45-3177">Objet dont il faut obtenir le handle de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3177">The object for which to get the type handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3178">Obtient le handle pour le <see cref="T:System.Type" /> d'un objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3178">Gets the handle for the <see cref="T:System.Type" /> of a specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3179">Handle pour le <see cref="T:System.Type" /> de l'objet <see cref="T:System.Object" /> spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3179">The handle for the <see cref="T:System.Type" /> of the specified <see cref="T:System.Object" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3180">Les poignées sont valides uniquement dans le domaine d’application dans lequel ils ont été obtenus.</span><span class="sxs-lookup"><span data-stu-id="09f45-3180">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3181">L’exemple suivant définit la classe `MyClass1`, obtient une instance de celui-ci et récupère le handle de runtime de l’objet.</span><span class="sxs-lookup"><span data-stu-id="09f45-3181">The following example defines the class `MyClass1`, gets an instance of it, and retrieves the runtime handle of the object.</span></span>  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-3182">
            <paramref name="o" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3182">
              <paramref name="o" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3183">Obtient le GUID associé à <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3183">Gets the GUID associated with the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3184">GUID associé à <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3184">The GUID associated with the <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3185">Un GUID est associé à un type à l’aide de la <xref:System.Runtime.InteropServices.GuidAttribute> attribut.</span><span class="sxs-lookup"><span data-stu-id="09f45-3185">A GUID is associated with a type using the <xref:System.Runtime.InteropServices.GuidAttribute> attribute.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3186">L’exemple suivant crée la classe `MyClass1` avec une méthode publique, crée un `Type` objet correspondant à `MyClass1`et obtient le <xref:System.Guid> à l’aide de la structure du `GUID` propriété de la `Type` classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-3186">The following example creates the class `MyClass1` with a public method, creates a `Type` object corresponding to `MyClass1`, and gets the <xref:System.Guid> structure using the `GUID` property of the `Type` class.</span></span>  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3187">Obtient une valeur indiquant si le <see cref="T:System.Type" /> actuel englobe ou se réfère à un autre type, c'est-à-dire si le <see cref="T:System.Type" /> actuel est un tableau ou un pointeur ou encore s'il est passé par référence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3187">Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3188">
            <see langword="true" /> si <see cref="T:System.Type" /> est un tableau ou un pointeur ou encore s'il est passé par référence ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3188">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3189">Par exemple, Type.GetType("Int32[]"). HasElementType retourne `true`, mais Type.GetType("Int32"). HasElementType retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3189">For example, Type.GetType("Int32[]").HasElementType returns `true`, but Type.GetType("Int32").HasElementType returns `false`.</span></span> <span data-ttu-id="09f45-3190">HasElementType retourne également `true` pour « Int32 \* » et « Int32 & ».</span><span class="sxs-lookup"><span data-stu-id="09f45-3190">HasElementType also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
 <span data-ttu-id="09f45-3191">Si le courant <xref:System.Type> représente un type générique ou un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3191">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3192">L’exemple suivant renvoie `true` ou `false` selon ou non l’objet est un tableau, un type référence ou un pointeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-3192">The following example returns `true` or `false` depending on whether or not the object is an array, a reference type, or a pointer.</span></span>  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3193">En cas de substitution dans une classe dérivée, implémente la propriété <see cref="P:System.Type.HasElementType" /> et détermine si le <see cref="T:System.Type" /> actuel englobe ou se réfère à un autre type ; c'est-à-dire si le <see cref="T:System.Type" /> actuel est un tableau ou un pointeur ou encore s'il est passé par référence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3193">When overridden in a derived class, implements the <see cref="P:System.Type.HasElementType" /> property and determines whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3194">
            <see langword="true" /> si <see cref="T:System.Type" /> est un tableau ou un pointeur ou encore s'il est passé par référence ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3194">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3195">Par exemple, Type.GetType("Int32[]"). HasElementTypeImpl retourne `true`, mais Type.GetType("Int32"). HasElementTypeImpl retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3195">For example, Type.GetType("Int32[]").HasElementTypeImpl returns `true`, but Type.GetType("Int32").HasElementTypeImpl returns `false`.</span></span> <span data-ttu-id="09f45-3196">HasElementTypeImpl retourne également `true` pour « Int32 \* » et « Int32 & ».</span><span class="sxs-lookup"><span data-stu-id="09f45-3196">HasElementTypeImpl also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3197">L’exemple suivant définit la classe `MyTypeDelegator`, qui remplace le `HasElementTypeImpl` (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3197">The following example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="09f45-3198">La classe principale vérifie la `HasElementType` propriété et affiche le type d’élément.</span><span class="sxs-lookup"><span data-stu-id="09f45-3198">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3199">Appelle un membre spécifique du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3199">Invokes a specific member of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-3200">Chaîne contenant le nom du membre de constructeur, de méthode, de propriété ou de champ à appeler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3200">The string containing the name of the constructor, method, property, or field member to invoke.</span>
          </span>
          <span data-ttu-id="09f45-3201">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3201">-or-</span>
          </span>
          <span data-ttu-id="09f45-3202">Une chaîne vide ("") pour appeler le membre par défaut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3202">An empty string ("") to invoke the default member.</span>
          </span>
          <span data-ttu-id="09f45-3203">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3203">-or-</span>
          </span>
          <span data-ttu-id="09f45-3204">Pour les membres <see langword="IDispatch" />, chaîne représentant le DispID, par exemple "[DispID=3]".</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3204">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="09f45-3205">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3205">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-3206">L'accès peut être fourni par l'un des <see langword="BindingFlags" />, par exemple <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3206">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span>
          </span>
          <span data-ttu-id="09f45-3207">Il n'est pas nécessaire de spécifier le type de recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3207">The type of lookup need not be specified.</span>
          </span>
          <span data-ttu-id="09f45-3208">Si le type de recherche est omis, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> sont utilisés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3208">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="09f45-3209">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3209">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="09f45-3210">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3210">-or-</span>
          </span>
          <span data-ttu-id="09f45-3211">Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3211">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
          <span data-ttu-id="09f45-3212">Notez que la définition explicite d'un objet <see cref="T:System.Reflection.Binder" /> peut être nécessaire pour appeler correctement des surcharges de méthode avec des arguments variables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3212">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="09f45-3213">Objet sur lequel appeler le membre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3213">The object on which to invoke the specified member.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="09f45-3214">Tableau contenant les arguments à passer au membre à appeler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3214">An array containing the arguments to pass to the member to invoke.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3215">Appelle le membre défini, à l’aide des contraintes de liaison spécifiées et correspondant à la liste d’arguments spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3215">Invokes the specified member, using the specified binding constraints and matching the specified argument list.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3216">Objet représentant la valeur de retour du membre appelé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3216">An object representing the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="09f45-3217">Vous ne pouvez pas utiliser <xref:System.Type.InvokeMember%2A> pour appeler une méthode générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3217">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="09f45-3218">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-3218">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-3219">Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-3219">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="09f45-3220">Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-3220">Specify `BindingFlags.NonPublic` to include non-public members (that is, private and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="09f45-3221">Spécifiez `BindingFlags.FlattenHierarchy` pour inclure les membres statiques dans la hiérarchie.</span><span class="sxs-lookup"><span data-stu-id="09f45-3221">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="09f45-3222">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-3222">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-3223">`BindingFlags.IgnoreCase` pour ignorer la casse de `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3223">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="09f45-3224">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-3224">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-3225">Les éléments suivants <xref:System.Reflection.BindingFlags> indicateurs d’appel peuvent être utilisés pour désigner l’action à effectuer sur le membre :</span><span class="sxs-lookup"><span data-stu-id="09f45-3225">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="09f45-3226">`CreateInstance` pour appeler un constructeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-3226">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="09f45-3227">`name` est ignoré.</span><span class="sxs-lookup"><span data-stu-id="09f45-3227">`name` is ignored.</span></span> <span data-ttu-id="09f45-3228">Non valide avec d’autres indicateurs d’appel.</span><span class="sxs-lookup"><span data-stu-id="09f45-3228">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="09f45-3229">`InvokeMethod` pour appeler une méthode, mais pas sur un constructeur ou un initialiseur de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3229">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="09f45-3230">Non valide avec `SetField` ou `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3230">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="09f45-3231">Si `InvokeMethod` est spécifié par lui-même, `BindingFlags.Public`, `BindingFlags.Instance`, et `BindingFlags.Static` sont automatiquement inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-3231">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="09f45-3232">`GetField` Pour obtenir la valeur d’un champ.</span><span class="sxs-lookup"><span data-stu-id="09f45-3232">`GetField` to get the value of a field.</span></span> <span data-ttu-id="09f45-3233">Non valide avec `SetField`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3233">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="09f45-3234">`SetField` Pour définir la valeur d’un champ.</span><span class="sxs-lookup"><span data-stu-id="09f45-3234">`SetField` to set the value of a field.</span></span> <span data-ttu-id="09f45-3235">Non valide avec `GetField`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3235">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="09f45-3236">`GetProperty` Pour obtenir une propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-3236">`GetProperty` to get a property.</span></span> <span data-ttu-id="09f45-3237">Non valide avec `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3237">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="09f45-3238">`SetProperty` Pour définir une propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-3238">`SetProperty` to set a property.</span></span> <span data-ttu-id="09f45-3239">Non valide avec `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3239">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="09f45-3240">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3240">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-3241">Une méthode est appelée si les deux conditions suivantes sont remplies :</span><span class="sxs-lookup"><span data-stu-id="09f45-3241">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="09f45-3242">Le nombre de paramètres dans la déclaration de méthode est égal au nombre d’arguments dans le `args` tableau (à moins que les arguments par défaut sont définis sur le membre et `BindingFlags.OptionalParamBinding` est spécifié).</span><span class="sxs-lookup"><span data-stu-id="09f45-3242">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="09f45-3243">Le type de chaque argument peut être converti par le binder pour le type du paramètre.</span><span class="sxs-lookup"><span data-stu-id="09f45-3243">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="09f45-3244">Le binder va trouver toutes les méthodes correspondantes.</span><span class="sxs-lookup"><span data-stu-id="09f45-3244">The binder will find all of the matching methods.</span></span> <span data-ttu-id="09f45-3245">Ces méthodes sont recherchées en fonction du type de liaison demandé (<xref:System.Reflection.BindingFlags> valeurs `InvokeMethod`, `GetProperty`, et ainsi de suite).</span><span class="sxs-lookup"><span data-stu-id="09f45-3245">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="09f45-3246">L’ensemble de méthodes est filtré par le nom, nombre d’arguments et un ensemble de modificateurs de recherche définis dans le classeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-3246">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="09f45-3247">Une fois que la méthode est sélectionnée, elle est appelée.</span><span class="sxs-lookup"><span data-stu-id="09f45-3247">After the method is selected, it is invoked.</span></span> <span data-ttu-id="09f45-3248">Accessibilité est vérifiée à ce stade.</span><span class="sxs-lookup"><span data-stu-id="09f45-3248">Accessibility is checked at that point.</span></span> <span data-ttu-id="09f45-3249">La recherche peut contrôler quel ensemble de méthodes est analysé en fonction de l’attribut d’accessibilité associé à la méthode.</span><span class="sxs-lookup"><span data-stu-id="09f45-3249">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="09f45-3250">Le <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> méthode de la <xref:System.Reflection.Binder> classe est chargée de sélectionner la méthode à appeler.</span><span class="sxs-lookup"><span data-stu-id="09f45-3250">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="09f45-3251">Le binder par défaut sélectionne la correspondance la plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3251">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="09f45-3252">Restrictions d’accès sont ignorées pour le code de confiance totale ; Autrement dit, propriétés, méthodes, champs et constructeurs privés peuvent être accessibles et appelées par la <xref:System.Reflection> chaque fois que le code est entièrement fiable.</span><span class="sxs-lookup"><span data-stu-id="09f45-3252">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="09f45-3253">Vous pouvez utiliser `Type.InvokeMember` pour définir un champ à une valeur particulière, en spécifiant <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3253">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09f45-3254">Par exemple, si vous souhaitez définir un champ d’instance public nommé F sur la classe C et F est un `String`, vous pouvez utiliser le code :</span><span class="sxs-lookup"><span data-stu-id="09f45-3254">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 <span data-ttu-id="09f45-3255">Si F est un `String[]`, vous pouvez utiliser le code :</span><span class="sxs-lookup"><span data-stu-id="09f45-3255">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 <span data-ttu-id="09f45-3256">ce qui initialisera le champ F à ce nouveau tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-3256">which will initialize the field F to this new array.</span></span> <span data-ttu-id="09f45-3257">Vous pouvez également utiliser `Type.InvokeMember` pour définir une position dans un tableau en fournissant l’index de la valeur, puis la valeur suivante en utilisant le code suivant :</span><span class="sxs-lookup"><span data-stu-id="09f45-3257">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 <span data-ttu-id="09f45-3258">Cela modifie la chaîne « z » dans le tableau F conserve la chaîne « b ».</span><span class="sxs-lookup"><span data-stu-id="09f45-3258">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="09f45-3259">Quand vous appelez un `IDispatch` membre, vous pouvez spécifier le DispID au lieu du nom de membre, à l’aide du format de chaîne « [DispID = ##] ».</span><span class="sxs-lookup"><span data-stu-id="09f45-3259">When you invoke an `IDispatch` member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="09f45-3260">Par exemple, si le DispID de MyComMethod est 3, vous pouvez spécifier la chaîne « [DispID = 3] » au lieu de « MyComMethod ».</span><span class="sxs-lookup"><span data-stu-id="09f45-3260">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="09f45-3261">L’appel d’un membre par DispID est plus rapide que la recherche d’un membre par nom.</span><span class="sxs-lookup"><span data-stu-id="09f45-3261">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="09f45-3262">Dans les scénarios d’agrégation complexes, le DispID est parfois la seule façon d’appeler le membre souhaité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3262">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-3263">En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des membres non publics est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son.</span><span class="sxs-lookup"><span data-stu-id="09f45-3263">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="09f45-3264">(Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="09f45-3264">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="09f45-3265">Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="09f45-3265">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3266">L’exemple suivant utilise `InvokeMember` pour accéder aux membres d’un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3266">The following example uses `InvokeMember` to access members of a type.</span></span>  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-3267">
            <paramref name="invokeAttr" /> ne contient pas <see langword="CreateInstance" /> et <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3267">
              <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-3268">
            <paramref name="invokeAttr" /> n’est pas un attribut <see cref="T:System.Reflection.BindingFlags" /> valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3268">
              <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span>
          </span>
          <span data-ttu-id="09f45-3269">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3269">-or-</span>
          </span>
          <span data-ttu-id="09f45-3270">
            <paramref name="invokeAttr" /> ne contient pas l’un des indicateurs de liaison suivants : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3270">
              <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="09f45-3271">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3271">-or-</span>
          </span>
          <span data-ttu-id="09f45-3272">
            <paramref name="invokeAttr" /> contient <see langword="CreateInstance" /> combiné avec <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3272">
              <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="09f45-3273">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3273">-or-</span>
          </span>
          <span data-ttu-id="09f45-3274">
            <paramref name="invokeAttr" /> contient à la fois <see langword="GetField" /> et <see langword="SetField" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3274">
              <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span>
          </span>
          <span data-ttu-id="09f45-3275">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3275">-or-</span>
          </span>
          <span data-ttu-id="09f45-3276">
            <paramref name="invokeAttr" /> contient à la fois <see langword="GetProperty" /> et <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3276">
              <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="09f45-3277">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3277">-or-</span>
          </span>
          <span data-ttu-id="09f45-3278">
            <paramref name="invokeAttr" /> contient <see langword="InvokeMethod" /> combiné avec <see langword="SetField" /> ou <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3278">
              <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="09f45-3279">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3279">-or-</span>
          </span>
          <span data-ttu-id="09f45-3280">
            <paramref name="invokeAttr" /> contient <see langword="SetField" /> et <paramref name="args" /> a plusieurs éléments.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3280">
              <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span>
          </span>
          <span data-ttu-id="09f45-3281">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3281">-or-</span>
          </span>
          <span data-ttu-id="09f45-3282">Cette méthode est appelée sur un objet COM et l’un des indicateurs de liaisons suivants n’a pas été passé : <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> ou <see langword="BindingFlags.PutRefDispProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3282">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span>
          </span>
          <span data-ttu-id="09f45-3283">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3283">-or-</span>
          </span>
          <span data-ttu-id="09f45-3284">L’un des tableaux de paramètres nommés contient une chaîne qui est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3284">One of the named parameter arrays contains a string that is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="09f45-3285">Le membre spécifié est un initialiseur de classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3285">The specified member is a class initializer.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingFieldException">
          <span data-ttu-id="09f45-3286">Le champ ou la propriété est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3286">The field or property cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="09f45-3287">Aucune méthode ne peut être trouvée qui correspond aux arguments de <paramref name="args" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3287">No method can be found that matches the arguments in <paramref name="args" />.</span>
          </span>
          <span data-ttu-id="09f45-3288">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3288">-or-</span>
          </span>
          <span data-ttu-id="09f45-3289">L’objet <see cref="T:System.Type" /> actuel représente un type qui contient les paramètres de type ouverts, à savoir, <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3289">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="09f45-3290">Le membre spécifié ne peut pas être appelé sur <paramref name="target" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3290">The specified member cannot be invoked on <paramref name="target" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-3291">Plusieurs méthodes correspondent aux critères de liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3291">More than one method matches the binding criteria.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-3292">Le .NET Compact Framework ne prend pas en charge cette méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3292">The .NET Compact Framework does not currently support this method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="09f45-3293">La méthode représentée par <paramref name="name" /> a un ou plusieurs paramètres de type générique non spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3293">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span>
          </span>
          <span data-ttu-id="09f45-3294">Autrement dit, la propriété <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> de la méthode retourne <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3294">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="09f45-3295">Pour accéder aux membres non publics, quelle que soit leur allocation définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3295">for accessing non-public members regardless of their grant set.</span>
          </span>
          <span data-ttu-id="09f45-3296">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3296">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="09f45-3297">appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3297">to call unmanaged code.</span>
          </span>
          <span data-ttu-id="09f45-3298">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3298">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-3299">Chaîne contenant le nom du membre de constructeur, de méthode, de propriété ou de champ à appeler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3299">The string containing the name of the constructor, method, property, or field member to invoke.</span>
          </span>
          <span data-ttu-id="09f45-3300">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3300">-or-</span>
          </span>
          <span data-ttu-id="09f45-3301">Une chaîne vide ("") pour appeler le membre par défaut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3301">An empty string ("") to invoke the default member.</span>
          </span>
          <span data-ttu-id="09f45-3302">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3302">-or-</span>
          </span>
          <span data-ttu-id="09f45-3303">Pour les membres <see langword="IDispatch" />, chaîne représentant le DispID, par exemple "[DispID=3]".</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3303">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="09f45-3304">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3304">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-3305">L'accès peut être fourni par l'un des <see langword="BindingFlags" />, par exemple <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3305">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span>
          </span>
          <span data-ttu-id="09f45-3306">Il n'est pas nécessaire de spécifier le type de recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3306">The type of lookup need not be specified.</span>
          </span>
          <span data-ttu-id="09f45-3307">Si le type de recherche est omis, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> sont utilisés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3307">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="09f45-3308">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3308">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="09f45-3309">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3309">-or-</span>
          </span>
          <span data-ttu-id="09f45-3310">Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3310">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
          <span data-ttu-id="09f45-3311">Notez que la définition explicite d'un objet <see cref="T:System.Reflection.Binder" /> peut être nécessaire pour appeler correctement des surcharges de méthode avec des arguments variables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3311">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="09f45-3312">Objet sur lequel appeler le membre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3312">The object on which to invoke the specified member.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="09f45-3313">Tableau contenant les arguments à passer au membre à appeler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3313">An array containing the arguments to pass to the member to invoke.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="09f45-3314">Objet représentant le paramètre régional de globalisation à utiliser si nécessaire, notamment pour les conversions spécifiques aux paramètres régionaux telles que la conversion d'un type numérique <see cref="T:System.String" /> en type <see cref="T:System.Double" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3314">The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <see cref="T:System.String" /> to a <see cref="T:System.Double" />.</span>
          </span>
          <span data-ttu-id="09f45-3315">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3315">-or-</span>
          </span>
          <span data-ttu-id="09f45-3316">Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3316">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3317">Appelle le membre spécifié, à l'aide des contraintes de liaison spécifiées et correspondant à la liste d'arguments et à la culture spécifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3317">Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3318">Objet représentant la valeur de retour du membre appelé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3318">An object representing the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3319">Bien que le binder par défaut ne traite pas <xref:System.Globalization.CultureInfo> (le `culture` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `culture`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3319">Although the default binder does not process <xref:System.Globalization.CultureInfo> (the `culture` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `culture`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-3320">Vous ne pouvez pas utiliser <xref:System.Type.InvokeMember%2A> pour appeler une méthode générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3320">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="09f45-3321">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-3321">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-3322">Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-3322">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="09f45-3323">Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-3323">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="09f45-3324">Spécifiez `BindingFlags.FlattenHierarchy` pour inclure les membres statiques dans la hiérarchie.</span><span class="sxs-lookup"><span data-stu-id="09f45-3324">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="09f45-3325">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-3325">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-3326">`BindingFlags.IgnoreCase` pour ignorer la casse de `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3326">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="09f45-3327">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-3327">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-3328">Les éléments suivants <xref:System.Reflection.BindingFlags> indicateurs d’appel peuvent être utilisés pour désigner l’action à effectuer sur le membre :</span><span class="sxs-lookup"><span data-stu-id="09f45-3328">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="09f45-3329">`CreateInstance` pour appeler un constructeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-3329">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="09f45-3330">`name` est ignoré.</span><span class="sxs-lookup"><span data-stu-id="09f45-3330">`name` is ignored.</span></span> <span data-ttu-id="09f45-3331">Non valide avec d’autres indicateurs d’appel.</span><span class="sxs-lookup"><span data-stu-id="09f45-3331">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="09f45-3332">`InvokeMethod` pour appeler une méthode, mais pas sur un constructeur ou un initialiseur de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3332">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="09f45-3333">Non valide avec `SetField` ou `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3333">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="09f45-3334">Si `InvokeMethod` est spécifié par lui-même, `BindingFlags.Public`, `BindingFlags.Instance`, et `BindingFlags.Static` sont automatiquement inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-3334">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="09f45-3335">`GetField` Pour obtenir la valeur d’un champ.</span><span class="sxs-lookup"><span data-stu-id="09f45-3335">`GetField` to get the value of a field.</span></span> <span data-ttu-id="09f45-3336">Non valide avec `SetField`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3336">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="09f45-3337">`SetField` Pour définir la valeur d’un champ.</span><span class="sxs-lookup"><span data-stu-id="09f45-3337">`SetField` to set the value of a field.</span></span> <span data-ttu-id="09f45-3338">Non valide avec `GetField`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3338">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="09f45-3339">`GetProperty` Pour obtenir une propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-3339">`GetProperty` to get a property.</span></span> <span data-ttu-id="09f45-3340">Non valide avec `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3340">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="09f45-3341">`SetProperty` Pour définir une propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-3341">`SetProperty` to set a property.</span></span> <span data-ttu-id="09f45-3342">Non valide avec `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3342">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="09f45-3343">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3343">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-3344">Une méthode est appelée si les deux conditions suivantes sont remplies :</span><span class="sxs-lookup"><span data-stu-id="09f45-3344">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="09f45-3345">Le nombre de paramètres dans la déclaration de méthode est égal au nombre d’arguments dans le `args` tableau (à moins que les arguments par défaut sont définis sur le membre et `BindingFlags.OptionalParamBinding` est spécifié).</span><span class="sxs-lookup"><span data-stu-id="09f45-3345">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="09f45-3346">Le type de chaque argument peut être converti par le binder pour le type du paramètre.</span><span class="sxs-lookup"><span data-stu-id="09f45-3346">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="09f45-3347">Le binder va trouver toutes les méthodes correspondantes.</span><span class="sxs-lookup"><span data-stu-id="09f45-3347">The binder will find all of the matching methods.</span></span> <span data-ttu-id="09f45-3348">Ces méthodes sont recherchées en fonction du type de liaison demandé (<xref:System.Reflection.BindingFlags> valeurs `InvokeMethod`, `GetProperty`, et ainsi de suite).</span><span class="sxs-lookup"><span data-stu-id="09f45-3348">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="09f45-3349">L’ensemble de méthodes est filtré par le nom, nombre d’arguments et un ensemble de modificateurs de recherche définis dans le classeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-3349">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="09f45-3350">Une fois que la méthode est sélectionnée, elle est appelée.</span><span class="sxs-lookup"><span data-stu-id="09f45-3350">After the method is selected, it is invoked.</span></span> <span data-ttu-id="09f45-3351">Accessibilité est vérifiée à ce stade.</span><span class="sxs-lookup"><span data-stu-id="09f45-3351">Accessibility is checked at that point.</span></span> <span data-ttu-id="09f45-3352">La recherche peut contrôler quel ensemble de méthodes est analysé en fonction de l’attribut d’accessibilité associé à la méthode.</span><span class="sxs-lookup"><span data-stu-id="09f45-3352">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="09f45-3353">Le <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> méthode de la <xref:System.Reflection.Binder> classe est chargée de sélectionner la méthode à appeler.</span><span class="sxs-lookup"><span data-stu-id="09f45-3353">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="09f45-3354">Le binder par défaut sélectionne la correspondance la plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3354">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="09f45-3355">Restrictions d’accès sont ignorées pour le code de confiance totale ; Autrement dit, les propriétés, méthodes, champs et constructeurs privés sont accessibles et peuvent être appelées par réflexion, chaque fois que le code est entièrement fiable.</span><span class="sxs-lookup"><span data-stu-id="09f45-3355">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="09f45-3356">Vous pouvez utiliser `Type.InvokeMember` pour définir un champ à une valeur particulière, en spécifiant <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3356">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09f45-3357">Par exemple, si vous souhaitez définir un champ d’instance public nommé F sur la classe C et F est un `String` vous pouvez utiliser le code :</span><span class="sxs-lookup"><span data-stu-id="09f45-3357">For example, if you want to set a public instance field named F on class C, and F is a `String` you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 <span data-ttu-id="09f45-3358">Si F est un `String[]`, vous pouvez utiliser le code :</span><span class="sxs-lookup"><span data-stu-id="09f45-3358">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 <span data-ttu-id="09f45-3359">ce qui initialisera le champ F à ce nouveau tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-3359">which will initialize the field F to this new array.</span></span> <span data-ttu-id="09f45-3360">Vous pouvez également utiliser `Type.InvokeMember` pour définir une position dans un tableau en fournissant l’index de la valeur, puis la valeur suivante en utilisant le code suivant :</span><span class="sxs-lookup"><span data-stu-id="09f45-3360">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 <span data-ttu-id="09f45-3361">Cela modifie la chaîne « z » dans le tableau F conserve la chaîne « b ».</span><span class="sxs-lookup"><span data-stu-id="09f45-3361">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="09f45-3362">Quand vous appelez un `IDispatch` membre que vous pouvez spécifier le DispID à la place du nom de membre en utilisant le format de chaîne « [DispID = ##] ».</span><span class="sxs-lookup"><span data-stu-id="09f45-3362">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="09f45-3363">Par exemple, si le DispID de MyComMethod est 3, vous pouvez spécifier la chaîne « [DispID = 3] » au lieu de « MyComMethod ».</span><span class="sxs-lookup"><span data-stu-id="09f45-3363">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="09f45-3364">L’appel d’un membre par DispID est plus rapide que la recherche d’un membre par nom.</span><span class="sxs-lookup"><span data-stu-id="09f45-3364">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="09f45-3365">Dans les scénarios d’agrégation complexes, le DispID est parfois la seule façon d’appeler le membre souhaité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3365">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-3366">En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des membres non publics est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son.</span><span class="sxs-lookup"><span data-stu-id="09f45-3366">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="09f45-3367">(Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="09f45-3367">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="09f45-3368">Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="09f45-3368">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-3369">
            <paramref name="invokeAttr" /> ne contient pas <see langword="CreateInstance" /> et <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3369">
              <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-3370">
            <paramref name="invokeAttr" /> n’est pas un attribut <see cref="T:System.Reflection.BindingFlags" /> valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3370">
              <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span>
          </span>
          <span data-ttu-id="09f45-3371">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3371">-or-</span>
          </span>
          <span data-ttu-id="09f45-3372">
            <paramref name="invokeAttr" /> ne contient pas l’un des indicateurs de liaison suivants : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3372">
              <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="09f45-3373">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3373">-or-</span>
          </span>
          <span data-ttu-id="09f45-3374">
            <paramref name="invokeAttr" /> contient <see langword="CreateInstance" /> combiné avec <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3374">
              <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="09f45-3375">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3375">-or-</span>
          </span>
          <span data-ttu-id="09f45-3376">
            <paramref name="invokeAttr" /> contient à la fois <see langword="GetField" /> et <see langword="SetField" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3376">
              <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span>
          </span>
          <span data-ttu-id="09f45-3377">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3377">-or-</span>
          </span>
          <span data-ttu-id="09f45-3378">
            <paramref name="invokeAttr" /> contient à la fois <see langword="GetProperty" /> et <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3378">
              <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="09f45-3379">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3379">-or-</span>
          </span>
          <span data-ttu-id="09f45-3380">
            <paramref name="invokeAttr" /> contient <see langword="InvokeMethod" /> combiné avec <see langword="SetField" /> ou <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3380">
              <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="09f45-3381">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3381">-or-</span>
          </span>
          <span data-ttu-id="09f45-3382">
            <paramref name="invokeAttr" /> contient <see langword="SetField" /> et <paramref name="args" /> a plusieurs éléments.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3382">
              <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span>
          </span>
          <span data-ttu-id="09f45-3383">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3383">-or-</span>
          </span>
          <span data-ttu-id="09f45-3384">Cette méthode est appelée sur un objet COM et l’un des indicateurs de liaisons suivants n’a pas été passé : <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> ou <see langword="BindingFlags.PutRefDispProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3384">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span>
          </span>
          <span data-ttu-id="09f45-3385">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3385">-or-</span>
          </span>
          <span data-ttu-id="09f45-3386">L’un des tableaux de paramètres nommés contient une chaîne qui est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3386">One of the named parameter arrays contains a string that is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="09f45-3387">Le membre spécifié est un initialiseur de classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3387">The specified member is a class initializer.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingFieldException">
          <span data-ttu-id="09f45-3388">Le champ ou la propriété est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3388">The field or property cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="09f45-3389">Aucune méthode ne peut être trouvée qui correspond aux arguments de <paramref name="args" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3389">No method can be found that matches the arguments in <paramref name="args" />.</span>
          </span>
          <span data-ttu-id="09f45-3390">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3390">-or-</span>
          </span>
          <span data-ttu-id="09f45-3391">L’objet <see cref="T:System.Type" /> actuel représente un type qui contient les paramètres de type ouverts, à savoir, <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3391">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="09f45-3392">Le membre spécifié ne peut pas être appelé sur <paramref name="target" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3392">The specified member cannot be invoked on <paramref name="target" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-3393">Plusieurs méthodes correspondent aux critères de liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3393">More than one method matches the binding criteria.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="09f45-3394">La méthode représentée par <paramref name="name" /> a un ou plusieurs paramètres de type générique non spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3394">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span>
          </span>
          <span data-ttu-id="09f45-3395">Autrement dit, la propriété <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> de la méthode retourne <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3395">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="09f45-3396">Pour accéder aux membres non publics, quelle que soit leur allocation définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3396">for accessing non-public members regardless of their grant set.</span>
          </span>
          <span data-ttu-id="09f45-3397">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3397">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="09f45-3398">appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3398">to call unmanaged code.</span>
          </span>
          <span data-ttu-id="09f45-3399">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3399">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="09f45-3400">Chaîne contenant le nom du membre de constructeur, de méthode, de propriété ou de champ à appeler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3400">The string containing the name of the constructor, method, property, or field member to invoke.</span>
          </span>
          <span data-ttu-id="09f45-3401">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3401">-or-</span>
          </span>
          <span data-ttu-id="09f45-3402">Une chaîne vide ("") pour appeler le membre par défaut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3402">An empty string ("") to invoke the default member.</span>
          </span>
          <span data-ttu-id="09f45-3403">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3403">-or-</span>
          </span>
          <span data-ttu-id="09f45-3404">Pour les membres <see langword="IDispatch" />, chaîne représentant le DispID, par exemple "[DispID=3]".</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3404">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="09f45-3405">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3405">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="09f45-3406">L'accès peut être fourni par l'un des <see langword="BindingFlags" />, par exemple <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3406">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span>
          </span>
          <span data-ttu-id="09f45-3407">Il n'est pas nécessaire de spécifier le type de recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3407">The type of lookup need not be specified.</span>
          </span>
          <span data-ttu-id="09f45-3408">Si le type de recherche est omis, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> sont utilisés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3408">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="09f45-3409">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3409">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="09f45-3410">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3410">-or-</span>
          </span>
          <span data-ttu-id="09f45-3411">Référence null (Nothing en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3411">A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
          <span data-ttu-id="09f45-3412">Notez que la définition explicite d'un objet <see cref="T:System.Reflection.Binder" /> peut être nécessaire pour appeler correctement des surcharges de méthode avec des arguments variables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3412">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="09f45-3413">Objet sur lequel appeler le membre spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3413">The object on which to invoke the specified member.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="09f45-3414">Tableau contenant les arguments à passer au membre à appeler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3414">An array containing the arguments to pass to the member to invoke.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="09f45-3415">Tableau d’objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l’élément correspondant dans le tableau <c>args</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3415">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>args</c> array.</span>
          </span>
          <span data-ttu-id="09f45-3416">Les attributs associés d'un paramètre sont stockés dans la signature du membre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3416">A parameter's associated attributes are stored in the member's signature.</span>
          </span>
          <span data-ttu-id="09f45-3417">Le binder par défaut traite ce paramètre uniquement au moment de l'appel d'un composant COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3417">The default binder processes this parameter only when calling a COM component.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="09f45-3418">Objet <see cref="T:System.Globalization.CultureInfo" /> représentant le paramètre régional de globalisation à utiliser si nécessaire, notamment pour les conversions spécifiques aux paramètres régionaux comme la conversion d'un type numérique String en type Double.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3418">The <see cref="T:System.Globalization.CultureInfo" /> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</span>
          </span>
          <span data-ttu-id="09f45-3419">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3419">-or-</span>
          </span>
          <span data-ttu-id="09f45-3420">Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3420">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span>
          </span>
        </param>
        <param name="namedParameters">
          <span data-ttu-id="09f45-3421">Tableau contenant les noms des paramètres auxquels les valeurs du tableau <c>args</c> sont passées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3421">An array containing the names of the parameters to which the values in the <c>args</c> array are passed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3422">En cas de substitution dans une classe dérivée, appelle le membre défini, à l'aide des contraintes de liaison spécifiées et correspondant à la liste d'arguments, aux modificateurs et à la culture spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3422">When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3423">Objet représentant la valeur de retour du membre appelé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3423">An object representing the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3424">`InvokeMember` appelle un membre de constructeur ou un membre de méthode, obtient ou définit une propriété de membre, obtient ou définit un membre de champ de données, ou obtient ou définit un élément d’un membre de tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-3424">`InvokeMember` calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-3425">Vous ne pouvez pas utiliser <xref:System.Type.InvokeMember%2A> pour appeler une méthode générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3425">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="09f45-3426">Quand vous appelez un `IDispatch` membre que vous pouvez spécifier le DispID à la place du nom de membre en utilisant le format de chaîne « [DispID = ##] ».</span><span class="sxs-lookup"><span data-stu-id="09f45-3426">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="09f45-3427">Par exemple, si le DispID de MyComMethod est 3, vous pouvez spécifier la chaîne « [DispID = 3] » au lieu de « MyComMethod ».</span><span class="sxs-lookup"><span data-stu-id="09f45-3427">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="09f45-3428">L’appel d’un membre par DispID est plus rapide que la recherche d’un membre par nom.</span><span class="sxs-lookup"><span data-stu-id="09f45-3428">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="09f45-3429">Dans les scénarios d’agrégation complexes, le DispID est parfois la seule façon d’appeler le membre souhaité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3429">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
 <span data-ttu-id="09f45-3430">Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> ou <xref:System.Globalization.CultureInfo> (le `modifiers` et `culture` paramètres), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers` et `culture`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3430">Although the default binder does not process <xref:System.Reflection.ParameterModifier> or <xref:System.Globalization.CultureInfo> (the `modifiers` and `culture` parameters), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers` and `culture`.</span></span> <span data-ttu-id="09f45-3431">`ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.</span><span class="sxs-lookup"><span data-stu-id="09f45-3431">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="09f45-3432">Chaque paramètre du tableau `namedParameters` obtient la valeur indiquée dans l'élément correspondant du tableau `args`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3432">Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array.</span></span> <span data-ttu-id="09f45-3433">Si la longueur de `args` est supérieure à la longueur de `namedParameters`, les valeurs d'arguments restantes sont passées dans l'ordre.</span><span class="sxs-lookup"><span data-stu-id="09f45-3433">If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order.</span></span>  
  
 <span data-ttu-id="09f45-3434">Le `namedParameters` tableau peut être utilisé pour modifier l’ordre des arguments dans un tableau d’entrée.</span><span class="sxs-lookup"><span data-stu-id="09f45-3434">The `namedParameters` array can be used to change the order of arguments in an input array.</span></span> <span data-ttu-id="09f45-3435">Par exemple, étant donné la méthode `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` en Visual Basic) et le tableau d’entrée `{ 42, "x" }`, le tableau d’entrée peut être passé sans modification à `args` si le tableau `{ "b", "a" }` est fourni pour `namedParameters`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3435">For example, given the method `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) and the input array `{ 42, "x" }`, the input array can be passed unchanged to `args` if the array `{ "b", "a" }` is supplied for `namedParameters`.</span></span>  
  
 <span data-ttu-id="09f45-3436">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-3436">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="09f45-3437">Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-3437">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="09f45-3438">Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="09f45-3438">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="09f45-3439">Spécifiez `BindingFlags.FlattenHierarchy` pour inclure les membres statiques dans la hiérarchie.</span><span class="sxs-lookup"><span data-stu-id="09f45-3439">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="09f45-3440">Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :</span><span class="sxs-lookup"><span data-stu-id="09f45-3440">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="09f45-3441">`BindingFlags.IgnoreCase` pour ignorer la casse de `name`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3441">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="09f45-3442">`BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.</span><span class="sxs-lookup"><span data-stu-id="09f45-3442">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="09f45-3443">Les éléments suivants <xref:System.Reflection.BindingFlags> indicateurs d’appel peuvent être utilisés pour désigner l’action à effectuer sur le membre :</span><span class="sxs-lookup"><span data-stu-id="09f45-3443">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="09f45-3444">`CreateInstance` pour appeler un constructeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-3444">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="09f45-3445">`name` est ignoré.</span><span class="sxs-lookup"><span data-stu-id="09f45-3445">`name` is ignored.</span></span> <span data-ttu-id="09f45-3446">Non valide avec d’autres indicateurs d’appel.</span><span class="sxs-lookup"><span data-stu-id="09f45-3446">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="09f45-3447">`InvokeMethod` pour appeler une méthode, mais pas sur un constructeur ou un initialiseur de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3447">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="09f45-3448">Non valide avec `SetField` ou `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3448">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="09f45-3449">Si `InvokeMethod` est spécifié par lui-même, `BindingFlags.Public`, `BindingFlags.Instance`, et `BindingFlags.Static` sont automatiquement inclus.</span><span class="sxs-lookup"><span data-stu-id="09f45-3449">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="09f45-3450">`GetField` Pour obtenir la valeur d’un champ.</span><span class="sxs-lookup"><span data-stu-id="09f45-3450">`GetField` to get the value of a field.</span></span> <span data-ttu-id="09f45-3451">Non valide avec `SetField`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3451">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="09f45-3452">`SetField` Pour définir la valeur d’un champ.</span><span class="sxs-lookup"><span data-stu-id="09f45-3452">`SetField` to set the value of a field.</span></span> <span data-ttu-id="09f45-3453">Non valide avec `GetField`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3453">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="09f45-3454">`GetProperty` Pour obtenir une propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-3454">`GetProperty` to get a property.</span></span> <span data-ttu-id="09f45-3455">Non valide avec `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3455">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="09f45-3456">`SetProperty` Pour définir une propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-3456">`SetProperty` to set a property.</span></span> <span data-ttu-id="09f45-3457">Non valide avec `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3457">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="09f45-3458">Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3458">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="09f45-3459">Une méthode est appelée si les deux conditions suivantes sont remplies :</span><span class="sxs-lookup"><span data-stu-id="09f45-3459">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="09f45-3460">Le nombre de paramètres dans la déclaration de méthode est égal au nombre d’arguments dans le `args` tableau (à moins que les arguments par défaut sont définis sur le membre et `BindingFlags.OptionalParamBinding` est spécifié).</span><span class="sxs-lookup"><span data-stu-id="09f45-3460">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="09f45-3461">Le type de chaque argument peut être converti par le binder pour le type du paramètre.</span><span class="sxs-lookup"><span data-stu-id="09f45-3461">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="09f45-3462">Le binder va trouver toutes les méthodes correspondantes.</span><span class="sxs-lookup"><span data-stu-id="09f45-3462">The binder will find all of the matching methods.</span></span> <span data-ttu-id="09f45-3463">Ces méthodes sont recherchées en fonction du type de liaison demandé (<xref:System.Reflection.BindingFlags> valeurs `InvokeMethod`, `GetProperty`, et ainsi de suite).</span><span class="sxs-lookup"><span data-stu-id="09f45-3463">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="09f45-3464">L’ensemble de méthodes est filtré par le nom, nombre d’arguments et un ensemble de modificateurs de recherche définis dans le classeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-3464">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="09f45-3465">Une fois que la méthode est sélectionnée, elle est appelée.</span><span class="sxs-lookup"><span data-stu-id="09f45-3465">After the method is selected, it is invoked.</span></span> <span data-ttu-id="09f45-3466">Accessibilité est vérifiée à ce stade.</span><span class="sxs-lookup"><span data-stu-id="09f45-3466">Accessibility is checked at that point.</span></span> <span data-ttu-id="09f45-3467">La recherche peut contrôler quel ensemble de méthodes est analysé en fonction de l’attribut d’accessibilité associé à la méthode.</span><span class="sxs-lookup"><span data-stu-id="09f45-3467">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="09f45-3468">Le <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> méthode de la <xref:System.Reflection.Binder> classe est chargée de sélectionner la méthode à appeler.</span><span class="sxs-lookup"><span data-stu-id="09f45-3468">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="09f45-3469">Le binder par défaut sélectionne la correspondance la plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3469">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="09f45-3470">`InvokeMember` peut être utilisé pour appeler des méthodes avec des paramètres qui ont des valeurs par défaut.</span><span class="sxs-lookup"><span data-stu-id="09f45-3470">`InvokeMember` can be used to invoke methods with parameters that have default values.</span></span> <span data-ttu-id="09f45-3471">Pour lier ces méthodes, Reflection requiert <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> être spécifié.</span><span class="sxs-lookup"><span data-stu-id="09f45-3471">To bind to these methods, Reflection requires <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> to be specified.</span></span> <span data-ttu-id="09f45-3472">Pour un paramètre qui a une valeur par défaut, vous pouvez fournir une valeur différente, ou fournir <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> pour utiliser la valeur par défaut.</span><span class="sxs-lookup"><span data-stu-id="09f45-3472">For a parameter that has a default value, you can either supply a different value, or supply <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> to use the default value.</span></span>  
  
 <span data-ttu-id="09f45-3473">Par exemple, considérez une méthode telle que MyMethod (int x, float y = 2.0).</span><span class="sxs-lookup"><span data-stu-id="09f45-3473">For example, consider a method such as MyMethod(int x, float y = 2.0).</span></span> <span data-ttu-id="09f45-3474">Pour appeler cette méthode avec uniquement le premier argument en tant que MyMethod (4), passez un des indicateurs de liaisons ci-dessus, puis passez deux arguments, à savoir 4 pour le premier argument et `Missing.Value` pour le deuxième argument.</span><span class="sxs-lookup"><span data-stu-id="09f45-3474">To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and `Missing.Value` for the second argument.</span></span> <span data-ttu-id="09f45-3475">Sauf si vous utilisez `Missing.Value`, vous ne pouvez pas omettre les paramètres facultatifs avec le `Invoke` (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3475">Unless you use `Missing.Value`, you may not omit optional parameters with the `Invoke` method.</span></span> <span data-ttu-id="09f45-3476">Si vous devez le faire, utilisez `InvokeMember` à la place.</span><span class="sxs-lookup"><span data-stu-id="09f45-3476">If you must do so, use `InvokeMember` instead.</span></span>  
  
 <span data-ttu-id="09f45-3477">Restrictions d’accès sont ignorées pour le code de confiance totale ; Autrement dit, propriétés, méthodes, champs et constructeurs privés peuvent être accessibles et appelées par la <xref:System.Reflection> chaque fois que le code est entièrement fiable.</span><span class="sxs-lookup"><span data-stu-id="09f45-3477">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="09f45-3478">Vous pouvez utiliser `Type.InvokeMember` pour définir un champ à une valeur particulière, en spécifiant <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3478">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09f45-3479">Par exemple, si vous souhaitez définir un champ d’instance public nommé F sur la classe C et F est un `String`, vous pouvez utiliser le code :</span><span class="sxs-lookup"><span data-stu-id="09f45-3479">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 <span data-ttu-id="09f45-3480">Si F est un `String[]`, vous pouvez utiliser le code :</span><span class="sxs-lookup"><span data-stu-id="09f45-3480">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 <span data-ttu-id="09f45-3481">ce qui initialisera le champ F à ce nouveau tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-3481">which will initialize the field F to this new array.</span></span> <span data-ttu-id="09f45-3482">Vous pouvez également utiliser `Type.InvokeMember` pour définir une position dans un tableau en fournissant l’index de la valeur, puis la valeur suivante en utilisant le code suivant :</span><span class="sxs-lookup"><span data-stu-id="09f45-3482">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 <span data-ttu-id="09f45-3483">Cela modifie la chaîne « z » dans le tableau F conserve la chaîne « b ».</span><span class="sxs-lookup"><span data-stu-id="09f45-3483">This will change string "z" in the array that F holds to string "b".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-3484">En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des membres non publics est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son.</span><span class="sxs-lookup"><span data-stu-id="09f45-3484">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="09f45-3485">(Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="09f45-3485">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="09f45-3486">Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="09f45-3486">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-3487">
            <paramref name="invokeAttr" /> ne contient pas <see langword="CreateInstance" /> et <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3487">
              <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-3488">
            <paramref name="args" /> et <paramref name="modifiers" /> n’ont pas la même longueur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3488">
              <paramref name="args" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
          <span data-ttu-id="09f45-3489">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3489">-or-</span>
          </span>
          <span data-ttu-id="09f45-3490">
            <paramref name="invokeAttr" /> n’est pas un attribut <see cref="T:System.Reflection.BindingFlags" /> valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3490">
              <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span>
          </span>
          <span data-ttu-id="09f45-3491">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3491">-or-</span>
          </span>
          <span data-ttu-id="09f45-3492">
            <paramref name="invokeAttr" /> ne contient pas l’un des indicateurs de liaison suivants : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3492">
              <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="09f45-3493">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3493">-or-</span>
          </span>
          <span data-ttu-id="09f45-3494">
            <paramref name="invokeAttr" /> contient <see langword="CreateInstance" /> combiné avec <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3494">
              <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="09f45-3495">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3495">-or-</span>
          </span>
          <span data-ttu-id="09f45-3496">
            <paramref name="invokeAttr" /> contient à la fois <see langword="GetField" /> et <see langword="SetField" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3496">
              <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span>
          </span>
          <span data-ttu-id="09f45-3497">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3497">-or-</span>
          </span>
          <span data-ttu-id="09f45-3498">
            <paramref name="invokeAttr" /> contient à la fois <see langword="GetProperty" /> et <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3498">
              <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="09f45-3499">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3499">-or-</span>
          </span>
          <span data-ttu-id="09f45-3500">
            <paramref name="invokeAttr" /> contient <see langword="InvokeMethod" /> combiné avec <see langword="SetField" /> ou <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3500">
              <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="09f45-3501">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3501">-or-</span>
          </span>
          <span data-ttu-id="09f45-3502">
            <paramref name="invokeAttr" /> contient <see langword="SetField" /> et <paramref name="args" /> a plusieurs éléments.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3502">
              <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span>
          </span>
          <span data-ttu-id="09f45-3503">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3503">-or-</span>
          </span>
          <span data-ttu-id="09f45-3504">Le tableau de paramètres nommé est supérieur à un tableau d’arguments.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3504">The named parameter array is larger than the argument array.</span>
          </span>
          <span data-ttu-id="09f45-3505">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3505">-or-</span>
          </span>
          <span data-ttu-id="09f45-3506">Cette méthode est appelée sur un objet COM et l’un des indicateurs de liaisons suivants n’a pas été passé : <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> ou <see langword="BindingFlags.PutRefDispProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3506">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span>
          </span>
          <span data-ttu-id="09f45-3507">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3507">-or-</span>
          </span>
          <span data-ttu-id="09f45-3508">L’un des tableaux de paramètres nommés contient une chaîne qui est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3508">One of the named parameter arrays contains a string that is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="09f45-3509">Le membre spécifié est un initialiseur de classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3509">The specified member is a class initializer.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingFieldException">
          <span data-ttu-id="09f45-3510">Le champ ou la propriété est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3510">The field or property cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="09f45-3511">Aucune méthode ne peut être trouvée qui correspond aux arguments de <paramref name="args" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3511">No method can be found that matches the arguments in <paramref name="args" />.</span>
          </span>
          <span data-ttu-id="09f45-3512">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3512">-or-</span>
          </span>
          <span data-ttu-id="09f45-3513">Aucun membre ne peut être trouvé avec les noms des arguments fournis dans <paramref name="namedParameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3513">No member can be found that has the argument names supplied in <paramref name="namedParameters" />.</span>
          </span>
          <span data-ttu-id="09f45-3514">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3514">-or-</span>
          </span>
          <span data-ttu-id="09f45-3515">L’objet <see cref="T:System.Type" /> actuel représente un type qui contient les paramètres de type ouverts, à savoir, <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3515">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="09f45-3516">Le membre spécifié ne peut pas être appelé sur <paramref name="target" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3516">The specified member cannot be invoked on <paramref name="target" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="09f45-3517">Plusieurs méthodes correspondent aux critères de liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3517">More than one method matches the binding criteria.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="09f45-3518">La méthode représentée par <paramref name="name" /> a un ou plusieurs paramètres de type générique non spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3518">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span>
          </span>
          <span data-ttu-id="09f45-3519">Autrement dit, la propriété <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> de la méthode retourne <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3519">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="09f45-3520">Pour accéder aux membres non publics, quelle que soit leur allocation définie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3520">for accessing non-public members regardless of their grant set.</span>
          </span>
          <span data-ttu-id="09f45-3521">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3521">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="09f45-3522">appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3522">to call unmanaged code.</span>
          </span>
          <span data-ttu-id="09f45-3523">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3523">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3524">Obtient une valeur indiquant si le <see cref="T:System.Type" /> est abstrait et doit être substitué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3524">Gets a value indicating whether the <see cref="T:System.Type" /> is abstract and must be overridden.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3525">
            <see langword="true" /> si le <see cref="T:System.Type" /> est abstrait ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3525">
              <see langword="true" /> if the <see cref="T:System.Type" /> is abstract; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3526">Le <xref:System.Type.IsAbstract%2A> propriété renvoie `true` dans les cas suivants :</span><span class="sxs-lookup"><span data-stu-id="09f45-3526">The <xref:System.Type.IsAbstract%2A> property returns `true` in the following cases:</span></span>  
  
-   <span data-ttu-id="09f45-3527">Le type actuel est abstrait ; Autrement dit, il ne peut pas être instanciée, mais peut servir uniquement à la classe de base pour les classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="09f45-3527">The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</span></span> <span data-ttu-id="09f45-3528">En c#, classes abstraites sont marquées avec le [abstraite](~/docs/csharp/language-reference/keywords/abstract.md) (mot clé) ; en Visual Basic, elles sont marquées avec le [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) (mot clé).</span><span class="sxs-lookup"><span data-stu-id="09f45-3528">In C#, abstract classes are marked with the [abstract](~/docs/csharp/language-reference/keywords/abstract.md) keyword; in Visual Basic, they are marked with the [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) keyword.</span></span>  
  
-   <span data-ttu-id="09f45-3529">Le type actuel est une interface.</span><span class="sxs-lookup"><span data-stu-id="09f45-3529">The current type is an interface.</span></span>  
  
 <span data-ttu-id="09f45-3530">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3530">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3531">L’exemple suivant crée un tableau de <xref:System.Type> objets qui représentent les types suivants : contient des retours de type `true` si l’objet spécifié est `abstract`; sinon, elle retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3531">The following example creates an array of <xref:System.Type> objects that represent the following types:contains type returns `true` if the specified object is `abstract`; otherwise, it returns `false`.</span></span>  
  
-   <span data-ttu-id="09f45-3532">`AbstractClass`, une classe abstraite (une classe marquée en tant que `abstract` en c# et `MustInherit` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-3532">`AbstractClass`, an abstract class (a class marked as `abstract` in C# and `MustInherit` in Visual Basic).</span></span>  
  
-   <span data-ttu-id="09f45-3533">`DerivedClass`, une classe qui hérite de `AbstractClass`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3533">`DerivedClass`, a class that inherits from `AbstractClass`.</span></span>  
  
-   <span data-ttu-id="09f45-3534">`SingleClass`, une classe non héritable.</span><span class="sxs-lookup"><span data-stu-id="09f45-3534">`SingleClass`, a non-inheritable class.</span></span> <span data-ttu-id="09f45-3535">Il est défini en tant que `sealed` en c# et `NotInheritable` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="09f45-3535">It is defined as `sealed` in C# and `NotInheritable` in Visual Basic.</span></span>  
  
-   <span data-ttu-id="09f45-3536">`ITypeInfo`, une interface.</span><span class="sxs-lookup"><span data-stu-id="09f45-3536">`ITypeInfo`, an interface.</span></span>  
  
-   <span data-ttu-id="09f45-3537">`ImplementingClass`, une classe qui implémente le `ITypeInfo` interface.</span><span class="sxs-lookup"><span data-stu-id="09f45-3537">`ImplementingClass`, a class that implements the `ITypeInfo` interface.</span></span>  
  
 <span data-ttu-id="09f45-3538">La méthode retourne `true` uniquement pour `AbstractClass`, la classe abstraite, et `ITypeInfo`, l’interface.</span><span class="sxs-lookup"><span data-stu-id="09f45-3538">The method returns `true` only for `AbstractClass`, the abstract class, and `ITypeInfo`, the interface.</span></span>  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3539">Obtient une valeur indiquant si l'attribut de format de chaîne <see langword="AnsiClass" /> est sélectionné pour <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3539">Gets a value indicating whether the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3540">
            <see langword="true" /> si l'attribut de format de chaîne <see langword="AnsiClass" /> est sélectionné pour le <see cref="T:System.Type" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3540">
              <see langword="true" /> if the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3541">Le <xref:System.Reflection.TypeAttributes.StringFormatMask> sélectionne les attributs de format de chaîne.</span><span class="sxs-lookup"><span data-stu-id="09f45-3541">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="09f45-3542">Les attributs de format de chaîne améliorent l’interopérabilité en définissant la manière dont les chaînes doivent être interprétées.</span><span class="sxs-lookup"><span data-stu-id="09f45-3542">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="09f45-3543">Si le courant <xref:System.Type> représente un type générique, cette propriété se rapporte à la définition de type générique à partir de laquelle le type a été construit.</span><span class="sxs-lookup"><span data-stu-id="09f45-3543">If the current <xref:System.Type> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="09f45-3544">Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3544">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="09f45-3545">Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3545">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3546">L’exemple suivant obtient les informations de champ et vérifie le `AnsiClass` attribut.</span><span class="sxs-lookup"><span data-stu-id="09f45-3546">The following example gets the field information and checks for the `AnsiClass` attribute.</span></span>  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3547">Obtient une valeur qui indique si le type est un tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3547">Gets a value that indicates whether the type is an array.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3548">
            <see langword="true" /> si le type actuel est un tableau ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3548">
              <see langword="true" /> if the current type is an array; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3549">Le <xref:System.Type.IsArray%2A> propriété renvoie `false` pour la <xref:System.Array> classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-3549">The <xref:System.Type.IsArray%2A> property returns `false` for the <xref:System.Array> class.</span></span> <span data-ttu-id="09f45-3550">Il renvoie également `false` si l’instance actuelle est un <xref:System.Type> objet qui représente un type de collection ou d’une interface conçue pour fonctionner avec les collections, telles que <xref:System.Collections.IEnumerable> ou <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3550">It also returns `false` if the current instance is a <xref:System.Type> object that represents a collection type or an interface designed to work with collections, such as <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="09f45-3551">Pour vérifier si un tableau, utilisez le code tel que :</span><span class="sxs-lookup"><span data-stu-id="09f45-3551">To check for an array, use code such as:</span></span>  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 <span data-ttu-id="09f45-3552">Si le type actuel représente un type générique ou un paramètre de type dans la définition d’un type générique ou de méthode générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3552">If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="09f45-3553">Cette propriété est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="09f45-3553">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3554">L’exemple suivant montre comment utiliser le <xref:System.Type.IsArray%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-3554">The following example demonstrates using the <xref:System.Type.IsArray%2A> property.</span></span>  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3555">En cas de substitution dans une classe dérivée, implémente la propriété <see cref="P:System.Type.IsArray" /> et détermine si <see cref="T:System.Type" /> est un tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3555">When overridden in a derived class, implements the <see cref="P:System.Type.IsArray" /> property and determines whether the <see cref="T:System.Type" /> is an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3556">
            <see langword="true" /> si <see cref="T:System.Type" /> est un tableau ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3556">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3557">Une instance de la <xref:System.Array> classe doit retourner `false` , car il s’agit d’un objet, pas un tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-3557">An instance of the <xref:System.Array> class must return `false` because it is an object, not an array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3558">L’exemple suivant substitue la `IsArrayImpl` méthode dans la `MyTypeDelegator` classe, vérifie si une variable est un tableau et affiche le résultat.</span><span class="sxs-lookup"><span data-stu-id="09f45-3558">The following example overrides the `IsArrayImpl` method in the `MyTypeDelegator` class, checks if a variable is an array, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="09f45-3559">Type à comparer avec le type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3559">The type to compare with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3560">Détermine si une instance d’un type spécifié peut être affectée à une instance du type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3560">Determines whether an instance of a specified type can be assigned to an instance of the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3561">
            <see langword="true" /> si l'une ou plusieurs des conditions suivantes sont remplies :</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3561">
              <see langword="true" /> if any of the following conditions is true:</span>
          </span>  
  
-   <span data-ttu-id="09f45-3562"><paramref name="c" /> et l'instance actuelle représentent le même type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3562"><paramref name="c" /> and the current instance represent the same type.</span></span>  
  
-   <span data-ttu-id="09f45-3563"><paramref name="c" /> est dérivé directement ou indirectement de l'instance actuelle.</span><span class="sxs-lookup"><span data-stu-id="09f45-3563"><paramref name="c" /> is derived either directly or indirectly from the current instance.</span></span><span data-ttu-id="09f45-3564"><paramref name="c" /> est dérivé directement de l’instance actuelle s’il hérite de l’instance actuelle ; <paramref name="c" /> est dérivé indirectement de l’instance actuelle s’il hérite d’une succession d’une ou plusieurs classes qui héritent de l’instance actuelle.</span><span class="sxs-lookup"><span data-stu-id="09f45-3564"><paramref name="c" /> is derived directly from the current instance if it inherits from the current instance; <paramref name="c" /> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</span></span>  
  
-   <span data-ttu-id="09f45-3565">L'instance actuelle est une interface implémentée par <paramref name="c" />.</span><span class="sxs-lookup"><span data-stu-id="09f45-3565">The current instance is an interface that <paramref name="c" /> implements.</span></span>  
  
-   <span data-ttu-id="09f45-3566"><paramref name="c" /> est un paramètre de type générique et l'instance actuelle représente l'une des contraintes de <paramref name="c" />.</span><span class="sxs-lookup"><span data-stu-id="09f45-3566"><paramref name="c" /> is a generic type parameter, and the current instance represents one of the constraints of <paramref name="c" />.</span></span><span data-ttu-id="09f45-3567">Dans l’exemple suivant, l’instance actuelle est un objet <see cref="T:System.Type" /> qui représente la classe <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="09f45-3567">In the following example, the current instance is a <see cref="T:System.Type" /> object that represents the <see cref="T:System.IO.Stream" /> class.</span></span><span data-ttu-id="09f45-3568"><c>GenericWithConstraint</c> est un type générique dont le paramètre de type générique doit être de type <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="09f45-3568"><c>GenericWithConstraint</c> is a generic type whose generic type parameter must be of type    <see cref="T:System.IO.Stream" />.</span></span><span data-ttu-id="09f45-3569">Le fait de passer son paramètre de type générique à <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indique qu’une instance du paramètre de type générique peut être affectée à un objet <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="09f45-3569">Passing its generic type parameter to the <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indicates that  an instance of the generic type parameter can be assigned to an <see cref="T:System.IO.Stream" /> object.</span></span>  
  
     [!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]
     [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  
  
-   <span data-ttu-id="09f45-3570"><paramref name="c" /> représente un type valeur et l’instance actuelle représente <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-3570"><paramref name="c" /> represents a value type, and the current instance represents <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic).</span></span><span data-ttu-id="09f45-3571"><see langword="false" /> si aucune de ces conditions n'a la valeur true, ou si <paramref name="c" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="09f45-3571"><see langword="false" /> if none of these conditions are true, or if <paramref name="c" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3572">Le <xref:System.Type.IsAssignableFrom%2A> méthode peut être utilisée pour déterminer si une instance de `c` peut être affectée à une instance du type actuel, la méthode est particulièrement utile lorsque vous gérez les objets dont les types ne sont pas connus au moment du design et permet de conditionnelle l’attribution, comme l’exemple suivant s’affiche.</span><span class="sxs-lookup"><span data-stu-id="09f45-3572">The <xref:System.Type.IsAssignableFrom%2A> method can be used to determine whether an instance of `c` can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 <span data-ttu-id="09f45-3573">Cette méthode qui garantit ainsi une ligne de code comme celui-ci s’exécute lors de l’exécution sans lever une <xref:System.InvalidCastException> exception ou une exception semblable :</span><span class="sxs-lookup"><span data-stu-id="09f45-3573">This method thus ensures that a line of code like the following will execute at runtime without throwing an <xref:System.InvalidCastException> exception or a similar exception:</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 <span data-ttu-id="09f45-3574">Cette méthode peut être substituée par une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="09f45-3574">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-3575">Une définition de type générique n’est pas attribuable à partir d’un type construit fermé.</span><span class="sxs-lookup"><span data-stu-id="09f45-3575">A generic type definition is not assignable from a closed constructed type.</span></span> <span data-ttu-id="09f45-3576">Autrement dit, vous ne pouvez pas affecter le type construit fermé `MyGenericList<int>` (`MyGenericList(Of Integer)` en Visual Basic) à une variable de type `MyGenericList<T>`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3576">That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`.</span></span>  
  
 <span data-ttu-id="09f45-3577">Si le `c` paramètre est de type <xref:System.Reflection.Emit.TypeBuilder>, le résultat est basé sur le type doit être créé.</span><span class="sxs-lookup"><span data-stu-id="09f45-3577">If the `c` parameter is of type <xref:System.Reflection.Emit.TypeBuilder>, the result is based on the type that is to be built.</span></span> <span data-ttu-id="09f45-3578">L’exemple de code suivant illustre cela : à l’aide d’un type construit nommé `B`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3578">The following code example demonstrates this using a built type named `B`.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3579">L’exemple suivant illustre la `IsAssignableFrom` à l’aide de la méthode définie par les classes, des tableaux d’entiers et des génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-3579">The following example demonstrates the `IsAssignableFrom` method using defined classes, integer arrays, and generics.</span></span>  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3580">Obtient une valeur indiquant si l'attribut de format de chaîne <see langword="AutoClass" /> est sélectionné pour <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3580">Gets a value indicating whether the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3581">
            <see langword="true" /> si l'attribut de format de chaîne <see langword="AutoClass" /> est sélectionné pour le <see cref="T:System.Type" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3581">
              <see langword="true" /> if the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3582">Le <xref:System.Reflection.TypeAttributes.StringFormatMask> sélectionne les attributs de format de chaîne.</span><span class="sxs-lookup"><span data-stu-id="09f45-3582">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="09f45-3583">Les attributs de format de chaîne améliorent l’interopérabilité en définissant la manière dont les chaînes doivent être interprétées.</span><span class="sxs-lookup"><span data-stu-id="09f45-3583">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="09f45-3584">Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit.</span><span class="sxs-lookup"><span data-stu-id="09f45-3584">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="09f45-3585">Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3585">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="09f45-3586">Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3586">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3587">Obtient une valeur qui indique si les champs du type actuel sont placés automatiquement par le Common Language Runtime.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3587">Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3588">
            <see langword="true" /> si la propriété <see cref="P:System.Type.Attributes" /> du type actuel comprend <see cref="F:System.Reflection.TypeAttributes.AutoLayout" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3588">
              <see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3589">Cette propriété est fournie pour des raisons pratiques.</span><span class="sxs-lookup"><span data-stu-id="09f45-3589">This property is provided as a convenience.</span></span> <span data-ttu-id="09f45-3590">Vous pouvez également utiliser le <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valeur d’énumération pour sélectionner les attributs de mise en page de type, puis effectuer des tests de si <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> est défini.</span><span class="sxs-lookup"><span data-stu-id="09f45-3590">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="09f45-3591">Le <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, et <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valeurs d’énumération indiquent la façon des champs du type sont disposés en mémoire.</span><span class="sxs-lookup"><span data-stu-id="09f45-3591">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="09f45-3592">Pour les types dynamiques, vous pouvez spécifier <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> lorsque vous créez le type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3592">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="09f45-3593">Dans le code, vous devez appliquer le <xref:System.Runtime.InteropServices.StructLayoutAttribute> d’attribut avec le <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> valeur d’énumération pour le type, pour permettre au runtime de déterminer la méthode appropriée pour disposer de la classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-3593">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-3594">Vous ne pouvez pas utiliser le <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> méthode pour déterminer si le <xref:System.Runtime.InteropServices.StructLayoutAttribute> a été appliqué à un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3594">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="09f45-3595">Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit.</span><span class="sxs-lookup"><span data-stu-id="09f45-3595">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="09f45-3596">Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="09f45-3596">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="09f45-3597">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3597">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3598">L’exemple suivant crée une instance du type et affiche le <xref:System.Type.IsAutoLayout%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-3598">The following example creates an instance of the type and displays the <xref:System.Type.IsAutoLayout%2A> property.</span></span>  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3599">Obtient une valeur indiquant si <see cref="T:System.Type" /> est passé par référence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3599">Gets a value indicating whether the <see cref="T:System.Type" /> is passed by reference.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3600">
            <see langword="true" /> si <see cref="T:System.Type" /> est passé par référence ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3600">
              <see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3601">Pour obtenir le type réel, supprimez la référence le type a été passé par référence, puis appelez <xref:System.Type.GetElementType%2A> sur ce type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3601">To get to the actual type, dereference the type that was passed by reference, and then call <xref:System.Type.GetElementType%2A> on that type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3602">L’exemple suivant illustre une utilisation de la `IsByRef` propriété pour vérifier si un type spécifié est passé par référence.</span><span class="sxs-lookup"><span data-stu-id="09f45-3602">The following example demonstrates a use of the `IsByRef` property to check whether a specified type is passed by reference.</span></span> <span data-ttu-id="09f45-3603">L’exemple définit la classe `MyTypeDelegator`, qui remplace le `HasElementTypeImpl` (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3603">The example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="09f45-3604">La classe principale vérifie la `HasElementType` propriété et affiche le type d’élément.</span><span class="sxs-lookup"><span data-stu-id="09f45-3604">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3605">En cas de substitution dans une classe dérivée, implémente la propriété <see cref="P:System.Type.IsByRef" /> et détermine si le <see cref="T:System.Type" /> est passé par référence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3605">When overridden in a derived class, implements the <see cref="P:System.Type.IsByRef" /> property and determines whether the <see cref="T:System.Type" /> is passed by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3606">
            <see langword="true" /> si <see cref="T:System.Type" /> est passé par référence ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3606">
              <see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3607">Obtient une valeur indiquant si le <see cref="T:System.Type" /> est une classe ou un délégué, c'est-à-dire ni un type valeur ni une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3607">Gets a value indicating whether the <see cref="T:System.Type" /> is a class or a delegate; that is, not a value type or interface.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3608">
            <see langword="true" /> si <see cref="T:System.Type" /> est une classe ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3608">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a class; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3609">Cette propriété retourne `true` pour les classes, ainsi que les délégués.</span><span class="sxs-lookup"><span data-stu-id="09f45-3609">This property returns `true` for classes as well as delegates.</span></span> <span data-ttu-id="09f45-3610">Elle retourne `false` pour les types valeur (pour les structures et les énumérations) même si elles sont boxed.</span><span class="sxs-lookup"><span data-stu-id="09f45-3610">It returns `false` for value types (for structures and enumerations) even if they are boxed.</span></span>  
  
 <span data-ttu-id="09f45-3611">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `true`. Si le courant <xref:System.Type> représente un type générique construit, cette propriété retourne `true` si la définition de type générique est une définition de classe ; autrement dit, il ne définit pas une interface ou un type valeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-3611">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `true`.If the current <xref:System.Type> represents a constructed generic type, this property returns `true` if the generic type definition is a class definition; that is, it does not define an interface or a value type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-3612">Cette propriété retourne `true` pour `Type` instances qui représentent le <xref:System.Enum> et <xref:System.ValueType> classes.</span><span class="sxs-lookup"><span data-stu-id="09f45-3612">This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes.</span></span> <span data-ttu-id="09f45-3613">Ces deux classes sont les types de base pour les énumérations et les types valeur, respectivement, mais ils ne sont pas des énumérations ou des types valeur eux-mêmes.</span><span class="sxs-lookup"><span data-stu-id="09f45-3613">These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</span></span> <span data-ttu-id="09f45-3614">Pour plus d’informations, consultez la <xref:System.Type.IsValueType%2A> et <xref:System.Type.IsEnum%2A> propriétés.</span><span class="sxs-lookup"><span data-stu-id="09f45-3614">For more information, see the <xref:System.Type.IsValueType%2A> and <xref:System.Type.IsEnum%2A> properties.</span></span>  
  
 <span data-ttu-id="09f45-3615">Le <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valeur d’énumération distingue une déclaration de type en tant que classe ou interface. Toutefois, les classes et les types valeur sont marqués avec le <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attribut.</span><span class="sxs-lookup"><span data-stu-id="09f45-3615">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="09f45-3616">Si vous récupérez la valeur de propriété des attributs et l’utilisation d’un type la <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valeur pour déterminer si un type est une classe au lieu d’un type valeur, vous devez également appeler le <xref:System.Type.IsValueType%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-3616">If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property.</span></span> <span data-ttu-id="09f45-3617">L’exemple de la <xref:System.Reflection.TypeAttributes> énumération contient des informations supplémentaires ainsi qu’Unexemple.</span><span class="sxs-lookup"><span data-stu-id="09f45-3617">The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample.</span></span>  
  
 <span data-ttu-id="09f45-3618">Cette propriété est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="09f45-3618">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3619">L’exemple suivant crée une instance d’un type et indique si le type est une classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-3619">The following example creates an instance of a type and indicates whether the type is a class.</span></span>  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3620">Obtient une valeur indiquant si <see cref="T:System.Type" /> est un objet COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3620">Gets a value indicating whether the <see cref="T:System.Type" /> is a COM object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3621">
            <see langword="true" /> si <see cref="T:System.Type" /> est un objet COM ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3621">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3622">Cette méthode retourne `false` pour les interfaces COM, car ils ne sont pas des objets.</span><span class="sxs-lookup"><span data-stu-id="09f45-3622">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="09f45-3623">Interfaces COM peuvent être implémentées par des objets Microsoft .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="09f45-3623">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 <span data-ttu-id="09f45-3624">Vous pouvez également charger une classe COM et obtenir un `Type` objet pour cette classe COM à l’aide de la [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) outil.</span><span class="sxs-lookup"><span data-stu-id="09f45-3624">You can also load a COM class and get a `Type` object for that COM class by using the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.</span></span>  
  
 <span data-ttu-id="09f45-3625">Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit.</span><span class="sxs-lookup"><span data-stu-id="09f45-3625">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="09f45-3626">Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int`> (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3626">For example, if the current <xref:System.Type> represents `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="09f45-3627">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3627">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3628">En cas de substitution dans une classe dérivée, implémente la propriété <see cref="P:System.Type.IsCOMObject" /> et détermine si le <see cref="T:System.Type" /> est un objet COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3628">When overridden in a derived class, implements the <see cref="P:System.Type.IsCOMObject" /> property and determines whether the <see cref="T:System.Type" /> is a COM object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3629">
            <see langword="true" /> si <see cref="T:System.Type" /> est un objet COM ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3629">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3630">Cette méthode retourne `false` pour les interfaces COM, car ils ne sont pas des objets.</span><span class="sxs-lookup"><span data-stu-id="09f45-3630">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="09f45-3631">Interfaces COM peuvent être implémentées par des objets Microsoft .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="09f45-3631">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3632">Obtient une valeur qui indique si cet objet représente un type générique construit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3632">Gets a value that indicates whether this object represents a constructed generic type.</span>
          </span>
          <span data-ttu-id="09f45-3633">Vous pouvez créer des instances d'un type générique construit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3633">You can create instances of a constructed generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3634">
            <see langword="true" /> si cet objet représente un type générique construit ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3634">
              <see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3635">Un type générique construit a été fournies pour tous ses paramètres de type générique de types explicites.</span><span class="sxs-lookup"><span data-stu-id="09f45-3635">A constructed generic type has had explicit types supplied for all of its generic type parameters.</span></span> <span data-ttu-id="09f45-3636">Il est également appelé un type générique fermé.</span><span class="sxs-lookup"><span data-stu-id="09f45-3636">It is also referred to as a closed generic type.</span></span>  
  
 <span data-ttu-id="09f45-3637">Lorsque cette propriété est `true`, vous pouvez créer des instances du type actuel ; lorsqu’il est `false`, vous ne pouvez pas.</span><span class="sxs-lookup"><span data-stu-id="09f45-3637">When this property is `true`, you can create instances of the current type; when it is `false`, you can't.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3638">Obtient une valeur indiquant si <see cref="T:System.Type" /> peut être hébergé dans un contexte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3638">Gets a value indicating whether the <see cref="T:System.Type" /> can be hosted in a context.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3639">
            <see langword="true" /> si <see cref="T:System.Type" /> peut être hébergé dans un contexte ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3639">
              <see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3640">Un contexte intercepte les appels aux membres de la classe et applique les stratégies sont appliquées à la classe, telles que la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="09f45-3640">A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</span></span> <span data-ttu-id="09f45-3641">Pour plus d’informations sur les contextes de communication à distance, consultez <xref:System.Runtime.Remoting.Contexts.Context>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3641">For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>.</span></span>  
  
 <span data-ttu-id="09f45-3642">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3642">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3643">L’exemple suivant illustre la `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, et <xref:System.Type.IsPrimitive%2A> propriétés de la <xref:System.Type> classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-3643">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="09f45-3644">Il vérifie si le type donné peut être hébergé dans le contexte, si elle peut être marshalée par référence, et si le type est un type de données primitif.</span><span class="sxs-lookup"><span data-stu-id="09f45-3644">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3645">Implémente la propriété <see cref="P:System.Type.IsContextful" /> et détermine si <see cref="T:System.Type" /> peut être hébergé dans un contexte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3645">Implements the <see cref="P:System.Type.IsContextful" /> property and determines whether the <see cref="T:System.Type" /> can be hosted in a context.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3646">
            <see langword="true" /> si <see cref="T:System.Type" /> peut être hébergé dans un contexte ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3646">
              <see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3647">Cette méthode peut être substituée par une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="09f45-3647">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="09f45-3648">Un contexte intercepte les appels aux membres de la classe et appliquer des stratégies qui sont appliquées à la classe, telles que la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="09f45-3648">A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3649">L’exemple suivant illustre une utilisation de la `IsContextfulImpl` (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3649">The following example demonstrates a use of the `IsContextfulImpl` method.</span></span>  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3650">Obtient une valeur indiquant si le <see cref="T:System.Type" /> actuel représente une énumération.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3650">Gets a value indicating whether the current <see cref="T:System.Type" /> represents an enumeration.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3651">
            <see langword="true" /> si le <see cref="T:System.Type" /> actuel représente une énumération ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3651">
              <see langword="true" /> if the current <see cref="T:System.Type" /> represents an enumeration; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3652">Cette propriété retourne `true` pour une énumération, mais pas pour le <xref:System.Enum> type lui-même.</span><span class="sxs-lookup"><span data-stu-id="09f45-3652">This property returns `true` for an enumeration, but not for the <xref:System.Enum> type itself.</span></span>  
  
 <span data-ttu-id="09f45-3653">Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit.</span><span class="sxs-lookup"><span data-stu-id="09f45-3653">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="09f45-3654">Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3654">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="09f45-3655">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3655">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="09f45-3656">Cette propriété est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="09f45-3656">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3657">L’exemple suivant montre comment utiliser le `IsEnum` propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-3657">The following example demonstrates how to use the `IsEnum` property.</span></span>  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="09f45-3658">Valeur à tester.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3658">The value to be tested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3659">Retourne une valeur qui indique si la valeur spécifiée existe dans le type énumération actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3659">Returns a value that indicates whether the specified value exists in the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3660">
            <see langword="true" /> si la valeur spécifiée est un membre du type énumération actuel ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3660">
              <see langword="true" /> if the specified value is a member of the current enumeration type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-3661">Le type actuel n’est pas une énumération.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3661">The current type is not an enumeration.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-3662">
            <paramref name="value" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3662">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="09f45-3663">
            <paramref name="value" /> est d'un type qui ne peut pas être le type sous-jacent d'une énumération.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3663">
              <paramref name="value" /> is of a type that cannot be the underlying type of an enumeration.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="09f45-3664">Type COM testé pour l'équivalence avec le type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3664">The COM type that is tested for equivalence with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3665">Détermine si deux types COM ont la même identité et prennent en charge l'équivalence de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3665">Determines whether two COM types have the same identity and are eligible for type equivalence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3666">
            <see langword="true" /> si les types COM sont équivalents ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3666">
              <see langword="true" /> if the COM types are equivalent; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="09f45-3667">Cette méthode retourne également la valeur <see langword="false" /> si un type est dans un assembly chargé pour l'exécution et que l'autre est dans un assembly chargé dans le contexte de réflexion uniquement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3667">This method also returns <see langword="false" /> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3668">Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le common language runtime prend en charge l’incorporation des informations de type pour les types COM directement dans des assemblys managés, au lieu de demander les assemblys managés obtenir des informations de type pour les types COM à partir de l’interopérabilité assemblys.</span><span class="sxs-lookup"><span data-stu-id="09f45-3668">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</span></span> <span data-ttu-id="09f45-3669">Étant donné que les informations de type incorporées incluent uniquement les types et les membres qui sont réellement utilisés par un assembly managé, deux assemblys managés peuvent présenter des affichages très différents du même type COM.</span><span class="sxs-lookup"><span data-stu-id="09f45-3669">Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</span></span> <span data-ttu-id="09f45-3670">Chaque assembly managé a un objet <xref:System.Type> différent pour représenter son affichage du type COM.</span><span class="sxs-lookup"><span data-stu-id="09f45-3670">Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type.</span></span> <span data-ttu-id="09f45-3671">Le Common Language Runtime prend en charge l’équivalence des types entre ces différents affichages pour les interfaces, les structures, les énumérations et les délégués.</span><span class="sxs-lookup"><span data-stu-id="09f45-3671">The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</span></span>  
  
 <span data-ttu-id="09f45-3672">Avec l’équivalence des types, un objet COM qui est passé d’un assembly managé à un autre peut être casté en type managé approprié dans l’assembly de réception.</span><span class="sxs-lookup"><span data-stu-id="09f45-3672">Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</span></span> <span data-ttu-id="09f45-3673">Le <xref:System.Type.IsEquivalentTo%2A> méthode permet à un assembly de déterminer qu’un objet COM obtenu à partir d’un autre assembly a la même identité COM en tant qu’un des types interop du premier assembly incorporé et peut donc être casté en ce type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3673">The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</span></span>  
  
 <span data-ttu-id="09f45-3674">Pour plus d’informations, consultez [équivalence des types et Types Interop incorporés](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span><span class="sxs-lookup"><span data-stu-id="09f45-3674">For more information, see [Type Equivalence and Embedded Interop Types](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3675">Obtient une valeur qui indique si les champs du type actuel sont placés aux offsets explicitement spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3675">Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3676">
            <see langword="true" /> si la propriété <see cref="P:System.Type.Attributes" /> du type actuel comprend <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3676">
              <see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3677">Cette propriété est fournie pour des raisons pratiques.</span><span class="sxs-lookup"><span data-stu-id="09f45-3677">This property is provided as a convenience.</span></span> <span data-ttu-id="09f45-3678">Vous pouvez également utiliser le <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valeur d’énumération pour sélectionner les attributs de mise en page de type, puis effectuer des tests de si <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> est défini.</span><span class="sxs-lookup"><span data-stu-id="09f45-3678">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="09f45-3679">Le <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, et <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valeurs d’énumération indiquent la façon des champs du type sont disposés en mémoire.</span><span class="sxs-lookup"><span data-stu-id="09f45-3679">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="09f45-3680">Pour les types dynamiques, vous pouvez spécifier <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> lorsque vous créez le type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3680">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="09f45-3681">Dans le code, vous devez appliquer le <xref:System.Runtime.InteropServices.StructLayoutAttribute> d’attribut avec le <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> valeur d’énumération pour le type, pour spécifier que les décalages à laquelle démarrer les champs sont spécifiés explicitement.</span><span class="sxs-lookup"><span data-stu-id="09f45-3681">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-3682">Vous ne pouvez pas utiliser le <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> méthode pour déterminer si le <xref:System.Runtime.InteropServices.StructLayoutAttribute> a été appliqué à un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3682">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="09f45-3683">Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit.</span><span class="sxs-lookup"><span data-stu-id="09f45-3683">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="09f45-3684">Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3684">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="09f45-3685">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3685">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3686">L’exemple suivant crée une instance d’un type et affiche la valeur de son <xref:System.Type.IsExplicitLayout%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-3686">The following example creates an instance of a type and displays the value of its <xref:System.Type.IsExplicitLayout%2A> property.</span></span> <span data-ttu-id="09f45-3687">Elle utilise le `MySystemTime` (classe), qui est également dans l’exemple de code <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3687">It uses the `MySystemTime` class, which is also in the code example for <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span></span>  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3688">Obtient une valeur indiquant si le <see cref="T:System.Type" /> actuel représente un paramètre de type d'une définition de type ou de méthode générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3688">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3689">
            <see langword="true" /> si l'objet <see cref="T:System.Type" /> représente un paramètre de type d'une définition de type générique ou de méthode générique ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3689">
              <see langword="true" /> if the <see cref="T:System.Type" /> object represents a type parameter of a generic type definition or generic method definition; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3690"><xref:System.Type> objets qui représentent les paramètres de type générique peuvent être obtenus en appelant le <xref:System.Type.GetGenericArguments%2A> méthode d’un <xref:System.Type> objet qui représente une définition de type générique, ou la <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> méthode d’un <xref:System.Reflection.MethodInfo> objet qui représente une méthode générique définition.</span><span class="sxs-lookup"><span data-stu-id="09f45-3690"><xref:System.Type> objects that represent generic type parameters can be obtained by calling the <xref:System.Type.GetGenericArguments%2A> method of a <xref:System.Type> object that represents a generic type definition, or the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
-   <span data-ttu-id="09f45-3691">Pour un type générique ou la définition de méthode, le <xref:System.Type.IsGenericParameter%2A> propriété renvoie `true` pour chaque élément du tableau résultant.</span><span class="sxs-lookup"><span data-stu-id="09f45-3691">For a generic type or method definition, the <xref:System.Type.IsGenericParameter%2A> property returns `true` for every element of the resulting array.</span></span>  
  
-   <span data-ttu-id="09f45-3692">Pour un type construit fermé ou une méthode, le <xref:System.Type.IsGenericParameter%2A> propriété renvoie `false` pour chaque élément du tableau retourné par la <xref:System.Type.GetGenericArguments%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3692">For a closed constructed type or method, the <xref:System.Type.IsGenericParameter%2A> property returns `false` for every element of the array returned by the <xref:System.Type.GetGenericArguments%2A> method.</span></span>  
  
-   <span data-ttu-id="09f45-3693">Pour une méthode ou un type construit ouvert, certains éléments du tableau peuvent être des types spécifiques et d’autres peuvent être des paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3693">For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</span></span> <span data-ttu-id="09f45-3694"><xref:System.Type.IsGenericParameter%2A> Retourne `false` pour les types et `true` pour les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3694"><xref:System.Type.IsGenericParameter%2A> returns `false` for the types and `true` for the type parameters.</span></span> <span data-ttu-id="09f45-3695">L’exemple de code pour le <xref:System.Type.ContainsGenericParameters%2A> propriété montre une classe générique avec un mélange de types et les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3695">The code example for the <xref:System.Type.ContainsGenericParameters%2A> property demonstrates a generic class with a mixture of types and type parameters.</span></span>  
  
 <span data-ttu-id="09f45-3696">Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3696">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3697">L’exemple suivant utilise le <xref:System.Type.IsGenericParameter%2A> propriété pour tester les paramètres de type générique dans un type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3697">The following example uses the <xref:System.Type.IsGenericParameter%2A> property to test for generic type parameters in a generic type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3698">Obtient une valeur indiquant si le type actuel est un type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3698">Gets a value indicating whether the current type is a generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3699">
            <see langword="true" /> Si le type actuel est un type générique ; dans le cas contraire, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3699">
              <see langword="true" /> if the current type is a generic type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3700">Utilisez le <xref:System.Type.IsGenericType%2A> propriété pour déterminer si un <xref:System.Type> objet représente un type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3700">Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type.</span></span> <span data-ttu-id="09f45-3701">Utilisez le <xref:System.Type.ContainsGenericParameters%2A> propriété pour déterminer si un <xref:System.Type> objet représente un type construit ouvert ou un type construit fermé.</span><span class="sxs-lookup"><span data-stu-id="09f45-3701">Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-3702">Le <xref:System.Type.IsGenericType%2A> propriété renvoie `false` si le type immédiat n’est pas générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3702">The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic.</span></span> <span data-ttu-id="09f45-3703">Par exemple, un tableau dont les éléments sont de type `A<int>` (`A(Of Integer)` en Visual Basic) n’est pas lui-même un type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3703">For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type.</span></span>  
  
 <span data-ttu-id="09f45-3704">Le tableau suivant résume les conditions invariantes pour les termes couramment utilisés dans la réflexion générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3704">The following table summarizes the invariant conditions for common terms used in generic reflection.</span></span>  
  
|<span data-ttu-id="09f45-3705">Terme</span><span class="sxs-lookup"><span data-stu-id="09f45-3705">Term</span></span>|<span data-ttu-id="09f45-3706">Invariant</span><span class="sxs-lookup"><span data-stu-id="09f45-3706">Invariant</span></span>|  
|----------|---------------|  
|<span data-ttu-id="09f45-3707">définition de type générique</span><span class="sxs-lookup"><span data-stu-id="09f45-3707">generic type definition</span></span>|<span data-ttu-id="09f45-3708">La propriété <xref:System.Type.IsGenericTypeDefinition%2A> a la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3708">The <xref:System.Type.IsGenericTypeDefinition%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="09f45-3709">Définit un type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3709">Defines a generic type.</span></span> <span data-ttu-id="09f45-3710">Un type construit est créé en appelant le <xref:System.Type.MakeGenericType%2A> méthode sur un <xref:System.Type> de l’objet qui représente une définition de type générique et en spécifiant un tableau d’arguments de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3710">A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments.</span></span><br /><br /> <span data-ttu-id="09f45-3711"><xref:System.Type.MakeGenericType%2A> peut être appelée uniquement sur les définitions de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3711"><xref:System.Type.MakeGenericType%2A> can be called only on generic type definitions.</span></span><br /><br /> <span data-ttu-id="09f45-3712">Toute définition de type générique est un type générique (la <xref:System.Type.IsGenericType%2A> propriété est `true`), mais l’inverse n’est pas vrai.</span><span class="sxs-lookup"><span data-stu-id="09f45-3712">Any generic type definition is a generic type (the <xref:System.Type.IsGenericType%2A> property is `true`), but the converse is not true.</span></span>|  
|<span data-ttu-id="09f45-3713">type générique</span><span class="sxs-lookup"><span data-stu-id="09f45-3713">generic type</span></span>|<span data-ttu-id="09f45-3714">La propriété <xref:System.Type.IsGenericType%2A> a la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3714">The <xref:System.Type.IsGenericType%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="09f45-3715">Peut être une définition de type générique, un type construit ouvert ou un type construit fermé.</span><span class="sxs-lookup"><span data-stu-id="09f45-3715">Can be a generic type definition, an open constructed type, or a closed constructed type.</span></span><br /><br /> <span data-ttu-id="09f45-3716">Notez qu’un type tableau dont le type d’élément est générique n’est pas lui-même un type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3716">Note that an array type whose element type is generic is not itself a generic type.</span></span> <span data-ttu-id="09f45-3717">Est de même d’une <xref:System.Type> objet représentant un pointeur vers un type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3717">The same is true of a <xref:System.Type> object representing a pointer to a generic type.</span></span>|  
|<span data-ttu-id="09f45-3718">type construit ouvert</span><span class="sxs-lookup"><span data-stu-id="09f45-3718">open constructed type</span></span>|<span data-ttu-id="09f45-3719">La propriété <xref:System.Type.ContainsGenericParameters%2A> a la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3719">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="09f45-3720">Les exemples sont un type générique qui a des paramètres de type non assignés, un type qui est imbriqué dans une définition de type générique ou dans un type construit ouvert ou un type générique qui a un argument de type pour lequel le <xref:System.Type.ContainsGenericParameters%2A> propriété est `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3720">Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="09f45-3721">Il n’est pas possible de créer une instance d’un type construit ouvert.</span><span class="sxs-lookup"><span data-stu-id="09f45-3721">It is not possible to create an instance of an open constructed type.</span></span><br /><br /> <span data-ttu-id="09f45-3722">Notez que les types construits ouverts pas génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-3722">Note that not all open constructed types are generic.</span></span> <span data-ttu-id="09f45-3723">Par exemple, un tableau dont le type d’élément est une définition de type générique n’est pas générique, et un pointeur vers un type construit ouvert n’est pas générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3723">For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</span></span>|  
|<span data-ttu-id="09f45-3724">type construit fermé</span><span class="sxs-lookup"><span data-stu-id="09f45-3724">closed constructed type</span></span>|<span data-ttu-id="09f45-3725">La propriété <xref:System.Type.ContainsGenericParameters%2A> a la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3725">The <xref:System.Type.ContainsGenericParameters%2A> property is `false`.</span></span><br /><br /> <span data-ttu-id="09f45-3726">Lorsque examinées de manière récursive, le type n’a aucun paramètre générique non assignés.</span><span class="sxs-lookup"><span data-stu-id="09f45-3726">When examined recursively, the type has no unassigned generic parameters.</span></span>|  
|<span data-ttu-id="09f45-3727">paramètre de type générique</span><span class="sxs-lookup"><span data-stu-id="09f45-3727">generic type parameter</span></span>|<span data-ttu-id="09f45-3728">La propriété <xref:System.Type.IsGenericParameter%2A> a la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3728">The <xref:System.Type.IsGenericParameter%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="09f45-3729">La propriété <xref:System.Type.ContainsGenericParameters%2A> a la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3729">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="09f45-3730">Dans une définition de type générique, un espace réservé pour un type qui sera assigné ultérieurement.</span><span class="sxs-lookup"><span data-stu-id="09f45-3730">In a generic type definition, a placeholder for a type that will be assigned later.</span></span>|  
|<span data-ttu-id="09f45-3731">argument de type générique</span><span class="sxs-lookup"><span data-stu-id="09f45-3731">generic type argument</span></span>|<span data-ttu-id="09f45-3732">Peut être n’importe quel type, y compris un paramètre de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3732">Can be any type, including a generic type parameter.</span></span><br /><br /> <span data-ttu-id="09f45-3733">Arguments de type sont spécifiés sous forme de tableau de <xref:System.Type> objets passés à la <xref:System.Type.MakeGenericType%2A> méthode lors de la création d’un type générique construit.</span><span class="sxs-lookup"><span data-stu-id="09f45-3733">Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type.</span></span> <span data-ttu-id="09f45-3734">Si les instances du type résultant doivent être créés, le <xref:System.Type.ContainsGenericParameters%2A> propriété doit être `false` pour tous les arguments de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3734">If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments.</span></span>|  
  
 <span data-ttu-id="09f45-3735">L’exemple de code et le tableau suivants illustrent certaines de ces termes et invariants.</span><span class="sxs-lookup"><span data-stu-id="09f45-3735">The following code example and table illustrate some of these terms and invariants.</span></span> <span data-ttu-id="09f45-3736">La `Derived` classe présente un intérêt particulier, car son type de base est un type construit qui possède un mélange de types et les paramètres de type dans sa liste d’arguments de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3736">The `Derived` class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 <span data-ttu-id="09f45-3737">Le tableau suivant montre des exemples qui utilisent et générer des classes `Base`, `Derived`, et `G`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3737">The following table shows examples that use and build on the classes `Base`, `Derived`, and `G`.</span></span> <span data-ttu-id="09f45-3738">Lorsque le code C++ et c# est la même, une seule entrée est indiquée.</span><span class="sxs-lookup"><span data-stu-id="09f45-3738">When the C++ and C# code is the same, only one entry is shown.</span></span>  
  
|<span data-ttu-id="09f45-3739">Exemple</span><span class="sxs-lookup"><span data-stu-id="09f45-3739">Example</span></span>|<span data-ttu-id="09f45-3740">Invariants</span><span class="sxs-lookup"><span data-stu-id="09f45-3740">Invariants</span></span>|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|<span data-ttu-id="09f45-3741">Pour ce type :</span><span class="sxs-lookup"><span data-stu-id="09f45-3741">For this type:</span></span><br /><br /> <span data-ttu-id="09f45-3742"><xref:System.Type.IsGenericType%2A> est `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3742"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="09f45-3743"><xref:System.Type.IsGenericTypeDefinition%2A> est `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3743"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="09f45-3744"><xref:System.Type.ContainsGenericParameters%2A> est `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3744"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|<span data-ttu-id="09f45-3745">Pour ce type :</span><span class="sxs-lookup"><span data-stu-id="09f45-3745">For this type:</span></span><br /><br /> <span data-ttu-id="09f45-3746"><xref:System.Type.IsGenericType%2A> est `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3746"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="09f45-3747"><xref:System.Type.IsGenericTypeDefinition%2A> est `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3747"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="09f45-3748"><xref:System.Type.ContainsGenericParameters%2A> est `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3748"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|<span data-ttu-id="09f45-3749">Pour le type de variable `d`:</span><span class="sxs-lookup"><span data-stu-id="09f45-3749">For the type of variable `d`:</span></span><br /><br /> <span data-ttu-id="09f45-3750"><xref:System.Type.IsGenericType%2A> est `false` car `d` est un tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-3750"><xref:System.Type.IsGenericType%2A> is `false` because `d` is an array.</span></span><br /><br /> <span data-ttu-id="09f45-3751"><xref:System.Type.IsGenericTypeDefinition%2A> est `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3751"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="09f45-3752"><xref:System.Type.ContainsGenericParameters%2A> est `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3752"><xref:System.Type.ContainsGenericParameters%2A> is `false`.</span></span>|  
|<span data-ttu-id="09f45-3753">`T`, `U`, et `V` (partout où ils apparaissent)</span><span class="sxs-lookup"><span data-stu-id="09f45-3753">`T`, `U`, and `V` (everywhere they appear)</span></span>|<span data-ttu-id="09f45-3754"><xref:System.Type.IsGenericParameter%2A> est `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3754"><xref:System.Type.IsGenericParameter%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="09f45-3755"><xref:System.Type.IsGenericType%2A> est `false` , car il n’existe aucun moyen de contraindre un paramètre de type aux types génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-3755"><xref:System.Type.IsGenericType%2A> is `false` because there is no way to constrain a type parameter to generic types.</span></span><br /><br /> <span data-ttu-id="09f45-3756"><xref:System.Type.IsGenericTypeDefinition%2A> est `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3756"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="09f45-3757"><xref:System.Type.ContainsGenericParameters%2A> est `true` car `T`, `U`, et `V` sont elles-mêmes des paramètres de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3757"><xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters.</span></span> <span data-ttu-id="09f45-3758">Cela ne signifie pas rien sur les arguments de type qui leur sont assignés ultérieurement.</span><span class="sxs-lookup"><span data-stu-id="09f45-3758">This does not imply anything about type arguments that are assigned to them later.</span></span>|  
|<span data-ttu-id="09f45-3759">Le type de champ `F`</span><span class="sxs-lookup"><span data-stu-id="09f45-3759">The type of field `F`</span></span>|<span data-ttu-id="09f45-3760"><xref:System.Type.IsGenericType%2A> est `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3760"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="09f45-3761"><xref:System.Type.IsGenericTypeDefinition%2A> est `false` , car un type a été affecté au paramètre de type de `G`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3761"><xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to the type parameter of `G`.</span></span> <span data-ttu-id="09f45-3762">Notez que cela équivaut à appeler le <xref:System.Type.MakeGenericType%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-3762">Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method.</span></span><br /><br /> <span data-ttu-id="09f45-3763"><xref:System.Type.ContainsGenericParameters%2A> est `true` , car le type du champ `F` a un argument de type est un type construit ouvert.</span><span class="sxs-lookup"><span data-stu-id="09f45-3763"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type.</span></span> <span data-ttu-id="09f45-3764">Le type construit est ouvert, car son argument de type (c'est-à-dire, `Base`) est une définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3764">The constructed type is open because its type argument (that is, `Base`) is a generic type definition.</span></span> <span data-ttu-id="09f45-3765">Cet exemple illustre la nature récursive de la <xref:System.Type.IsGenericType%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-3765">This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property.</span></span>|  
|<span data-ttu-id="09f45-3766">La classe imbriquée `Nested`</span><span class="sxs-lookup"><span data-stu-id="09f45-3766">The nested class `Nested`</span></span>|<span data-ttu-id="09f45-3767"><xref:System.Type.IsGenericType%2A> est `true`, même si la `Nested` classe n’a aucun paramètre de type générique de son propre, car elle est imbriquée dans un type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3767"><xref:System.Type.IsGenericType%2A> is `true`, even though the `Nested` class has no generic type parameters of its own, because it is nested in a generic type.</span></span><br /><br /> <span data-ttu-id="09f45-3768"><xref:System.Type.IsGenericTypeDefinition%2A> est `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3768"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span> <span data-ttu-id="09f45-3769">Autrement dit, vous pouvez appeler la <xref:System.Type.MakeGenericType%2A> méthode et fournir le paramètre de type du type englobant, `Derived`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3769">That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`.</span></span><br /><br /> <span data-ttu-id="09f45-3770"><xref:System.Type.ContainsGenericParameters%2A> est `true` , car le type englobant, `Derived`, a des paramètres de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3770"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters.</span></span> <span data-ttu-id="09f45-3771">Cet exemple illustre la nature récursive de la <xref:System.Type.ContainsGenericParameters%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-3771">This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3772">L’exemple de code suivant affiche la valeur de la <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, et <xref:System.Type.ContainsGenericParameters%2A> propriétés pour les types décrits dans la section Notes.</span><span class="sxs-lookup"><span data-stu-id="09f45-3772">The following code example displays the value of the <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, and <xref:System.Type.ContainsGenericParameters%2A> properties for the types described in the Remarks section.</span></span> <span data-ttu-id="09f45-3773">Pour obtenir des explications des valeurs de propriété, consultez le tableau joint dans la section Notes.</span><span class="sxs-lookup"><span data-stu-id="09f45-3773">For explanations of the property values, see the accompanying table in Remarks.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3774">Obtient une valeur qui indique si le <see cref="T:System.Type" /> actuel représente une définition de type générique, à partir de laquelle d'autres types génériques peuvent être construits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3774">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a generic type definition, from which other generic types can be constructed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3775">
            <see langword="true" /> si l'objet <see cref="T:System.Type" /> représente une définition de type générique ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3775">
              <see langword="true" /> if the <see cref="T:System.Type" /> object represents a generic type definition; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3776">Une définition de type générique est un modèle à partir de laquelle d’autres types peuvent être construits.</span><span class="sxs-lookup"><span data-stu-id="09f45-3776">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="09f45-3777">Par exemple, à partir de la définition de type générique `G<T>` (exprimé en syntaxe c# ; `G(Of T)` en Visual Basic ou `generic <typename T> ref class G` en C++) vous pouvez construire et instancier le type `G<int>` (`G(Of Integer)` en Visual Basic), en appelant le <xref:System.Type.MakeGenericType%2A> méthode avec une liste d’arguments génériques contenant le <xref:System.Int32> type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3777">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic), by calling the <xref:System.Type.MakeGenericType%2A> method with a generic argument list containing the <xref:System.Int32> type.</span></span> <span data-ttu-id="09f45-3778">Étant donné un <xref:System.Type> objet représentant ce type construit, le <xref:System.Type.GetGenericTypeDefinition%2A> méthode récupère la définition de type générique à nouveau.</span><span class="sxs-lookup"><span data-stu-id="09f45-3778">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method gets the generic type definition back again.</span></span>  
  
 <span data-ttu-id="09f45-3779">Utilisez le <xref:System.Type.IsGenericTypeDefinition%2A> propriété pour déterminer si vous pouvez créer de nouveaux types à partir du type actuel.</span><span class="sxs-lookup"><span data-stu-id="09f45-3779">Use the <xref:System.Type.IsGenericTypeDefinition%2A> property to determine whether you can create new types from the current type.</span></span> <span data-ttu-id="09f45-3780">Si le <xref:System.Type.IsGenericTypeDefinition%2A> propriété renvoie `true`, vous pouvez appeler la <xref:System.Type.MakeGenericType%2A> méthode pour créer des types génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-3780">If the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `true`, you can call the <xref:System.Type.MakeGenericType%2A> method to create new generic types.</span></span>  
  
 <span data-ttu-id="09f45-3781">Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3781">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3782">L’exemple suivant affiche des informations sur un type, notamment si elle est une définition de type générique ou non.</span><span class="sxs-lookup"><span data-stu-id="09f45-3782">The following example displays information about a type, including whether or not it is a generic type definition.</span></span> <span data-ttu-id="09f45-3783">Informations s’affichent pour un type construit, pour sa définition de type générique et un type ordinaire.</span><span class="sxs-lookup"><span data-stu-id="09f45-3783">Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3784">Obtient une valeur qui indique si le <see cref="T:System.Type" /> a un attribut appliqué <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />, indiquant qu'il a été importé d'une bibliothèque de types COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3784">Gets a value indicating whether the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> attribute applied, indicating that it was imported from a COM type library.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3785">
            <see langword="true" /> si le <see cref="T:System.Type" /> a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3785">
              <see langword="true" /> if the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3786">Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit.</span><span class="sxs-lookup"><span data-stu-id="09f45-3786">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="09f45-3787">Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="09f45-3787">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="09f45-3788">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3788">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="09f45-3789">Objet à comparer au type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3789">The object to compare with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-3790">Détermine si l'objet spécifié est une instance du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3790">Determines whether the specified object is an instance of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3791">
            <see langword="true" /> si le <see langword="Type" /> actuel se trouve dans la hiérarchie d'héritage de l'objet représenté par <paramref name="o" /> ou si le <see langword="Type" /> actuel est une interface que <paramref name="o" /> implémente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3791">
              <see langword="true" /> if the current <see langword="Type" /> is in the inheritance hierarchy of the object represented by <paramref name="o" />, or if the current <see langword="Type" /> is an interface that <paramref name="o" /> implements.</span>
          </span>
          <span data-ttu-id="09f45-3792">
            <see langword="false" /> si aucune de ces conditions n'est respectée, si <paramref name="o" /> est <see langword="null" /> ou si le <see langword="Type" /> actuel est un type générique ouvert (autrement dit, <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3792">
              <see langword="false" /> if neither of these conditions is the case, if <paramref name="o" /> is <see langword="null" />, or if the current <see langword="Type" /> is an open generic type (that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3793">Cette méthode peut être substituée par une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="09f45-3793">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-3794">Un type construit n’est pas une instance de sa définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-3794">A constructed type is not an instance of its generic type definition.</span></span> <span data-ttu-id="09f45-3795">Autrement dit, `MyGenericList<int>` (`MyGenericList(Of Integer)` en Visual Basic) n’est pas une instance de `MyGenericList<T>` (`MyGenericList(Of T)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-3795">That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3796">L'exemple suivant illustre l'utilisation de la méthode `IsInstanceOfType`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3796">The following example demonstrates the use of the `IsInstanceOfType` method.</span></span>  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3797">Obtient une valeur indiquant si le <see cref="T:System.Type" /> est une interface, c'est-à-dire ni une classe ni un type valeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3797">Gets a value indicating whether the <see cref="T:System.Type" /> is an interface; that is, not a class or a value type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3798">
            <see langword="true" /> si <see cref="T:System.Type" /> est une interface ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3798">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an interface; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3799">Le <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distingue une déclaration de type en tant que classe, interface ou un type valeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-3799">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distinguishes a type declaration as class, interface or value type.</span></span>  
  
 <span data-ttu-id="09f45-3800">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3800">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="09f45-3801">Cette propriété est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="09f45-3801">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3802">L’exemple suivant crée une interface, vérifie le type d’interface et indique si une classe possède le `IsInterface` jeu de propriétés.</span><span class="sxs-lookup"><span data-stu-id="09f45-3802">The following example creates an interface, checks for the interface type, and indicates whether a class has the `IsInterface` property set.</span></span>  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3803">Obtient une valeur qui indique si les champs du type actuel sont placés séquentiellement, en respectant l'ordre dans lequel ils ont été définis ou émis aux métadonnées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3803">Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3804">
            <see langword="true" /> si la propriété <see cref="P:System.Type.Attributes" /> du type actuel comprend <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3804">
              <see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3805">Cette propriété est fournie pour des raisons pratiques.</span><span class="sxs-lookup"><span data-stu-id="09f45-3805">This property is provided as a convenience.</span></span> <span data-ttu-id="09f45-3806">Vous pouvez également utiliser le <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valeur d’énumération pour sélectionner les attributs de mise en page de type, puis effectuer des tests de si <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> est défini.</span><span class="sxs-lookup"><span data-stu-id="09f45-3806">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="09f45-3807">Le <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, et <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valeurs d’énumération indiquent la façon des champs du type sont disposés en mémoire.</span><span class="sxs-lookup"><span data-stu-id="09f45-3807">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="09f45-3808">Pour les types dynamiques, vous pouvez spécifier <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> lorsque vous créez le type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3808">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="09f45-3809">Dans le code, vous devez appliquer le <xref:System.Runtime.InteropServices.StructLayoutAttribute> d’attribut avec le <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valeur d’énumération pour le type, pour spécifier que la disposition est séquentielle.</span><span class="sxs-lookup"><span data-stu-id="09f45-3809">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value to the type, to specify that layout is sequential.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-3810">Vous ne pouvez pas utiliser le <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> méthode pour déterminer si le <xref:System.Runtime.InteropServices.StructLayoutAttribute> a été appliqué à un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3810">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="09f45-3811">Pour plus d’informations, consultez la section 9.1.2 de la spécification de la documentation du Common Language Infrastructure (CLI), « Partition II : Metadata Definition et Semantics ».</span><span class="sxs-lookup"><span data-stu-id="09f45-3811">For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="09f45-3812">La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.</span><span class="sxs-lookup"><span data-stu-id="09f45-3812">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="09f45-3813">Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit.</span><span class="sxs-lookup"><span data-stu-id="09f45-3813">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="09f45-3814">Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3814">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="09f45-3815">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3815">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3816">L’exemple suivant crée une instance d’une classe pour laquelle le <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valeur d’énumération dans le <xref:System.Runtime.InteropServices.StructLayoutAttribute> classe a été défini, les contrôles pour le <xref:System.Type.IsLayoutSequential%2A> propriété et affiche le résultat.</span><span class="sxs-lookup"><span data-stu-id="09f45-3816">The following example creates an instance of a class for which the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value in the <xref:System.Runtime.InteropServices.StructLayoutAttribute> class has been set, checks for the <xref:System.Type.IsLayoutSequential%2A> property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3817">Obtient une valeur indiquant si <see cref="T:System.Type" /> est marshalé par référence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3817">Gets a value indicating whether the <see cref="T:System.Type" /> is marshaled by reference.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3818">
            <see langword="true" /> si <see cref="T:System.Type" /> est marshalé par référence ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3818">
              <see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="09f45-3819">L’exemple suivant illustre la `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, et <xref:System.Type.IsPrimitive%2A> propriétés de la <xref:System.Type> classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-3819">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="09f45-3820">Il vérifie si le type donné peut être hébergé dans le contexte, si elle peut être marshalée par référence, et si le type est un type de données primitif.</span><span class="sxs-lookup"><span data-stu-id="09f45-3820">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3821">Implémente la propriété <see cref="P:System.Type.IsMarshalByRef" /> et détermine si le <see cref="T:System.Type" /> est marshalé par référence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3821">Implements the <see cref="P:System.Type.IsMarshalByRef" /> property and determines whether the <see cref="T:System.Type" /> is marshaled by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3822">
            <see langword="true" /> si <see cref="T:System.Type" /> est marshalé par référence ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3822">
              <see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3823">Cette méthode peut être substituée par une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="09f45-3823">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3824">L’exemple suivant détermine si le type donné est marshalé par référence et affiche le résultat.</span><span class="sxs-lookup"><span data-stu-id="09f45-3824">The following example determines whether the given type is marshaled by reference and displays the result.</span></span>  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3825">Obtient une valeur indiquant si l'objet <see cref="T:System.Type" /> actuel représente un type dont la définition est imbriquée dans la définition d'un autre type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3825">Gets a value indicating whether the current <see cref="T:System.Type" /> object represents a type whose definition is nested inside the definition of another type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3826">
            <see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué dans un autre type ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3826">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested inside another type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3827">Le <xref:System.Type.IsNested%2A> propriété renvoie `true` pour tous les types imbriqués, quelle que soit la visibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3827">The <xref:System.Type.IsNested%2A> property returns `true` for all nested types, regardless of visibility.</span></span> <span data-ttu-id="09f45-3828">Pour tester l’imbrication et la visibilité en même temps, utilisez les propriétés connexes <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, ou <xref:System.Type.IsNestedPublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3828">To test for nesting and visibility at the same time, use the related properties <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, or <xref:System.Type.IsNestedPublic%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-3829">Le <xref:System.Reflection.TypeAttributes.VisibilityMask> membre de l’énumération sélectionne les attributs de visibilité pour un type.</span><span class="sxs-lookup"><span data-stu-id="09f45-3829">The <xref:System.Reflection.TypeAttributes.VisibilityMask> enumeration member selects the visibility attributes for a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3830">L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont des types différents de visibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3830">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="09f45-3831">Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="09f45-3831">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3832">Obtient une valeur indiquant si le <see cref="T:System.Type" /> est imbriqué et visible uniquement dans son propre assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3832">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3833">
            <see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué et visible uniquement dans son propre assembly ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3833">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own assembly; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3834">Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3834">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="09f45-3835"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3835"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3836">L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont des types différents de visibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3836">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="09f45-3837">Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="09f45-3837">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3838">Obtient une valeur indiquant si le <see cref="T:System.Type" /> est imbriqué et visible uniquement par rapport aux classes qui appartiennent à la fois à sa propre famille et à son propre assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3838">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3839">
            <see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué et visible uniquement par rapport aux classes qui appartiennent à la fois à sa propre famille et à son propre assembly ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3839">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3840">Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3840">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="09f45-3841"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3841"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-3842">Les langages c# et Visual Basic n’incluent pas de sémantique qui vous permettent de définir un type imbriqué qui est visible uniquement pour les types protégés dans son propre assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-3842">The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</span></span> <span data-ttu-id="09f45-3843">`protected internal` visibilité en c# et `Protected Friend` visibilité en Visual Basic définissent un type imbriqué qui est visible pour les types protégés et les types dans le même assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-3843">`protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</span></span>  
  
 <span data-ttu-id="09f45-3844">A <xref:System.Type> famille de l’objet est défini en tant que tous les objets du même <xref:System.Type> et de ses sous-types.</span><span class="sxs-lookup"><span data-stu-id="09f45-3844">A <xref:System.Type> object's family is defined as all objects of the same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3845">L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont des types différents de visibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3845">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="09f45-3846">Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="09f45-3846">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3847">Obtient une valeur indiquant si le <see cref="T:System.Type" /> est imbriqué et visible uniquement dans sa propre famille.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3847">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own family.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3848">
            <see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué et visible uniquement dans sa propre famille ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3848">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own family; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3849">Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3849">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="09f45-3850"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3850"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="09f45-3851">A <xref:System.Type> famille de l’objet est défini en tant que tous les objets de la même <xref:System.Type> et de ses sous-types.</span><span class="sxs-lookup"><span data-stu-id="09f45-3851">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3852">L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont des types différents de visibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3852">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="09f45-3853">Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="09f45-3853">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3854">Obtient une valeur indiquant si le <see cref="T:System.Type" /> est imbriqué et visible uniquement par rapport aux classes qui appartiennent à sa propre famille ou à son propre assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3854">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to either its own family or to its own assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3855">
            <see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué et visible uniquement par rapport aux classes qui appartiennent à sa propre famille ou à son propre assembly ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3855">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3856">Si la visibilité d’un type est `protected internal` en c# ou `Protected Friend` en Visual Basic, le <xref:System.Type.IsNestedFamORAssem%2A> propriété renvoie `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3856">If the visibility of a type is `protected internal` in C# or `Protected Friend` in Visual Basic, the <xref:System.Type.IsNestedFamORAssem%2A> property returns `true`.</span></span>  
  
 <span data-ttu-id="09f45-3857">Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3857">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="09f45-3858"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3858"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="09f45-3859">A <xref:System.Type> famille de l’objet est défini en tant que tous les objets de la même <xref:System.Type> et de ses sous-types.</span><span class="sxs-lookup"><span data-stu-id="09f45-3859">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3860">L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont des types différents de visibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3860">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="09f45-3861">Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="09f45-3861">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3862">Obtient une valeur indiquant si le <see cref="T:System.Type" /> est imbriqué et déclaré privé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3862">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and declared private.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3863">
            <see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué et déclaré privé ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3863">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and declared private; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3864">Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3864">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="09f45-3865"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3865"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3866">L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont des types différents de visibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3866">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="09f45-3867">Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="09f45-3867">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3868">Obtient une valeur indiquant si une classe est imbriquée et déclarée publique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3868">Gets a value indicating whether a class is nested and declared public.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3869">
            <see langword="true" /> si la classe est imbriquée et déclarée publique ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3869">
              <see langword="true" /> if the class is nested and declared public; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3870">Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3870">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="09f45-3871"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3871"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3872">L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont des types différents de visibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3872">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="09f45-3873">Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="09f45-3873">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3874">Obtient une valeur indiquant si <see cref="T:System.Type" /> n'est pas déclaré public.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3874">Gets a value indicating whether the <see cref="T:System.Type" /> is not declared public.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3875">
            <see langword="true" /> si <see cref="T:System.Type" /> n'est pas déclaré public et n'est pas un type imbriqué ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3875">
              <see langword="true" /> if the <see cref="T:System.Type" /> is not declared public and is not a nested type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3876">N’utilisez pas cette propriété avec les types imbriqués ; Utilisez le <xref:System.Type.IsNestedPublic%2A> propriété à la place.</span><span class="sxs-lookup"><span data-stu-id="09f45-3876">Do not use this property with nested types; use the <xref:System.Type.IsNestedPublic%2A> property instead.</span></span>  
  
 <span data-ttu-id="09f45-3877">Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3877">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3878">Cet exemple montre comment l’option `IsNotPublic` pour obtenir la visibilité du type de propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-3878">This example usesthe `IsNotPublic` property to get the visibility of the type.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 <span data-ttu-id="09f45-3879">L’exemple de code suivant montre pourquoi vous ne pouvez pas utiliser `IsPublic` et `IsNotPublic` pour les classes imbriquées.</span><span class="sxs-lookup"><span data-stu-id="09f45-3879">The following code example demonstrates why you cannot use `IsPublic` and `IsNotPublic` for nested classes.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 <span data-ttu-id="09f45-3880">Pour les classes imbriquées, ignorez les résultats de `IsPublic` et `IsNotPublic` et uniquement pour les résultats d’une attention `IsNestedPublic` et `IsNestedPrivate`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3880">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of `IsNestedPublic` and `IsNestedPrivate`.</span></span> <span data-ttu-id="09f45-3881">La sortie de la réflexion pour ce fragment de code se présente comme suit :</span><span class="sxs-lookup"><span data-stu-id="09f45-3881">The reflection output for this code fragment would be as follows:</span></span>  
  
|<span data-ttu-id="09f45-3882">Classe</span><span class="sxs-lookup"><span data-stu-id="09f45-3882">Class</span></span>|<span data-ttu-id="09f45-3883">IsNotPublic</span><span class="sxs-lookup"><span data-stu-id="09f45-3883">IsNotPublic</span></span>|<span data-ttu-id="09f45-3884">IsPublic</span><span class="sxs-lookup"><span data-stu-id="09f45-3884">IsPublic</span></span>|<span data-ttu-id="09f45-3885">IsNestedPublic</span><span class="sxs-lookup"><span data-stu-id="09f45-3885">IsNestedPublic</span></span>|<span data-ttu-id="09f45-3886">IsNestedPrivate</span><span class="sxs-lookup"><span data-stu-id="09f45-3886">IsNestedPrivate</span></span>|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|<span data-ttu-id="09f45-3887">A</span><span class="sxs-lookup"><span data-stu-id="09f45-3887">A</span></span>|<span data-ttu-id="09f45-3888">false</span><span class="sxs-lookup"><span data-stu-id="09f45-3888">FALSE</span></span>|<span data-ttu-id="09f45-3889">true</span><span class="sxs-lookup"><span data-stu-id="09f45-3889">TRUE</span></span>|<span data-ttu-id="09f45-3890">false</span><span class="sxs-lookup"><span data-stu-id="09f45-3890">FALSE</span></span>|<span data-ttu-id="09f45-3891">false</span><span class="sxs-lookup"><span data-stu-id="09f45-3891">FALSE</span></span>|  
|<span data-ttu-id="09f45-3892">B</span><span class="sxs-lookup"><span data-stu-id="09f45-3892">B</span></span>|<span data-ttu-id="09f45-3893">false</span><span class="sxs-lookup"><span data-stu-id="09f45-3893">FALSE</span></span>|<span data-ttu-id="09f45-3894">false</span><span class="sxs-lookup"><span data-stu-id="09f45-3894">FALSE</span></span>|<span data-ttu-id="09f45-3895">true</span><span class="sxs-lookup"><span data-stu-id="09f45-3895">TRUE</span></span>|<span data-ttu-id="09f45-3896">false</span><span class="sxs-lookup"><span data-stu-id="09f45-3896">FALSE</span></span>|  
|<span data-ttu-id="09f45-3897">C</span><span class="sxs-lookup"><span data-stu-id="09f45-3897">C</span></span>|<span data-ttu-id="09f45-3898">false</span><span class="sxs-lookup"><span data-stu-id="09f45-3898">FALSE</span></span>|<span data-ttu-id="09f45-3899">false</span><span class="sxs-lookup"><span data-stu-id="09f45-3899">FALSE</span></span>|<span data-ttu-id="09f45-3900">false</span><span class="sxs-lookup"><span data-stu-id="09f45-3900">FALSE</span></span>|<span data-ttu-id="09f45-3901">true</span><span class="sxs-lookup"><span data-stu-id="09f45-3901">TRUE</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3902">Obtient une valeur indiquant si <see cref="T:System.Type" /> est un pointeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3902">Gets a value indicating whether the <see cref="T:System.Type" /> is a pointer.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3903">
            <see langword="true" /> si <see cref="T:System.Type" /> est un pointeur ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3903">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3904">Si le courant <xref:System.Type> représente un type générique ou un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3904">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="09f45-3905">Cette propriété est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="09f45-3905">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3906">L’exemple suivant illustre une utilisation de la `IsPointer` propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-3906">The following example shows a use of the `IsPointer` property.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3907">En cas de substitution dans une classe dérivée, implémente la propriété <see cref="P:System.Type.IsPointer" /> et détermine si le <see cref="T:System.Type" /> est un pointeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3907">When overridden in a derived class, implements the <see cref="P:System.Type.IsPointer" /> property and determines whether the <see cref="T:System.Type" /> is a pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3908">
            <see langword="true" /> si <see cref="T:System.Type" /> est un pointeur ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3908">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3909">Obtient une valeur indiquant si le <see cref="T:System.Type" /> est l'un des types primitifs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3909">Gets a value indicating whether the <see cref="T:System.Type" /> is one of the primitive types.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3910">
            <see langword="true" /> si <see cref="T:System.Type" /> est l'un des types primitifs ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3910">
              <see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3911">Les types primitifs sont <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, et <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3911">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
 <span data-ttu-id="09f45-3912">Si le courant <xref:System.Type> représente un type générique ou un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3912">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3913">L’exemple suivant illustre la `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, et <xref:System.Type.IsPrimitive%2A> propriétés de la <xref:System.Type> classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-3913">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="09f45-3914">Il vérifie si le type donné peut être hébergé dans le contexte, si elle peut être marshalée par référence, et si le type est un type de données primitif.</span><span class="sxs-lookup"><span data-stu-id="09f45-3914">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3915">En cas de substitution dans une classe dérivée, implémente la propriété <see cref="P:System.Type.IsPrimitive" /> et détermine si <see cref="T:System.Type" /> est l'un des types primitifs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3915">When overridden in a derived class, implements the <see cref="P:System.Type.IsPrimitive" /> property and determines whether the <see cref="T:System.Type" /> is one of the primitive types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-3916">
            <see langword="true" /> si <see cref="T:System.Type" /> est l'un des types primitifs ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3916">
              <see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3917">Les types primitifs sont <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, et <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3917">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3918">L’exemple suivant détermine si le type donné est un type primitif et affiche le résultat.</span><span class="sxs-lookup"><span data-stu-id="09f45-3918">The following example determines whether the given type is a primitive type and displays the result.</span></span>  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3919">Obtient une valeur indiquant si <see cref="T:System.Type" /> est déclaré public.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3919">Gets a value indicating whether the <see cref="T:System.Type" /> is declared public.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3920">
            <see langword="true" /> si <see cref="T:System.Type" /> est déclaré public et n'est pas un type imbriqué ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3920">
              <see langword="true" /> if the <see cref="T:System.Type" /> is declared public and is not a nested type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3921">N’utilisez pas avec les types imbriqués ; Utilisez <xref:System.Type.IsNestedPublic%2A> à la place.</span><span class="sxs-lookup"><span data-stu-id="09f45-3921">Do not use with nested types; use <xref:System.Type.IsNestedPublic%2A> instead.</span></span>  
  
 <span data-ttu-id="09f45-3922">Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3922">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `true`.</span></span>  
  
 <span data-ttu-id="09f45-3923"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.</span><span class="sxs-lookup"><span data-stu-id="09f45-3923"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3924">L’exemple suivant crée une instance de `MyTestClass`, vérifie le `IsPublic` propriété et affiche le résultat.</span><span class="sxs-lookup"><span data-stu-id="09f45-3924">The following example creates an instance of `MyTestClass`, checks for the `IsPublic` property, and displays the result.</span></span>  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 <span data-ttu-id="09f45-3925">Pour les classes imbriquées, ignorez les résultats de `IsPublic` et `IsNotPublic` et uniquement pour les résultats d’une attention <xref:System.Type.IsNestedPublic%2A> et <xref:System.Type.IsNestedPrivate%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3925">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of <xref:System.Type.IsNestedPublic%2A> and <xref:System.Type.IsNestedPrivate%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3926">Obtient une valeur indiquant si <see cref="T:System.Type" /> est déclaré sealed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3926">Gets a value indicating whether the <see cref="T:System.Type" /> is declared sealed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3927">
            <see langword="true" /> si le <see cref="T:System.Type" /> est déclaré sealed ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3927">
              <see langword="true" /> if the <see cref="T:System.Type" /> is declared sealed; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3928">Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3928">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3929">L’exemple suivant crée une instance d’un `sealed` classe vérifie le `IsSealed` propriété et affiche le résultat.</span><span class="sxs-lookup"><span data-stu-id="09f45-3929">The following example creates an instance of a `sealed` class, checks for the `IsSealed` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3930">Obtient une valeur qui indique si le type actuel est critique de sécurité (security-critical) ou critique sécurisé (security-safe-critical) au niveau de confiance actuel et peut donc exécuter des opérations critiques.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3930">Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3931">
            <see langword="true" /> si le type actuel est critique de sécurité ou critique sécurisé au niveau de confiance actuel ; <see langword="false" /> s'il est transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3931">
              <see langword="true" /> if the current type is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3932">Le <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, et <xref:System.Type.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence du type à son niveau de confiance actuel, tel que déterminé par le common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="09f45-3932">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="09f45-3933">Les combinaisons de ces propriétés sont répertoriées dans le tableau suivant :</span><span class="sxs-lookup"><span data-stu-id="09f45-3933">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="09f45-3934">Niveau de sécurité</span><span class="sxs-lookup"><span data-stu-id="09f45-3934">Security level</span></span>|<span data-ttu-id="09f45-3935">EstCritiqueDeSécurité</span><span class="sxs-lookup"><span data-stu-id="09f45-3935">IsSecurityCritical</span></span>|<span data-ttu-id="09f45-3936">EstCritiqueSécurisé</span><span class="sxs-lookup"><span data-stu-id="09f45-3936">IsSecuritySafeCritical</span></span>|<span data-ttu-id="09f45-3937">EstTransparentDeSécurité</span><span class="sxs-lookup"><span data-stu-id="09f45-3937">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="09f45-3938">Critique</span><span class="sxs-lookup"><span data-stu-id="09f45-3938">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="09f45-3939">Critique sécurisé</span><span class="sxs-lookup"><span data-stu-id="09f45-3939">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="09f45-3940">Transparent</span><span class="sxs-lookup"><span data-stu-id="09f45-3940">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="09f45-3941">L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.</span><span class="sxs-lookup"><span data-stu-id="09f45-3941">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="09f45-3942">Pour les assemblys de confiance partielle, la valeur de cette propriété dépend du niveau de confiance actuel de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-3942">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="09f45-3943">Si l’assembly est chargé dans un domaine d’application partiellement fiable (par exemple, dans un domaine d’application sandbox), le runtime ignore les annotations de sécurité de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-3943">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="09f45-3944">L’assembly et tous ses types sont traités comme étant transparent.</span><span class="sxs-lookup"><span data-stu-id="09f45-3944">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="09f45-3945">Le runtime tient compte des annotations de sécurité d’un assembly de confiance partielle uniquement lorsque cet assembly est chargé dans un domaine d’application de confiance totale (par exemple, dans le domaine d’application par défaut d’une application de bureau).</span><span class="sxs-lookup"><span data-stu-id="09f45-3945">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="09f45-3946">En revanche, un assembly fiable (autrement dit, un assembly avec nom fort est installé dans le global assembly cache) est toujours chargé avec une confiance totale, quelle que soit le niveau de confiance du domaine d’application, son niveau de confiance actuel est toujours entièrement fiable.</span><span class="sxs-lookup"><span data-stu-id="09f45-3946">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="09f45-3947">Vous pouvez déterminer les niveaux de confiance actuels des assemblys et des domaines d’application à l’aide de la <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> et <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propriétés.</span><span class="sxs-lookup"><span data-stu-id="09f45-3947">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="09f45-3948">Pour plus d’informations sur la réflexion et transparence, consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="09f45-3948">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="09f45-3949">Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="09f45-3949">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3950">Obtient une valeur qui indique si le type actuel est critique sécurisé au niveau de confiance actuel, autrement dit s'il peut exécuter des opérations critiques et être accessible par du code transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3950">Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3951">
            <see langword="true" /> si le type actuel est critique sécurisé au niveau de confiance actuel ; <see langword="false" /> s'il est critique de sécurité ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3951">
              <see langword="true" /> if the current type is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3952">Le <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, et <xref:System.Type.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence du type à son niveau de confiance actuel, tel que déterminé par le common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="09f45-3952">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="09f45-3953">Les combinaisons de ces propriétés sont répertoriées dans le tableau suivant :</span><span class="sxs-lookup"><span data-stu-id="09f45-3953">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="09f45-3954">Niveau de sécurité</span><span class="sxs-lookup"><span data-stu-id="09f45-3954">Security level</span></span>|<span data-ttu-id="09f45-3955">EstCritiqueDeSécurité</span><span class="sxs-lookup"><span data-stu-id="09f45-3955">IsSecurityCritical</span></span>|<span data-ttu-id="09f45-3956">EstCritiqueSécurisé</span><span class="sxs-lookup"><span data-stu-id="09f45-3956">IsSecuritySafeCritical</span></span>|<span data-ttu-id="09f45-3957">EstTransparentDeSécurité</span><span class="sxs-lookup"><span data-stu-id="09f45-3957">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="09f45-3958">Critique</span><span class="sxs-lookup"><span data-stu-id="09f45-3958">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="09f45-3959">Critique sécurisé</span><span class="sxs-lookup"><span data-stu-id="09f45-3959">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="09f45-3960">Transparent</span><span class="sxs-lookup"><span data-stu-id="09f45-3960">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="09f45-3961">L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.</span><span class="sxs-lookup"><span data-stu-id="09f45-3961">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="09f45-3962">Pour les assemblys de confiance partielle, la valeur de cette propriété dépend du niveau de confiance actuel de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-3962">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="09f45-3963">Si l’assembly est chargé dans un domaine d’application partiellement fiable (par exemple, dans un domaine d’application sandbox), le runtime ignore les annotations de sécurité de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-3963">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="09f45-3964">L’assembly et tous ses types sont traités comme étant transparent.</span><span class="sxs-lookup"><span data-stu-id="09f45-3964">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="09f45-3965">Le runtime tient compte des annotations de sécurité d’un assembly de confiance partielle uniquement lorsque cet assembly est chargé dans un domaine d’application de confiance totale (par exemple, dans le domaine d’application par défaut d’une application de bureau).</span><span class="sxs-lookup"><span data-stu-id="09f45-3965">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="09f45-3966">En revanche, un assembly fiable (autrement dit, un assembly avec nom fort est installé dans le global assembly cache) est toujours chargé avec une confiance totale, quelle que soit le niveau de confiance du domaine d’application, son niveau de confiance actuel est toujours entièrement fiable.</span><span class="sxs-lookup"><span data-stu-id="09f45-3966">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="09f45-3967">Vous pouvez déterminer les niveaux de confiance actuels des assemblys et des domaines d’application à l’aide de la <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> et <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propriétés.</span><span class="sxs-lookup"><span data-stu-id="09f45-3967">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="09f45-3968">Pour plus d’informations sur la réflexion et transparence, consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="09f45-3968">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="09f45-3969">Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="09f45-3969">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3970">Obtient une valeur qui indique si le type actuel est transparent au niveau de confiance actuel et ne peut donc pas exécuter d'opérations critiques.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3970">Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3971">
            <see langword="true" /> si le type est transparent de sécurité au niveau de confiance actuel ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3971">
              <see langword="true" /> if the type is security-transparent at the current trust level; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3972">Si cette propriété retourne `true`, le <xref:System.Type.IsSecurityCritical%2A> et <xref:System.Type.IsSecuritySafeCritical%2A> propriétés retour `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3972">If this property returns `true`, the <xref:System.Type.IsSecurityCritical%2A> and <xref:System.Type.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="09f45-3973">Le <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, et <xref:System.Type.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence du type à son niveau de confiance actuel, tel que déterminé par le common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="09f45-3973">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="09f45-3974">L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.</span><span class="sxs-lookup"><span data-stu-id="09f45-3974">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="09f45-3975">Pour les assemblys de confiance partielle, la valeur de cette propriété dépend du niveau de confiance actuel de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-3975">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="09f45-3976">Si l’assembly est chargé dans un domaine d’application partiellement fiable (par exemple, dans un domaine d’application sandbox), le runtime ignore les annotations de sécurité de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-3976">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="09f45-3977">L’assembly et tous ses types sont traités comme étant transparent.</span><span class="sxs-lookup"><span data-stu-id="09f45-3977">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="09f45-3978">Le runtime tient compte des annotations de sécurité d’un assembly de confiance partielle uniquement lorsque cet assembly est chargé dans un domaine d’application de confiance totale (par exemple, dans le domaine d’application par défaut d’une application de bureau).</span><span class="sxs-lookup"><span data-stu-id="09f45-3978">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="09f45-3979">En revanche, un assembly fiable (autrement dit, un assembly avec nom fort est installé dans le global assembly cache) est toujours chargé avec une confiance totale, quelle que soit le niveau de confiance du domaine d’application, son niveau de confiance actuel est toujours entièrement fiable.</span><span class="sxs-lookup"><span data-stu-id="09f45-3979">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="09f45-3980">Vous pouvez déterminer les niveaux de confiance actuels des assemblys et des domaines d’application à l’aide de la <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> et <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propriétés.</span><span class="sxs-lookup"><span data-stu-id="09f45-3980">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="09f45-3981">Pour plus d’informations sur la réflexion et transparence, consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="09f45-3981">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="09f45-3982">Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="09f45-3982">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3983">Obtient une valeur indiquant si le <see cref="T:System.Type" /> est sérialisable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3983">Gets a value indicating whether the <see cref="T:System.Type" /> is serializable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3984">
            <see langword="true" /> si le <see cref="T:System.Type" /> est sérialisable ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3984">
              <see langword="true" /> if the <see cref="T:System.Type" /> is serializable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="09f45-3985">Les types qui sont définis dans le .NET Standard ne sont pas marqués avec <xref:System.SerializableAttribute>.</span><span class="sxs-lookup"><span data-stu-id="09f45-3985">Types that are defined in the .NET Standard are not marked with <xref:System.SerializableAttribute>.</span></span> <span data-ttu-id="09f45-3986">Au lieu de cela, chaque implémentation .NET détermine si un type est sérialisable.</span><span class="sxs-lookup"><span data-stu-id="09f45-3986">Instead, each .NET implementation determines whether a type is serializable.</span></span> <span data-ttu-id="09f45-3987">Au moment de l’exécution, vous pouvez utiliser la <xref:System.Type.IsSerializable%2A> pour déterminer si cette implémentation prend en charge la sérialisation d’une instance du type de propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-3987">At run time, you can use the <xref:System.Type.IsSerializable%2A> property to determine whether that implementation supports serialization of an instance of the type.</span></span> <span data-ttu-id="09f45-3988">Pour plus d’informations et obtenir un exemple, consultez [comment déterminer si un objet .NET Standard est sérialisable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span><span class="sxs-lookup"><span data-stu-id="09f45-3988">For more information and an example, see [How to determine if a .NET Standard object is serializable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span></span>
  
 <span data-ttu-id="09f45-3989">Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit.</span><span class="sxs-lookup"><span data-stu-id="09f45-3989">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="09f45-3990">Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3990">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="09f45-3991">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3991">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-3992">L’exemple suivant crée une instance de `MyTestClass` (classe), définit l’attribut [Serializable] et vérifie le `IsSerializable` propriété `true` ou `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3992">The following example creates an instance of `MyTestClass` class, sets the [Serializable] attribute, and checks the `IsSerializable` property for `true` or `false`.</span></span>  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-3993">Obtient une valeur indiquant si le type a un nom qui nécessite un traitement spécial.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3993">Gets a value indicating whether the type has a name that requires special handling.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-3994">
            <see langword="true" /> si le type a un nom qui nécessite un traitement spécial ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3994">
              <see langword="true" /> if the type has a name that requires special handling; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-3995">Les noms commencent par ou un caractère de soulignement (_), les accesseurs de propriété et les méthodes de surcharge d’opérateur sont des exemples de types qui peuvent nécessiter un traitement spécial par certains compilateurs.</span><span class="sxs-lookup"><span data-stu-id="09f45-3995">Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</span></span>  
  
 <span data-ttu-id="09f45-3996">Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit.</span><span class="sxs-lookup"><span data-stu-id="09f45-3996">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="09f45-3997">Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3997">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="09f45-3998">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-3998">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="09f45-3999">Type à comparer avec le type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-3999">The type to compare with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-4000">Détermine si le <see cref="T:System.Type" /> actuel dérive du <see cref="T:System.Type" /> spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4000">Determines whether the current <see cref="T:System.Type" /> derives from the specified <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-4001">
            <see langword="true" /> si le <see langword="Type" /> actuel dérive de <paramref name="c" /> ; sinon <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4001">
              <see langword="true" /> if the current <see langword="Type" /> derives from <paramref name="c" />; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="09f45-4002">Cette méthode retourne également <see langword="false" /> si <paramref name="c" /> et le <see langword="Type" /> actuel sont égaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4002">This method also returns <see langword="false" /> if <paramref name="c" /> and the current <see langword="Type" /> are equal.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4003">Vous pouvez appeler la <xref:System.Type.IsSubclassOf%2A> méthode pour déterminer les éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="09f45-4003">You can call the <xref:System.Type.IsSubclassOf%2A> method to determine any of the following:</span></span>  
  
-   <span data-ttu-id="09f45-4004">Si une classe dérive d’un autre.</span><span class="sxs-lookup"><span data-stu-id="09f45-4004">Whether one class derives from another.</span></span>  
  
-   <span data-ttu-id="09f45-4005">Si un type dérive de <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-4005">Whether a type derives from <xref:System.ValueType>.</span></span> <span data-ttu-id="09f45-4006">Toutefois, le <xref:System.Type.IsValueType%2A> est un moyen plus efficace pour déterminer si un type est un type valeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-4006">However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type.</span></span>  
  
-   <span data-ttu-id="09f45-4007">Si un type dérive de <xref:System.Enum>.</span><span class="sxs-lookup"><span data-stu-id="09f45-4007">Whether a type derives from <xref:System.Enum>.</span></span> <span data-ttu-id="09f45-4008">Toutefois, le <xref:System.Type.IsEnum%2A> méthode est un moyen plus efficace pour déterminer si un type est une énumération.</span><span class="sxs-lookup"><span data-stu-id="09f45-4008">However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration.</span></span>  
  
-   <span data-ttu-id="09f45-4009">Si un type est un délégué, autrement dit, si elle dérive <xref:System.Delegate> ou <xref:System.MulticastDelegate>.</span><span class="sxs-lookup"><span data-stu-id="09f45-4009">Whether a type is a delegate, that is, whether it derives from either <xref:System.Delegate> or <xref:System.MulticastDelegate>.</span></span>  
  
 <span data-ttu-id="09f45-4010">Le <xref:System.Type.IsSubclassOf%2A> méthode ne peut pas être utilisée pour déterminer si une interface dérive d’une autre interface, ou si une classe implémente une interface.</span><span class="sxs-lookup"><span data-stu-id="09f45-4010">The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</span></span> <span data-ttu-id="09f45-4011">Utilisez le <xref:System.Type.IsAssignableFrom%2A> (méthode) à cette fin, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="09f45-4011">Use the <xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 <span data-ttu-id="09f45-4012">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, il dérive de sa contrainte de classe ou de <xref:System.Object?displayProperty=nameWithType> si elle ne possède aucune contrainte de classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-4012">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <xref:System.Object?displayProperty=nameWithType> if it has no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-4013">Sauf lorsqu’il est utilisé avec les interfaces, <xref:System.Type.IsSubclassOf%2A> est l’inverse de <xref:System.Type.IsAssignableFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-4013">Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>.</span></span> <span data-ttu-id="09f45-4014">Autrement dit, si `t1.IsSubclassOf(t2)` est `true`, puis `t2.IsAssignableFrom(t1)` est également `true`.</span><span class="sxs-lookup"><span data-stu-id="09f45-4014">That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`.</span></span>  
  
 <span data-ttu-id="09f45-4015">Cette méthode peut être substituée par une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="09f45-4015">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-4016">L’exemple suivant crée une classe nommée `Class1` et une classe dérivée nommée `DerivedC1`.</span><span class="sxs-lookup"><span data-stu-id="09f45-4016">The following example creates a class named `Class1` and a derived class named `DerivedC1`.</span></span> <span data-ttu-id="09f45-4017">Il appelle le <xref:System.Type.IsSubclassOf%2A> méthode pour indiquer que `DerivedC1` est une sous-classe de `Class1`.</span><span class="sxs-lookup"><span data-stu-id="09f45-4017">It calls the <xref:System.Type.IsSubclassOf%2A> method to show that `DerivedC1` is a subclass of `Class1`.</span></span>  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-4018">
            <paramref name="c" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4018">
              <paramref name="c" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4019">Obtient une valeur indiquant si l'attribut de format de chaîne <see langword="UnicodeClass" /> est sélectionné pour <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4019">Gets a value indicating whether the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-4020">
            <see langword="true" /> si l'attribut de format de chaîne <see langword="UnicodeClass" /> est sélectionné pour le <see cref="T:System.Type" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4020">
              <see langword="true" /> if the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4021">Le <xref:System.Reflection.TypeAttributes.StringFormatMask> est utilisé pour sélectionner les attributs de format de chaîne.</span><span class="sxs-lookup"><span data-stu-id="09f45-4021">The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes.</span></span> <span data-ttu-id="09f45-4022">Les attributs de format de chaîne améliorent l’interopérabilité en définissant la manière dont les chaînes doivent être interprétées.</span><span class="sxs-lookup"><span data-stu-id="09f45-4022">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="09f45-4023">Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit.</span><span class="sxs-lookup"><span data-stu-id="09f45-4023">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="09f45-4024">Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="09f45-4024">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="09f45-4025">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-4025">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4026">Obtient une valeur indiquant si le <see cref="T:System.Type" /> est un type valeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4026">Gets a value indicating whether the <see cref="T:System.Type" /> is a value type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-4027">
            <see langword="true" /> si <see cref="T:System.Type" /> est un type valeur ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4027">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4028">Les types valeur sont des types qui sont représentés sous forme de séquences de bits ; types valeur ne sont pas des classes ou des interfaces.</span><span class="sxs-lookup"><span data-stu-id="09f45-4028">Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</span></span> <span data-ttu-id="09f45-4029">Types valeur sont appelés « structs » dans certains langages de programmation.</span><span class="sxs-lookup"><span data-stu-id="09f45-4029">Value types are referred to as "structs" in some programming languages.</span></span> <span data-ttu-id="09f45-4030">Les énumérations sont un cas spécial de types valeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-4030">Enums are a special case of value types.</span></span>  
  
 <span data-ttu-id="09f45-4031">Cette propriété retourne `false` pour le <xref:System.ValueType> classe, car <xref:System.ValueType> n’est pas lui-même un type valeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-4031">This property returns `false` for the <xref:System.ValueType> class, because <xref:System.ValueType> is not a value type itself.</span></span> <span data-ttu-id="09f45-4032">Il s’agit de la classe de base pour tous les types valeur et par conséquent n’importe quel type de valeur peut être affectée à celui-ci.</span><span class="sxs-lookup"><span data-stu-id="09f45-4032">It is the base class for all value types, and therefore any value type can be assigned to it.</span></span> <span data-ttu-id="09f45-4033">Cela ne serait pas possible si <xref:System.ValueType> lui-même était un type valeur.</span><span class="sxs-lookup"><span data-stu-id="09f45-4033">This would not be possible if <xref:System.ValueType> itself was a value type.</span></span> <span data-ttu-id="09f45-4034">Types valeur sont boxed lorsqu’ils sont attribués à un champ de type <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-4034">Value types are boxed when they are assigned to a field of type <xref:System.ValueType>.</span></span>  
  
 <span data-ttu-id="09f45-4035">Cette propriété retourne `true` pour les énumérations, mais pas pour le <xref:System.Enum> type lui-même.</span><span class="sxs-lookup"><span data-stu-id="09f45-4035">This property returns `true` for enumerations, but not for the <xref:System.Enum> type itself.</span></span> <span data-ttu-id="09f45-4036">Pour obtenir un exemple qui illustre ce comportement, consultez <xref:System.Type.IsEnum%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-4036">For an example that demonstrates this behavior, see <xref:System.Type.IsEnum%2A>.</span></span>  
  
 <span data-ttu-id="09f45-4037">Cette propriété est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="09f45-4037">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-4038">L’exemple suivant crée une variable de type `MyEnum`, vérifie le `IsValueType` propriété et affiche le résultat.</span><span class="sxs-lookup"><span data-stu-id="09f45-4038">The following example creates a variable of type `MyEnum`, checks for the `IsValueType` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4039">Implémente la propriété <see cref="P:System.Type.IsValueType" /> et détermine si le <see cref="T:System.Type" /> est un type valeur, c'est-à-dire ni une classe ni une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4039">Implements the <see cref="P:System.Type.IsValueType" /> property and determines whether the <see cref="T:System.Type" /> is a value type; that is, not a class or an interface.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-4040">
            <see langword="true" /> si <see cref="T:System.Type" /> est un type valeur ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4040">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4041">Cette méthode est fournie pour activer l’implémentation d’autres systèmes de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-4041">This method is provided to enable the implementation of alternate type systems.</span></span> <span data-ttu-id="09f45-4042">En règle générale, il n’est pas utilisé dans le code d’application.</span><span class="sxs-lookup"><span data-stu-id="09f45-4042">It is not generally used in application code.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4043">Obtient une valeur qui indique si <see cref="T:System.Type" /> est accessible par code à l'extérieur de l'assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4043">Gets a value indicating whether the <see cref="T:System.Type" /> can be accessed by code outside the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-4044">
            <see langword="true" /> si le <see cref="T:System.Type" /> actuel est un type public ou un type imbriqué public rendant publics tous les types englobants ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4044">
              <see langword="true" /> if the current <see cref="T:System.Type" /> is a public type or a public nested type such that all the enclosing types are public; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4045">Utilisez cette propriété pour déterminer si un type fait partie de l’interface publique d’un assembly de composant.</span><span class="sxs-lookup"><span data-stu-id="09f45-4045">Use this property to determine whether a type is part of the public interface of a component assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-4046">L’exemple de code suivant teste deux classes, un seul d'entre eux est visible en dehors de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-4046">The following code example tests two classes, only one of which is visible outside the assembly.</span></span>  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4047">Retourne un objet <see cref="T:System.Type" /> qui représente un tableau du type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4047">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4048">Retourne un objet <see cref="T:System.Type" /> qui représente un tableau unidimensionnel du type actuel, avec une limite inférieure de zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4048">Returns a <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-4049">Objet <see cref="T:System.Type" /> qui représente un tableau unidimensionnel du type actuel, avec une limite inférieure de zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4049">A <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4050">Le <xref:System.Type.MakeArrayType%2A> méthode fournit un moyen de générer des types tableau dont les types d’élément sont calculées au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="09f45-4050">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
 <span data-ttu-id="09f45-4051">**Remarque** le common language runtime établit une distinction entre les vecteurs (autrement dit, les tableaux unidimensionnels qui sont toujours de base zéro) et les tableaux multidimensionnels.</span><span class="sxs-lookup"><span data-stu-id="09f45-4051">**Note** The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="09f45-4052">Un vecteur, qui a toujours une seule dimension, n’est pas un tableau multidimensionnel qui n’a qu’une seule dimension.</span><span class="sxs-lookup"><span data-stu-id="09f45-4052">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="09f45-4053">Cette surcharge de méthode peut uniquement être utilisée pour créer des types de vecteurs, et elle est la seule façon de créer un type de vecteur.</span><span class="sxs-lookup"><span data-stu-id="09f45-4053">This method overload can only be used to create vector types, and it is the only way to create a vector type.</span></span> <span data-ttu-id="09f45-4054">Utilisez le <xref:System.Type.MakeArrayType%28System.Int32%29> surcharge de méthode pour créer des types de tableaux multidimensionnels.</span><span class="sxs-lookup"><span data-stu-id="09f45-4054">Use the <xref:System.Type.MakeArrayType%28System.Int32%29> method overload to create multidimensional array types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-4055">L’exemple de code suivant crée le tableau, `ref` (`ByRef` en Visual Basic) et les types de pointeur pour la `Test` classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-4055">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-4056">La méthode appelée n’est pas prise en charge dans la classe de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4056">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="09f45-4057">Les classes dérivées doivent fournir une implémentation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4057">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="09f45-4058">Le type actuel est <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4058">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="09f45-4059">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4059">-or-</span>
          </span>
          <span data-ttu-id="09f45-4060">Le type actuel est un type <see langword="ByRef" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4060">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="09f45-4061">Autrement dit, <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4061">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">
          <span data-ttu-id="09f45-4062">Nombre de dimensions pour le tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4062">The number of dimensions for the array.</span>
          </span>
          <span data-ttu-id="09f45-4063">Ce nombre doit être inférieur ou égal à 32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4063">This number must be less than or equal to 32.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-4064">Retourne un objet <see cref="T:System.Type" /> qui représente un tableau du type actuel, avec le nombre spécifié de dimensions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4064">Returns a <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-4065">Objet qui représente un tableau du type actuel, avec le nombre spécifié de dimensions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4065">An object representing an array of the current type, with the specified number of dimensions.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4066">Le <xref:System.Type.MakeArrayType%2A> méthode fournit un moyen de générer des types tableau dont les types d’élément sont calculées au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="09f45-4066">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-4067">Le common language runtime établit une distinction entre les vecteurs (autrement dit, les tableaux unidimensionnels qui sont toujours de base zéro) et les tableaux multidimensionnels.</span><span class="sxs-lookup"><span data-stu-id="09f45-4067">The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="09f45-4068">Un vecteur, qui a toujours une seule dimension, n’est pas un tableau multidimensionnel qui n’a qu’une seule dimension.</span><span class="sxs-lookup"><span data-stu-id="09f45-4068">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="09f45-4069">Vous ne pouvez pas utiliser cette surcharge de méthode pour créer un type vectoriel ; Si `rank` est 1, cette surcharge de méthode retourne un type de tableau multidimensionnel qui possède une seule dimension.</span><span class="sxs-lookup"><span data-stu-id="09f45-4069">You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension.</span></span> <span data-ttu-id="09f45-4070">Utilisez le <xref:System.Type.MakeArrayType> surcharge de méthode pour créer des types vectoriels.</span><span class="sxs-lookup"><span data-stu-id="09f45-4070">Use the <xref:System.Type.MakeArrayType> method overload to create vector types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-4071">L’exemple de code suivant crée le tableau, `ref` (`ByRef` en Visual Basic) et les types de pointeur pour la `Test` classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-4071">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="09f45-4072">
            <paramref name="rank" /> n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4072">
              <paramref name="rank" /> is invalid.</span>
          </span>
          <span data-ttu-id="09f45-4073">Par exemple, 0 ou un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4073">For example, 0 or negative.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-4074">La méthode appelée n’est pas prise en charge dans la classe de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4074">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="09f45-4075">Le type actuel est <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4075">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="09f45-4076">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4076">-or-</span>
          </span>
          <span data-ttu-id="09f45-4077">Le type actuel est un type <see langword="ByRef" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4077">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="09f45-4078">Autrement dit, <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4078">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
          <span data-ttu-id="09f45-4079">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4079">-or-</span>
          </span>
          <span data-ttu-id="09f45-4080">
            <paramref name="rank" /> est supérieur à 32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4080">
              <paramref name="rank" /> is greater than 32.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4081">Retourne un objet <see cref="T:System.Type" /> qui représente le type actuel quand il est passé en tant que paramètre <see langword="ref" /> (paramètre <see langword="ByRef" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4081">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-4082">Objet <see cref="T:System.Type" /> qui représente le type actuel quand il est passé en tant que paramètre <see langword="ref" /> (paramètre <see langword="ByRef" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4082">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4083">Le <xref:System.Type.MakeByRefType%2A> méthode fournit un moyen de générer `ref` types (`ByRef` en Visual Basic) pour le paramètre répertorie.</span><span class="sxs-lookup"><span data-stu-id="09f45-4083">The <xref:System.Type.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
 <span data-ttu-id="09f45-4084">À l’aide de la syntaxe de langage intermédiaire Microsoft (MSIL), si actuel <xref:System.Type> représente l’objet <xref:System.Int32>, cette méthode retourne un <xref:System.Type> objet représentant `Int32&`.</span><span class="sxs-lookup"><span data-stu-id="09f45-4084">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-4085">L’exemple de code suivant crée le tableau, `ref` (`ByRef` en Visual Basic) et les types de pointeur pour la `Test` classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-4085">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-4086">La méthode appelée n’est pas prise en charge dans la classe de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4086">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="09f45-4087">Le type actuel est <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4087">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="09f45-4088">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4088">-or-</span>
          </span>
          <span data-ttu-id="09f45-4089">Le type actuel est un type <see langword="ByRef" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4089">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="09f45-4090">Autrement dit, <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4090">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">
          <span data-ttu-id="09f45-4091">Tableau de types à remplacer pour les paramètres de type du type générique actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4091">An array of types to be substituted for the type parameters of the current generic type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-4092">Substitue les éléments d'un tableau de types aux paramètres de type de la définition du type générique actuel et retourne un objet <see cref="T:System.Type" /> qui représente le type construit résultant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4092">Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <see cref="T:System.Type" /> object representing the resulting constructed type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-4093">
            <see cref="T:System.Type" /> représentant le type construit formé en substituant les éléments de <paramref name="typeArguments" /> pour les paramètres de type du type générique actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4093">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4094">Le <xref:System.Type.MakeGenericType%2A> méthode vous permet d’écrire du code qui assigne des types spécifiques aux paramètres de type d’une définition de type générique, créant ainsi un <xref:System.Type> objet qui représente un type construit particulier.</span><span class="sxs-lookup"><span data-stu-id="09f45-4094">The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type.</span></span> <span data-ttu-id="09f45-4095">Vous pouvez utiliser cette <xref:System.Type> objet à créer des instances d’exécution du type construit.</span><span class="sxs-lookup"><span data-stu-id="09f45-4095">You can use this <xref:System.Type> object to create run-time instances of the constructed type.</span></span>  
  
 <span data-ttu-id="09f45-4096">Types construits avec <xref:System.Type.MakeGenericType%2A> peut être ouvert, autrement dit, certains de leurs arguments de type peuvent être de placer des méthodes génériques ou les types des paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-4096">Types constructed with <xref:System.Type.MakeGenericType%2A> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</span></span> <span data-ttu-id="09f45-4097">Vous pouvez utiliser ces types construits ouverts lorsque vous émettez des assemblys dynamiques.</span><span class="sxs-lookup"><span data-stu-id="09f45-4097">You might use such open constructed types when you emit dynamic assemblies.</span></span> <span data-ttu-id="09f45-4098">Par exemple, considérez les classes `Base` et `Derived` dans le code suivant.</span><span class="sxs-lookup"><span data-stu-id="09f45-4098">For example, consider the classes `Base` and `Derived` in the following code.</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="09f45-4099">Pour générer `Derived` dans un assembly dynamique, il est nécessaire de construire son type de base.</span><span class="sxs-lookup"><span data-stu-id="09f45-4099">To generate `Derived` in a dynamic assembly, it is necessary to construct its base type.</span></span> <span data-ttu-id="09f45-4100">Pour ce faire, appelez le <xref:System.Type.MakeGenericType%2A> méthode sur un <xref:System.Type> objet représentant la classe `Base`, à l’aide des arguments de type générique <xref:System.Int32> et le paramètre de type `V` de `Derived`.</span><span class="sxs-lookup"><span data-stu-id="09f45-4100">To do this, call the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object representing the class `Base`, using the generic type arguments <xref:System.Int32> and the type parameter `V` from `Derived`.</span></span> <span data-ttu-id="09f45-4101">Étant donné que les types et les paramètres de type générique sont représentés par <xref:System.Type> des objets, un tableau contenant les deux peut être passé à la <xref:System.Type.MakeGenericType%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-4101">Because types and generic type parameters are both represented by <xref:System.Type> objects, an array containing both can be passed to the <xref:System.Type.MakeGenericType%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-4102">Un type construit comme `Base<int, V>` est utile lorsque l’émission de code, mais vous ne pouvez pas appeler la <xref:System.Type.MakeGenericType%2A> méthode sur ce type, car il n’est pas une définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-4102">A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition.</span></span> <span data-ttu-id="09f45-4103">Pour créer un type construit fermé qui peut être instancié, appelez d’abord la <xref:System.Type.GetGenericTypeDefinition%2A> méthode pour obtenir un <xref:System.Type> de l’objet qui représente la définition de type générique, puis appelez <xref:System.Type.MakeGenericType%2A> avec les arguments de type souhaité.</span><span class="sxs-lookup"><span data-stu-id="09f45-4103">To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments.</span></span>  
  
 <span data-ttu-id="09f45-4104">Le <xref:System.Type> objet retourné par <xref:System.Type.MakeGenericType%2A> est le même que le <xref:System.Type> obtenu en appelant le <xref:System.Object.GetType%2A> méthode des résultats de type construit, ou le <xref:System.Object.GetType%2A> méthode de n’importe quel construite de type qui a été créé à partir de la même générique définition du type à l’aide des mêmes arguments de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-4104">The <xref:System.Type> object returned by <xref:System.Type.MakeGenericType%2A> is the same as the <xref:System.Type> obtained by calling the <xref:System.Object.GetType%2A> method of the resulting constructed type, or the <xref:System.Object.GetType%2A> method of any constructed type that was created from the same generic type definition using the same type arguments.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09f45-4105">Un tableau de types génériques n’est pas lui-même un type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-4105">An array of generic types is not itself a generic type.</span></span> <span data-ttu-id="09f45-4106">Vous ne pouvez pas appeler <xref:System.Type.MakeGenericType%2A> sur un type tableau tel que `C<T>[]` (`Dim ac() As C(Of T)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-4106">You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic).</span></span> <span data-ttu-id="09f45-4107">Pour construire un type générique fermé de `C<T>[]`, appelez <xref:System.Type.GetElementType%2A> pour obtenir la définition de type générique `C<T>`; appeler <xref:System.Type.MakeGenericType%2A> sur la définition de type générique pour créer le type construit ; enfin appeler la <xref:System.Type.MakeArrayType%2A> méthode sur le type construit pour créer le type de tableau.</span><span class="sxs-lookup"><span data-stu-id="09f45-4107">To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type.</span></span> <span data-ttu-id="09f45-4108">Est de même des types pointeur et `ref` types (`ByRef` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09f45-4108">The same is true of pointer types and `ref` types (`ByRef` in Visual Basic).</span></span>  
  
 <span data-ttu-id="09f45-4109">Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="09f45-4109">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
## <a name="nested-types"></a><span data-ttu-id="09f45-4110">Types imbriqués</span><span class="sxs-lookup"><span data-stu-id="09f45-4110">Nested Types</span></span>  
 <span data-ttu-id="09f45-4111">Si un type générique est défini à l’aide de c#, C++ ou Visual Basic, ses types imbriqués sont tous génériques.</span><span class="sxs-lookup"><span data-stu-id="09f45-4111">If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</span></span> <span data-ttu-id="09f45-4112">Cela est vrai même si les types imbriqués n’ont leurs propres, aucun paramètre de type, car les trois langages incluent les paramètres de type de types englobants dans les listes de paramètres de type de types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="09f45-4112">This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</span></span> <span data-ttu-id="09f45-4113">Considérez les classes suivantes :</span><span class="sxs-lookup"><span data-stu-id="09f45-4113">Consider the following classes:</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 <span data-ttu-id="09f45-4114">La liste de paramètres de type de la classe imbriquée `Inner` possède deux paramètres de type, `T` et `U`, le premier est le paramètre de type de sa classe englobante.</span><span class="sxs-lookup"><span data-stu-id="09f45-4114">The type parameter list of the nested class `Inner` has two type parameters, `T` and `U`, the first of which is the type parameter of its enclosing class.</span></span> <span data-ttu-id="09f45-4115">De même, la liste de paramètres de type de la classe imbriquée `Innermost1` a trois paramètres de type, `T`, `U`, et `V`, avec `T` et `U` en provenance de ses classes englobantes.</span><span class="sxs-lookup"><span data-stu-id="09f45-4115">Similarly, the type parameter list of the nested class `Innermost1` has three type parameters, `T`, `U`, and `V`, with `T` and `U` coming from its enclosing classes.</span></span> <span data-ttu-id="09f45-4116">La classe imbriquée `Innermost2` possède deux paramètres de type, `T` et `U`, provenant de ses classes englobantes.</span><span class="sxs-lookup"><span data-stu-id="09f45-4116">The nested class `Innermost2` has two type parameters, `T` and `U`, which come from its enclosing classes.</span></span>  
  
 <span data-ttu-id="09f45-4117">Si la liste des paramètres du type englobant comporte plusieurs paramètres de type, tous les paramètres de type dans l’ordre sont inclus dans la liste de paramètres de type du type imbriqué.</span><span class="sxs-lookup"><span data-stu-id="09f45-4117">If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</span></span>  
  
 <span data-ttu-id="09f45-4118">Pour construire un type générique de la définition de type générique pour un type imbriqué, appelez le <xref:System.Type.MakeGenericType%2A> méthode avec le tableau formé en concaténant les tableaux d’argument de type de tous les types englobants, commençant par le type générique à l’extérieur et se terminant par le type de tableau d’arguments du type imbriqué lui-même, s’il possède des paramètres de type de son propre.</span><span class="sxs-lookup"><span data-stu-id="09f45-4118">To construct a generic type from the generic type definition for a nested type, call the <xref:System.Type.MakeGenericType%2A> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</span></span> <span data-ttu-id="09f45-4119">Pour créer une instance de `Innermost1`, appelez le <xref:System.Type.MakeGenericType%2A> méthode avec un tableau contenant trois types à assigner à T, U et V. Pour créer une instance de `Innermost2`, appelez le <xref:System.Type.MakeGenericType%2A> méthode avec un tableau contenant deux types à assigner à T, U.</span><span class="sxs-lookup"><span data-stu-id="09f45-4119">To create an instance of `Innermost1`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing three types, to be assigned to T, U, and V. To create an instance of `Innermost2`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing two types, to be assigned to T and U.</span></span>  
  
 <span data-ttu-id="09f45-4120">Les langages propagent les paramètres de type des types englobants de cette façon afin de pouvoir utiliser les paramètres de type d’un type englobant pour définir des champs de types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="09f45-4120">The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</span></span> <span data-ttu-id="09f45-4121">Dans le cas contraire, les paramètres de type ne serait pas dans la portée au sein des instances des types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="09f45-4121">Otherwise, the type parameters would not be in scope within the bodies of the nested types.</span></span> <span data-ttu-id="09f45-4122">Il est possible de définir des types imbriqués sans propager les paramètres de type de types englobants, en émettant le code dans des assemblys dynamiques ou en utilisant le [Ilasm.exe (assembleur IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="09f45-4122">It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span> <span data-ttu-id="09f45-4123">Prenons le code suivant pour l’assembleur MSIL :</span><span class="sxs-lookup"><span data-stu-id="09f45-4123">Consider the following code for the MSIL assembler:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="09f45-4124">Dans cet exemple, il n’est pas possible de définir un champ de type `T` ou `U` dans la classe `Innermost`, car ces paramètres de type ne sont pas dans la portée.</span><span class="sxs-lookup"><span data-stu-id="09f45-4124">In this example, it is not possible to define a field of type `T` or `U` in class `Innermost`, because those type parameters are not in scope.</span></span> <span data-ttu-id="09f45-4125">Le code assembleur suivant définit les classes imbriquées qui se comportent comme si elles étaient définies en C++, Visual Basic et c# :</span><span class="sxs-lookup"><span data-stu-id="09f45-4125">The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="09f45-4126">Vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner les classes imbriquées définies dans les langages de niveau supérieur et observer ce schéma d’affectation de noms.</span><span class="sxs-lookup"><span data-stu-id="09f45-4126">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine nested classes defined in the high-level languages and observe this naming scheme.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-4127">L’exemple suivant utilise le <xref:System.Type.MakeGenericType%2A> méthode pour créer un type construit à partir de la définition de type générique pour le <xref:System.Collections.Generic.Dictionary%602> type.</span><span class="sxs-lookup"><span data-stu-id="09f45-4127">The following example uses the <xref:System.Type.MakeGenericType%2A> method to create a constructed type from the generic type definition for the <xref:System.Collections.Generic.Dictionary%602> type.</span></span> <span data-ttu-id="09f45-4128">Le type construit représente un <xref:System.Collections.Generic.Dictionary%602> de `Test` objets avec des clés de chaîne.</span><span class="sxs-lookup"><span data-stu-id="09f45-4128">The constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="09f45-4129">Le type actuel ne représente pas une définition de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4129">The current type does not represent a generic type definition.</span>
          </span>
          <span data-ttu-id="09f45-4130">Autrement dit, <see cref="P:System.Type.IsGenericTypeDefinition" /> retourne <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4130">That is, <see cref="P:System.Type.IsGenericTypeDefinition" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-4131">
            <paramref name="typeArguments" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4131">
              <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-4132">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4132">-or-</span>
          </span>
          <span data-ttu-id="09f45-4133">Tout élément de <paramref name="typeArguments" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4133">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-4134">Le nombre d'éléments dans <paramref name="typeArguments" /> n'est pas le même que le nombre de paramètres de type dans la définition du type générique actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4134">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters in the current generic type definition.</span>
          </span>
          <span data-ttu-id="09f45-4135">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4135">-or-</span>
          </span>
          <span data-ttu-id="09f45-4136">Tout élément de <paramref name="typeArguments" /> ne satisfait pas les contraintes spécifiées pour le paramètre de type correspondant du type générique actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4136">Any element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</span>
          </span>
          <span data-ttu-id="09f45-4137">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4137">-or-</span>
          </span>
          <span data-ttu-id="09f45-4138">
            <paramref name="typeArguments" /> contient un élément qui est un type pointeur (<see cref="P:System.Type.IsPointer" /> retourne <see langword="true" />), un type par référence (<see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />) ou <see cref="T:System.Void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4138">
              <paramref name="typeArguments" /> contains an element that is a pointer type (<see cref="P:System.Type.IsPointer" /> returns <see langword="true" />), a by-ref type (<see cref="P:System.Type.IsByRef" /> returns <see langword="true" />), or <see cref="T:System.Void" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-4139">La méthode appelée n’est pas prise en charge dans la classe de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4139">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="09f45-4140">Les classes dérivées doivent fournir une implémentation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4140">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4141">Retourne un objet <see cref="T:System.Type" /> qui représente un pointeur vers le type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4141">Returns a <see cref="T:System.Type" /> object that represents a pointer to the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-4142">Objet <see cref="T:System.Type" /> qui représente un pointeur vers le type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4142">A <see cref="T:System.Type" /> object that represents a pointer to the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4143">Le <xref:System.Type.MakePointerType%2A> méthode fournit un moyen de générer des types pointeur pour les listes de paramètres.</span><span class="sxs-lookup"><span data-stu-id="09f45-4143">The <xref:System.Type.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
 <span data-ttu-id="09f45-4144">À l’aide de la syntaxe de langage intermédiaire Microsoft (MSIL), si actuel <xref:System.Type> représente l’objet <xref:System.Int32>, cette méthode retourne un <xref:System.Type> objet représentant `Int32*`.</span><span class="sxs-lookup"><span data-stu-id="09f45-4144">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-4145">L’exemple de code suivant crée le tableau, `ref` (`ByRef` en Visual Basic) et les types de pointeur pour la `Test` classe.</span><span class="sxs-lookup"><span data-stu-id="09f45-4145">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-4146">La méthode appelée n’est pas prise en charge dans la classe de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4146">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="09f45-4147">Le type actuel est <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4147">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="09f45-4148">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4148">-or-</span>
          </span>
          <span data-ttu-id="09f45-4149">Le type actuel est un type <see langword="ByRef" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4149">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="09f45-4150">Autrement dit, <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4150">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4151">Obtient une valeur <see cref="T:System.Reflection.MemberTypes" /> qui indique que ce membre est un type ou un type imbriqué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4151">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-4152">Valeur <see cref="T:System.Reflection.MemberTypes" /> qui indique que ce membre est un type ou un type imbriqué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4152">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4153">Cette propriété substitue <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-4153">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09f45-4154">Par conséquent, lorsque vous examinez un ensemble de <xref:System.Reflection.MemberInfo> objets — par exemple, le tableau retourné par <xref:System.Type.GetMembers%2A>: le <xref:System.Reflection.MemberInfo.MemberType%2A> propriété renvoie <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> quand un membre donné est un type imbriqué.</span><span class="sxs-lookup"><span data-stu-id="09f45-4154">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects—for example, the array returned by <xref:System.Type.GetMembers%2A>—the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> when a given member is a nested type.</span></span>  
  
 <span data-ttu-id="09f45-4155">Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit.</span><span class="sxs-lookup"><span data-stu-id="09f45-4155">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="09f45-4156">Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="09f45-4156">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="09f45-4157">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09f45-4157">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-4158">Ce qui suit montre l’exemple de code la `MemberType` champ en tant que paramètre à la `GetMember` méthode :</span><span class="sxs-lookup"><span data-stu-id="09f45-4158">The following code example shows the `MemberType` field as a parameter to the `GetMember` method:</span></span>  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4159">Représente une valeur manquante dans les informations <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4159">Represents a missing value in the <see cref="T:System.Type" /> information.</span>
          </span>
          <span data-ttu-id="09f45-4160">Ce champ est en lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4160">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4161">Utilisez le `Missing` field pour un appel par la réflexion pour obtenir la valeur par défaut d’un paramètre.</span><span class="sxs-lookup"><span data-stu-id="09f45-4161">Use the `Missing` field for invocation through reflection to obtain the default value of a parameter.</span></span> <span data-ttu-id="09f45-4162">Si le `Missing` champ est passé pour une valeur de paramètre et il n’existe aucune valeur par défaut pour ce paramètre, un <xref:System.ArgumentException> est levée.</span><span class="sxs-lookup"><span data-stu-id="09f45-4162">If the `Missing` field is passed in for a parameter value and there is no default value for that parameter, an <xref:System.ArgumentException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-4163">L’exemple de code suivant illustre l’utilisation de la `Missing` champ à appeler une méthode avec ses arguments par défaut.</span><span class="sxs-lookup"><span data-stu-id="09f45-4163">The following code example shows the use of the `Missing` field to invoke a method with its default arguments.</span></span>  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 <span data-ttu-id="09f45-4164">Ce code génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="09f45-4164">This code produces the following output:</span></span>  
  
 <span data-ttu-id="09f45-4165">un = 10 b = 55.3 c = 12</span><span class="sxs-lookup"><span data-stu-id="09f45-4165">a = 10 b = 55.3 c = 12</span></span>  
  
 <span data-ttu-id="09f45-4166">un = 10 b = 1.3 c = 1</span><span class="sxs-lookup"><span data-stu-id="09f45-4166">a = 10 b = 1.3 c = 1</span></span>  
  
 <span data-ttu-id="09f45-4167">un = 10 b = 1.2 c = 1</span><span class="sxs-lookup"><span data-stu-id="09f45-4167">a = 10 b = 1.2 c = 1</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4168">Obtient le module (la DLL) dans lequel le <see cref="T:System.Type" /> actuel est défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4168">Gets the module (the DLL) in which the current <see cref="T:System.Type" /> is defined.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-4169">Module dans lequel le <see cref="T:System.Type" /> actuel est défini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4169">The module in which the current <see cref="T:System.Type" /> is defined.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4170">Si le courant <xref:System.Type> représente un type générique construit, cette propriété retourne le module dans lequel la définition de type générique a été définie.</span><span class="sxs-lookup"><span data-stu-id="09f45-4170">If the current <xref:System.Type> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</span></span> <span data-ttu-id="09f45-4171">Par exemple, si vous créez une instance de `MyGenericStack<int>`, le <xref:System.Type.Module%2A> propriété pour le type construit retourne le module dans lequel `MyGenericStack<T>` est défini.</span><span class="sxs-lookup"><span data-stu-id="09f45-4171">For example, if you create an instance of `MyGenericStack<int>`, the <xref:System.Type.Module%2A> property for the constructed type returns the module in which `MyGenericStack<T>` is defined.</span></span>  
  
 <span data-ttu-id="09f45-4172">De même, si le courant <xref:System.Type> représente un paramètre générique `T`, cette propriété retourne l’assembly qui contient le type générique qui définit `T`.</span><span class="sxs-lookup"><span data-stu-id="09f45-4172">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-4173">L’exemple suivant illustre une utilisation de la <xref:System.Type.Namespace%2A> et `Module` propriétés et le <xref:System.Type.ToString%2A> méthode <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="09f45-4173">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and `Module` properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4174">Obtient l'espace de noms de l'objet <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4174">Gets the namespace of the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-4175">Espace de noms du <see cref="T:System.Type" /> ; <see langword="null" /> si l'instance actuelle n'a pas d'espace de noms ou représente un paramètre générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4175">The namespace of the <see cref="T:System.Type" />; <see langword="null" /> if the current instance has no namespace or represents a generic parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4176">Un espace de noms est une logique au moment du design d’affectation des noms plus de commodité, principalement utilisé pour définir l’étendue d’une application et organiser des classes et autres types dans une structure hiérarchique unique.</span><span class="sxs-lookup"><span data-stu-id="09f45-4176">A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</span></span> <span data-ttu-id="09f45-4177">Du point de vue de l’exécution, il n’existe aucun espace de noms.</span><span class="sxs-lookup"><span data-stu-id="09f45-4177">From the viewpoint of the runtime, there are no namespaces.</span></span>  
  
 <span data-ttu-id="09f45-4178">Si le courant <xref:System.Type> représente un type générique construit, cette propriété retourne l’espace de noms qui contient la définition de type générique.</span><span class="sxs-lookup"><span data-stu-id="09f45-4178">If the current <xref:System.Type> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</span></span> <span data-ttu-id="09f45-4179">De même, si le courant <xref:System.Type> représente un paramètre générique `T`, cette propriété retourne l’espace de noms qui contient la définition de type générique qui définit `T`.</span><span class="sxs-lookup"><span data-stu-id="09f45-4179">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the namespace that contains the generic type definition that defines `T`.</span></span>  
  
 <span data-ttu-id="09f45-4180">Si le courant <xref:System.Type> objet représente un paramètre générique, cette propriété retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-4180">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-4181">L’exemple suivant illustre une utilisation de la `Namespace` et <xref:System.Type.Module%2A> propriétés et le <xref:System.Type.ToString%2A> méthode <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="09f45-4181">This following example demonstrates a use of the `Namespace` and <xref:System.Type.Module%2A> properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="09f45-4182">Premier objet à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4182">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="09f45-4183">Deuxième objet à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4183">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-4184">Indique si deux objets <see cref="T:System.Type" /> sont égaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4184">Indicates whether two <see cref="T:System.Type" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-4185">
            <see langword="true" /> si <paramref name="left" /> est égal à <paramref name="right" /> ; sinon <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4185">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="09f45-4186">Premier objet à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4186">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="09f45-4187">Deuxième objet à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4187">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-4188">Indique si deux objets <see cref="T:System.Type" /> ne sont pas égaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4188">Indicates whether two <see cref="T:System.Type" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-4189">
            <see langword="true" /> si <paramref name="left" /> n'est pas égal à <paramref name="right" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4189">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4190">Obtient l'objet de la classe qui a été utilisé pour obtenir ce membre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4190">Gets the class object that was used to obtain this member.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-4191">Objet <see langword="Type" /> via lequel cet objet <see cref="T:System.Type" /> a été obtenu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4191">The <see langword="Type" /> object through which this <see cref="T:System.Type" /> object was obtained.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4192">Pour <xref:System.Type> des objets, la valeur de cette propriété est toujours identique à la valeur de la <xref:System.Type.DeclaringType%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-4192">For <xref:System.Type> objects, the value of this property is always the same as the value of the <xref:System.Type.DeclaringType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-4193">Cet exemple affiche le type réfléchi d’une classe imbriquée.</span><span class="sxs-lookup"><span data-stu-id="09f45-4193">This example displays the reflected type of a nested class.</span></span>  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="09f45-4194">Nom complet de l'assembly du <see cref="T:System.Type" /> à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4194">The assembly-qualified name of the <see cref="T:System.Type" /> to get.</span>
          </span>
        </param>
        <param name="throwIfNotFound">
          <span data-ttu-id="09f45-4195">
            <see langword="true" /> pour lever une <see cref="T:System.TypeLoadException" /> si le type est introuvable ; <see langword="false" /> pour retourner <see langword="null" /> si le type est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4195">
              <see langword="true" /> to throw a <see cref="T:System.TypeLoadException" /> if the type cannot be found; <see langword="false" /> to return <see langword="null" /> if the type cannot be found.</span>
          </span>
          <span data-ttu-id="09f45-4196">
            <see langword="false" /> supprime également d'autres conditions d'exception, mais pas toutes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4196">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="09f45-4197">Consultez la section Exceptions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4197">See the Exceptions section.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="09f45-4198">
            <see langword="true" /> pour effectuer une recherche qui ne respecte pas la casse de <c>typeName</c> ; <see langword="false" /> pour effectuer une recherche qui respecte la casse de <c>typeName</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4198">
              <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>; <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-4199">Obtient le <see cref="T:System.Type" /> portant le nom spécifié, indiquant s'il faut effectuer une recherche respectant la casse et lever une exception si le type est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4199">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</span>
          </span>
          <span data-ttu-id="09f45-4200">Le type est chargé dans un contexte de réflexion, et non d'exécution.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4200">The type is loaded for reflection only, not for execution.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-4201">Type présentant le nom spécifié, s'il est trouvé ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4201">The type with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
          <span data-ttu-id="09f45-4202">Si le type est introuvable, le paramètre <paramref name="throwIfNotFound" /> spécifie si <see langword="null" /> est retourné ou bien une exception est levée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4202">If the type is not found, the <paramref name="throwIfNotFound" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="09f45-4203">Dans certains cas, une exception est levée indépendamment de la valeur de <paramref name="throwIfNotFound" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4203">In some cases, an exception is thrown regardless of the value of <paramref name="throwIfNotFound" />.</span>
          </span>
          <span data-ttu-id="09f45-4204">Consultez la section Exceptions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4204">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4205">Si l’assembly contenant le type n’est pas déjà chargé dans le contexte de réflexion uniquement, à l’aide du <xref:System.Type.ReflectionOnlyGetType%2A> méthode est équivalent au premier chargement de l’assembly pour la réflexion uniquement, à l’aide de la <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> (méthode), puis le chargement du type en appelant le l’assembly <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-4205">If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="09f45-4206">Pour plus d’informations sur les noms qualifiés d’assembly, consultez la <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="09f45-4206">For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="09f45-4207">Pour plus d’informations sur la spécification des noms de types, consultez le <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="09f45-4207">For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="09f45-4208">Si l’assembly est déjà chargé pour l’exécution, une autre copie est chargée dans le contexte de réflexion uniquement.</span><span class="sxs-lookup"><span data-stu-id="09f45-4208">If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="09f45-4209">Le `throwIfNotFound` paramètre spécifie que se passe-t-il lorsque le type est introuvable et supprime également certaines autres conditions d’exception, comme décrit dans la section Exceptions.</span><span class="sxs-lookup"><span data-stu-id="09f45-4209">The `throwIfNotFound` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="09f45-4210">Certaines exceptions sont levées, quelle que soit la valeur de `throwIfNotFound`.</span><span class="sxs-lookup"><span data-stu-id="09f45-4210">Some exceptions are thrown regardless of the value of `throwIfNotFound`.</span></span> <span data-ttu-id="09f45-4211">Par exemple, si l’assembly n’est pas valide, un <xref:System.BadImageFormatException> est levée même si `throwIfNotFound` est `false`.</span><span class="sxs-lookup"><span data-stu-id="09f45-4211">For example, if the assembly is not valid, a <xref:System.BadImageFormatException> is thrown even if `throwIfNotFound` is `false`.</span></span>  
  
 <span data-ttu-id="09f45-4212">Pour plus d’informations sur le contexte de réflexion uniquement, consultez [Comment : charger des assemblys dans le contexte de Reflection](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span><span class="sxs-lookup"><span data-stu-id="09f45-4212">For more information about using the reflection-only context, see [How to: Load Assemblies into the Reflection-Only Context](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="09f45-4213">
            <paramref name="typeName" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4213">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="09f45-4214">Un initialiseur de classe est appelé et lève une exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4214">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="09f45-4215">
            <paramref name="throwIfNotFound" /> a la valeur <see langword="true" /> et le type est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4215">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="09f45-4216">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4216">-or-</span>
          </span>
          <span data-ttu-id="09f45-4217">
            <paramref name="throwIfNotFound" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient des caractères non valides, tels qu’une tabulation incorporée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4217">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="09f45-4218">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4218">-or-</span>
          </span>
          <span data-ttu-id="09f45-4219">
            <paramref name="throwIfNotFound" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> est une chaîne vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4219">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="09f45-4220">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4220">-or-</span>
          </span>
          <span data-ttu-id="09f45-4221">
            <paramref name="throwIfNotFound" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> représente un type de tableau avec une taille non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4221">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="09f45-4222">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4222">-or-</span>
          </span>
          <span data-ttu-id="09f45-4223">
            <paramref name="typeName" /> représente un tableau d’objets <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4223">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" /> objects.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="09f45-4224">
            <paramref name="typeName" /> n’inclut pas le nom de l’assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4224">
              <paramref name="typeName" /> does not include the assembly name.</span>
          </span>
          <span data-ttu-id="09f45-4225">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4225">-or-</span>
          </span>
          <span data-ttu-id="09f45-4226">
            <paramref name="throwIfNotFound" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient une syntaxe non valide ; par exemple, « MyType[,\*,] ».</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4226">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax; for example, "MyType[,\*,]".</span>
          </span>
          <span data-ttu-id="09f45-4227">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4227">-or-</span>
          </span>
          <span data-ttu-id="09f45-4228">
            <paramref name="typeName" /> représente un type générique qui a un type pointeur, un type <see langword="ByRef" /> ou <see cref="T:System.Void" /> comme l’un de ses arguments de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4228">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="09f45-4229">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4229">-or-</span>
          </span>
          <span data-ttu-id="09f45-4230">
            <paramref name="typeName" /> représente un type générique qui a un nombre incorrect d’arguments de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4230">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="09f45-4231">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4231">-or-</span>
          </span>
          <span data-ttu-id="09f45-4232">
            <paramref name="typeName" /> représente un type générique, et un de ses arguments de type ne satisfait pas aux contraintes pour le paramètre de type correspondant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4232">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="09f45-4233">
            <paramref name="throwIfNotFound" /> a la valeur <see langword="true" />, et l’assembly ou l’une de ses dépendances est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4233">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="09f45-4234">L’assembly ou une de ses dépendances a été trouvé, mais n’a pas pu être chargé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4234">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="09f45-4235">L’assembly ou une de ses dépendances n’est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4235">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="09f45-4236">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4236">-or-</span>
          </span>
          <span data-ttu-id="09f45-4237">L’assembly a été compilé avec une version du Common Language Runtime postérieure à la version actuellement chargée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4237">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4238">Obtient un <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> qui décrit la disposition du type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4238">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the layout of the current type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-4239">Obtient un <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> qui décrit les fonctions de disposition brutes du type actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4239">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the gross layout features of the current type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4240"><xref:System.Runtime.InteropServices.StructLayoutAttribute> n’est pas retournée par le <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="09f45-4240"><xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method.</span></span> <span data-ttu-id="09f45-4241">Au lieu de cela, utilisez cette propriété pour l’obtenir.</span><span class="sxs-lookup"><span data-stu-id="09f45-4241">Instead, use this property to get it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-4242">L’exemple de code suivant définit tout d’abord une classe, une structure et une structure avec des attributs de disposition spéciaux (les structures sont imbriquées dans la classe).</span><span class="sxs-lookup"><span data-stu-id="09f45-4242">The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</span></span> <span data-ttu-id="09f45-4243">L’exemple utilise ensuite la <xref:System.Type.StructLayoutAttribute%2A> propriété pour obtenir un <xref:System.Runtime.InteropServices.StructLayoutAttribute> pour chaque type et affiche les propriétés des attributs.</span><span class="sxs-lookup"><span data-stu-id="09f45-4243">The example then uses the <xref:System.Type.StructLayoutAttribute%2A> property to obtain a <xref:System.Runtime.InteropServices.StructLayoutAttribute> for each type, and displays the properties of the attributes.</span></span>  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-4244">La méthode appelée n’est pas prise en charge dans la classe de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4244">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="09f45-4245">Réservé à un usage ultérieur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4245">Reserved for future use.</span>
          </span>
          <span data-ttu-id="09f45-4246">Doit être IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4246">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="09f45-4247">Tableau passé des noms à mapper.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4247">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="09f45-4248">Compte des noms à mapper.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4248">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="09f45-4249">Contexte des paramètres régionaux dans lequel interpréter les noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4249">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="09f45-4250">Tableau alloué par l'appelant et recevant les ID qui correspondent aux noms.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4250">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-4251">Mappe un jeu de noms avec un jeu correspondant d'identificateurs de dispatch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4251">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4252">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="09f45-4252">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="09f45-4253">Pour plus d’informations sur `IDispatch::GetIDsOfNames`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="09f45-4253">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="09f45-4254">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4254">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="09f45-4255">Informations de type à retourner.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4255">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="09f45-4256">Identificateur des paramètres régionaux pour les informations de type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4256">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="09f45-4257">Pointeur vers l'objet d'informations de type demandé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4257">A pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-4258">Récupère les informations de type pour un objet, qui peuvent être utilisées ensuite pour obtenir les informations de type d'une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4258">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4259">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="09f45-4259">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="09f45-4260">Pour plus d’informations sur `IDispatch::GetTypeInfo`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="09f45-4260">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="09f45-4261">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4261">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="09f45-4262">Pointe vers un emplacement qui reçoit le nombre d'interfaces d'informations de type fourni par l'objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4262">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-4263">Récupère le nombre d'interfaces d'informations de type fourni par un objet (0 ou 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4263">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4264">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="09f45-4264">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="09f45-4265">Pour plus d’informations sur `IDispatch::GetTypeInfoCount`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="09f45-4265">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="09f45-4266">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4266">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="09f45-4267">Identifie le membre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4267">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="09f45-4268">Réservé à un usage ultérieur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4268">Reserved for future use.</span>
          </span>
          <span data-ttu-id="09f45-4269">Doit être IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4269">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="09f45-4270">Contexte des paramètres régionaux dans lequel interpréter les arguments.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4270">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="09f45-4271">Indicateurs décrivant le contexte de l'appel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4271">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="09f45-4272">Pointeur vers une structure qui contient un tableau d’arguments, un tableau d’arguments DISPID pour les arguments nommés et le nombre d’éléments de chaque tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4272">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="09f45-4273">Pointeur vers l'emplacement où le résultat doit être stocké.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4273">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="09f45-4274">Pointeur vers une structure qui contient les informations sur les exceptions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4274">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="09f45-4275">Index du premier argument comportant une erreur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4275">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="09f45-4276">Fournit l'accès aux propriétés et aux méthodes exposées par un objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4276">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4277">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="09f45-4277">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="09f45-4278">Pour plus d’informations sur `IDispatch::Invoke`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="09f45-4278">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="09f45-4279">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4279">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4280">Retourne <see langword="String" /> représentant le nom du <see langword="Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4280">Returns a <see langword="String" /> representing the name of the current <see langword="Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="09f45-4281">
            <see cref="T:System.String" /> représentant le nom du <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4281">A <see cref="T:System.String" /> representing the name of the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4282">Cette méthode retourne le common language runtime espace de noms complet et le nom de tous les types primitifs.</span><span class="sxs-lookup"><span data-stu-id="09f45-4282">This method returns the fully qualified common language runtime namespace and name for all primitive types.</span></span> <span data-ttu-id="09f45-4283">Par exemple, l’instruction c# `(long)0.Type().ToString()` retourne « System.Int64 » au lieu de simplement « Int64 ».</span><span class="sxs-lookup"><span data-stu-id="09f45-4283">For example, the C# instruction, `(long)0.Type().ToString()` returns "System.Int64" instead of merely "Int64".</span></span>  
  
 <span data-ttu-id="09f45-4284">Si le courant <xref:System.Type> représente un type générique, le type et ses arguments de type sont qualifiés par espace de noms et par un type imbriqué, mais pas par un assembly.</span><span class="sxs-lookup"><span data-stu-id="09f45-4284">If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</span></span> <span data-ttu-id="09f45-4285">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode retourne le nom non qualifié du paramètre de type.</span><span class="sxs-lookup"><span data-stu-id="09f45-4285">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-4286">L’exemple suivant illustre une utilisation de la <xref:System.Type.Namespace%2A> et <xref:System.Type.Module%2A> propriétés et le `ToString` méthode <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="09f45-4286">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and <xref:System.Type.Module%2A> properties and the `ToString` method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 <span data-ttu-id="09f45-4287">L’exemple suivant compare les chaînes retournées par la <xref:System.Type.ToString%2A> (méthode) et le `Name`, <xref:System.Type.FullName%2A>, et <xref:System.Type.AssemblyQualifiedName%2A> propriétés.</span><span class="sxs-lookup"><span data-stu-id="09f45-4287">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4288">Obtient le handle pour le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4288">Gets the handle for the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-4289">Handle pour le <see cref="T:System.Type" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4289">The handle for the current <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4290">`TypeHandle` encapsule un pointeur vers une structure de données interne qui représente le type.</span><span class="sxs-lookup"><span data-stu-id="09f45-4290">`TypeHandle` encapsulates a pointer to an internal data structure that represents the type.</span></span> <span data-ttu-id="09f45-4291">Ce handle est unique pendant la durée de vie du processus.</span><span class="sxs-lookup"><span data-stu-id="09f45-4291">This handle is unique during the process lifetime.</span></span> <span data-ttu-id="09f45-4292">Le handle est valide uniquement dans le domaine d’application dans lequel il a été obtenu.</span><span class="sxs-lookup"><span data-stu-id="09f45-4292">The handle is valid only in the application domain in which it was obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09f45-4293">L’exemple suivant retourne le handle du type correspondant et passe le handle à une méthode qui obtient le type à partir du handle et l’affiche.</span><span class="sxs-lookup"><span data-stu-id="09f45-4293">The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</span></span>  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="09f45-4294">Le .NET Compact Framework ne prend pas en charge cette propriété.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4294">The .NET Compact Framework does not currently support this property.</span>
          </span>
        </exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4295">Obtient l'initialiseur du type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4295">Gets the initializer for the type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-4296">Objet contenant le nom du constructeur de classe pour <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4296">An object that contains the name of the class constructor for the <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09f45-4297">Les initialiseurs de classe sont également disponibles via le <xref:System.Type.FindMembers%2A> (méthode), ou via les surcharges de la <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, et <xref:System.Type.GetConstructors%2A> méthodes qui prennent des <xref:System.Reflection.BindingFlags> en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="09f45-4297">Class initializers are also available through the <xref:System.Type.FindMembers%2A> method, or through overloads of the <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, and <xref:System.Type.GetConstructors%2A> methods that take <xref:System.Reflection.BindingFlags> as a parameter.</span></span>  
  
 <span data-ttu-id="09f45-4298">Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="09f45-4298">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="09f45-4299">Indique le type fourni par le Common Language Runtime qui représente ce type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4299">Indicates the type provided by the common language runtime that represents this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="09f45-4300">Type de système sous-jacent pour <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="09f45-4300">The underlying system type for the <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>